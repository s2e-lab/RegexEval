[
    {
        "id": 1,
        "expression": "^\\d$",
        "description": "Matches exactly 1 numeric digit (0-9).",
        "matches": [
            "1",
            "2",
            "3"
        ],
        "non_matches": [
            "a",
            "324",
            "num"
        ]
    },
    {
        "id": 2,
        "expression": "^\\d{5}$",
        "description": "Matches 5 numeric digits, such as a zip code.",
        "matches": [
            "33333",
            "55555",
            "23445"
        ],
        "non_matches": [
            "abcd",
            "1324",
            "as;lkjdf"
        ]
    },
    {
        "id": 3,
        "expression": "^\\d{5}-\\d{4}$",
        "description": "Numeric and hyphen 5+4 ZIP code match for ZIP+4.",
        "matches": [
            "22222-3333",
            "34545-2367",
            "56334-2343"
        ],
        "non_matches": [
            "123456789",
            "A3B 4C5",
            "55335"
        ]
    },
    {
        "id": 4,
        "expression": "^\\d{5}$|^\\d{5}-\\d{4}$",
        "description": "This regular expression will match either a 5 digit ZIP code or a ZIP+4 code formatted as 5 digits, a hyphen, and another 4 digits. Other than that, this is just a really really long description of a regular expression that I'm using to test how my front page will look in the case where very long expression descriptions are used.",
        "matches": [
            "55555-5555",
            "34564-3342",
            "90210"
        ],
        "non_matches": [
            "434454444",
            "645-32-2345",
            "abc"
        ]
    },
    {
        "id": 5,
        "expression": "^\\d{3}-\\d{2}-\\d{4}$",
        "description": "This regular expression will match a hyphen-separated Social Security Number (SSN) in the format NNN-NN-NNNN.",
        "matches": [
            "333-22-4444",
            "123-45-6789"
        ],
        "non_matches": [
            "123456789",
            "SSN"
        ]
    },
    {
        "id": 6,
        "expression": "^[a-zA-Z]$",
        "description": "Matches any single upper- or lower-case letter.",
        "matches": [
            "a",
            "B",
            "c"
        ],
        "non_matches": [
            "0",
            "&amp;",
            "AbC"
        ]
    },
    {
        "id": 7,
        "expression": "^[a-zA-Z]+$",
        "description": "Matches any string of only upper- and lower- case letters (no spaces).",
        "matches": [
            "abc",
            "ABC",
            "aBcDeF"
        ],
        "non_matches": [
            "abc123",
            "mr.",
            "a word"
        ]
    },
    {
        "id": 8,
        "expression": "^[a-zA-Z0-9]+$",
        "description": "Matches any alphanumeric string (no spaces).",
        "matches": [
            "10a",
            "ABC",
            "A3fg"
        ],
        "non_matches": [
            "45.3",
            "this or that",
            "$23"
        ]
    },
    {
        "id": 9,
        "expression": "^\\d+$",
        "description": "Positive integer value.",
        "matches": [
            "123",
            "10",
            "54"
        ],
        "non_matches": [
            "-54",
            "54.234",
            "abc"
        ]
    },
    {
        "id": 10,
        "expression": "^(\\+|-)?\\d+$",
        "description": "Matches any signed integer.",
        "matches": [
            "-34",
            "34",
            "+5"
        ],
        "non_matches": [
            "abc",
            "3.1415",
            "-5.3"
        ]
    },
    {
        "id": 11,
        "expression": "^[a-zA-Z]\\w{3,14}$",
        "description": "The password's first character must be a letter, it must contain at least 4 characters and no more than 15 characters and no characters other than letters, numbers and the underscore may be used",
        "matches": [
            "abcd",
            "aBc45DSD_sdf",
            "password"
        ],
        "non_matches": [
            "afv",
            "1234",
            "reallylongpassword"
        ]
    },
    {
        "id": 12,
        "expression": "^\\w+@[a-zA-Z_]+?\\.[a-zA-Z]{2,3}$",
        "description": "Simple email expression. Doesn't allow numbers in the domain name and doesn't allow for top level domains that are less than 2 or more than 3 letters (which is fine until they allow more). Doesn't handle multiple &quot;.&quot; in the domain (joe@abc.co.uk).",
        "matches": [
            "joe@aol.com",
            "ssmith@aspalliance.com",
            "a@b.cc"
        ],
        "non_matches": [
            "joe@123aspx.com",
            "joe@web.info",
            "joe@company.co.uk"
        ]
    },
    {
        "id": 13,
        "expression": "^\\d{1,2}\\/\\d{1,2}\\/\\d{4}$",
        "description": "This regular expressions matches dates of the form XX/XX/YYYY where XX can be 1 or 2 digits long and YYYY is always 4 digits long.",
        "matches": [
            "4/1/2001",
            "12/12/2001",
            "55/5/3434"
        ],
        "non_matches": [
            "1/1/01",
            "12 Jan 01",
            "1-1-2001"
        ]
    },
    {
        "id": 15,
        "expression": "^[1-5]$",
        "description": "This matches a single numeric digit between 1 and 5, and is the same as saying ^[12345]$.",
        "matches": [
            "1",
            "3",
            "4"
        ],
        "non_matches": [
            "6",
            "23",
            "a"
        ]
    },
    {
        "id": 16,
        "expression": "^[12345]$",
        "description": "This matches a single numeric digit between 1 and 5, and is the same as saying ^[1-5]$.",
        "matches": [
            "1",
            "2",
            "4"
        ],
        "non_matches": [
            "6",
            "-1",
            "abc"
        ]
    },
    {
        "id": 18,
        "expression": "^[2-9]\\d{2}-\\d{3}-\\d{4}$",
        "description": "This expression matches a hyphen separated US phone number, of the form ANN-NNN-NNNN, where A is between 2 and 9 and N is between 0 and 9.",
        "matches": [
            "800-555-5555",
            "333-444-5555",
            "212-666-1234"
        ],
        "non_matches": [
            "000-000-0000",
            "123-456-7890",
            "2126661234"
        ]
    },
    {
        "id": 19,
        "expression": "^\\d{5}-\\d{4}|\\d{5}|[A-Z]\\d[A-Z] \\d[A-Z]\\d$",
        "description": "This expression matches three different formats of postal codes: 5 digit US ZIP code, 5 digit US ZIP code + 4, and 6 digit alphanumeric Canadian Postal Code. The first one must be 5 numeric digits. The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits. The Canadian postal code must be of the form ANA NAN where A is any uppercase alphabetic character and N is a numeric digit from 0 to 9.",
        "matches": [
            "44240",
            "44240-5555",
            "G3H 6A3"
        ],
        "non_matches": [
            "Ohio",
            "abc",
            "g3h6a3"
        ]
    },
    {
        "id": 20,
        "expression": "^[a-zA-Z0-9\\-\\.]+\\.(com|org|net|mil|edu|COM|ORG|NET|MIL|EDU)$",
        "description": "Domain names:\nThis regular expression tests the validity of a domain or hostname. It will match any valid domain name that does not contain characters which are invalid in URLs, and which ends in .com, .org, .net, .mil, or .edu. You can add additional valid TLDs by appending the | (pipe) character and the desired TLD to the list in the parens.",
        "matches": [
            "3SquareBand.com",
            "asp.net",
            "army.mil"
        ],
        "non_matches": [
            "$SquareBand.com",
            "asp/dot.net",
            "army.military"
        ]
    },
    {
        "id": 25,
        "expression": "^(?=.*\\d).{4,8}$",
        "description": "Password expression. Password must be between 4 and 8 digits long and include at least one numeric digit.",
        "matches": [
            "1234",
            "asdf1234",
            "asp123"
        ],
        "non_matches": [
            "asdf",
            "asdf12345",
            "password"
        ]
    },
    {
        "id": 26,
        "expression": "^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{4,8}$",
        "description": "Password matching expression. Password must be at least 4 characters, no more than 8 characters, and must include at least one upper case letter, one lower case letter, and one numeric digit.",
        "matches": [
            "asD1",
            "asDF1234",
            "ASPgo123"
        ],
        "non_matches": [
            "asdf",
            "1234",
            "ASDF12345"
        ]
    },
    {
        "id": 27,
        "expression": "^(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9])\\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[0-9])$",
        "description": "RegExp for validating the format of IP Addresses. This works great with the ASP.NET RegularExpressionValidator server control.",
        "matches": [
            "127.0.0.1",
            "255.255.255.0",
            "192.168.0.1"
        ],
        "non_matches": [
            "1200.5.4.3",
            "abc.def.ghi.jkl",
            "255.foo.bar.1"
        ]
    },
    {
        "id": 29,
        "expression": "\\(([0-9]{2}|0{1}((x|[0-9]){2}[0-9]{2}))\\)\\s*[0-9]{3,4}[- ]*[0-9]{4}",
        "description": "Match diferent styles for brazilian Phone number code.\nOnly DDD (12), complete DDD (012), complete DDD + Telephony Company (0xx12) plus 3 or 4 digits (city code) plus 4 digits (phone number).",
        "matches": [
            "(12) 123 1234",
            "(01512) 123 1234",
            "(0xx12) 1234 1234"
        ],
        "non_matches": [
            "12 123 1234",
            "(012) 123/1234",
            "(012) 123 12345"
        ]
    },
    {
        "id": 31,
        "expression": "^#?([a-f]|[A-F]|[0-9]){3}(([a-f]|[A-F]|[0-9]){3})?$",
        "description": "Tests for valid HTML hexadecimal color codes. The # symbol is optional. And it will except either the 3 digit form for the 216 Web safe colors, or the full 6 digit form. I am use it on my site to allow users to customize the site's colors.",
        "matches": [
            "#00ccff",
            "#039",
            "ffffcc"
        ],
        "non_matches": [
            "blue",
            "0x000000",
            "#ff000"
        ]
    },
    {
        "id": 33,
        "expression": "^[a-zA-Z]{1,2}[0-9][0-9A-Za-z]{0,1} {0,1}[0-9][A-Za-z]{2}$",
        "description": "Matches UK postcodes according to the following rules\n1. LN NLL eg N1 1AA\n2. LLN NLL eg SW4 0QL\n3. LNN NLL eg M23 4PJ\n4. LLNN NLL eg WS14 0JT\n5. LLNL NLL eg SW1N 4TB\n6. LNL NLL eg W1C 8LQ\nThanks to Simon Bell for informing me of LNL NLL rule for postcodes which I had omitted in an earlier version.",
        "matches": [
            "G1 1AA",
            "EH10 2QQ",
            "SW1 1ZZ"
        ],
        "non_matches": [
            "G111 1AA",
            "X10 WW",
            "DDD 5WW"
        ]
    },
    {
        "id": 34,
        "expression": "^[\\w\\.=-]+@[\\w\\.-]+\\.[\\w]{2,3}$",
        "description": "Much simpler email expression. This one forces a length of 2 or 3, which fits current specs, but you may need to alter the end as this one allows all numerals on the .COM section.",
        "matches": [
            "a@a.com",
            "a@a.com.au",
            "a@a.au"
        ],
        "non_matches": [
            "word",
            "word@",
            "@word"
        ]
    },
    {
        "id": 36,
        "expression": "^\\$[0-9]+(\\.[0-9][0-9])?$",
        "description": "Validates a dollar amount including a dollar sign and 2 decmals. The decimal and cents are optional.",
        "matches": [
            "$1.50",
            "$49",
            "$0.50"
        ],
        "non_matches": [
            "1.5",
            "$1.333",
            "this $5.12 fails"
        ]
    },
    {
        "id": 37,
        "expression": "\\b(([01]?\\d?\\d|2[0-4]\\d|25[0-5])\\.){3}([01]?\\d?\\d|2[0-4]\\d|25[0-5])\\b",
        "description": "Most Concise RegExp for matching Decimal IPs. If nothing else, it'll make your code easier to read. (And I know that \\d?\\d is \\d{1,2} but that's 2 extra characters.)\n--Update: darkone noticed 8 characters could be shaved down. I've edited it to reflect this. Thanks, darkone!",
        "matches": [
            "217.6.9.89",
            "0.0.0.0",
            "255.255.255.255"
        ],
        "non_matches": [
            "256.0.0.0",
            "0978.3.3.3",
            "65.4t.54.3"
        ]
    },
    {
        "id": 41,
        "expression": "^([\\w\\d\\-\\.]+)@{1}(([\\w\\d\\-]{1,67})|([\\w\\d\\-]+\\.[\\w\\d\\-]{1,67}))\\.(([a-zA-Z\\d]{2,4})(\\.[a-zA-Z\\d]{2})?)$",
        "description": "This pattern allows standard e-mail addresses (e.g. user@domain.com), sub domains (e.g. user@foo.domain.com), the new two- and four-letter domains (e.g. user@domain.tv and user@domain.name) and country codes (e.g. user@foo.com.us). Also, this patter follows the Network Solutions standard length of 67 characters for top-level domains. The reason I allow numbers to be entered in the domain suffix is for future planning. If you do not want numbers to be able to be added as a domain suffix (e.g. user@domain.123), simply delete the last two occurrences of &quot;\\d&quot;.",
        "matches": [
            "foo@foo.com",
            "foo@foo-foo.com.au",
            "foo@foo.foo.info"
        ],
        "non_matches": [
            "foo@.com",
            "foo@foo..com",
            "foo@me@.com"
        ]
    },
    {
        "id": 42,
        "expression": "^[0-9]+$",
        "description": "Validate a string to see if it contains a number / integer",
        "matches": [
            "1234567890",
            "1234567890",
            "1234567890"
        ],
        "non_matches": [
            "http://none",
            "http://none",
            "http://none"
        ]
    },
    {
        "id": 44,
        "expression": "^((4\\d{3})|(5[1-5]\\d{2})|(6011))-?\\d{4}-?\\d{4}-?\\d{4}|3[4,7]\\d{13}$",
        "description": "Matches major credit cards including:\nVisa (length 16, prefix 4), Mastercard (length 16, prefix 51-55), Discover (length 16, prefix 6011), American Express (length 15, prefix 34 or 37). All 16 digit formats accept optional hyphens (-) between each group of four digits.",
        "matches": [
            "6011-1111-1111-1111",
            "5423-1111-1111-1111",
            "341111111111111"
        ],
        "non_matches": [
            "4111-111-111-111",
            "3411-1111-1111-111",
            "Visa"
        ]
    },
    {
        "id": 45,
        "expression": "^.{4,8}$",
        "description": "Matches any string between 4 and 8 characters in length. Limits the length of a string. Useful to add to password regular expressions.",
        "matches": [
            "asdf",
            "1234",
            "asdf1234"
        ],
        "non_matches": [
            "asd",
            "123",
            "asdfe12345"
        ]
    },
    {
        "id": 46,
        "expression": "^\\d*$",
        "description": "Accepts an unsigned integer number. Also matches empty strings.",
        "matches": [
            "123",
            "000",
            "43"
        ],
        "non_matches": [
            "asbc",
            "-34",
            "3.1415"
        ]
    },
    {
        "id": 47,
        "expression": "^[-+]?\\d*$",
        "description": "Matches any integer number or numeric string, including positive and negative value characters (+ or -). Also matches empty strings.",
        "matches": [
            "123",
            "-123",
            "+123"
        ],
        "non_matches": [
            "abc",
            "3.14159",
            "-3.14159"
        ]
    },
    {
        "id": 48,
        "expression": "^\\d*\\.?\\d*$",
        "description": "Matches any unsigned floating point number/numeric string. Also matches empty strings.",
        "matches": [
            "123",
            "3.14159",
            ".234"
        ],
        "non_matches": [
            "abc",
            "-3.14159",
            "3.4.2"
        ]
    },
    {
        "id": 49,
        "expression": "^[-+]?\\d*\\.?\\d*$",
        "description": "Matches any floating point numer/numeric string, including optional sign character (+ or -). Also matches empty strings.",
        "matches": [
            "123",
            "+3.14159",
            "-3.14159"
        ],
        "non_matches": [
            "abc",
            "3.4.5",
            "$99.95"
        ]
    },
    {
        "id": 53,
        "expression": "^([0-9]( |-)?)?(\\(?[0-9]{3}\\)?|[0-9]{3})( |-)?([0-9]{3}( |-)?[0-9]{4}|[a-zA-Z0-9]{7})$",
        "description": "Matches US phone number format. 1 in the beginning is optional, area code is required, spaces or dashes can be used as optional divider between number groups. Also alphanumeric format is allowed after area code.",
        "matches": [
            "1-(123)-123-1234",
            "123 123 1234",
            "1-800-ALPHNUM"
        ],
        "non_matches": [
            "1.123.123.1234",
            "(123)-1234-123",
            "123-1234"
        ]
    },
    {
        "id": 54,
        "expression": "^([0-1][0-9]|[2][0-3]):([0-5][0-9])$",
        "description": "Matches a string if it is a valid time in the format of HH:MM",
        "matches": [
            "02:04",
            "16:56",
            "23:59"
        ],
        "non_matches": [
            "02:00 PM",
            "PM2:00",
            "24:00"
        ]
    },
    {
        "id": 55,
        "expression": "^[0,1]?\\d{1}\\/(([0-2]?\\d{1})|([3][0,1]{1}))\\/(([1]{1}[9]{1}[9]{1}\\d{1})|([2-9]{1}\\d{3}))$",
        "description": "This expression checks the validity of a date (US, but it is easily editable for other format's). Year's 1990-9999, Month's 1 or 01 to 12, Day's 1 or 01 to 31. Still needs to have individual months added (i.e., Feb's 28 days), and some how to check for leap year...the months issue should not be to hard, but the leap year seems like a real chore. Please let me know if you have any suggestions for leap year.",
        "matches": [
            "01/01/1990",
            "12/12/9999",
            "3/28/2001"
        ],
        "non_matches": [
            "3-8-01",
            "13/32/1001",
            "03/32/1989"
        ]
    },
    {
        "id": 57,
        "expression": "^\\s*[a-zA-Z,\\s]+\\s*$",
        "description": "Any Expression Upper/Lower Case, with commas and space between the text, with any amount of space before or after",
        "matches": [
            "Smith, Ed",
            "Ed Smith",
            "aBcDeFgH"
        ],
        "non_matches": [
            "a123",
            "AB5",
            "Mr. Ed"
        ]
    },
    {
        "id": 64,
        "expression": "^(([1-9])|(0[1-9])|(1[0-2]))\\/((0[1-9])|([1-31]))\\/((\\d{2})|(\\d{4}))$",
        "description": "Matches U.S. dates with leading zeros and without and with 2 or four digit years",
        "matches": [
            "01/01/2001",
            "1/1/2001",
            "01/1/01"
        ],
        "non_matches": [
            "13/01/2001",
            "1/2/100",
            "09/32/2001"
        ]
    },
    {
        "id": 65,
        "expression": "^\\$?([0-9]{1,3},([0-9]{3},)*[0-9]{3}|[0-9]+)(.[0-9][0-9])?$",
        "description": "Matches currency input with or without commas.",
        "matches": [
            "$3,023,123.34",
            "9,876,453",
            "123456.78"
        ],
        "non_matches": [
            "4,33,234.34",
            "$1.234",
            "abc"
        ]
    },
    {
        "id": 66,
        "expression": "((\\d{2})|(\\d))\\/((\\d{2})|(\\d))\\/((\\d{4})|(\\d{2}))",
        "description": "This matches simple dates against 1 or 2 digits for the month, 1 or 2 digit for the day, and either 2 or 4 digits for the year",
        "matches": [
            "4/5/91",
            "04/5/1991",
            "4/05/89"
        ],
        "non_matches": [
            "4/5/1"
        ]
    },
    {
        "id": 67,
        "expression": "^(\\(?\\+?[0-9]*\\)?)?[0-9_\\- \\(\\)]*$",
        "description": "A regular expression to match phone numbers, allowing for an international dialing code at the start and hyphenation and spaces that are sometimes entered.",
        "matches": [
            "(+44)(0)20-12341234",
            "02012341234",
            "+44 (0) 1234-1234"
        ],
        "non_matches": [
            "(44+)020-12341234",
            "12341234(+020)"
        ]
    },
    {
        "id": 68,
        "expression": "^\\d{5}(-\\d{4})?$",
        "description": "Matches standard 5 digit US Zip Codes, or the US ZIP + 4 Standard.",
        "matches": [
            "48222",
            "48222-1746"
        ],
        "non_matches": [
            "4632",
            "Blake",
            "37333-32"
        ]
    },
    {
        "id": 69,
        "expression": "(^\\+[0-9]{2}|^\\+[0-9]{2}\\(0\\)|^\\(\\+[0-9]{2}\\)\\(0\\)|^00[0-9]{2}|^0)([0-9]{9}$|[0-9\\-\\s]{10}$)",
        "description": "Regular expression to evaluate dutch-style phone numbers. Possible example prefixes: +31, +31(0), (+31)(0), 0, 0031\nfollowed by 9 numbers (which can contain a space or -).",
        "matches": [
            "+31235256677",
            "+31(0)235256677",
            "023-5256677"
        ],
        "non_matches": [
            "+3123525667788999",
            "3123525667788",
            "232-2566778"
        ]
    },
    {
        "id": 72,
        "expression": "\\b(\\w+)\\s+\\1\\b",
        "description": "Uses backreferences and word boundaries to match repeated words seperated by whitespace without matching a word with the same ending as the next words beginning.",
        "matches": [
            "Tell the the preacher",
            "some some",
            "hubba hubba"
        ],
        "non_matches": [
            "once an annual report",
            "mandate dated submissions",
            "Hubba hubba"
        ]
    },
    {
        "id": 73,
        "expression": "^\\d{9}[\\d|X]$",
        "description": "A very simple ISBN validation expression - it just checks for a 10 digit number where the last digit could also be a capital 'X'. Complete specs for ISBN available here:\nhttp://www.isbn.org/standards/home/isbn/international/html/usm4.htm. An enhancement would be to allow exactly 3 or 0 hyphens or 3 or 0 spaces, since these are also valid formats.",
        "matches": [
            "1234123412",
            "123412341X"
        ],
        "non_matches": [
            "not an isbn"
        ]
    },
    {
        "id": 74,
        "expression": "^(([1-9])|(0[1-9])|(1[0-2]))\\/(([0-9])|([0-2][0-9])|(3[0-1]))\\/(([0-9][0-9])|([1-2][0,9][0-9][0-9]))$",
        "description": "Dates\nday: d or dd, &lt;= 31,\nmonth: m or mm, &lt;= 12,\nyear: yy or yyyy &gt;= 1900, &lt;= 2099",
        "matches": [
            "01/01/2001",
            "1/1/1999",
            "10/20/2080"
        ],
        "non_matches": [
            "13/01/2001",
            "1/1/1800",
            "10/32/2080"
        ]
    },
    {
        "id": 75,
        "expression": "^\\d*\\.?((25)|(50)|(5)|(75)|(0)|(00))?$",
        "description": "This is a pattern to search and verify that a decimal number ends with a 25, 50, 75, 0 or 00. It does match for a nothing after decimal also but I guess thats ok !!",
        "matches": [
            "0.25",
            ".75",
            "123.50"
        ],
        "non_matches": [
            ".77",
            "1.435"
        ]
    },
    {
        "id": 76,
        "expression": "^(s-|S-){0,1}[0-9]{3}\\s?[0-9]{2}$",
        "description": "Validates swedish zipcodes (postnr) with or without space between groups. With leading s- or not. Can be disconnected by removing ''(s-|S-){0,1}''.",
        "matches": [
            "12345",
            "932 68",
            "S-621 46"
        ],
        "non_matches": [
            "5367",
            "425611",
            "31 545"
        ]
    },
    {
        "id": 77,
        "expression": "((0?[13578]|10|12)(-|\\/)((0[0-9])|([12])([0-9]?)|(3[01]?))(-|\\/)((\\d{4})|(\\d{2}))|(0?[2469]|11)(-|\\/)((0[0-9])|([12])([0-9]?)|(3[0]?))(-|\\/)((\\d{4}|\\d{2})))",
        "description": "Regex used in .NET to validate a date. Matches the following formats mm/dd/yy, mm/dd/yyyy, mm-dd-yy, mm-dd-yyyy\nThis covers days with 30 or 31 days but does not handle February, it is allowed 30 days.",
        "matches": [
            "1/31/2002",
            "04-30-02",
            "12-01/2002"
        ],
        "non_matches": [
            "2/31/2002",
            "13/0/02",
            "Jan 1, 2001"
        ]
    },
    {
        "id": 78,
        "expression": "^(?!^(PRN|AUX|CLOCK\\$|NUL|CON|COM\\d|LPT\\d|\\..*)(\\..+)?$)[^\\x00-\\x1f\\\\?*:\\\";|/]+$",
        "description": "Checks for a valid windows file name (Must be used with the case-insensitive option\nChecks that the file has at lease one char, does not contain any invalid characters and does not have a reserved word as a file name.\n&quot;If you see a &amp;quot; in the regex replace it with a &quot; character&quot;",
        "matches": [
            "test.txt",
            "test.jpg.txt",
            "a&b c.bmp"
        ],
        "non_matches": [
            "CON",
            ".pdf",
            "test:2.pdf"
        ]
    },
    {
        "id": 80,
        "expression": "^(\\d{5}-\\d{4}|\\d{5})$|^([a-zA-Z]\\d[a-zA-Z] \\d[a-zA-Z]\\d)$",
        "description": "This is a modification of the zip code regular expression submitted by Steven Smith (ssmith@aspalliance.com)\nIt no longer matches 78754-12aA",
        "matches": [
            "78754",
            "78754-1234",
            "G3H 6A3"
        ],
        "non_matches": [
            "78754-12aA",
            "7875A",
            "g3h6a3"
        ]
    },
    {
        "id": 81,
        "expression": "^([\\w\\-\\.]+)@((\\[([0-9]{1,3}\\.){3}[0-9]{1,3}\\])|(([\\w\\-]+\\.)+)([a-zA-Z]{2,4}))$",
        "description": "Expression 1 of 2 used to check email address syntax.",
        "matches": [
            "bob@somewhere.com",
            "bob.jones@[1.1.1.1]",
            "bob@a.b.c.d.info"
        ],
        "non_matches": [
            "bob@com",
            "bob.jones@some.where",
            "bob@1.1.1.123"
        ]
    },
    {
        "id": 82,
        "expression": "^(([-\\w \\.]+)|(&quot;&quot;[-\\w \\.]+&quot;&quot;) )?&lt;([\\w\\-\\.]+)@((\\[([0-9]{1,3}\\.){3}[0-9]{1,3}\\])|(([\\w\\-]+\\.)+)([a-zA-Z]{2,4}))&gt;$",
        "description": "Expression 2 or 2 for matching email address syntax. This one matches the &lt;angle bracket syntax&gt;.",
        "matches": [
            "&lt;ab@cd.ef&gt;",
            "bob A. jones &lt;ab@cd.ef&gt;",
            "bob A. jones &lt;ab@[1.1.1.111]&gt;"
        ],
        "non_matches": [
            "ab@cd.ef",
            "&quot;bob A. jones &lt;ab@cd.ef&gt;",
            "bob A. jones &lt;ab@1.1.1.111&gt;"
        ]
    },
    {
        "id": 83,
        "expression": "^http\\://[a-zA-Z0-9\\-\\.]+\\.[a-zA-Z]{2,3}(/\\S*)?$",
        "description": "Verifies URLs. Checks for the leading protocol, a good looking domain (two or three letter TLD; no invalid characters in domain) and a somwhat reasonable file path.",
        "matches": [
            "http://psychopop.org",
            "http://www.edsroom.com/newUser.asp",
            "http://unpleasant.jarrin.net/markov/inde"
        ],
        "non_matches": [
            "ftp://psychopop.org",
            "http://www.edsroom/",
            "http://un/pleasant.jarrin.net/markov/index.asp"
        ]
    },
    {
        "id": 84,
        "expression": "^[A-Za-z]{1,2}[0-9A-Za-z]{1,2}[ ]?[0-9]{0,1}[A-Za-z]{2}$",
        "description": "This regular expression can be used to validate UK postcodes. Especially useful if want to provide a client side validation on a web site.",
        "matches": [
            "SW112LE",
            "SW11 2LE",
            "CR05LE"
        ],
        "non_matches": [
            "12CR0LE",
            "12CR 0LE",
            "SWLE05"
        ]
    },
    {
        "id": 86,
        "expression": "20\\d{2}(-|\\/)((0[1-9])|(1[0-2]))(-|\\/)((0[1-9])|([1-2][0-9])|(3[0-1]))(T|\\s)(([0-1][0-9])|(2[0-3])):([0-5][0-9]):([0-5][0-9])",
        "description": "Sql date format tester.",
        "matches": [
            "2099-12-31T23:59:59",
            "2002/02/09 16:30:00",
            "2000-01-01T00:00:00"
        ],
        "non_matches": [
            "2000-13-31T00:00:00",
            "2002/02/33 24:00:00",
            "2000-01-01 60:00:00"
        ]
    },
    {
        "id": 87,
        "expression": "^\\d{4}[\\-\\/\\s]?((((0[13578])|(1[02]))[\\-\\/\\s]?(([0-2][0-9])|(3[01])))|(((0[469])|(11))[\\-\\/\\s]?(([0-2][0-9])|(30)))|(02[\\-\\/\\s]?[0-2][0-9]))$",
        "description": "- validates a yyyy-mm-dd, yyyy mm dd, or yyyy/mm/dd date\n- makes sure day is within valid range for the month\n- does NOT validate Feb. 29 on a leap year, only that Feb. CAN have 29 days",
        "matches": [
            "0001-12-31",
            "9999 09 30",
            "2002/03/03"
        ],
        "non_matches": [
            "0001\\02\\30",
            "9999.15.01",
            "2002/3/3"
        ]
    },
    {
        "id": 89,
        "expression": "^(1?(-?\\d{3})-?)?(\\d{3})(-?\\d{4})$",
        "description": "US Telephone Reg expression that allows 7, 10 or 11 digits with or without hyphens.",
        "matches": [
            "15615552323",
            "1-561-555-1212",
            "5613333"
        ],
        "non_matches": [
            "1-555-5555",
            "15553333",
            "0-561-555-1212"
        ]
    },
    {
        "id": 92,
        "expression": "([a-zA-Z]:(\\\\w+)*\\\\[a-zA-Z0_9]+)?.xls",
        "description": "This RegEx will help to validate a physical file path with a specific file extension (here xls)",
        "matches": [
            "E:\\DyAGT\\SD01A_specV2.xls"
        ],
        "non_matches": [
            "E:\\DyAGT\\SD01A_specV2.txt"
        ]
    },
    {
        "id": 94,
        "expression": "^( [1-9]|[1-9]|0[1-9]|10|11|12)[0-5]\\d$",
        "description": "Matches a 12-hour time value expressed as either 4 numeric digits, 3 numeric digits, or a space and 3 numeric digits. 3 digit times (930) can be expressed with leading 0's (0930) or not. AM/PM designation is not included in this expression.",
        "matches": [
            "1145",
            "933",
            "801"
        ],
        "non_matches": [
            "0000",
            "1330",
            "8:30"
        ]
    },
    {
        "id": 95,
        "expression": "^\\d{1,2}\\/\\d{2,4}$",
        "description": "Accepts 1-2 digits followed by a slash followed by 2-4 digits. Useful for numeric month/year entry.",
        "matches": [
            "9/02",
            "09/2002",
            "09/02"
        ],
        "non_matches": [
            "Fall 2002",
            "Sept 2002"
        ]
    },
    {
        "id": 96,
        "expression": "^(|(0[1-9])|(1[0-2]))\\/((0[1-9])|(1\\d)|(2\\d)|(3[0-1]))\\/((\\d{4}))$",
        "description": "This expression matches dates formatted as MM/DD/YYYY where months and days must be 2 digits each, zero padded. It is not perfect - it allows DD to be from 01 to 31 regardless of the month.",
        "matches": [
            "01/01/2001",
            "02/30/2001",
            "12/31/2002"
        ],
        "non_matches": [
            "1/1/02",
            "1/1/2002",
            "1/25/2002"
        ]
    },
    {
        "id": 97,
        "expression": "^((((0[13578])|(1[02]))[\\/]?(([0-2][0-9])|(3[01])))|(((0[469])|(11))[\\/]?(([0-2][0-9])|(30)))|(02[\\/]?[0-2][0-9]))[\\/]?\\d{4}$",
        "description": "Date expressions that matches MM/DD/YYYY where MM and DD must be two digits and zero padded. Validates correctly for all months except February, which it assumes to always have 29 days. The &quot;/&quot; separator is optional.",
        "matches": [
            "01/01/2001",
            "02/29/2002",
            "12/31/2002"
        ],
        "non_matches": [
            "1/1/02",
            "02/30/2002",
            "1/25/2002"
        ]
    },
    {
        "id": 98,
        "expression": "^(\\d{1,3}'(\\d{3}')*\\d{3}(\\.\\d{1,3})?|\\d{1,3}(\\.\\d{3})?)$",
        "description": "This regex match numeric data in the following format: thousands are separated by (') apostrophe, decimal places are separated by dot (.) Maximum three decimal places are not required. It's easy to change to other separators as well.",
        "matches": [
            "1'235.140",
            "1'222'333.120",
            "456"
        ],
        "non_matches": [
            "1234.500",
            "78'45.123",
            "123,0012"
        ]
    },
    {
        "id": 99,
        "expression": "^((0?[1-9]|[12][1-9]|3[01])\\.(0?[13578]|1[02])\\.20[0-9]{2}|(0?[1-9]|[12][1-9]|30)\\.(0?[13456789]|1[012])\\.20[0-9]{2}|(0?[1-9]|1[1-9]|2[0-8])\\.(0?[123456789]|1[012])\\.20[0-9]{2}|(0?[1-9]|[12][1-9])\\.(0?[123456789]|1[012])\\.20(00|04|08|12|16|20|24|28|32|36|40|44|48|52|56|60|64|68|72|76|80|84|88|92|96))$",
        "description": "Fully functional date validator in format dd.MM.yyyy\nWorks only within range of years 2000-2099 !\nIt allows leading zeros but does not require them. The last year pattern (enumeration) is not very clever but I will improve it, if needed.",
        "matches": [
            "31.01.2002",
            "29.2.2004",
            "09.02.2005"
        ],
        "non_matches": [
            "31.11.2002",
            "29.2.2002",
            "33.06.2000"
        ]
    },
    {
        "id": 100,
        "expression": "^(0[1-9]|1[0-2])\\/((0[1-9]|2\\d)|3[0-1])\\/(19\\d\\d|200[0-3])$",
        "description": "This expression is an attempt to match the most obvious features of a valid date in American/US format of the form mm/dd/yyyy for any year 1900 through 2003. It can easily be adapted for different date ranges. It matches any date where the day part is any number 01-31, the month part is any number 01-12, and the year part is any number 1900-2003. The only invalid dates that it matches are ones where the day part may be in the range 01-31 but that range might not be valid for the specified month. An example of an invalid date that it would allow to pass through would be 11/31/2002. This date is invalid because 11/31 of any year does not exist, but this expression would allow it pass through since the day part is in the range 01-31.\nThis regular expression has been used successfully in ASP with VBScript using the windows scripting library RegExp object.",
        "matches": [
            "12/31/2003",
            "01/01/1900",
            "11/31/2002"
        ],
        "non_matches": [
            "1/1/2002",
            "01/01/02",
            "01/01/2004"
        ]
    },
    {
        "id": 103,
        "expression": "^((((0[13578])|([13578])|(1[02]))[\\/](([1-9])|([0-2][0-9])|(3[01])))|(((0[469])|([469])|(11))[\\/](([1-9])|([0-2][0-9])|(30)))|((2|02)[\\/](([1-9])|([0-2][0-9]))))[\\/]\\d{4}$|^\\d{4}$",
        "description": "The following validates dates with and without leading zeros in the following formats: MM/DD/YYYY and it also takes YYYY (this can easily be removed). All months are validated for the correct number of days for that particular month except for February which can be set to 29 days. date day month year",
        "matches": [
            "01/01/2001",
            "1/01/2001",
            "2002"
        ],
        "non_matches": [
            "2/30/2002",
            "13/23/2002",
            "12345"
        ]
    },
    {
        "id": 104,
        "expression": "^(?:(?:(?:0?[13578]|1[02])(\\/|-|\\.)31)\\1|(?:(?:0?[13-9]|1[0-2])(\\/|-|\\.)(?:29|30)\\2))(?:(?:1[6-9]|[2-9]\\d)?\\d{2})$|^(?:0?2(\\/|-|\\.)29\\3(?:(?:(?:1[6-9]|[2-9]\\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00))))$|^(?:(?:0?[1-9])|(?:1[0-2]))(\\/|-|\\.)(?:0?[1-9]|1\\d|2[0-8])\\4(?:(?:1[6-9]|[2-9]\\d)?\\d{2})$",
        "description": "This expression validates dates in the US m/d/y format from 1/1/1600 - 12/31/9999.",
        "matches": [
            "01.1.02",
            "11-30-2001",
            "2/29/2000"
        ],
        "non_matches": [
            "02/29/01",
            "13/01/2002",
            "11/00/02"
        ]
    },
    {
        "id": 107,
        "expression": "^[\\\\(]{0,1}([0-9]){3}[\\\\)]{0,1}[ ]?([^0-1]){1}([0-9]){2}[ ]?[-]?[ ]?([0-9]){4}[ ]*((x){0,1}([0-9]){1,5}){0,1}$",
        "description": "US Telephone Number where this is regular expression excludes the first number, after the area code,from being 0 or 1; it also allows an extension\nto be added where it does not have to be prefixed by 'x'.",
        "matches": [
            "(910)456-7890",
            "(910)456-8970 x12",
            "(910)456-8970 1211"
        ],
        "non_matches": [
            "(910) 156-7890",
            "(910) 056-7890",
            "(910) 556-7890 x"
        ]
    },
    {
        "id": 108,
        "expression": "^[-+]?\\d+(\\.\\d+)?$",
        "description": "This matches any real number, with optional decimal point and numbers after the decimal, and optional positive (+) or negative (-) designation.",
        "matches": [
            "123",
            "-123.45",
            "+123.56"
        ],
        "non_matches": [
            "123x",
            ".123",
            "-123."
        ]
    },
    {
        "id": 110,
        "expression": "^((\\d{5}-\\d{4})|(\\d{5})|([A-Z]\\d[A-Z]\\s\\d[A-Z]\\d))$",
        "description": "This expression matches three different formats of postal codes: 5 digit US ZIP code, 5 digit US ZIP code + 4, and 6 digit alphanumeric Canadian Postal Code. The first one must be 5 numeric digits. The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits. The Canadian postal code must be of the form ANA NAN where A is any uppercase alphabetic character and N is a numeric digit from 0 to 9.",
        "matches": [
            "44240",
            "44240-5555",
            "T2P 3C7"
        ],
        "non_matches": [
            "44240ddd",
            "t44240-55",
            "t2p3c7"
        ]
    },
    {
        "id": 112,
        "expression": "\"((\\\\\")|[^\"(\\\\\")])+\"",
        "description": "Matches quoted string, using \\&quot; as an escape to place quotes in the string",
        "matches": [
            "\"test\"",
            "\"escape\\\"quote\"",
            "\"\\\"\""
        ],
        "non_matches": [
            "test",
            "\"test",
            "\"test\\\""
        ]
    },
    {
        "id": 113,
        "expression": "^\\d{5}(-\\d{3})?$",
        "description": "Matches standard 5 digit Brazilian Postal Codes (CEP), or the CEP + 3 digits (distribution identifiers - suffix).\nFor more info refer to: http://www.correios.com.br/servicos/cep/Estrutura_CEP.cfm (in portuguese).",
        "matches": [
            "13165-000",
            "38175-000",
            "81470-276"
        ],
        "non_matches": [
            "13165-00",
            "38175-abc",
            "81470-2763"
        ]
    },
    {
        "id": 114,
        "expression": "^\\$(\\d{1,3}(\\,\\d{3})*|(\\d+))(\\.\\d{2})?$",
        "description": "This re matches US currency format with lead dollar sign. Dollar value must have at least one digit and may or may not be comma separated. Cents value is optional.",
        "matches": [
            "$0.84",
            "$123458",
            "$1,234,567.89"
        ],
        "non_matches": [
            "$12,3456.01",
            "12345",
            "$1.234"
        ]
    },
    {
        "id": 115,
        "expression": "([A-Z]:\\\\[^/:\\*\\?<>\\|]+\\.\\w{2,6})|(\\\\{2}[^/:\\*\\?<>\\|]+\\.\\w{2,6})",
        "description": "This regular expression pattern can be used to check the validity of paths for file upload controls. The uploaded file can be either stored locally or accessible through UNC. It cannot contain illegal characters for the windows OS - that may be supported e.g. on Mac OS \u2013 and cannot be a URL (Yes, as weird as it may seem, some users enter URLs in the file upload box, even though there is a browse button...)",
        "matches": [
            "C:\\temp\\this allows spaces\\web.config",
            "\\\\Andromeda\\share\\file name.123"
        ],
        "non_matches": [
            "tz:\\temp\\ fi*le?na:m<e>.doc",
            "\\\\Andromeda\\share\\filename.a"
        ]
    },
    {
        "id": 117,
        "expression": "(^([0-9]|[0-1][0-9]|[2][0-3]):([0-5][0-9])$)|(^([0-9]|[1][0-9]|[2][0-3])$)",
        "description": "Matches a string if it is a valid time in the format of HH:MM / H:MM / HH / H",
        "matches": [
            "10:35",
            "9:20",
            "23"
        ],
        "non_matches": [
            "24:00",
            "20 PM",
            "20:15 PM"
        ]
    },
    {
        "id": 118,
        "expression": "^\\$?([0-9]{1,3},([0-9]{3},)*[0-9]{3}|[0-9]+)(\\.[0-9][0-9])?$",
        "description": "Matches US currency input with or without commas. This provides a fix for the currency regular expression posted at http://regxlib.com/REDetails.aspx?regexp_id=70 by escaping the . (period) to ensure that no other characters may be used in it's place.",
        "matches": [
            "$3,023,123.34",
            "9,876,453",
            "123456.78"
        ],
        "non_matches": [
            "4,33,234.34",
            "$1.234",
            "abc"
        ]
    },
    {
        "id": 119,
        "expression": "^\\$?\\d+(\\.(\\d{2}))?$",
        "description": "To evaluate an amount with or without a dollar sign where the cents are optional.",
        "matches": [
            "$2.43",
            "2.02",
            "$2112"
        ],
        "non_matches": [
            "2.1",
            "$.14",
            "$2,222.12"
        ]
    },
    {
        "id": 120,
        "expression": "((0[1-9])|(1[02]))/\\d{2}",
        "description": "Fromat check for MM/YY, checks month is 1-12 and any 2 digit year.",
        "matches": [
            "01/00",
            "12/99"
        ],
        "non_matches": [
            "13/00",
            "12/AS"
        ]
    },
    {
        "id": 121,
        "expression": "(\"[^\"]*\")|('[^\\r]*)(\\r\\n)?",
        "description": "Will match a VBScript string and/or comment\nEx:\n' userinfo\nstrUsername = &quot;tomsve&quot;\niAge = 20\n' temp\nstrPassword = &quot;halloj&quot;\n...Would result in the following matches:\n' userinfo\n&quot;tomsve&quot;\n' temp\n&quot;halloj&quot;\nGood luck!\nTom S. info@tomsvensson.com",
        "matches": [
            "\"my string\"",
            "\"a string with ' in it\"",
            "' comment"
        ],
        "non_matches": [
            "asd \""
        ]
    },
    {
        "id": 123,
        "expression": "^([0-9]{2})?(\\([0-9]{2})\\)([0-9]{3}|[0-9]{4})-[0-9]{4}$",
        "description": "A simple expression to brazilian phone number code, with international code.\nSimple DDI without &quot;+&quot; 99 plus simple DDD (99) plus simple local phone number 3 or 4 digits plus &quot;-&quot; plus 4 digits.",
        "matches": [
            "55(21)123-4567",
            "(11)1234-5678",
            "55(71)4562-2234"
        ],
        "non_matches": [
            "3434-3432",
            "4(23)232-3232",
            "55(2)232-232"
        ]
    },
    {
        "id": 125,
        "expression": "^(([a-zA-Z]:)|(\\\\{2}\\w+)\\$?)(\\\\(\\w[\\w ]*))+\\.(txt|TXT)$",
        "description": "This RE validates a path/file of type txt (text file)\nThis RE can be used as a filter on certain file types, while insuring the entire string is a fully qualified path and file. The filter value can be changed or added to as you need",
        "matches": [
            "c:\\file.txt",
            "c:\\folder\\sub folder\\file.txt",
            "\\\\network\\folder\\file.txt"
        ],
        "non_matches": [
            "C:",
            "C:\\file.xls",
            "folder.txt"
        ]
    },
    {
        "id": 126,
        "expression": "^[a-zA-Z0-9]+([a-zA-Z0-9\\-\\.]+)?\\.(com|org|net|mil|edu|COM|ORG|NET|MIL|EDU)$",
        "description": "Checks domain names. This is an attempt to deal with some of the issues of the other reg ex in not handling leading periods(.) and hypens(-).",
        "matches": [
            "my.domain.com",
            "regexlib.com",
            "big-reg.com"
        ],
        "non_matches": [
            ".mydomain.com",
            "regexlib.comm",
            "-bigreg.com"
        ]
    },
    {
        "id": 127,
        "expression": "^[-+]?[0-9]+[.]?[0-9]*([eE][-+]?[0-9]+)?$",
        "description": "This matches floating point expression in a more rigorous way - accepts both exponent as well as non exponent notations.",
        "matches": [
            "123",
            "-123.35",
            "-123.35e-2"
        ],
        "non_matches": [
            "abc",
            "123.32e",
            "123.32.3"
        ]
    },
    {
        "id": 128,
        "expression": "^[_a-zA-Z0-9-]+(\\.[_a-zA-Z0-9-]+)*@[a-zA-Z0-9-]+(\\.[a-zA-Z0-9-]+)*\\.(([0-9]{1,3})|([a-zA-Z]{2,3})|(aero|coop|info|museum|name))$",
        "description": "Matches e-mail addresses, including some of the newer top-level-domain extensions, such as info, museum, name, etc. Also allows for emails tied directly to IP addresses.",
        "matches": [
            "example@example.com",
            "foo@bar.info",
            "blah@127.0.0.1"
        ],
        "non_matches": [
            "broken@@example.com",
            "foo@bar.infp",
            "blah@.nospam.biz"
        ]
    },
    {
        "id": 130,
        "expression": "(^\\(\\)$|^\\(((\\([0-9]+,(\\((\\([0-9]+,[0-9]+,[0-9]+\\),)*(\\([0-9]+,[0-9]+,[0-9]+\\)){1}\\))+\\),)*(\\([0-9]+,(\\((\\([0-9]+,[0-9]+,[0-9]+\\),)*(\\([0-9]+,[0-9]+,[0-9]+\\)){1}\\))+\\)){1}\\)))$",
        "description": "This checks for the specific syntax ((A,((b,c,d),(e,f,g))), ..). No limit on number of occurances.",
        "matches": [
            "((24,((1,2,3),(3,4,5))))",
            "((1,((2,3,4),(4,5,6),(96,34,26))),(12,((1,3,4),(4,5,6),(7,8,9))))",
            "()"
        ],
        "non_matches": [
            "(24,((1,2,3),(3,4,5)))",
            "( )",
            "((23,(12,3,4),(4,5,6)))"
        ]
    },
    {
        "id": 131,
        "expression": "^[a-zA-Z]+(([\\'\\,\\.\\- ][a-zA-Z ])?[a-zA-Z]*)*$",
        "description": "Person's name (first, last, or both) in any letter case. Although not perfect, this expression will filter out many incorrect name formats (especially numerics and invalid special characters).",
        "matches": [
            "T.F. Johnson",
            "John O'Neil",
            "Mary-Kate Johnson"
        ],
        "non_matches": [
            "sam_johnson",
            "Joe--Bob Jones",
            "dfjsd0rd"
        ]
    },
    {
        "id": 132,
        "expression": "^((([0]?[1-9]|1[0-2])(:|\\.)[0-5][0-9]((:|\\.)[0-5][0-9])?( )?(AM|am|aM|Am|PM|pm|pM|Pm))|(([0]?[0-9]|1[0-9]|2[0-3])(:|\\.)[0-5][0-9]((:|\\.)[0-5][0-9])?))$",
        "description": "Matches times seperated by either : or . will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.",
        "matches": [
            "1:01 AM",
            "23:52:01",
            "03.24.36 AM"
        ],
        "non_matches": [
            "19:31 AM",
            "9:9 PM",
            "25:60:61"
        ]
    },
    {
        "id": 133,
        "expression": "^[a-zA-Z0-9\\s.\\-_']+$",
        "description": "Alphanumeric, hyphen apostrophe, comma dash spaces",
        "matches": [
            "dony d'gsa"
        ],
        "non_matches": [
            "^[a-zA-Z0-9\\s.\\-_']+$"
        ]
    },
    {
        "id": 134,
        "expression": "^(http|https|ftp)\\://[a-zA-Z0-9\\-\\.]+\\.[a-zA-Z]{2,3}(:[a-zA-Z0-9]*)?/?([a-zA-Z0-9\\-\\._\\?\\,\\'/\\\\\\+&amp;%\\$#\\=~])*$",
        "description": "Modified URL RegExp that requires (http, https, ftp)://, A nice domain, and a decent file/folder string. Allows : after domain name, and these characters in the file/folder sring (letter, numbers, - . _ ? , ' / \\ + &amp; % $ # = ~). Blocks all other special characters-good for protecting against user input!",
        "matches": [
            "http://www.blah.com/~joe",
            "ftp://ftp.blah.co.uk:2828/blah%20blah.gif",
            "https://blah.gov/blah-blah.as"
        ],
        "non_matches": [
            "www.blah.com",
            "http://www.blah&quot;blah.com/I have spaces!",
            "ftp://blah_underscore/[nope]"
        ]
    },
    {
        "id": 137,
        "expression": "[^A-Za-z0-9_@\\.]|@{2,}|\\.{5,}",
        "description": "Used as a username validation script requires:\n1. Allows All Alphanumeric characters &amp; underscore\n2. Allows One &quot;@&quot; character\n3. Allows Five &quot;.&quot; periods\n4. Rejects spaces",
        "matches": [
            "user name",
            "user#name",
            "....."
        ],
        "non_matches": [
            "User_Name1",
            "username@foo.com",
            "user.name@mail.foo.com"
        ]
    },
    {
        "id": 138,
        "expression": "^(?:(?:31(\\/|-|\\.)(?:0?[13578]|1[02]))\\1|(?:(?:29|30)(\\/|-|\\.)(?:0?[1,3-9]|1[0-2])\\2))(?:(?:1[6-9]|[2-9]\\d)?\\d{2})$|^(?:29(\\/|-|\\.)0?2\\3(?:(?:(?:1[6-9]|[2-9]\\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00))))$|^(?:0?[1-9]|1\\d|2[0-8])(\\/|-|\\.)(?:(?:0?[1-9])|(?:1[0-2]))\\4(?:(?:1[6-9]|[2-9]\\d)?\\d{2})$",
        "description": "This expression validates dates in the ITALIAN d/m/y format from 1/1/1600 - 31/12/9999. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00 since it could be any century (1900, 2000, 2100). Days and months must be 1 or 2 digits and may have leading zeros. Years must be 2 or 4 digit years. 4 digit years must be between 1600 and 9999. Date separator may be a slash (/), dash (-), or period (.)\nThanks to Michael Ash for US Version",
        "matches": [
            "29/02/1972",
            "5-9-98",
            "10-11-2002"
        ],
        "non_matches": [
            "29/02/2003",
            "12/13/2002",
            "1-1-1500"
        ]
    },
    {
        "id": 139,
        "expression": "^\\d{0,2}(\\.\\d{1,2})?$",
        "description": "This regular expression validates that the data entered is a number with a maximum of two integers and two decimals and a minimum of one integer or one decimal.",
        "matches": [
            "99.99",
            "99",
            ".99"
        ],
        "non_matches": [
            "999.999",
            "999",
            ".999"
        ]
    },
    {
        "id": 140,
        "expression": "^(http|https|ftp)\\://[a-zA-Z0-9\\-\\.]+\\.[a-zA-Z]{2,3}(:[a-zA-Z0-9]*)?/?([a-zA-Z0-9\\-\\._\\?\\,\\'/\\\\\\+&amp;%\\$#\\=~])*[^\\.\\,\\)\\(\\s]$",
        "description": "This Regex (can be used e.g. in PHP with eregi) will match any valid URL. Unlike the other exapmles here, it will NOT match a valid URL ending with a dot or bracket. This is important if you use this regex to find and &quot;activate&quot; Links in an Text",
        "matches": [
            "https://www.restrictd.com/~myhome/"
        ],
        "non_matches": [
            "http://www.krumedia.com.",
            "(http://www.krumedia.com)",
            "http://www.krumedia.com,"
        ]
    },
    {
        "id": 141,
        "expression": "^([0-9a-fA-F][0-9a-fA-F]:){5}([0-9a-fA-F][0-9a-fA-F])$",
        "description": "This will grep for a valid MAC address , with colons seperating octets. It will ignore strings too short or long, or with invalid characters. It will accept mixed case hexadecimal. Use extended grep.",
        "matches": [
            "01:23:45:67:89:ab",
            "01:23:45:67:89:AB",
            "fE:dC:bA:98:76:54"
        ],
        "non_matches": [
            "01:23:45:67:89:ab:cd",
            "01:23:45:67:89:Az",
            "01:23:45:56:"
        ]
    },
    {
        "id": 142,
        "expression": "^100$|^[0-9]{1,2}$|^[0-9]{1,2}\\,[0-9]{1,3}$",
        "description": "Percentage with 3 number after comma.",
        "matches": [
            "12,654",
            "1,987"
        ],
        "non_matches": [
            "128,2",
            "12,"
        ]
    },
    {
        "id": 143,
        "expression": "^(([0-2]\\d|[3][0-1])\\/([0]\\d|[1][0-2])\\/[2][0]\\d{2})$|^(([0-2]\\d|[3][0-1])\\/([0]\\d|[1][0-2])\\/[2][0]\\d{2}\\s([0-1]\\d|[2][0-3])\\:[0-5]\\d\\:[0-5]\\d)$",
        "description": "Correct French DateTime(DD/MM/YYYY OR DD/MM/YYYY HH:MM:SS)",
        "matches": [
            "12/01/2002",
            "12/01/2002 12:32:10"
        ],
        "non_matches": [
            "32/12/2002",
            "12/13/2001",
            "12/02/06"
        ]
    },
    {
        "id": 144,
        "expression": "^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?!.*\\s).{4,8}$",
        "description": "Password expresion that requires one lower case letter, one upper case letter, one digit, 6-13 length, and no spaces. This is merely an extension of a previously posted expression by Steven Smith (ssmith@aspalliance.com) . The no spaces is new.",
        "matches": [
            "1agdA*$#",
            "1agdA*$#",
            "1agdA*$#"
        ],
        "non_matches": [
            "wyrn%@*&amp;$# f",
            "mbndkfh782",
            "BNfhjdhfjd&amp;*)%#$)"
        ]
    },
    {
        "id": 145,
        "expression": "^([a-zA-Z0-9][-a-zA-Z0-9]*[a-zA-Z0-9]\\.)+([a-zA-Z0-9]{3,5})$",
        "description": "Host/Domain name validation for perl.\nShould be combined with a check for\nlength &lt;= 63 characters and that $2\nis in a list of top-level domains.",
        "matches": [
            "freshmeat.net",
            "123.com",
            "TempLate-toolkKt.orG"
        ],
        "non_matches": [
            "-dog.com",
            "?boy.net",
            "this.domain"
        ]
    },
    {
        "id": 146,
        "expression": "^[^']*$",
        "description": "This one matches all strings that do not contain the single quotation mark (').",
        "matches": [
            "asljas",
            "%/&amp;89uhuhadjkh",
            "&quot;hi there!&quot;"
        ],
        "non_matches": [
            "'hi there!'",
            "It's 9 o'clock",
            "'''''"
        ]
    },
    {
        "id": 147,
        "expression": "^([1-9]|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])$",
        "description": "This validates a number between 1 and 255. Could be modified to IP, or just to verify a number in a range.",
        "matches": [
            "1",
            "108",
            "255"
        ],
        "non_matches": [
            "01",
            "256"
        ]
    },
    {
        "id": 148,
        "expression": "^((https?|ftp)\\://((\\[?(\\d{1,3}\\.){3}\\d{1,3}\\]?)|(([-a-zA-Z0-9]+\\.)+[a-zA-Z]{2,4}))(\\:\\d+)?(/[-a-zA-Z0-9._?,'+&amp;%$#=~\\\\]+)*/?)$",
        "description": "Using other regular experssions from this page, combining others for email addresses, and mixing in my own ideas - I came up with this regular expression. Can be used to validate input into a database.",
        "matches": [
            "http://207.68.172.254/home.ashx",
            "ftp://ftp.netscape.com/",
            "https://www.brinkster.com/login.asp"
        ],
        "non_matches": [
            "htp://mistake.com/",
            "http://www_address.com/",
            "ftp://www.files.com/file with spaces.txt"
        ]
    },
    {
        "id": 149,
        "expression": "^[0-9](\\.[0-9]+)?$",
        "description": "matches non-negative decimal floating points numbers less than 10",
        "matches": [
            "1.2345",
            "0.00001",
            "7"
        ],
        "non_matches": [
            "12.2",
            "1.10.1",
            "15.98"
        ]
    },
    {
        "id": 153,
        "expression": "^((((31\\/(0?[13578]|1[02]))|((29|30)\\/(0?[1,3-9]|1[0-2])))\\/(1[6-9]|[2-9]\\d)?\\d{2})|(29\\/0?2\\/(((1[6-9]|[2-9]\\d)?(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))))|(0?[1-9]|1\\d|2[0-8])\\/((0?[1-9])|(1[0-2]))\\/((1[6-9]|[2-9]\\d)?\\d{2})) (20|21|22|23|[0-1]?\\d):[0-5]?\\d:[0-5]?\\d$",
        "description": "this expression validates a date-time field in European d/m/y h:m:s format. It is a european variation of Michael Ash's date-validation expression in this library.\nThe days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00",
        "matches": [
            "29/02/2004 20:15:27",
            "29/2/04 8:9:5",
            "31/3/2004 9:20:17"
        ],
        "non_matches": [
            "29/02/2003 20:15:15",
            "2/29/04 20:15:15",
            "31/3/4 9:20:17"
        ]
    },
    {
        "id": 155,
        "expression": "(^([0-9]|[0-1][0-9]|[2][0-3]):([0-5][0-9])(\\s{0,1})(AM|PM|am|pm|aM|Am|pM|Pm{2,2})$)|(^([0-9]|[1][0-9]|[2][0-3])(\\s{0,1})(AM|PM|am|pm|aM|Am|pM|Pm{2,2})$)",
        "description": "Validate \u201cTime\u201d Data to Work with SQL Server\nThis is a fix (I hope) for a problem with the original expression. It originally allowed any combination of am or pm. For example: ma, aa, mm, mp, etc.",
        "matches": [
            "8am",
            "8 am",
            "8:00 am"
        ],
        "non_matches": [
            "8a",
            "8 a",
            "8:00 a"
        ]
    },
    {
        "id": 156,
        "expression": "(?!^0*$)(?!^0*\\.0*$)^\\d{1,5}(\\.\\d{1,3})?$",
        "description": "This regular expression validates a number NOT 0, with no more than 5 places ahead and 3 places behind the decimal point.",
        "matches": [
            "1",
            "12345.123",
            "0.5"
        ],
        "non_matches": [
            "0",
            "0.0",
            "123456.1234"
        ]
    },
    {
        "id": 158,
        "expression": "@{2}((\\S)+)@{2}",
        "description": "This will match results in a template situation. For example:\ntemplate reads\nDear @@Name@@,\n....\nwould become\nDear John,\nIf you dont want to use the @@ change the @ to what ever characters you want.",
        "matches": [
            "@@test@@",
            "@@name@@",
            "@@2342@@"
        ],
        "non_matches": [
            "@test@",
            "@@na me@@",
            "@@ name@@"
        ]
    },
    {
        "id": 159,
        "expression": "([0-1][0-9]|2[0-3]):[0-5][0-9]",
        "description": "Validate an hour entry to be between 00:00 and 23:59",
        "matches": [
            "00:00",
            "13:59",
            "23:59"
        ],
        "non_matches": [
            "24:00",
            "23:60"
        ]
    },
    {
        "id": 161,
        "expression": "[A-Z][a-z]+",
        "description": "This expression was developed to match the Title cased words within a Camel cased variable name. So it will match 'First' and 'Name' within 'strFirstName'.",
        "matches": [
            "strFirstName",
            "intAgeInYears",
            "Where the Wild Things Are"
        ],
        "non_matches": [
            "123",
            "abc",
            "this has no caps in it"
        ]
    },
    {
        "id": 162,
        "expression": "^[+-]?([0-9]*\\.?[0-9]+|[0-9]+\\.?[0-9]*)([eE][+-]?[0-9]+)?$",
        "description": "A regular expression that matches numbers. Integers or decimal numbers with or without the exponential form.",
        "matches": [
            "23",
            "-17.e23",
            "+.23e+2"
        ],
        "non_matches": [
            "+.e2",
            "23.17.5",
            "10e2.0"
        ]
    },
    {
        "id": 163,
        "expression": "^([1-zA-Z0-1@.\\s]{1,255})$",
        "description": "A general string validation to insure no malicious code is being passed through user input. General enough too allow email address, names, address, passwords, so on. Disallows \u2018,\\*&amp;$&lt;&gt; or other characters that could cause issues.",
        "matches": [
            "email@email.com",
            "My Name",
            "asdf12df"
        ],
        "non_matches": [
            "\u2018,\\*&amp;$&lt;&gt;",
            "1001' string"
        ]
    },
    {
        "id": 166,
        "expression": "^(?:(?:(?:(?:(?:1[6-9]|[2-9]\\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00)))(\\/|-|\\.)(?:0?2\\1(?:29)))|(?:(?:(?:1[6-9]|[2-9]\\d)?\\d{2})(\\/|-|\\.)(?:(?:(?:0?[13578]|1[02])\\2(?:31))|(?:(?:0?[1,3-9]|1[0-2])\\2(29|30))|(?:(?:0?[1-9])|(?:1[0-2]))\\2(?:0?[1-9]|1\\d|2[0-8]))))$",
        "description": "This expression validates dates in the y/m/d format from 1600/1/1 - 9999/12/31. Follows the same validation rules for dates as my other date validator (m/d/y format) located in this library.",
        "matches": [
            "04/2/29",
            "2002-4-30",
            "02.10.31"
        ],
        "non_matches": [
            "2003/2/29",
            "02.4.31",
            "00/00/00"
        ]
    },
    {
        "id": 169,
        "expression": "([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})",
        "description": "Checks for Date in the typical MySQL DB Format. Not mutch but simple to for converting to German date format:\n$date = &quot;2003-12-03&quot;;\nif (ereg (&quot;([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})&quot;, $date, $regs))\n{\necho &quot;$regs[3].$regs[2].$regs[1]&quot;; // prints 03.12.2003\n}",
        "matches": [
            "2002-11-03",
            "2007-17-08",
            "9999-99-99"
        ],
        "non_matches": [
            "2002/17/18",
            "2002.18.45",
            "18.45.2002"
        ]
    },
    {
        "id": 170,
        "expression": "^(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])$",
        "description": "This matches an IP address, putting each number in its own group that can be retrieved by number. If you do not care about capturing the numbers, then you can make this shorter by putting everything after ^ until immediately after the first \\. in a group ( ) with a {3} after it. Then put the number matching regex in once more.\nIt only permits numbers in the range 0-255.",
        "matches": [
            "0.0.0.0",
            "255.255.255.02",
            "192.168.0.136"
        ],
        "non_matches": [
            "256.1.3.4",
            "023.44.33.22",
            "10.57.98.23."
        ]
    },
    {
        "id": 172,
        "expression": "^\\$?([1-9]{1}[0-9]{0,2}(\\,[0-9]{3})*(\\.[0-9]{0,2})?|[1-9]{1}[0-9]{0,}(\\.[0-9]{0,2})?|0(\\.[0-9]{0,2})?|(\\.[0-9]{1,2})?)$",
        "description": "Many currency expresssions allow leading zeros, thus $01.40 passes thru them. This expression kills them, except for 0 in the one's column. Works with or without commas and/or dollar sign. Decimals not mandatory, unless no zero in ones column and decimal point is placed. Allows $0.00 and .0 Keywords: money dollar currency",
        "matches": [
            "$1,234.50",
            "$0.70",
            ".7"
        ],
        "non_matches": [
            "$0,123.50",
            "$00.5"
        ]
    },
    {
        "id": 173,
        "expression": "^(((((0[1-9])|(1\\d)|(2[0-8]))-((0[1-9])|(1[0-2])))|((31-((0[13578])|(1[02])))|((29|30)-((0[1,3-9])|(1[0-2])))))-((20[0-9][0-9]))|(29-02-20(([02468][048])|([13579][26]))))$",
        "description": "This expression validates a date field in the European DD-MM-YYYY format. Days are validate for the given month and year.",
        "matches": [
            "05-01-2002",
            "29-02-2004",
            "31-12-2002"
        ],
        "non_matches": [
            "1-1-02",
            "29-02-2002",
            "31-11-2002"
        ]
    },
    {
        "id": 174,
        "expression": "^\\d*[0-9](|.\\d*[0-9]|,\\d*[0-9])?$",
        "description": "This is permit all decimal number, exclude all alphanumeric caracter",
        "matches": [
            "123456.123456",
            "123456,123456",
            "123456"
        ],
        "non_matches": [
            "123a.123",
            "123a,123",
            "a"
        ]
    },
    {
        "id": 176,
        "expression": "^([A-Z]{1,2}[0-9]{1,2}|[A-Z]{3}|[A-Z]{1,2}[0-9][A-Z])( |-)[0-9][A-Z]{2}",
        "description": "Checks whether the string specified is in the same format as the UK postcode format defined on:\nhttp://www.magma.ca/~djcl/postcd.txt\nIt allows:\nA = Letter\nN = Number\nAN NAA, ANA NAA, ANN NAA, AAN NAA, AAA NAA (rare), AANN NAA, AANA NAA\nIt gives the option to have the two parts of the uk postcode to be separated by a space or a hyphen.\n(restriction is set to all-capitals)",
        "matches": [
            "AA11 1AA",
            "AA1A 1AA",
            "A11-1AA"
        ],
        "non_matches": [
            "111 AAA",
            "1AAA 1AA",
            "A1AA 1AA"
        ]
    },
    {
        "id": 183,
        "expression": "<img([^>]*[^/])>",
        "description": "Use this along with this replacement string &lt;img\\1 /&gt; to convert image tags to XHTML compliant image tags.",
        "matches": [
            "<img src=\"bob\">"
        ],
        "non_matches": [
            "<img src=\"bob\" />"
        ]
    },
    {
        "id": 184,
        "expression": "^((0?[1-9])|((1|2)[0-9])|30|31)$",
        "description": "matches any day of\nmonth 0?1-31",
        "matches": [
            "01",
            "12",
            "31"
        ],
        "non_matches": [
            "123",
            "32",
            "abc"
        ]
    },
    {
        "id": 185,
        "expression": "&lt;!--[\\s\\S]*?--&gt;",
        "description": "Removes pesky comments and commented javascript from HTML",
        "matches": [
            "&lt;!-- comments --&gt;",
            "&lt;!-- x = a &gt; b - 3 --&gt;"
        ],
        "non_matches": [
            "&lt;COMMENTS&gt;this is a comment&lt;/COMMENTS&gt;"
        ]
    },
    {
        "id": 186,
        "expression": "&lt;/?(\\w+)(\\s+\\w+=(\\w+|&quot;[^&quot;]*&quot;|'[^']*'))*&gt;",
        "description": "Finds any HTML tag and sub-matches properties weather it has an apposterphee, quote, or no quote/apposterphee",
        "matches": [
            "&lt;TD&gt;",
            "&lt;TD bgColor=&quot;FFFFFF&quot;&gt;",
            "&lt;/TD&gt;"
        ],
        "non_matches": [
            "No Tag Here ..."
        ]
    },
    {
        "id": 187,
        "expression": "^\\{?[a-fA-F\\d]{8}-([a-fA-F\\d]{4}-){3}[a-fA-F\\d]{12}\\}?$",
        "description": "Validates a GUID with and without brackets. 8,4,4,4,12 hex characters seperated by dashes.",
        "matches": [
            "{e02ff0e4-00ad-090A-c030-0d00a0008ba0}",
            "e02ff0e4-00ad-090A-c030-0d00a0008ba0"
        ],
        "non_matches": [
            "0xe02ff0e400ad090Ac0300d00a0008ba0"
        ]
    },
    {
        "id": 188,
        "expression": "^([a-zA-Z0-9@*#]{8,15})$",
        "description": "Password matching expression. Match all alphanumeric character and predefined wild characters. Password must consists of at least 8 characters and not more than 15 characters.",
        "matches": [
            "@12X*567",
            "1#Zv96g@*Yfasd4",
            "#67jhgt@erd"
        ],
        "non_matches": [
            "$12X*567",
            "1#Zv_96",
            "+678jhgt@erd"
        ]
    },
    {
        "id": 191,
        "expression": "(\\d*)'*-*(\\d*)/*(\\d*)&quot;",
        "description": "This regular expression is for parsing feet and inches measurements.",
        "matches": [
            "5'-3/16&quot;",
            "1'-2&quot;",
            "5/16&quot;"
        ],
        "non_matches": [
            "1 3/16"
        ]
    },
    {
        "id": 192,
        "expression": "^(/w|/W|[^<>+?$%{}&])+$",
        "description": "simple expression for excluding a given list of characters. simply change the contents of [^] to suite your needs. for example ^(/w|/W|[^&lt;&gt;])+$ would allow everything except the characters &lt; and &gt;.",
        "matches": [
            "John Doe Sr.",
            "100 Elm St., Suite 25",
            "Valerie's Gift Shop"
        ],
        "non_matches": [
            "<h1>Hey</h1>"
        ]
    },
    {
        "id": 194,
        "expression": "&amp;lt;/?([a-zA-Z][-A-Za-z\\d\\.]{0,71})(\\s+(\\S+)(\\s*=\\s*([-\\w\\.]{1,1024}|&amp;quot;[^&amp;quot;]{0,1024}&amp;quot;|'[^']{0,1024}'))?)*\\s*&amp;gt;",
        "description": "Searches for tags and there atributes according to the HTML 2.0 specification to limit length of tags to 72 characters, and length of attribute values to 1024 characters.",
        "matches": [
            "&amp;lt;IMG src='stars.gif' alt=&amp;quot;space&amp;quot; height=1&amp;gt;"
        ],
        "non_matches": [
            "this is not a tag"
        ]
    },
    {
        "id": 195,
        "expression": "<[a-zA-Z][^>]*\\son\\w+=(\\w+|'[^']*'|\"[^\"]*\")[^>]*>",
        "description": "Find HTML tags that have javascript events attached to them.",
        "matches": [
            "<IMG onmouseover=\"window.close()\">"
        ],
        "non_matches": [
            "<IMG src=\"star.gif\">"
        ]
    },
    {
        "id": 196,
        "expression": "((&quot;|')[a-z0-9\\/\\.\\?\\=\\&amp;]*(\\.htm|\\.asp|\\.php|\\.jsp)[a-z0-9\\/\\.\\?\\=\\&amp;]*(&quot;|'))|(href=*?[a-z0-9\\/\\.\\?\\=\\&amp;&quot;']*)",
        "description": "Will locate an URL in a webpage.\nIt'll search in 2 ways - first it will try to locate a href=, and then go to the end of the link. If there is nu href=, it will search for the end of the file instead (.asp, .htm and so on), and then take the data between the &quot;xxxxxx&quot; or 'xxxxxx'",
        "matches": [
            "href=&quot;produktsida.asp?kategori2=218&quot;",
            "href=&quot;NuclearTesting.htm&quot;"
        ],
        "non_matches": [
            "U Suck"
        ]
    },
    {
        "id": 197,
        "expression": "^((0[1-9])|(1[0-2]))\\/(\\d{4})$",
        "description": "This regular expressions matches dates in the format MM/YYYY where MM can be 01 to 12 and YYYY is always 4 digits long.",
        "matches": [
            "12/2002",
            "11/1900",
            "02/1977"
        ],
        "non_matches": [
            "1/1977",
            "00/000",
            "15/2002"
        ]
    },
    {
        "id": 202,
        "expression": "^[A-Z]{2}[0-9]{6}[A-DFM]{1}$",
        "description": "UK National Insurance Number (NINO) validation. (The following modifications have been made: Only A to D are permitted as the last letter, and all letters should be in uppercase. For temporary numbers F and M are permitted for female and male holders.)",
        "matches": [
            "AB123456D",
            "AB123456F",
            "AB123456M"
        ],
        "non_matches": [
            "AB123456E",
            "ab123456d"
        ]
    },
    {
        "id": 203,
        "expression": "^[A-Z]{1,2}[1-9][0-9]?[A-Z]? [0-9][A-Z]{2,}|GIR 0AA$",
        "description": "Matches UK postcodes according to the following rules 1. LN NLL eg N1 1AA 2. LLN NLL eg SW4 0QL 3. LNN NLL eg M23 4PJ 4. LLNN NLL eg WS14 0JT 5. LLNL NLL eg SW1N 4TB 6. LNL NLL eg W1C 8LQ. Modifications: 1) Doesn't allow leading zeros in first part (outward) eg BT01 3RT is incorrect; it should be BT1 3RT. 2) Only allows uppercase letters, which is the preference of the UK Post Office. 3) Permits the only postcode to break the rules - GIR 0AA (for the old Girobank, now Alliance &amp; Leicester bank, address)",
        "matches": [
            "G1 1AA",
            "GIR 0AA",
            "SW1 1ZZ"
        ],
        "non_matches": [
            "BT01 3RT",
            "G111 1AA"
        ]
    },
    {
        "id": 204,
        "expression": "^([0]\\d|[1][0-2])\\/([0-2]\\d|[3][0-1])\\/([2][01]|[1][6-9])\\d{2}(\\s([0-1]\\d|[2][0-3])(\\:[0-5]\\d){1,2})?$",
        "description": "This is a regular expression to validate a date string in &quot;MM/DD/YYYY&quot; format, a date time string in &quot;MM/DD/YYYY HH:MM&quot; or a date time string in &quot;MM/DD/YYYY HH:MM:SS&quot; format.\nIt can validate date from 1600 to 2199.",
        "matches": [
            "12/30/2002",
            "01/12/1998 13:30",
            "01/28/2002 22:35:00"
        ],
        "non_matches": [
            "13/30/2002",
            "01/12/1998 24:30",
            "01/28/2002 22:35:64"
        ]
    },
    {
        "id": 207,
        "expression": "^([0]\\d|[1][0-2])\\/([0-2]\\d|[3][0-1])\\/([2][01]|[1][6-9])\\d{2}(\\s([0]\\d|[1][0-2])(\\:[0-5]\\d){1,2})*\\s*([aApP][mM]{0,2})?$",
        "description": "This is a combination of a few regular expressions found on this site. It allows for a flexible date and time combination, but requires a 12-hour clock (am/pm). Many versions of the am/pm are supported.",
        "matches": [
            "12/31/2002",
            "12/31/2002 08:00",
            "12/31/2002 08:00 AM"
        ],
        "non_matches": [
            "12/31/02",
            "12/31/2002 14:00"
        ]
    },
    {
        "id": 208,
        "expression": "<blockquote>(?:\\s*([^<]+)<br>\\s*)+</blockquote>",
        "description": "Use this regular expression pattern to get the string1, string2, string3 .... from &lt;blockquote&gt;string1&lt;br&gt;string2&lt;br&gt;string3&lt;br&gt;&lt;/blockquote&gt;",
        "matches": [
            "<blockquote>string1<br>string2<br>string3<br></blockquote>"
        ],
        "non_matches": [
            ".."
        ]
    },
    {
        "id": 209,
        "expression": "^((0?[13578]|10|12)(-|\\/)(([1-9])|(0[1-9])|([12])([0-9]?)|(3[01]?))(-|\\/)((19)([2-9])(\\d{1})|(20)([01])(\\d{1})|([8901])(\\d{1}))|(0?[2469]|11)(-|\\/)(([1-9])|(0[1-9])|([12])([0-9]?)|(3[0]?))(-|\\/)((19)([2-9])(\\d{1})|(20)([01])(\\d{1})|([8901])(\\d{1})))$",
        "description": "improved date validation M/D/YY or M/D/YYYY or MM/DD/YYYY or MM/DD/YY: 1/1/1920 through 12/31/2019; Feb 29 and 30 always allowed, deal with it",
        "matches": [
            "1/2/03",
            "02/30/1999",
            "3/04/00"
        ],
        "non_matches": [
            "3/4/2020",
            "3/4/1919",
            "4/31/2000"
        ]
    },
    {
        "id": 210,
        "expression": "&lt;/?(\\w+)(\\s*\\w*\\s*=\\s*(&quot;[^&quot;]*&quot;|'[^']'|[^&gt;]*))*|/?&gt;",
        "description": "Matches HTML of XML tags, with or without attributes (single-, double-, or non-quoted), closing tags, or self-closing singleton tags.",
        "matches": [
            "&lt;font color=&quot;blue&quot;&gt;",
            "&lt;/font&gt;",
            "&lt;br /&gt;"
        ],
        "non_matches": [
            "this is a test..."
        ]
    },
    {
        "id": 211,
        "expression": "^(([0]?[1-9]|1[0-2])(:)([0-5][0-9]))$",
        "description": "This time validation expression accepts an hour between 1 and 9 (with optional leading zero) and minutes between 01 and 59. This is primarily for use with an AM/PM drop down list or radio button.",
        "matches": [
            "09:00",
            "9:00",
            "11:35"
        ],
        "non_matches": [
            "13:00",
            "9.00",
            "6:60"
        ]
    },
    {
        "id": 212,
        "expression": "^ *(1[0-2]|[1-9]):[0-5][0-9] *(a|p|A|P)(m|M) *$",
        "description": "validate 12-hour time with am/pm after it, with optional spaces before or after, and optionally between time and am/pm.",
        "matches": [
            "12:00am",
            "1:00 PM",
            "12:59 pm"
        ],
        "non_matches": [
            "0:00",
            "0:01 am",
            "13:00 pm"
        ]
    },
    {
        "id": 215,
        "expression": "^(([0]?[1-9]|[1][0-2])[\\/|\\-|\\.]([0-2]\\d|[3][0-1]|[1-9])[\\/|\\-|\\.]([2][0])?\\d{2}\\s+((([0][0-9]|[1][0-2]|[0-9])[\\:|\\-|\\.]([0-5]\\d)\\s*([aApP][mM])?)|(([0-1][0-9]|[2][0-3]|[0-9])[\\:|\\-|\\.]([0-5]\\d))))$",
        "description": "MM-DD-20YY HH:MM AP\nMM-DD-20YY H:MM AP\nMM-DD-20YY HH:MM\nMM-DD-20YY H:MM\nMM-DD-YY HH:MM AP\nMM-DD-YY H:MM AP\nMM-DD-YY HH:MM\nMM-DD-YY H:MM\nM-D-YY HH:MM AP\nM-D-YY H:MM AP\nM-D-YY HH:MM\nM-D-YY H:MM\nwhere - can be / or - or .\nwhere : can be : or - or .\nDefinition:\n^( ;Start of Line\n([0]?[1-9]|[1][0-2]) ;00-09 or 10-12 or 1-9\n[\\/|\\-|\\.] ;/ or - or .\n([0-2]\\d|[3][0-1]|[1-9]) ;00-29 or 30-31 or 1-9\n[\\/|\\-|\\.] ;/ or - or .\n([2][0])?\\d{2} ;2000-2099 or 00-99\n\\s+ ;one or more spaces\n( ;must be either 12H notation w/AM|PM\n(\n([0][0-9]|[1][0-2]|[0-9])\n[\\:|\\-|\\.] ;: or - or .\n([0-5]\\d) ;01 thru 59\n\\s* ;zero or more spaces\n([aApP][mM])? ;nothing or AM or PM (case insensitive)\n)\n| ;or 24H notation w/out AM|PM\n(\n([0-1][0-9]|[2][0-3]|[0-9]) ;00-19 or 20-23\n[\\:|\\-|\\.] ;: or - or .\n([0-5]\\d) ;00-59\n)\n)\n)$ ;End of Line",
        "matches": [
            "01/01/2002 04:42",
            "5-12-02 04:42 AM",
            "01.01/02 04-42aM"
        ],
        "non_matches": [
            "01-12-1999 4:50PM",
            "01-12-2002 15:10PM",
            "01-12-002 8:20PM"
        ]
    },
    {
        "id": 216,
        "expression": "^[1-9]{1}$|^[1-4]{1}[0-9]{1}$|^50$",
        "description": "Match any number between 1 and 50, no characters, no empty sets, and not zero. Match numbers greater than 1 and less than 51, no spaces, no characters.",
        "matches": [
            "1",
            "23",
            "50"
        ],
        "non_matches": [
            "0",
            "111",
            "xyz"
        ]
    },
    {
        "id": 217,
        "expression": "^([A-Z]{1}[a-z]{1,})$|^([A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,})$|^([A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,})$|^$",
        "description": "Matches up to three alphabet words separated by spaces with first alphabet character of each word uppercase. Also matches empty strings.",
        "matches": [
            "Sacramento",
            "San Francisco",
            "San Luis Obispo"
        ],
        "non_matches": [
            "SanFrancisco",
            "SanLuisObispo",
            "San francisco"
        ]
    },
    {
        "id": 218,
        "expression": "^([1][12]|[0]?[1-9])[\\/-]([3][01]|[12]\\d|[0]?[1-9])[\\/-](\\d{4}|\\d{2})$",
        "description": "Matches dates with the following format\nMonth - either MM (like 01) or M (like 1) - from 1 to 12\nDay - either DD (like 01) or D ( like 1) - from 1 to 31\nYear - either YYYY ( like 1998) or YY (like 98)\nSeparater - either - or /",
        "matches": [
            "11-02-02",
            "1-25-2002",
            "01/25/2002"
        ],
        "non_matches": [
            "13-02-02",
            "11.02.02",
            "11/32/2002"
        ]
    },
    {
        "id": 221,
        "expression": "^([ \\u00c0-\\u01ffa-zA-Z'])+$",
        "description": "Expression to match names and dis-allow any attempts to send evil characters. In particular, it tries to allow\nnon-english names by allowing unicode characters.",
        "matches": [
            "Jon Doe",
            "J\u00f8rn",
            "Mc'Neelan"
        ],
        "non_matches": [
            "Henry); hacking attempt"
        ]
    },
    {
        "id": 222,
        "expression": "(([0-1][0-9])|([2][0-3])):([0-5][0-9]):([0-5][0-9])",
        "description": "Validates time in MySQL time format. 24 hour time colon seperated hours:minutes:seconds",
        "matches": [
            "09:30:00",
            "17:45:20",
            "23:59:59"
        ],
        "non_matches": [
            "24:00:00"
        ]
    },
    {
        "id": 223,
        "expression": "^((([0]?[1-9]|1[0-2])(:|\\.)(00|15|30|45)?( )?(AM|am|aM|Am|PM|pm|pM|Pm))|(([0]?[0-9]|1[0-9]|2[0-3])(:|\\.)(00|15|30|45)?))$",
        "description": "This expression will allow a time value with 15 minute increments. It will not accept seconds. You can use either US time or Military time format.",
        "matches": [
            "1:00 PM",
            "6:45 am",
            "17:30"
        ],
        "non_matches": [
            "4:32 am",
            "5:30:00 am",
            "17:01"
        ]
    },
    {
        "id": 224,
        "expression": "^([0]?[1-9]|[1|2][0-9]|[3][0|1])[./-]([0]?[1-9]|[1][0-2])[./-]([0-9]{4}|[0-9]{2})$",
        "description": "Validate brazilian date formats: dd/mm/yyyy or d/m/yy or d.m.yyyy\nwith separators: . - /\nValid dates only! d (1-31)/ m (1-12)/ y (0..)\n(rizzipereira.com.br)\nFor American date format: http://www.regexlib.com/REDetails.aspx?regexp_id=932",
        "matches": [
            "10/03/1979",
            "1-1-02",
            "01.1.2003"
        ],
        "non_matches": [
            "10/03/197",
            "09--02--2004",
            "01 02 03"
        ]
    },
    {
        "id": 225,
        "expression": "(^\\d*\\.?\\d*[1-9]+\\d*$)|(^[1-9]+\\d*\\.\\d*$)",
        "description": "Accepts only positive decimal values. Zero and negatvie numbers are non-matching. Allows zeros after last non-zero numeric value after decimal place for significant digits.",
        "matches": [
            "0.050",
            "5.0000",
            "5000"
        ],
        "non_matches": [
            "0",
            "0.0",
            ".0"
        ]
    },
    {
        "id": 226,
        "expression": "(^-\\d*\\.?\\d*[1-9]+\\d*$)|(^-[1-9]+\\d*\\.\\d*$)",
        "description": "Accepts only negative decimal values. Zero and positive numbers are non-matching. Allows zeros after last non-zero numeric value after decimal place for significant digits.",
        "matches": [
            "-0.050",
            "-5.000",
            "-5"
        ],
        "non_matches": [
            "0",
            "0.0",
            ".0"
        ]
    },
    {
        "id": 227,
        "expression": "^([2][0]\\d{2}\\/([0]\\d|[1][0-2])\\/([0-2]\\d|[3][0-1]))$|^([2][0]\\d{2}\\/([0]\\d|[1][0-2])\\/([0-2]\\d|[3][0-1])\\s([0-1]\\d|[2][0-3])\\:[0-5]\\d\\:[0-5]\\d)$",
        "description": "this is a regular expression that for chinese programer!\nyyyy/mm/dd hh:mm:ss",
        "matches": [
            "2002/02/03",
            "2002/02/03 12:12:18"
        ],
        "non_matches": [
            "2002/02/36",
            "02/03/2002"
        ]
    },
    {
        "id": 228,
        "expression": "^(\\d|,)*\\.?\\d*$",
        "description": "Matches Numeric with Commas and a single decimal point. Also matches empty string.",
        "matches": [
            "1,000",
            "3,000.05",
            "5,000,000"
        ],
        "non_matches": [
            "abc",
            "$100,000",
            "Forty"
        ]
    },
    {
        "id": 231,
        "expression": "^[+]?\\d*$",
        "description": "This re was used for set numbers only!\nSomente numeros s&#227;o requeridos!",
        "matches": [
            "0123456789",
            "1234",
            "1"
        ],
        "non_matches": [
            "1.0?&amp;",
            "a1",
            "2a-"
        ]
    },
    {
        "id": 233,
        "expression": "^[0-9A-Za-z_ ]+(.[jJ][pP][gG]|.[gG][iI][fF])$",
        "description": "Matches HTML image leaf filenames.",
        "matches": [
            "good.gif",
            "go d.GIf",
            "goo_d.jPg"
        ],
        "non_matches": [
            "junk",
            "bad.bad.gif",
            "slash\\gif."
        ]
    },
    {
        "id": 234,
        "expression": "^([A-PR-UWYZ0-9][A-HK-Y0-9][AEHMNPRTVXY0-9]?[ABEHMNPRVWXY0-9]? {1,2}[0-9][ABD-HJLN-UW-Z]{2}|GIR 0AA)$",
        "description": "Regular expression to match valid UK postcodes.\nIn the UK postal system not all letters are used in all positions (the same with vehicle registration plates) and there are various rules to govern this. This regex takes into account those rules.\nDetails of the rules:\nFirst half of postcode\nValid formats\n[A-Z][A-Z][0-9][A-Z]\n[A-Z][A-Z][0-9][0-9]\n[A-Z][0-9][0-9]\n[A-Z][A-Z][0-9]\n[A-Z][A-Z][A-Z]\n[A-Z][0-9][A-Z]\n[A-Z][0-9]\nExceptions\nPosition - First.\nContraint - QVX not used\nPosition - Second.\nContraint - IJZ not used except in GIR 0AA\nPosition - Third.\nConstraint - AEHMNPRTVXY only used\nPosition - Forth.\nContraint - ABEHMNPRVWXY\nSecond half of postcode\nValid formats\n[0-9][A-Z][A-Z]\nExceptions\nPosition - Second and Third.\nContraint - CIKMOV not used",
        "matches": [
            "DN3 6GB",
            "SW42 4RG",
            "GIR 0AA"
        ],
        "non_matches": [
            "SEW4 5TY",
            "AA2C 4FG",
            "AA2 4CV"
        ]
    },
    {
        "id": 235,
        "expression": "^([0-1]?[0-9]|[2][0-3]):([0-5][0-9])$",
        "description": "Accepts data of time in format h:mm and hh:mm\n^([0-1]?[0-9]|[2][0-3]):([0-5][0-9])$\nin php [0-23]:[0-59]{2} (posix)",
        "matches": [
            "0:00",
            "23:00",
            "00:59"
        ],
        "non_matches": [
            "0:0",
            "24:00",
            "00:60"
        ]
    },
    {
        "id": 236,
        "expression": "^((0[1-9])|(1[0-2]))\\/(\\d{2})$",
        "description": "Validates MM/YY for rough checking credit card expiration dates.",
        "matches": [
            "11/03",
            "01/04"
        ],
        "non_matches": [
            "13/03",
            "10/2003"
        ]
    },
    {
        "id": 238,
        "expression": "<script[^>]*>[\\w|\\t|\\r|\\W]*</script>",
        "description": "this pattern can find all lines of script in HTML code from open to close tag range",
        "matches": [
            "<script language=javascript>document.write(\"one\");</script>"
        ],
        "non_matches": [
            "--"
        ]
    },
    {
        "id": 239,
        "expression": "(^|\\s)(00[1-9]|0[1-9]0|0[1-9][1-9]|[1-6]\\d{2}|7[0-6]\\d|77[0-2])(-?|[\\. ])([1-9]0|0[1-9]|[1-9][1-9])\\3(\\d{3}[1-9]|[1-9]\\d{3}|\\d[1-9]\\d{2}|\\d{2}[1-9]\\d)($|\\s|[;:,!\\.\\?])",
        "description": "Incorporated other people's examples; removed extraneous parenthesis on 10/7/04. Currently the SSA site says 772 is the highest AREA number generated (http://www.ssa.gov/employer/highgroup.txt). Old expression was: (^|\\s)\\d{3}(-?|[\\. ])\\d{2}\\2\\d{4}($|\\s|[;:,!\\.\\?]). Looks for either the beginning of a line or whitespace before the beginning of the social security number, then either zero or one hyphen OR one of a period or space, then uses the \\3 to reference the value returned in the parenthesis that includes the -?|[\\. ] (basically says if the first dash, period, or space is there, then the second one is required; and if the first dash, period, or space is not there, then the second one can't be either), and finally looks for the end of a line, whitespace, or punctuation characters after the social security number.",
        "matches": [
            "123-45-6789",
            "123 45 6789",
            "123456789"
        ],
        "non_matches": [
            "12345-67-890123",
            "1234-56-7890",
            "123-45-78901"
        ]
    },
    {
        "id": 241,
        "expression": "^[-+]?[1-9]\\d*\\.?[0]*$",
        "description": "This will check if a number is an integer. Positive integers are all the whole numbers greater than zero: 1, 2, 3, 4, 5, ... . Negative integers are all the opposites of whole numbers: -1, -2, -3,-4, -5, ... . Zero is not a whole number with either a positive or negative value, and is not an interger. Null or Empty values are not intergers.",
        "matches": [
            "10",
            "-10",
            "+10.00"
        ],
        "non_matches": [
            "0",
            "-10.50",
            "10.50"
        ]
    },
    {
        "id": 242,
        "expression": "^[\\w-]+(\\.[\\w-]+)*@([a-z0-9-]+(\\.[a-z0-9-]+)*?\\.[a-z]{2,6}|(\\d{1,3}\\.){3}\\d{1,3})(:\\d{4})?$",
        "description": "Matches a valid email address including ip's which are rarely used. Allows for a-z0-9_.- in the username, but not ending in a full stop i.e user.@domain.com is invalid and a-z0-9- as the optional sub domain(s) with domain name and a 2-7 char (a-z) tld allowing for short tld's like ca and new ones like museum.",
        "matches": [
            "username@domain.com",
            "u-s_e.r1@s-ub2.domain-name.museum:8080",
            "user_name@123.123.123.12"
        ],
        "non_matches": [
            "user@domain",
            "user@domain.c",
            "user.@domain.com"
        ]
    },
    {
        "id": 244,
        "expression": "^(([0]?[0-5][0-9]|[0-9]):([0-5][0-9]))$",
        "description": "This regex is to validate the time of a ~60 minute CD where the most time on the CD is 59:59 (minutes:seconds). It is derived from Ken Madden's time regex for a project for Erik Porter (Windows/Web guru). Written by Jason Gaylord.",
        "matches": [
            "30:05",
            "5:05",
            "02:59"
        ],
        "non_matches": [
            "25:7",
            "5m:16",
            "60:60"
        ]
    },
    {
        "id": 245,
        "expression": "^[0-9]{1,}(,[0-9]+){0,}$",
        "description": "It could be use to validate html input form (checkbox, optionbox, selectbox) when you have multiple numeric value under one field name. The validation is that the user have at lease chose one or more!",
        "matches": [
            "1111",
            "47,26,2,1,1111,12",
            "25,1245,2122,23232"
        ],
        "non_matches": [
            "111,",
            "1a1,111,1212,23",
            "11aa,aaa,asas,asa"
        ]
    },
    {
        "id": 249,
        "expression": "^\\$?(\\d{1,3},?(\\d{3},?)*\\d{3}(\\.\\d{1,3})?|\\d{1,3}(\\.\\d{2})?)$",
        "description": "Expression to handle US currency entry in .NET. Handy for regular expression validation controls where the user can be entering in a currancy value but you can't control explict entry values. Will accept a wide variety of values that can be easy cast to a double via the CDbl function. Expression is also compatible with default US string format for currency.",
        "matches": [
            "10000",
            "10,000",
            "$1,000.00"
        ],
        "non_matches": [
            "0.002",
            "x.0"
        ]
    },
    {
        "id": 250,
        "expression": "^\\d{0,2}(\\.\\d{1,4})? *%?$",
        "description": "An expression for .NET regular expression validation controls intended to faciliate the entry of percentage values both a whole numbers or as their decimal representations. Also compatible with the default US format for string formatting for percentages.\nRecommend that if you intended accept a value passing this express that you strip the percentage signs and take measures to ensure that any whole values are converted to percentages.",
        "matches": [
            "4.0%",
            "0.45",
            ".0345"
        ],
        "non_matches": [
            "123",
            "%12"
        ]
    },
    {
        "id": 251,
        "expression": "^(?![0-9]{6})[0-9a-zA-Z]{6}$",
        "description": "matches a six character &quot;password&quot; that has to consist of numbers and letters with at least one letter in it.",
        "matches": [
            "123a12",
            "a12345",
            "aaaaaa"
        ],
        "non_matches": [
            "111111"
        ]
    },
    {
        "id": 252,
        "expression": "((^(10|12|0?[13578])([/])(3[01]|[12][0-9]|0?[1-9])([/])((1[8-9]\\d{2})|([2-9]\\d{3}))$)|(^(11|0?[469])([/])(30|[12][0-9]|0?[1-9])([/])((1[8-9]\\d{2})|([2-9]\\d{3}))$)|(^(0?2)([/])(2[0-8]|1[0-9]|0?[1-9])([/])((1[8-9]\\d{2})|([2-9]\\d{3}))$)|(^(0?2)([/])(29)([/])([2468][048]00)$)|(^(0?2)([/])(29)([/])([3579][26]00)$)|(^(0?2)([/])(29)([/])([1][89][0][48])$)|(^(0?2)([/])(29)([/])([2-9][0-9][0][48])$)|(^(0?2)([/])(29)([/])([1][89][2468][048])$)|(^(0?2)([/])(29)([/])([2-9][0-9][2468][048])$)|(^(0?2)([/])(29)([/])([1][89][13579][26])$)|(^(0?2)([/])(29)([/])([2-9][0-9][13579][26])$))",
        "description": "This Validator Validates any date from 1800 - 9999. It takes special care of Leap years and validates any format of type mm/dd/yyyy , m/dd/yyyy , mm/d/yyyy , m/d/yyyy.\nSince SQL Server does not accept any date before 1/1/1753, so i hope it will meet Your Requirements.(Modified Version of Jason West's Date Validator.)",
        "matches": [
            "2/2/2000",
            "02/02/2000",
            "02/2/2000"
        ],
        "non_matches": [
            "2.2.2000",
            "2-2-2000"
        ]
    },
    {
        "id": 254,
        "expression": "^\\d* \\d*\\/{1}\\d*$|^\\d*$",
        "description": "This expression is used to validate fractions (entered as strings). It will also accept non-fractional entries. Simple, but effective.",
        "matches": [
            "100",
            "1 1/2",
            "1232 5/8"
        ],
        "non_matches": [
            "a 1/2",
            "abc",
            "a b/c"
        ]
    },
    {
        "id": 255,
        "expression": "^\\(?[\\d]{3}\\)?[\\s-]?[\\d]{3}[\\s-]?[\\d]{4}$",
        "description": "This regular expression matches 10 digit US Phone numbers in different formats. Some examples are\n1)area code in paranthesis.\n2)space between different parts of the phone number.\n3)no space between different parts of the number.\n4)dashes between parts.",
        "matches": [
            "(573)8841878",
            "573-884-1234",
            "573 234 1256"
        ],
        "non_matches": [
            "(573)(673)2345",
            "573-12-2345"
        ]
    },
    {
        "id": 257,
        "expression": "^(([A-Za-z0-9]+_+)|([A-Za-z0-9]+\\-+)|([A-Za-z0-9]+\\.+)|([A-Za-z0-9]+\\++))*[A-Za-z0-9]+@((\\w+\\-+)|(\\w+\\.))*\\w{1,63}\\.[a-zA-Z]{2,6}$",
        "description": "It verifies that: - Only letters, numbers and email acceptable symbols (+, _, -, .) are allowed - No two different symbols may follow each other - Cannot begin with a symbol - Ending domain must be at least 2 letters - Supports subdomains - TLD must be between 2 and 6 letters (Ex: .ca, .museum) - Only (-) and (.) symbols are allowed in domain, but not consecutively.\nProblems:\nSee comments below",
        "matches": [
            "g_s+gav@com.com",
            "gav@gav.com",
            "jim@jim.c.dc.ca"
        ],
        "non_matches": [
            "gs_.gs@com.com",
            "gav@gav.c",
            "jim@--c.ca"
        ]
    },
    {
        "id": 262,
        "expression": "(^[A-Z\u00c0-\u00dc]{1}[a-z\u00e0-\u00fc']+\\s[a-zA-Z\u00e0-\u00fc\u00c0-\u00dc]+((([\\s\\.'])|([a-z\u00e0-\u00fc']+))|[a-z\u00e0-\u00fc']+[a-zA-Z\u00e0-\u00fc\u00c0-\u00dc']+))",
        "description": "Checks if has the first and the last name, and check the capital letters.\nUse with the RegExp.test method",
        "matches": [
            "Carlos Rodrigues",
            "C\u00e1 de Laaa",
            "Crras R. L. Rodrig\u00fces"
        ],
        "non_matches": [
            "aa\u00e4A"
        ]
    },
    {
        "id": 263,
        "expression": "(^((((0[1-9])|([1-2][0-9])|(3[0-1]))|([1-9]))\\x2F(((0[1-9])|(1[0-2]))|([1-9]))\\x2F(([0-9]{2})|(((19)|([2]([0]{1})))([0-9]{2}))))$)",
        "description": "dd/mm/yy\nCheck dates between 1/1/1900 - 31/12/2099",
        "matches": [
            "31/12/2099",
            "1/1/1900",
            "10/12/2003"
        ],
        "non_matches": [
            "05/11/3000",
            "11/13/2003",
            "32/04/2030"
        ]
    },
    {
        "id": 265,
        "expression": "^(\\{|\\[|\\().+(\\}|\\]|\\)).+$",
        "description": "Matches &quot;clan&quot; nicks/names.",
        "matches": [
            "{CLaN}nick",
            "[Clan]Nick",
            "(Clan)Nick"
        ],
        "non_matches": [
            "Nick"
        ]
    },
    {
        "id": 266,
        "expression": "^(([\\w][\\w\\-\\.]*)\\.)?([\\w][\\w\\-]+)(\\.([\\w][\\w\\.]*))?$",
        "description": "Is used to evaluating domain names, none of the extras such as paths or protocols.",
        "matches": [
            "zigamorph.com",
            "www.zigamorph.com",
            "localhost"
        ],
        "non_matches": [
            "http://www.zigamorph.com",
            "ftp://zigamorph.com",
            "localhost/default.aspx"
        ]
    },
    {
        "id": 269,
        "expression": "^([a-zA-Z.\\s']{1,50})$",
        "description": "This is just a regular special char expression used to get the hax0rs off your back (hopefully). You can use this for regular open name checking if you wanted. It only fails on the insert of anything other than a-z, A-Z, and ' or whitespace. I'm open to suggestions, but try to email them to me as well as posting them to help others. Thanks.",
        "matches": [
            "Jon M. Doe",
            "Tim L. O'Doul",
            "...'''''"
        ],
        "non_matches": [
            "Doe, Jon",
            "&lt;&gt;,;:&quot;?/",
            "%\\$#@!"
        ]
    },
    {
        "id": 270,
        "expression": "^([a-zA-Z0-9!@#$%^&amp;*()-_=+;:'&quot;|~`&lt;&gt;?/{}]{1,5})$",
        "description": "This Regular expression validates a string that contains all printable characters with a minimum length of 1 and maximum length of 5.\nObviously the min and max can be changed to meet the users needs.\n^([a-zA-Z0-9!@#$%^&amp;*()-_=+;:'&quot;|~`&lt;&gt;?/{}]{1,5})$ This is the string, I keep getting &amp;amp;lt and other characters when I save it.",
        "matches": [
            "ilove",
            "$%*!_",
            "it"
        ],
        "non_matches": [
            "123456",
            "This is great"
        ]
    },
    {
        "id": 271,
        "expression": "^[0-9]{4}\\s{0,2}[a-zA-z]{2}$",
        "description": "Dutch postalcode expression. 4 digits followed by max. two spaces end ending on two letters.",
        "matches": [
            "4006 AB",
            "4006ab",
            "4006 AB"
        ],
        "non_matches": [
            "4006.ab",
            "4006_ab",
            "4006/ab"
        ]
    },
    {
        "id": 273,
        "expression": "^([\\(]{1}[0-9]{3}[\\)]{1}[ |\\-]{0,1}|^[0-9]{3}[\\-| ])?[0-9]{3}(\\-| ){1}[0-9]{4}$",
        "description": "Validates US phone numbers. Phone number can be delimited with dashes or spaces. Area code can optionally include parentheses. To optionally validate area codes, try this expression.\n^([\\(]{1}[0-9]{3}[\\)]{1}[ |\\-]{0,1}|^[0-9]{3}[\\-| ])?[0-9]{3}(\\-| ){1}[0-9]{4}$",
        "matches": [
            "(111) 223-2332",
            "(222)233-2332",
            "232-323-3233"
        ],
        "non_matches": [
            "(ddd) 223-2332",
            "222-232/2333",
            "322-3223-222"
        ]
    },
    {
        "id": 275,
        "expression": "^(?:(?:(?:0?[1-9]|1\\d|2[0-8])\\/(?:0?[1-9]|1[0-2]))\\/(?:(?:1[6-9]|[2-9]\\d)\\d{2}))$|^(?:(?:(?:31\\/0?[13578]|1[02])|(?:(?:29|30)\\/(?:0?[1,3-9]|1[0-2])))\\/(?:(?:1[6-9]|[2-9]\\d)\\d{2}))$|^(?:29\\/0?2\\/(?:(?:(?:1[6-9]|[2-9]\\d)(?:0[48]|[2468][048]|[13579][26]))))$",
        "description": "This expression validates dates in the Brazilian d/m/y format from 1/1/1600 - 12/31/9999. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999. Days and months must be 1 or 2 digits and may have leading zeros. Years must be 4 digit years, between 1600 and 9999. Date separator must be a slash (/)",
        "matches": [
            "29/02/2004",
            "15/3/1824",
            "31/01/2001"
        ],
        "non_matches": [
            "29/02/2000",
            "21/10/92",
            "31/02/2001"
        ]
    },
    {
        "id": 277,
        "expression": "^\\$?(\\d{1,3},?(\\d{3},?)*\\d{3}(\\.\\d{0,2})?|\\d{1,3}(\\.\\d{0,2})?|\\.\\d{1,2}?)$",
        "description": "This expression will validate for US Currency with a wide range of input. Using other exps found on this site, I built this one to fix 2 main problems I was finding:\n1-a space or blank entry is non-matching\n2-use of .9 in place of .90 will match (this is for those people like me who hate to type and if I put .9 I mean .90\nHope this helps others save a little time. I feel I was pretty thorough in testing, but if you find something wrong, please post it. -Thanks",
        "matches": [
            "$1.99",
            "1.99",
            ".99"
        ],
        "non_matches": [
            "$10.999",
            "100,00.99",
            "blank"
        ]
    },
    {
        "id": 278,
        "expression": "^(([1-9]|[0-2]\\d|[3][0-1])\\.([1-9]|[0]\\d|[1][0-2])\\.[2][0]\\d{2})$|^(([1-9]|[0-2]\\d|[3][0-1])\\.([1-9]|[0]\\d|[1][0-2])\\.[2][0]\\d{2}\\s([1-9]|[0-1]\\d|[2][0-3])\\:[0-5]\\d)$",
        "description": "Correct German DateTime. Does not check leap year rules!\nPossible Formats of date part:\nD.M.YYYY or D.MM.YYYY or DD.MM.YYYY or DD.M.YYYY\nPossible formats of time part:\nh:mm or hh:mm",
        "matches": [
            "20.10.2003 08:10",
            "24.12.2003",
            "1.1.2004 8:15"
        ],
        "non_matches": [
            "25.13.2004",
            "20.10.2003 08:9"
        ]
    },
    {
        "id": 279,
        "expression": "^((((0?[1-9]|[12]\\d|3[01])[\\.\\-\\/](0?[13578]|1[02])[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}))|((0?[1-9]|[12]\\d|30)[\\.\\-\\/](0?[13456789]|1[012])[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}))|((0?[1-9]|1\\d|2[0-8])[\\.\\-\\/]0?2[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}))|(29[\\.\\-\\/]0?2[\\.\\-\\/]((1[6-9]|[2-9]\\d)?(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)|00)))|(((0[1-9]|[12]\\d|3[01])(0[13578]|1[02])((1[6-9]|[2-9]\\d)?\\d{2}))|((0[1-9]|[12]\\d|30)(0[13456789]|1[012])((1[6-9]|[2-9]\\d)?\\d{2}))|((0[1-9]|1\\d|2[0-8])02((1[6-9]|[2-9]\\d)?\\d{2}))|(2902((1[6-9]|[2-9]\\d)?(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)|00))))$",
        "description": "Date with leap years. Accepts '.' '-' and '/' as separators\nd.m.yy to dd.mm.yyyy (or d.mm.yy, etc)\nEx: dd-mm-yyyy d.mm/yy dd/m.yyyy etc etc\nAccept 00 years also.",
        "matches": [
            "29.2.2004",
            "31121975",
            "29/2-00"
        ],
        "non_matches": [
            "29.2.2005",
            "32121975",
            "29.2/01"
        ]
    },
    {
        "id": 281,
        "expression": "&lt;[iI][mM][gG]([^&gt;]*[^/&gt;])",
        "description": "simple little RegExp to get the IMG tag from HTML",
        "matches": [
            "&lt;img src=&quot;abc.jpg&quot;&gt;",
            "&lt;img src=&quot;abc.jpg&quot;/&gt;",
            "&lt;ImG src=&quot;abc.j"
        ],
        "non_matches": [
            "none"
        ]
    },
    {
        "id": 282,
        "expression": "\\d{2}.?\\d{3}.?\\d{3}/?\\d{4}-?\\d{2}",
        "description": "This regular expressions matches CNPJ number. CNPJ is a Registration Number of Brazilian Companies.",
        "matches": [
            "00.000.000/0000-00",
            "00000000000000"
        ],
        "non_matches": [
            "00-000-000-000-00",
            "AA.AAA.AAA/AAAA-AA"
        ]
    },
    {
        "id": 283,
        "expression": "('.*$|Rem((\\t| ).*$|$)|&quot;(.|&quot;&quot;)*?&quot;)",
        "description": "Pulls out comments (both Rem and ') and string literals from VB or VBScript. Usefull for spell checking or review.\nNotes: The VBScript for &quot;Rem&quot; documentation says that it must be followed by a space but VBScript seems to accept tab characters as well.\nThe multiline flag is assumed for this search.",
        "matches": [
            "' This is a comment",
            "Rem This is a comment",
            "&quot; This is a string with &quot;&quot; and ' &quot;"
        ],
        "non_matches": [
            "&quot; This is not a string",
            "RemThis is not a comment",
            "This is not a comment or a string"
        ]
    },
    {
        "id": 285,
        "expression": "^((\\d{2}((0[13578]|1[02])(0[1-9]|[12]\\d|3[01])|(0[13456789]|1[012])(0[1-9]|[12]\\d|30)|02(0[1-9]|1\\d|2[0-8])))|([02468][048]|[13579][26])0229)$",
        "description": "Date expression validator with format YYMMDD\nValidates leap years.\nOf course, as year has only 2 digits, it's not possible to invalidate years like 2100, 2200, 2300, etc as a non-leap years !",
        "matches": [
            "751231",
            "000229",
            "040229"
        ],
        "non_matches": [
            "750431",
            "010229",
            "050229"
        ]
    },
    {
        "id": 287,
        "expression": "^((\\\"[^\\\"\\f\\n\\r\\t\\v\\b]+\\\")|([\\w\\!\\#\\$\\%\\&\\'\\*\\+\\-\\~\\/\\^\\`\\|\\{\\}]+(\\.[\\w\\!\\#\\$\\%\\&\\'\\*\\+\\-\\~\\/\\^\\`\\|\\{\\}]+)*))@((\\[(((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9])))\\])|(((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9])))|((([A-Za-z0-9\\-])+\\.)+[A-Za-z\\-]+))$",
        "description": "Email address validator. Should cover most of RFC 822, including unusual (but still valid) addresses. Does not restrict the top level domain size, but you're better off doing an nslookup or similar if you absolutely must have a valid domain. Accepts IP Addresses instead of the domain, with or without brackets. Believe it or not, this one is valid: !#$%^&amp;amp;amp;amp;*-+~/'`|{}@xyz.com\nSorry looks like this site is mangling the quote and ampersand characters - you'll have to fix that yourself.",
        "matches": [
            "/A/Wacky/User@weirdos.com",
            "bob.builder@[1.1.1.1]",
            "\"blah b. blahburger\"@blah.com"
        ],
        "non_matches": [
            "./A/Wacky/User@weirdos.com",
            "bob.builder@[256.1.1.1]",
            "-\"blah b. blahburger\"@blah.com"
        ]
    },
    {
        "id": 288,
        "expression": "^(\\d|-)?(\\d|,)*\\.?\\d*$",
        "description": "Input for Numeric values. Handles negatives, and comma formatted values. Also handles a single decimal point",
        "matches": [
            "5,000",
            "-5,000",
            "100.044"
        ],
        "non_matches": [
            "abc",
            "Hundred",
            "1.3.4"
        ]
    },
    {
        "id": 289,
        "expression": "^[1-9]+[0-9]*$",
        "description": "Allows only positive integers that are greater then 0. Easily modified for +/- intergers and allowing zero.",
        "matches": [
            "1",
            "12",
            "124"
        ],
        "non_matches": [
            "-1",
            "a",
            "1.0"
        ]
    },
    {
        "id": 292,
        "expression": "^[A-Za-z0-9](([_\\.\\-]?[a-zA-Z0-9]+)*)@([A-Za-z0-9]+)(([\\.\\-]?[a-zA-Z0-9]+)*)\\.([A-Za-z]{2,})$",
        "description": "does not allow IP for domain name : hello@154.145.68.12\ndoes not allow litteral addresses &quot;hello, how are you?&quot;@world.com\nallows numeric domain names\nafter the last &quot;.&quot; minimum 2 letters",
        "matches": [
            "he_llo@worl.d.com",
            "hel.l-o@wor-ld.museum",
            "h1ello@123.com"
        ],
        "non_matches": [
            "hello@worl_d.com",
            "he&amp;llo@world.co1",
            ".hello@wor#.co.uk"
        ]
    },
    {
        "id": 293,
        "expression": "\\b(((\\S+)?)(@|mailto\\:|(news|(ht|f)tp(s?))\\://)\\S+)\\b",
        "description": "Whilst writing a plain-text to HTML function, I ran into the problem of links that users had written with &amp;lt;a&amp;gt; tags (as opposed to just writing the URL) were linking improperly. This regular expression returns many types of URL, and preceding characters, if any. This allows you to handle each type of match appropriately",
        "matches": [
            "href='http://www.deepart.org'",
            "demogorgon@deepart.org",
            "ftp://123.123.123.123"
        ],
        "non_matches": [
            "www.deepart.org",
            "deepart.org",
            "123.123.123.123"
        ]
    },
    {
        "id": 294,
        "expression": "^(([a-z])+.)+[A-Z]([a-z])+$",
        "description": "This matches Java class names such as &quot;com.test.Test&quot;. It's being used within an XML Schema to validate classname as specified in XML documents.",
        "matches": [
            "com.test.Test",
            "com.Test"
        ],
        "non_matches": [
            "com.test.test",
            "com.test.TEst",
            "Com.test.Test"
        ]
    },
    {
        "id": 295,
        "expression": "^[a-zA-Z_][a-zA-Z0-9_]*$",
        "description": "Matches variable names/identifier from C# (and most other languages)",
        "matches": [
            "VariableName",
            "i",
            "Some_Value_3"
        ],
        "non_matches": [
            "3ID",
            "Hello World"
        ]
    },
    {
        "id": 299,
        "expression": "^((4\\d{3})|(5[1-5]\\d{2}))(-?|\\040?)(\\d{4}(-?|\\040?)){3}|^(3[4,7]\\d{2})(-?|\\040?)\\d{6}(-?|\\040?)\\d{5}",
        "description": "Credit card validator for AMEX, VISA, MasterCard only. Allows spaces, dashes, or no separator between digit groups according to the layout (4-6-5 for AMEX, 4-4-4-4 for Visa and Mastercard)",
        "matches": [
            "3711-078176-01234",
            "4123 5123 6123 7123",
            "5123412361237123"
        ],
        "non_matches": [
            "3711-4123-5123-6112"
        ]
    },
    {
        "id": 300,
        "expression": "^((\\d?)|(([-+]?\\d+\\.?\\d*)|([-+]?\\d*\\.?\\d+))|(([-+]?\\d+\\.?\\d*\\,\\ ?)*([-+]?\\d+\\.?\\d*))|(([-+]?\\d*\\.?\\d+\\,\\ ?)*([-+]?\\d*\\.?\\d+))|(([-+]?\\d+\\.?\\d*\\,\\ ?)*([-+]?\\d*\\.?\\d+))|(([-+]?\\d*\\.?\\d+\\,\\ ?)*([-+]?\\d+\\.?\\d*)))$",
        "description": "This allows a sequence of real numbers to be added, separated by a comma (required) and a space (optional). Based pretty heavily on an expression by Steven Smith on this site.",
        "matches": [
            "8.0",
            "8.0,-.38,+8.9",
            "8.0, +8.8, 0.09"
        ],
        "non_matches": [
            "+",
            ".",
            "a,b, c"
        ]
    },
    {
        "id": 301,
        "expression": "^(\\d{5}((|-)-\\d{4})?)|([A-Za-z]\\d[A-Za-z][\\s\\.\\-]?(|-)\\d[A-Za-z]\\d)|[A-Za-z]{1,2}\\d{1,2}[A-Za-z]? \\d[A-Za-z]{2}$",
        "description": "Allows Canadian, American and UK postal/zip codes. Allowing hyphens, periods, or spaces to separate.",
        "matches": [
            "N9B.1Y8",
            "90210-1234",
            "NE21 6EQ"
        ],
        "non_matches": [
            "NN8 Y83"
        ]
    },
    {
        "id": 302,
        "expression": "(.*\\.([wW][mM][aA])|([mM][pP][3])$)",
        "description": "Matches a file name to be either a .wma or .mp3 file. This can be used to check file uploads to make sure they are of a certain type. Substitute letters where appropriate for specific file types. To include more simply add logical 'or' (|) operator and append.",
        "matches": [
            "thisfile.mp3",
            "tH@tfile.wma"
        ],
        "non_matches": [
            "whatever.exe",
            "somethingelse.mpa",
            "thisagain.wm3"
        ]
    },
    {
        "id": 305,
        "expression": "(NOT)?(\\s*\\(*)\\s*(\\w+)\\s*(=|&lt;&gt;|&lt;|&gt;|LIKE|IN)\\s*(\\(([^\\)]*)\\)|'([^']*)'|(-?\\d*\\.?\\d+))(\\s*\\)*\\s*)(AND|OR)?",
        "description": "Heres my sql clause parser regexp for recordset filtering. Does recursive query parsing all by its self. Only problem I cant figure is how to match comma separated lists of quoted strings. Tell me if you figure out how!\nThe unicodes in the re was put in by the entry form please replace them with their ascii equivalents to use it.",
        "matches": [
            "Aeroplane LIKE 767",
            "Movie LIKE 'Star' AND NOT Movie LIKE 'Trek'",
            "Number IN (1,2,3,4,5)"
        ],
        "non_matches": [
            "Hello there",
            "A=EXCELLENT OR",
            "B!=POOR"
        ]
    },
    {
        "id": 306,
        "expression": "(^(\\+?\\-? *[0-9]+)([,0-9 ]*)([0-9 ])*$)|(^ *$)",
        "description": "This is my basic phone number verification. it allows a + - , signs digits, spaces and blank entry",
        "matches": [
            "+0335456 545 545",
            "-5465 545",
            "5456465 5454,545"
        ],
        "non_matches": [
            "fsd54df 54"
        ]
    },
    {
        "id": 308,
        "expression": "^(.|\\n){0,16}$",
        "description": "Limit Length - limit the length of a text box or other area to contain any character plus new line",
        "matches": [
            "shorter than max"
        ],
        "non_matches": [
            "string longer than max"
        ]
    },
    {
        "id": 310,
        "expression": "&quot;([^&quot;](?:\\\\.|[^\\\\&quot;]*)*)&quot;",
        "description": "Matches C style strings allowing for escaped string delimiters to be included in the match.\nALTERED 13-Dec-2003\n-------------------\nPrevious pattern was :\n&quot;([^&quot;](?:\\\\.|[^\\\\&quot;]*)*)&quot;\nChanged to:\n&quot;([^&quot;]*(?:\\\\.|[^\\\\&quot;]*)*)&quot;\nMaking the first character after the opening quote optional allows the pattern to match on empty quotes: &quot;&quot;.",
        "matches": [
            "&quot;This is a \\&quot;string\\&quot;.&quot;"
        ],
        "non_matches": [
            "&quot;This is a \\&quot;string\\&quot;."
        ]
    },
    {
        "id": 311,
        "expression": "(\\w[-._\\w]*\\w@\\w[-._\\w]*\\w\\.\\w{2,3})",
        "description": "This is my all-time favourite e-mail validator. I've used it for years and it's never failed me :-)",
        "matches": [
            "foo@bar.com",
            "foobar@foobar.com.au"
        ],
        "non_matches": [
            "foo@bar",
            "$$$@bar.com"
        ]
    },
    {
        "id": 312,
        "expression": "^([a-zA-Z]\\:)(\\\\[^\\\\/:*?<>\"|]*(?<![ ]))*(\\.[a-zA-Z]{2,6})$",
        "description": "Matches filenames.\nUPDATED on 1st Jan 2004.",
        "matches": [
            "C:\\di___r\\fi_sysle.txt",
            "c:\\dir\\filename.txt"
        ],
        "non_matches": [
            "c:\\dir\\file?name.txt"
        ]
    },
    {
        "id": 313,
        "expression": "^[^#]([^ ]+ ){6}[^ ]+$",
        "description": "We've come across the situation where we had to extract the IIS-Log entries without the header information. The data is far more complex than the sample given.\nExplanation:\n^[^#] = lines not beginnin with #\n([^ ]+ ){6} = 6 times no space until one space\n[^ ]+ = no spaces allowed...\n$ = ...until end of line\nFor further explanation don't hesitate to write E-Mail.",
        "matches": [
            "1111 2222 33 44444 55 6 7777"
        ],
        "non_matches": [
            "#IIS Logfile header"
        ]
    },
    {
        "id": 315,
        "expression": "^(([0-9])|([0-1][0-9])|([2][0-3])):?([0-5][0-9])$",
        "description": "For testing 24H based time entry. Tests if there is a colon to separate the hours from the minutes",
        "matches": [
            "0959",
            "959",
            "9:59"
        ],
        "non_matches": [
            "90",
            "960",
            "24:00"
        ]
    },
    {
        "id": 316,
        "expression": "^(((((0[13578])|([13578])|(1[02]))[\\-\\/\\s]?((0[1-9])|([1-9])|([1-2][0-9])|(3[01])))|((([469])|(11))[\\-\\/\\s]?((0[1-9])|([1-9])|([1-2][0-9])|(30)))|((02|2)[\\-\\/\\s]?((0[1-9])|([1-9])|([1-2][0-9]))))[\\-\\/\\s]?\\d{4})(\\s(((0[1-9])|([1-9])|(1[0-2]))\\:([0-5][0-9])((\\s)|(\\:([0-5][0-9])\\s))([AM|PM|am|pm]{2,2})))?$",
        "description": "Following expression can be used to validate a datetime column from SQL Server. This expression is an enhanced version of Scott Watermasysk's date/time submission. It now accepts leading zeros in months, days, and hours. In addition, this expression properly handles the 11th hour. Watermasysk's would take the 10th and 12th hour but not the 11th. This regex has been tweaked to do so. Does not handle the February 29th problem on non-leap years yet. Will learn a little more about RegEx and do so in later submission.",
        "matches": [
            "11/30/2003 10:12:24 am",
            "2/29/2003 08:14:56 pm",
            "5/22/2003"
        ],
        "non_matches": [
            "11/31/2003 10:12:24 am",
            "2/30/2003 08:14:56 pm",
            "5/22/2003 14:15"
        ]
    },
    {
        "id": 317,
        "expression": "^0(6[045679][0469]){1}(\\-)?(1)?[^0\\D]{1}\\d{6}$",
        "description": "Validates Austrian Cellular Phone Numbers. Works with ONE, T-Mobile, A1, Telering and new Provider &quot;Drei&quot;. WITHOUT Country Code Verification.",
        "matches": [
            "0664-1234567",
            "06641234567",
            "0699-11234567"
        ],
        "non_matches": [
            "06991-1234567",
            "+43650-1234567",
            "07661234567"
        ]
    },
    {
        "id": 318,
        "expression": "^1?[1-9]$|^[1-2]0$",
        "description": "Matches a whole number between 1 and 20 inclusively",
        "matches": [
            "1",
            "11",
            "20"
        ],
        "non_matches": [
            "0",
            "21"
        ]
    },
    {
        "id": 320,
        "expression": "^[1-9][0-9]{3}\\s?[a-zA-Z]{2}$",
        "description": "Validates Dutch Postal Codes (ZipCode). There was a previous one listed here, but it's not entirely correct. Namely that dutch postal codes can contain a zero but cannot start with one, so this one is the adjusted version.",
        "matches": [
            "1234AB",
            "1234 AB",
            "1001 AB"
        ],
        "non_matches": [
            "0123AB",
            "1234A B",
            "0123 AB"
        ]
    },
    {
        "id": 321,
        "expression": "^([0-9]*|\\d*\\.\\d{1}?\\d*)$",
        "description": "Accept only (0-9) integer and one decimal point(decimal point is also optional).After decimal point it accepts at least one numeric .This will be usefull in money related\nfields or decimal fields.",
        "matches": [
            ".568",
            "8578",
            "1234567.1234567"
        ],
        "non_matches": [
            "568.",
            "56.89.36",
            "5.3.6.9.6"
        ]
    },
    {
        "id": 322,
        "expression": "^(?=\\d)(?:(?:(?:(?:(?:0?[13578]|1[02])(\\/|-|\\.)31)\\1|(?:(?:0?[1,3-9]|1[0-2])(\\/|-|\\.)(?:29|30)\\2))(?:(?:1[6-9]|[2-9]\\d)?\\d{2})|(?:0?2(\\/|-|\\.)29\\3(?:(?:(?:1[6-9]|[2-9]\\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00))))|(?:(?:0?[1-9])|(?:1[0-2]))(\\/|-|\\.)(?:0?[1-9]|1\\d|2[0-8])\\4(?:(?:1[6-9]|[2-9]\\d)?\\d{2}))($|\\ (?=\\d)))?(((0?[1-9]|1[012])(:[0-5]\\d){0,2}(\\ [AP]M))|([01]\\d|2[0-3])(:[0-5]\\d){1,2})?$",
        "description": "DateTime Validator.",
        "matches": [
            "12/25/2003",
            "08:03:31",
            "02/29/2004 12 AM"
        ],
        "non_matches": [
            "02/29/2003 1:34 PM",
            "13:23 PM",
            "24:00:00"
        ]
    },
    {
        "id": 323,
        "expression": "^((0?[1-9]|1[012])(:[0-5]\\d){0,2}(\\ [AP]M))$|^([01]\\d|2[0-3])(:[0-5]\\d){0,2}$",
        "description": "This RE validates times patterns.",
        "matches": [
            "1 AM",
            "23:00:00",
            "5:29:59 PM"
        ],
        "non_matches": [
            "13 PM",
            "13:60:00",
            "00:00:00 AM"
        ]
    },
    {
        "id": 325,
        "expression": "^(#){1}([a-fA-F0-9]){6}$",
        "description": "Matches HTML Color strings. Like #FFFFFF is white and #000000 is black and #FF0000 is red and so on...",
        "matches": [
            "#FFFFFF",
            "#FF3421",
            "#00FF00"
        ],
        "non_matches": [
            "232323",
            "f#fddee",
            "#fd2"
        ]
    },
    {
        "id": 327,
        "expression": "(((0[1-9]|[12][0-9]|3[01])([/])(0[13578]|10|12)([/])(\\d{4}))|(([0][1-9]|[12][0-9]|30)([/])(0[469]|11)([/])(\\d{4}))|((0[1-9]|1[0-9]|2[0-8])([/])(02)([/])(\\d{4}))|((29)(\\.|-|\\/)(02)([/])([02468][048]00))|((29)([/])(02)([/])([13579][26]00))|((29)([/])(02)([/])([0-9][0-9][0][48]))|((29)([/])(02)([/])([0-9][0-9][2468][048]))|((29)([/])(02)([/])([0-9][0-9][13579][26])))",
        "description": "Date in DD/MM/YYYY format.\nFecha en formato DD/MM/AAAA.",
        "matches": [
            "28/12/2003",
            "28/02/2003",
            "29/02/2000"
        ],
        "non_matches": [
            "28-02-2003",
            "30/02/2003",
            "28.02.2003"
        ]
    },
    {
        "id": 329,
        "expression": "^((((((0?[13578])|(1[02]))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\\-\\/\\s]?((0?[1-9])|([1-2][0-9]))))[\\-\\/\\s]?\\d{2}(([02468][048])|([13579][26])))|(((((0?[13578])|(1[02]))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\\-\\/\\s]?((0?[1-9])|(1[0-9])|(2[0-8]))))[\\-\\/\\s]?\\d{2}(([02468][1235679])|([13579][01345789]))))(\\s(((0?[1-9])|(1[0-2]))\\:([0-5][0-9])((\\s)|(\\:([0-5][0-9])\\s))([AM|PM|am|pm]{2,2})))?$",
        "description": "This regex will match SQL Server datetime values, allowing date only, allowing zero padded digits in month, day and hour, and will match leap years from 1901 up until 2099.",
        "matches": [
            "2/29/2004",
            "04/01/2003 10:01:23 am",
            "03-20-1999"
        ],
        "non_matches": [
            "2/29/2003",
            "13/30/2001 10:05:00 pm",
            "12/32/2003"
        ]
    },
    {
        "id": 330,
        "expression": "[0-9A-Fa-f]{2}(\\.?)[0-9A-Fa-f]{2}(\\.?)[0-9A-Fa-f]{2}(\\.?)[0-9A-Fa-f]{2}",
        "description": "matches IP address in hex form in dotted or not dotted notation",
        "matches": [
            "c0.a8.01.64",
            "0A0275C4",
            "aC.10.1F.b1"
        ],
        "non_matches": [
            "192.168.1.1",
            "10.2.177.4",
            "ah.10.1f.20"
        ]
    },
    {
        "id": 331,
        "expression": "[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}",
        "description": "Very Simple Match for dotted Decimal IP address. Doesn\u2019t Validate addresses",
        "matches": [
            "192.168.1.1",
            "10.2.234.1",
            "66.129.71.122"
        ],
        "non_matches": [
            "192.168.1",
            "10.2.1234.1",
            "66 129 71 122"
        ]
    },
    {
        "id": 332,
        "expression": "(^[0-9]{1,8}|(^[0-9]{1,8}\\.{0,1}[0-9]{1,2}))$",
        "description": "Matches number in format XX.XX Please note that this expression allows maximum of 8 digits before the dot and 2 (optional) digits after the dot.",
        "matches": [
            "1.00",
            "2345",
            "332.3"
        ],
        "non_matches": [
            ".00",
            "23333333333.00",
            "j22.00"
        ]
    },
    {
        "id": 333,
        "expression": "^[AaWaKkNn][a-zA-Z]?[0-9][a-zA-Z]{1,3}$",
        "description": "Simple match for U.S. Amateur Radio Call signs\nMust start with an A,K,N or W.\n1 or two prefix letters (not case sensitive),\nExactly one zone digit,\nOne to three suffix digits( not case sensitive).\n73",
        "matches": [
            "kd6dun",
            "W9OXZ",
            "kb8ae"
        ],
        "non_matches": [
            "kdd90bz",
            "de7bgw",
            "WV7BXQ5"
        ]
    },
    {
        "id": 337,
        "expression": "^[a-zA-Z0-9&#192;&#193;&#194;&#195;&#196;&#197;&#198;&#199;&#200;&#201;&#202;&#203;&#204;&#205;&#206;&#207;&#208;&#209;&#210;&#211;&#212;&#213;&#214;&#216;&#217;&#218;&#219;&#220;&#221;&#223;&#224;&#225;&#226;&#227;&#228;&#229;&#230;&#231;&#232;&#233;&#234;&#235;&#236;&#237;&#238;&#239;&#241;&#242;&#243;&#244;&#245;&#246;&#248;&#249;&#250;&#251;&#252;&#253;&#255;\\.\\,\\-\\/\\']+[a-zA-Z0-9&#192;&#193;&#194;&#195;&#196;&#197;&#198;&#199;&#200;&#201;&#202;&#203;&#204;&#205;&#206;&#207;&#208;&#209;&#210;&#211;&#212;&#213;&#214;&#216;&#217;&#218;&#219;&#220;&#221;&#223;&#224;&#225;&#226;&#227;&#228;&#229;&#230;&#231;&#232;&#233;&#234;&#235;&#236;&#237;&#238;&#239;&#241;&#242;&#243;&#244;&#245;&#246;&#248;&#249;&#250;&#251;&#252;&#253;&#255;\\.\\,\\-\\/\\' ]+$",
        "description": "This simple regexp should match any possible italian address entry and doesn't match NULL entries (good if address is required). Should work well for any other address (it's been verified against 250 addresses from most european countries, usa and australia. Please mail me if there's something missing",
        "matches": [
            "v.le dell'industria 45/a",
            "via genova 45-3-d",
            "p.zza Garibaldi, 48"
        ],
        "non_matches": [
            "[NULL]"
        ]
    },
    {
        "id": 338,
        "expression": "^(Sun|Mon|(T(ues|hurs))|Fri)(day|\\.)?$|Wed(\\.|nesday)?$|Sat(\\.|urday)?$|T((ue?)|(hu?r?))\\.?$",
        "description": "This RE matches Days of the week or their abbreviations.",
        "matches": [
            "Sunday",
            "Mon",
            "Tu"
        ],
        "non_matches": [
            "day",
            "Wedday",
            "Payday"
        ]
    },
    {
        "id": 340,
        "expression": "<[a-zA-Z]+(\\s+[a-zA-Z]+\\s*=\\s*(\"([^\"]*)\"|'([^']*)'))*\\s*/>",
        "description": "Matches a valid &quot;empty&quot; tag (has trailing slash). Note, if you run it against a string such as &lt;img src=&quot;test.gif&quot; alt=&quot;&lt;hr /&gt;&quot;&gt; it will indeed return a match. But, the match is not at character 1 like you'd suspect, but rather it's matching the internal &lt;hr /&gt;. If you look at the source of this tag (http://concepts.waetech.com/unclosed_tags/) you'll find a whoe suite of regex's for matching html tags. Using them you could feasibly step though a document and avoid this mismatch as the outer tag would match *in totality* and you'd completely skip this inner match.",
        "matches": [
            "<img src=\"test.gif\"/>"
        ],
        "non_matches": [
            "<img src=\"test.gif\">",
            "<img src=\"test.gif\"a/>"
        ]
    },
    {
        "id": 341,
        "expression": "^[a-z0-9][a-z0-9_\\.-]{0,}[a-z0-9]@[a-z0-9][a-z0-9_\\.-]{0,}[a-z0-9][\\.][a-z0-9]{2,4}$",
        "description": "for validate a email, but with this regex it 's possible : a._-z@a_.....____---.com",
        "matches": [
            "az@er.tr",
            "a_zer-ty@az.er.ty",
            "123-456_789.0@1.2.3iuyt.azer"
        ],
        "non_matches": [
            "a@a.a",
            "a.@_1.com",
            "azerty_@domain-com"
        ]
    },
    {
        "id": 342,
        "expression": "^\\w+.*$",
        "description": "Validates any line begining with an alpha-numeric. If you need a regular expression that fails only for a zero length string. Remove the \\w+. I originally attempted to post was ^.*$ but the input form would not allow it.",
        "matches": [
            "user name",
            "o)(=-&amp;r443*/"
        ],
        "non_matches": [
            "=stuff",
            ".username"
        ]
    },
    {
        "id": 343,
        "expression": "^((\\d{2}(([02468][048])|([13579][26]))[\\-\\/\\s]?((((0?[13578])|(1[02]))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])))))|(\\d{2}(([02468][1235679])|([13579][01345789]))[\\-\\/\\s]?((((0?[13578])|(1[02]))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\\-\\/\\s]?((0?[1-9])|(1[0-9])|(2[0-8]))))))(\\s(((0?[1-9])|(1[0-2]))\\:([0-5][0-9])((\\s)|(\\:([0-5][0-9])\\s))([AM|PM|am|pm]{2,2})))?$",
        "description": "Matches ANSI SQL date format YYYY-mm-dd hh:mi:ss am/pm. You can use / - or space for date delimiters, so 2004-12-31 works just as well as 2004/12/31. Checks leap year from 1901 to 2099.",
        "matches": [
            "2004-2-29",
            "2004-02-29 10:29:39 pm",
            "2004/12/31"
        ],
        "non_matches": [
            "2003-2-29",
            "2003-13-02",
            "2003-2-2 10:72:30 am"
        ]
    },
    {
        "id": 344,
        "expression": "^([a-zA-Z0-9]([a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,6}$",
        "description": "Checks domain names. This validates domains based on latest specifications (RFCs 952 and 1123 dealing with hostnames and RFC 1035 dealing with domain name system requirements) except that it only includes realistic fully-qualified domains: 1. requires at least one subdomain 2. allows shortest top-level domains like &quot;ca&quot;, and &quot;museum&quot; as longest.\nOther validation rules: 1. Labels/parts should be seperated by period. 2. Each label/part has maximum of 63 characters. 3. First and last character of label must be alphanumeric, other characters alphanumeric or hyphen. 4. Does not check maxlength of domain which incidentally is 253 characters of text (255 binary representation).\nFor a regular expression that matches ALL domains:\n^([a-zA-Z0-9]([a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?\\.)*[a-zA-Z0-9]([a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?$",
        "matches": [
            "regexlib.com",
            "this.is.a.museum",
            "3com.com"
        ],
        "non_matches": [
            "notadomain-.com",
            "helloworld.c",
            ".oops.org"
        ]
    },
    {
        "id": 346,
        "expression": "^((AL)|(AK)|(AS)|(AZ)|(AR)|(CA)|(CO)|(CT)|(DE)|(DC)|(FM)|(FL)|(GA)|(GU)|(HI)|(ID)|(IL)|(IN)|(IA)|(KS)|(KY)|(LA)|(ME)|(MH)|(MD)|(MA)|(MI)|(MN)|(MS)|(MO)|(MT)|(NE)|(NV)|(NH)|(NJ)|(NM)|(NY)|(NC)|(ND)|(MP)|(OH)|(OK)|(OR)|(PW)|(PA)|(PR)|(RI)|(SC)|(SD)|(TN)|(TX)|(UT)|(VT)|(VI)|(VA)|(WA)|(WV)|(WI)|(WY))$",
        "description": "This validates the states and territories of the United States in a 2 character uppercase format. Very poor excuse for a regular expression! ;)\nWritten by Jason Gaylord.",
        "matches": [
            "NY",
            "PA",
            "NJ"
        ],
        "non_matches": [
            "Pennsylvania",
            "Pa",
            "pa"
        ]
    },
    {
        "id": 347,
        "expression": "^([\\(]{1}[0-9]{3}[\\)]{1}[ ]{1}[0-9]{3}[\\-]{1}[0-9]{4})$",
        "description": "It is the exact phone number regular expression for '(###) ###-####'.\nWritten by Jason Gaylord.",
        "matches": [
            "(555) 555-1212"
        ],
        "non_matches": [
            "555-1212",
            "1-800-555-1212",
            "555-555-1212"
        ]
    },
    {
        "id": 348,
        "expression": "^(([0]?[1-9]|1[0-2])/([0-2]?[0-9]|3[0-1])/[1-2]\\d{3})? ?((([0-1]?\\d)|(2[0-3])):[0-5]\\d)?(:[0-5]\\d)? ?(AM|am|PM|pm)?$",
        "description": "Matches variations on date/time/AM-PM. Must have 4 digit year, but everything else is open. Restrictions are: 4 digit year, months 1-12, hours 1-23, minutes and seconds 1-59, any case of AM and PM. If this don't woik, I wrote it, lemmy know.",
        "matches": [
            "12/30/2002",
            "12/30/2002 9:35 pm",
            "12/30/2002 19:35:02"
        ],
        "non_matches": [
            "18/22/2003",
            "8/12/99",
            "8/22/2003 25:00"
        ]
    },
    {
        "id": 349,
        "expression": "^\\d(\\d)?(\\d)?$",
        "description": "Matches positive whole numbers from 0-999",
        "matches": [
            "0",
            "12",
            "876"
        ],
        "non_matches": [
            "1000",
            "1.23",
            "-234"
        ]
    },
    {
        "id": 350,
        "expression": "^(3[0-1]|2[0-9]|1[0-9]|0[1-9])[\\s{1}|\\/|-](Jan|JAN|Feb|FEB|Mar|MAR|Apr|APR|May|MAY|Jun|JUN|Jul|JUL|Aug|AUG|Sep|SEP|Oct|OCT|Nov|NOV|Dec|DEC)[\\s{1}|\\/|-]\\d{4}$",
        "description": "More flexible date validator. Allows either spaces, / or - as dividers, also allows for fully uppercase months, year as 4 digit.",
        "matches": [
            "01 JAN 2003",
            "31/Dec/2002",
            "20-Apr-2003"
        ],
        "non_matches": [
            "32 Jan 2003",
            "00 Dec 2003",
            "10 dec 2003"
        ]
    },
    {
        "id": 351,
        "expression": "^[1-9]{1}[0-9]{3}\\s{0,1}?[a-zA-Z]{2}$",
        "description": "Used for dutch postalcodes; no leading zero. 4 numbers and 2 letters.",
        "matches": [
            "1234AB",
            "1234 AB",
            "1234 ab"
        ],
        "non_matches": [
            "0123AB",
            "123AA"
        ]
    },
    {
        "id": 352,
        "expression": "^\\s*(((\\d*\\.?\\d*[0-9]+\\d*)|([0-9]+\\d*\\.\\d*) )\\s*[xX]\\s*){2}((\\d*\\.?\\d*[0-9]+\\d*)|([0-9]+\\d*\\.\\d*))\\s*$",
        "description": "This validates Length times Width times Height measurements, which consists of 3 whole or decimal numbers separated by an x.",
        "matches": [
            "1.1 x 4.35 x 5.0",
            "1 x 2 x 3",
            "4.75 x 300.25 x 0"
        ],
        "non_matches": [
            "z.56 x 6 x 7",
            "1 xx 2 x 3",
            "1 by 2 by 3"
        ]
    },
    {
        "id": 353,
        "expression": "[\\\\s+,]",
        "description": "Simple expression for matching all commas and all whitespace characters: ASCII (13,10,44)",
        "matches": [
            ",",
            "whitespace",
            "carrage returns"
        ],
        "non_matches": [
            "cat"
        ]
    },
    {
        "id": 354,
        "expression": "^(?:(((Jan(uary)?|Ma(r(ch)?|y)|Jul(y)?|Aug(ust)?|Oct(ober)?|Dec(ember)?)\\ 31)|((Jan(uary)?|Ma(r(ch)?|y)|Apr(il)?|Ju((ly?)|(ne?))|Aug(ust)?|Oct(ober)?|(Sept|Nov|Dec)(ember)?)\\ (0?[1-9]|([12]\\d)|30))|(Feb(ruary)?\\ (0?[1-9]|1\\d|2[0-8]|(29(?=,\\ ((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))))\\,\\ ((1[6-9]|[2-9]\\d)\\d{2}))",
        "description": "This RE validate Dates in the MMM dd, yyyy format from Jan 1, 1600 to Dec 31, 9999. The format is as follows: The name or 3 letter abbreivation, without a period, of the month, then a space then the day value then a comma then a space finally the year. The correct number of day are validated for each month include leap years. The name of month is case sensitive.",
        "matches": [
            "Jan 1, 2003",
            "February 29, 2004",
            "November 02, 3202"
        ],
        "non_matches": [
            "Feb 29, 2003",
            "Apr 31, 1978",
            "jan 33,3333"
        ]
    },
    {
        "id": 355,
        "expression": "^((31(?!\\ (Feb(ruary)?|Apr(il)?|June?|(Sep(?=\\b|t)t?|Nov)(ember)?)))|((30|29)(?!\\ Feb(ruary)?))|(29(?=\\ Feb(ruary)?\\ (((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))|(0?[1-9])|1\\d|2[0-8])\\ (Jan(uary)?|Feb(ruary)?|Ma(r(ch)?|y)|Apr(il)?|Ju((ly?)|(ne?))|Aug(ust)?|Oct(ober)?|(Sep(?=\\b|t)t?|Nov|Dec)(ember)?)\\ ((1[6-9]|[2-9]\\d)\\d{2})$",
        "description": "This RE validates dates in the dd MMM yyyy format. Spaces separate the values.",
        "matches": [
            "31 January 2003",
            "29 March 2004",
            "29 Feb 2008"
        ],
        "non_matches": [
            "Jan 1 2003",
            "31 Sept 2003",
            "29 February 2003"
        ]
    },
    {
        "id": 356,
        "expression": "^(?:J(anuary|u(ne|ly))|February|Ma(rch|y)|A(pril|ugust)|(((Sept|Nov|Dec)em)|Octo)ber)$",
        "description": "This RE validate the full name of the months.",
        "matches": [
            "January",
            "May",
            "October"
        ],
        "non_matches": [
            "Jan",
            "Septem",
            "Octo"
        ]
    },
    {
        "id": 358,
        "expression": "^1+0+$",
        "description": "A simple regular expression to determine if a subnet mask is contiguous; that is, the submask must start with a 1 bit followed by 0 or more 1 bits, followed by 1 or more 0 bits until the end of the submask.",
        "matches": [
            "10",
            "110",
            "1100"
        ],
        "non_matches": [
            "0",
            "01",
            "101"
        ]
    },
    {
        "id": 359,
        "expression": "^(((0[1-9]|[12]\\d|3[01])\\/(0[13578]|1[02])\\/((1[6-9]|[2-9]\\d)\\d{2}))|((0[1-9]|[12]\\d|30)\\/(0[13456789]|1[012])\\/((1[6-9]|[2-9]\\d)\\d{2}))|((0[1-9]|1\\d|2[0-8])\\/02\\/((1[6-9]|[2-9]\\d)\\d{2}))|(29\\/02\\/((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))))$",
        "description": "dd/MM/yyyy with leap years 100% integrated\nValid years : from 1600 to 9999\nAs usual, many tests have been made.\nI think this one should be fine.",
        "matches": [
            "29/02/2000",
            "30/04/2003",
            "01/01/2003"
        ],
        "non_matches": [
            "29/02/2001",
            "30-04-2003",
            "1/1/2003"
        ]
    },
    {
        "id": 360,
        "expression": "^\\d{1,5}(\\.\\d{1,2})?$",
        "description": "validate a number 5 digits and 2 decimal places allowing zero",
        "matches": [
            "12345.67",
            "0",
            "0.1"
        ],
        "non_matches": [
            "123456.78",
            "123456.789",
            ".1"
        ]
    },
    {
        "id": 361,
        "expression": "(?!^0*$)(?!^0*\\.0*$)^\\d{1,5}(\\.\\d{1,2})?$",
        "description": "validates to 5 digits and 2 decimal places but not allowing zero",
        "matches": [
            "12345.12",
            "0.5"
        ],
        "non_matches": [
            "123456.12",
            "1.234",
            ".1"
        ]
    },
    {
        "id": 362,
        "expression": "^[^<>`~!/@\\#}$%:;)(_^{&*=|'+]+$",
        "description": "A general string validation to insure that NO malicious code or specified characters are passed through user input. This will allow you to input any characters except those specified. The expression above does not allow user input of &lt;&gt;`~!/@\\#}$%:;)(_^{&amp;*=|'+. Input as many invalid characters you wish to deny. This really works!",
        "matches": [
            "This is a test"
        ],
        "non_matches": [
            "<href =",
            "<br>",
            "That's it"
        ]
    },
    {
        "id": 363,
        "expression": "^([\\(]{1}[0-9]{3}[\\)]{1}[\\.| |\\-]{0,1}|^[0-9]{3}[\\.|\\-| ]?)?[0-9]{3}(\\.|\\-| )?[0-9]{4}$",
        "description": "More permissive than others on the site, this one allows you to let a user enter US phone numbers in the way they most commonly use, without letting them enter non-valid combinations.",
        "matches": [
            "5551212",
            "614555-1212",
            "(614)555-1212"
        ],
        "non_matches": [
            "A12-5555",
            "(614-555-1212",
            "555*1212"
        ]
    },
    {
        "id": 364,
        "expression": "^([1-9]{1}[0-9]{3}[,]?)*([1-9]{1}[0-9]{3})$",
        "description": "Matches a comma-seperated list of year(s).",
        "matches": [
            "1999,2001,1988",
            "1999"
        ],
        "non_matches": [
            "0199,1997",
            "0199",
            "1999,"
        ]
    },
    {
        "id": 366,
        "expression": "^(((0[13578]|10|12)([-./])(0[1-9]|[12][0-9]|3[01])([-./])(\\d{4}))|((0[469]|11)([-./])([0][1-9]|[12][0-9]|30)([-./])(\\d{4}))|((02)([-./])(0[1-9]|1[0-9]|2[0-8])([-./])(\\d{4}))|((02)(\\.|-|\\/)(29)([-./])([02468][048]00))|((02)([-./])(29)([-./])([13579][26]00))|((02)([-./])(29)([-./])([0-9][0-9][0][48]))|((02)([-./])(29)([-./])([0-9][0-9][2468][048]))|((02)([-./])(29)([-./])([0-9][0-9][13579][26])))$",
        "description": "This works for all accept 01/01/0000 mainly 0000. can anybody suggest a solution.",
        "matches": [
            "01/01/2001"
        ],
        "non_matches": [
            "01/01/00000"
        ]
    },
    {
        "id": 367,
        "expression": "^((\\d{5}-\\d{4})|(\\d{5})|([AaBbCcEeGgHhJjKkLlMmNnPpRrSsTtVvXxYy]\\d[A-Za-z]\\s?\\d[A-Za-z]\\d))$",
        "description": "Regular expression for US (ZIP and ZIP+4) and Canadian postal codes. It allows 5 digits for the first US postal code and requires that the +4, if it exists, is four digits long. Canadain postal codes can contain a space and take form of A1A 1A1. The letters can be upper or lower case, but the first letter must be one of the standard Canadian zones: A,B,C,E,G,H,J,K,L,M,N,P,R,S,T,V,X,Y.",
        "matches": [
            "00501",
            "84118-3423",
            "n3a 3B7"
        ],
        "non_matches": [
            "501-342",
            "123324",
            "Q4B 5C5"
        ]
    },
    {
        "id": 369,
        "expression": "^[a-zA-Z_]{1}[a-zA-Z0-9_]+$",
        "description": "This expression validates for valid C# or C++ identifier",
        "matches": [
            "_12ffsd",
            "abcd123",
            "abcd_23232"
        ],
        "non_matches": [
            "..//",
            "..13e232",
            "abcd 3232"
        ]
    },
    {
        "id": 370,
        "expression": "^[1]$|^[3]$|^[4]$|^[6]$|^[1]0$",
        "description": "This will match single numbers,the first block [1346] checks for single digits of 1, 3, 4 or 6, could easily by [1-5] as well. The second block [10] checks for 10 only.\nThis matches inclusively.",
        "matches": [
            "1",
            "4",
            "10"
        ],
        "non_matches": [
            "13",
            "2",
            "0"
        ]
    },
    {
        "id": 371,
        "expression": "^[A]$|^[C]$|^[D]$|^[F]$|^[H]$|^[K]$|^[L]$|^[M]$|^[O]$|^[P]$",
        "description": "This is for matching Single uppercase Letters inclusively",
        "matches": [
            "A",
            "F",
            "P"
        ],
        "non_matches": [
            "a",
            "b",
            "cd"
        ]
    },
    {
        "id": 374,
        "expression": "^[-]?([1-9]{1}[0-9]{0,}(\\.[0-9]{0,2})?|0(\\.[0-9]{0,2})?|\\.[0-9]{1,2})$",
        "description": "This regular expression will match on a real / decimal / floating point / numeric string with no more than 2 digits past the decimal. The negative sign (-) is allowed. No leading zeroes or commas. It is based on a currency regular expression by Tom Persing.",
        "matches": [
            "123",
            "123.54",
            "-.54"
        ],
        "non_matches": [
            "123.543",
            "0012",
            "1,000.12"
        ]
    },
    {
        "id": 375,
        "expression": "^([a-zA-Z]\\:|\\\\\\\\[^\\/\\\\:*?\"<>|]+\\\\[^\\/\\\\:*?\"<>|]+)(\\\\[^\\/\\\\:*?\"<>|]+)+(\\.[^\\/\\\\:*?\"<>|]+)$",
        "description": "This regular expression match any valid file path. It checks local drives and network path. The file extension is required.",
        "matches": [
            "c:\\Test.txt",
            "\\\\server\\shared\\Test.txt",
            "\\\\server\\shared\\Test.t"
        ],
        "non_matches": [
            "c:\\Test",
            "\\\\server\\shared",
            "\\\\server\\shared\\Test.?"
        ]
    },
    {
        "id": 381,
        "expression": "<[^>]*>",
        "description": "HTML Pattern Matching\nPLEASE HELP\n/&lt;[^&gt;]*&gt;/ig\nThe above pattern is only successful when html tag are simple (they don't include any javascript). This mean that the pattern will fail if something like this is within the tag &lt;input type=button value=test onclick='if(n.value&gt;5)do_this();'&gt;. It will not match the entire open n close sign.\nHow do you write a pattern that will pass all these tag so that the pattern will match from the open to the close sign and not when it just see a &gt; within a '' or &quot;&quot;.\n&lt;input type=button onclick='if(n.value&gt;5)do_this();'&gt; not this &lt;br&gt;\n&lt;input type=button onclick=&quot;n&gt;5?a():b();&quot; value=test&gt; not this &lt;br&gt;\n&lt;input type=button onclick=&quot;n&gt;5?a(\\&quot;OK\\&quot;):b('Not Ok');&quot; value=test&gt; not this &lt;br&gt;\n&lt;input type=button onclick='n&gt;5' value=test onmouseover=&quot;n&lt;5&amp;&amp;n&gt;8&quot; onmouseout='if(n&gt;5)alert(\\'True\\');else alert(&quot;False&quot;)'&gt; not this &lt;br&gt;\nAny help would be greatly appreciate. Thanks a whole lot.\nLogan",
        "matches": [
            "<html>"
        ],
        "non_matches": [
            "abc"
        ]
    },
    {
        "id": 382,
        "expression": "^([0-9]*\\-?\\ ?\\/?[0-9]*)$",
        "description": "Match italian telephone number with prefix followed by &quot;/&quot;, &quot;-&quot; or blank and number. Usefull with numeric keybord!",
        "matches": [
            "02-343536",
            "02/343536",
            "02 343536"
        ],
        "non_matches": [
            "02a343536",
            "02+343536"
        ]
    },
    {
        "id": 386,
        "expression": "^(\\d+|[a-zA-Z]+)$",
        "description": "Tests for all numbers OR all letters (upper or lower case)\n( posted from WebService - http://regexlib.com/webservices.asmx?op=Save )\n( updated from WebService - http://regexlib.com/webservices.asmx?op=Save )",
        "matches": [
            "aaaaadddaaaaa",
            "1166633337"
        ],
        "non_matches": [
            "1n",
            "ppppp99"
        ]
    },
    {
        "id": 392,
        "expression": "\\.com/(\\d+)$",
        "description": "This is a regex I wrote to capture requests to AspAlliance.com with an article id as the only thing after the domain. So http://aspalliance.com/123 would go to article number 123. It maps the URL to the actual aspx file that displays the article based on the ID.",
        "matches": [
            "http://aspalliance.com/123",
            "www.aspalliance.com/123",
            "http://aspalliance.com/34"
        ],
        "non_matches": [
            "http://aspalliance.com/article.aspx?id=123",
            "http://aspalliance.com/",
            "http://aspalliance.com/articl"
        ]
    },
    {
        "id": 393,
        "expression": ".*?$(?<!\\.aspx)",
        "description": "Matches a string to ensure that it does not end with .aspx; sure, you'd probably use string handling to do something this simple but, in the real world you'd whack a regex which validates a valid url to the front of this.\nThe pattern was created by Wayne King; you can read about it here:\nhttp://scottwater.com/blog/posts/10204.aspx",
        "matches": [
            "http://weblogs.asp.net/DNeimke/blah.gif"
        ],
        "non_matches": [
            "http://weblogs.asp.net/DNeimke/Default.aspx"
        ]
    },
    {
        "id": 394,
        "expression": "^(1\\s*[-\\/\\.]?)?(\\((\\d{3})\\)|(\\d{3}))\\s*[-\\/\\.]?\\s*(\\d{3})\\s*[-\\/\\.]?\\s*(\\d{4})\\s*(([xX]|[eE][xX][tT])\\.?\\s*(\\d+))*$",
        "description": "This regular expressions matches phone numbers with area codes and optional US country code and optional phone extension. User have so many ways of entering phone numbers into input fields. This allows for some of the ones I've encountered. Feel free to contact me if you find ones that do not match.",
        "matches": [
            "2405525009",
            "1(240) 652-5009",
            "240/752-5009 ext.55"
        ],
        "non_matches": [
            "(2405525009",
            "2 (240) 652-5009"
        ]
    },
    {
        "id": 395,
        "expression": "^[0-9]{5}([- /]?[0-9]{4})?$",
        "description": "US Zip Code + 4 digit extension Postal Code",
        "matches": [
            "14467",
            "144679554",
            "14467-9554"
        ],
        "non_matches": [
            "14467 955",
            "14467-",
            "1446-9554"
        ]
    },
    {
        "id": 396,
        "expression": "(.)\\1{2,}",
        "description": "matches any string with characters repeated more than twice, sometimes used as fake input",
        "matches": [
            "aaaeee",
            "????????",
            "gooogle"
        ],
        "non_matches": [
            "google",
            "booboo"
        ]
    },
    {
        "id": 397,
        "expression": "^p(ost)?[ |\\.]*o(ffice)?[ |\\.]*(box)?[ 0-9]*[^[a-z ]]*",
        "description": "This expression is useful for determining if an address is a PO Box type address. This can be useful in shipping systems as well as other systems that need to make determinations based on the type of address imputed.",
        "matches": [
            "po box 4353"
        ],
        "non_matches": [
            "pollo St.",
            "P. O. Box d3f12s",
            "BOX 23"
        ]
    },
    {
        "id": 398,
        "expression": "^\\d+\\x20*([pP][xXtT])?$",
        "description": "It can be used to validate Font Sizes.\nThanks to Gideon Engelberth for the shorter version of my original expression.",
        "matches": [
            "1px",
            "100 PT",
            "20Px"
        ],
        "non_matches": [
            "1abc",
            "px",
            "1 sdfs"
        ]
    },
    {
        "id": 399,
        "expression": "ISBN\\x20(?=.{13}$)\\d{1,5}([- ])\\d{1,7}\\1\\d{1,6}\\1(\\d|X)$",
        "description": "This RE validates the format of an ISBN number",
        "matches": [
            "ISBN 0 93028 923 4",
            "ISBN 1-56389-668-0",
            "ISBN 1-56389-016-X"
        ],
        "non_matches": [
            "123456789X",
            "ISBN 9-87654321-2",
            "ISBN 123 456-789X"
        ]
    },
    {
        "id": 400,
        "expression": "<([^\\s>]*)(\\s[^<]*)>",
        "description": "grab all tags attributes...\n&lt;img src=&quot;truc&quot;&gt; returns :\n&lt;\n(1:img)\n(2: src=&quot;truc&quot;)\n&gt;\ni use it to clean html pages to grab infos...\nuse a RegEx Replace with &quot;&lt;$1&gt;&quot; to keep only tags codes...",
        "matches": [
            "<img src=\"truc\">",
            "<body background='...'>",
            "<p align='left'>"
        ],
        "non_matches": [
            "<br>",
            "</body>",
            "<p>"
        ]
    },
    {
        "id": 401,
        "expression": "<([^<>\\s]*)(\\s[^<>]*)?>",
        "description": "All tags in first submatche\nAll attributes in second one...",
        "matches": [
            "<td class=\"TD2\">",
            "<!-- comment -->",
            "</table>"
        ],
        "non_matches": [
            "19-Fev-2002 - 19h00",
            "New Changes :",
            "..."
        ]
    },
    {
        "id": 402,
        "expression": "^((Bob)|(John)|(Mary)).*$(?<!White)",
        "description": "&quot;Starts with but does not end with.&quot;\nI needed a pattern to require certain first (and optional middle) names, but to fail for certain last names. So if Bob, John, and Mary are acceptable first names but the White's are always rejected then...",
        "matches": [
            "Bob Jones",
            "John Smith",
            "Mary Jane Smith"
        ],
        "non_matches": [
            "Bob White",
            "Mary Doe White",
            "Gina Smith"
        ]
    },
    {
        "id": 403,
        "expression": "[^!~/&gt;&lt;\\|/#%():;{}`_-]",
        "description": "Trying to remove all these characters in the regular expression: still working on it\n!~/[&gt;&lt;*\\|]/#$%^&amp;():;{},?`_-",
        "matches": [
            "Soma",
            "Infy",
            "every"
        ],
        "non_matches": [
            "&lt;",
            "&gt;",
            "!"
        ]
    },
    {
        "id": 404,
        "expression": "^([\\s\\S]){1,20}([\\s\\.])",
        "description": "This pattern returns as much of the first x characters of a string as full words or sentences as a match, where x is currently 20. Change x to adjust the length supported in your database field.\nI'm currently using this within a string shortening utility to shrink large text regions to word/sentance-boundary elements and appending an ellipsis as a text continuator.",
        "matches": [
            "Any text of any length",
            "...but will only 'match' the first 20 characters at a period or space."
        ],
        "non_matches": [
            "N/A"
        ]
    },
    {
        "id": 405,
        "expression": "^(?-i:A[LKSZRAEP]|C[AOT]|D[EC]|F[LM]|G[AU]|HI|I[ADLN]|K[SY]|LA|M[ADEHINOPST]|N[CDEHJMVY]|O[HKR]|P[ARW]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY])$",
        "description": "The RE match U.S. state abbreviation used by the U.S. Post Office.",
        "matches": [
            "AL",
            "CA",
            "AA"
        ],
        "non_matches": [
            "New York",
            "California",
            "ny"
        ]
    },
    {
        "id": 407,
        "expression": "^[A-Za-z]{6}[0-9]{2}[A-Za-z]{1}[0-9]{2}[A-Za-z]{1}[0-9]{3}[A-Za-z]{1}$",
        "description": "This pattern match italian fiscal code (codice fiscale).",
        "matches": [
            "SPGGRG73A02E625S",
            "czzdll74h18f205w"
        ],
        "non_matches": [
            "SP6FFFF3A02E625S",
            "czzdll74h18f205"
        ]
    },
    {
        "id": 408,
        "expression": "(\\w(\\s)?)+",
        "description": "Used to verify that the string consists of only A-z, 0 - 9 and underscore. Several words allowed, only one space between them. No spaces up front. Hey, I know it's easy, but it was not in the library! Plus, the test option here is not working well all the time.",
        "matches": [
            "Test",
            "TesT",
            "tesT9 _test9"
        ],
        "non_matches": [
            "\\\\\\"
        ]
    },
    {
        "id": 412,
        "expression": "^(([8]))$|^((([0-7]))$|^((([0-7])).?((25)|(50)|(5)|(75)|(0)|(00))))$",
        "description": "Time off hours edit for quarter hour(s) less than eight.",
        "matches": [
            "0.25",
            "7.75",
            "8"
        ],
        "non_matches": [
            "8.25",
            "7.15",
            "0.15"
        ]
    },
    {
        "id": 420,
        "expression": "^ISBN\\s(?=[-0-9xX ]{13}$)(?:[0-9]+[- ]){3}[0-9]*[xX0-9]$",
        "description": "This pattern validates ISBN numbers. I've written a full description about it here: http://regexblogs.com/dneimke/posts/201.aspx",
        "matches": [
            "ISBN 90-70002-34-5",
            "ISBN 90-70002-34-x"
        ],
        "non_matches": [
            "ISBN 90-70002-34-5x",
            "ISBN 90-700-02-34-5"
        ]
    },
    {
        "id": 421,
        "expression": "^(((0[1-9]|[12]\\d|3[01])\\/(0[13578]|1[02])\\/(\\d{2}))|((0[1-9]|[12]\\d|30)\\/(0[13456789]|1[012])\\/(\\d{2}))|((0[1-9]|1\\d|2[0-8])\\/02\\/(\\d{2}))|(29\\/02\\/((0[48]|[2468][048]|[13579][26])|(00))))$",
        "description": "Matching : dd/MM/yy\nLeap years compatible\nItalian style, just for more fun.\nPlease, don't forget to rate it if you use it. THX",
        "matches": [
            "31/12/75",
            "29/02/00",
            "29/02/04"
        ],
        "non_matches": [
            "01/13/01",
            "29/02/01",
            "29/02/2004"
        ]
    },
    {
        "id": 429,
        "expression": "^(0)$|^([1-9][0-9]*)$",
        "description": "This regular expression matches on postive whole numbers and 0. Whole numbers that are left padded with 0's are not a match.",
        "matches": [
            "12",
            "0",
            "1200"
        ],
        "non_matches": [
            "-12",
            "0012"
        ]
    },
    {
        "id": 431,
        "expression": "^(0*100{1,1}\\.?((?<=\\.)0*)?%?$)|(^0*\\d{0,2}\\.?((?<=\\.)\\d*)?%?)$",
        "description": "Percentage (From 0 to 100)",
        "matches": [
            "100%",
            "100",
            "52.65%"
        ],
        "non_matches": [
            "-1",
            "-1%",
            "100.1%"
        ]
    },
    {
        "id": 433,
        "expression": "((^(10|12|0?[13578])(3[01]|[12][0-9]|0?[1-9])((1[8-9]\\d{2})|([2-9]\\d{3}))$)|(^(11|0?[469])(30|[12][0-9]|0?[1-9])((1[8-9]\\d{2})|([2-9]\\d{3}))$)|(^(0?2)(2[0-8]|1[0-9]|0?[1-9])((1[8-9]\\d{2})|([2-9]\\d{3}))$)|(^(0?2)(29)([2468][048]00)$)|(^(0?2)(29)([3579][26]00)$)|(^(0?2)(29)([1][89][0][48])$)|(^(0?2)(29)([2-9][0-9][0][48])$)|(^(0?2)(29)([1][89][2468][048])$)|(^(0?2)(29)([2-9][0-9][2468][048])$)|(^(0?2)(29)([1][89][13579][26])$)|(^(0?2)(29)([2-9][0-9][13579][26])$))",
        "description": "Matches on MMDDYYYY only, requires all 8 digits",
        "matches": [
            "01012003",
            "02292000"
        ],
        "non_matches": [
            "01/01/2003"
        ]
    },
    {
        "id": 435,
        "expression": "^\\d{1,7}$",
        "description": "Positive Whole number matched from 0 to 9999999. Only 7 digits length is allowed.",
        "matches": [
            "1234567",
            "9999999",
            "1"
        ],
        "non_matches": [
            "12345678",
            "9999.99",
            "-1234"
        ]
    },
    {
        "id": 439,
        "expression": "^((([sS][r-tR-Tx-zX-Z])\\s*([sx-zSX-Z])?\\s*([a-zA-Z]{2,3}))?\\s*(\\d\\d)\\s*-?\\s*(\\d{6,7}))$",
        "description": "California Resale License number validator. Validates Letters and Numbers or Number only. Letters: First 2 letters can be SR, SS, ST , SX, SY, SZ (TAT Code) Next optional letter can be S,X,Y,Z. Next letters must be a minimum of two and a maximum of 3 (District Code). Numbers: Can be 8-9 numbers. Numbers can be delimited with a hypen or spaces after the first 2 numbers. Note: I use () to extract the information I want for use in other scripts.",
        "matches": [
            "SR BH 97-578613",
            "97578613",
            "SRXBH97578613"
        ],
        "non_matches": [
            "RR BH 97-578613",
            "9757861",
            "SRAABH 97-578613"
        ]
    },
    {
        "id": 440,
        "expression": "^[a-zA-Z0-9_\\s-]+$",
        "description": "This tests an input string for only a-z and A-Z and only allows underscores, hyphens and spaces. The purpose is to force users to generate legitimate, readable file names that can be streamed from the web.",
        "matches": [
            "123Testing",
            "123_Testing",
            "123-Testing This"
        ],
        "non_matches": [
            "!@#Testing",
            "Testing &quot;This&quot;",
            "Don't Forget to Write"
        ]
    },
    {
        "id": 441,
        "expression": "^DOMAIN\\\\\\w+$",
        "description": "In response to a question on the regex list at www.aspadvice.com, this expression should ensure that a login field's username includes a 'DOMAIN\\' prefix. The latter part of the expression should probably be limited so that it only allows usernames of appropriate lengths, perhaps 3 to 20 characters (by replacing + with {3,20} for instance).",
        "matches": [
            "DOMAIN\\ssmith",
            "DOMAIN\\a",
            "DOMAIN\\username"
        ],
        "non_matches": [
            "ssmith",
            "username",
            "DOMAIN\\"
        ]
    },
    {
        "id": 442,
        "expression": "^\\W{0,5}[Rr]e:\\W[a-zA-Z0-9]{1,10},\\W[a-z]{1,10}\\W[a-z]{1,10}\\W[a-z]{1,10}",
        "description": "Simple email subject line matching. This regex matches those really annoying emails that begin with 0-5 spaces, followed by a fake reply, contain a random string of letters (usually CAPITALIZED) from 1-10 characters long followed by a comma, and then followed by three lower-case words each from 1-10 characters long. In my experience, the 3 trailing words are always lower-case. the words make begin with, contain, or end in common punctuation marks.",
        "matches": [
            "re: ASDFG, hours among lifestyle",
            "Re: ASD34SSDF, i can't believe",
            "Re: VZWENKS, the coffin brogade"
        ],
        "non_matches": [
            "re: ASDFGASFDASDF, Hours among lifestyle",
            "Re: ASD34SSDF, I can't believe it's true"
        ]
    },
    {
        "id": 444,
        "expression": "^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\,*\\s\\s*\\d{4}$|^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\\,*\\s\\d{4}$|^(January|February|March|April|May|June|July|August|September|October|November|December)\\,*\\s\\d{4}$|^(january|february|march|april|may|june|july|august|september|october|november|december)\\,*\\s\\d{4}$",
        "description": "Best Use validation to accept a valid &quot;MonthName(,) Year&quot;.\nIt can validate an entry with or without comma (,).",
        "matches": [
            "January 2004",
            "Jan, 2004",
            "january 2003"
        ],
        "non_matches": [
            "Janu 2004",
            "jAn, 2004",
            "January,2003"
        ]
    },
    {
        "id": 452,
        "expression": "^[a-zA-Z]+(([\\'\\,\\.\\-][a-zA-Z])?[a-zA-Z]*)*$",
        "description": "This allows you to validate first names and last names in seperate fields. Instead of validating a full name in one field.",
        "matches": [
            "Sameul",
            "O'Conner",
            "Mary-Kate"
        ],
        "non_matches": [
            "David Bugel",
            "Robert1",
            "Robert M. Larry"
        ]
    },
    {
        "id": 454,
        "expression": "(?i:on(blur|c(hange|lick)|dblclick|focus|keypress|(key|mouse)(down|up)|(un)?load|mouse(move|o(ut|ver))|reset|s(elect|ubmit)))",
        "description": "This regex will match all the valid on event attributes in HTML 4.01/XHTML 1.0",
        "matches": [
            "onclick",
            "onsubmit",
            "onmouseover"
        ],
        "non_matches": [
            "click",
            "onandon",
            "mickeymouse"
        ]
    },
    {
        "id": 458,
        "expression": "^#?(([fFcC0369])\\2){3}$",
        "description": "Matches the 216 web colors with or without the '#' sign.",
        "matches": [
            "#FFFFFF",
            "FFCC00",
            "003300"
        ],
        "non_matches": [
            "#FFFFF",
            "EFCC00",
            "030303"
        ]
    },
    {
        "id": 459,
        "expression": "^(\\d{4}-){3}\\d{4}$|^(\\d{4} ){3}\\d{4}$|^\\d{16}$",
        "description": "Used to validate Credit Card numbers, Checks if it contains 16 numbers in groups of 4 separated by -, ,or nothing",
        "matches": [
            "1111-2323-2312-3434",
            "1234343425262837",
            "1111 2323 2312 3434"
        ],
        "non_matches": [
            "1111 2323 2312-3434",
            "34323423",
            "1111-2323-23122-3434"
        ]
    },
    {
        "id": 460,
        "expression": "^([\\+][0-9]{1,3}[\\.][0-9]{1,12})([x]?[0-9]{1,4}?)$",
        "description": "Validates on the following standards:\n+CCC.ZZZZZZZZZZxYYYY, where 'C' is the numeric\ncountry phone code (up to three digits), 'Z' is the phone number (up to\n12 digits) and 'Y' is the extension (up to 4 digits); max length overall is\n20 characters, including the '+', '.', and 'x' (if extension is present).\nUseful for people communicating with the OpenSRS API",
        "matches": [
            "+800.4453377x4444",
            "+80.4453377",
            "+8.123456789123x1111"
        ],
        "non_matches": [
            "181823884499",
            "+800.4453377x",
            "2486994x11"
        ]
    },
    {
        "id": 462,
        "expression": "&amp;(?![a-zA-Z]{2,6};|#[0-9]{3};)",
        "description": "The goal of this regular expression is to replace all &amp; (ampersand) characters by &amp;amp; if they are not the start of HTML entities. I used\nhttp://www.w3schools.com/html/html_entitiesref.asp as a reference. You can then use RegExp Replace method to do the work. Was helpful for me, might helpful be for you...",
        "matches": [
            "&amp;ThisIsTooLong;",
            "Lilo &amp; Stich",
            "&amp;l;"
        ],
        "non_matches": [
            "&amp;lt;",
            "&amp;brvbar;",
            "&amp;#166;"
        ]
    },
    {
        "id": 464,
        "expression": "^([0-9]{2})(00[1-9]|0[1-9][0-9]|[1-2][0-9][0-9]|3[0-5][0-9]|36[0-6])$",
        "description": "Matches a Julian date in the format YYDDD. Two digit year followed by a number from 1 - 366 indicating the day of the year.",
        "matches": [
            "99366",
            "00001"
        ],
        "non_matches": [
            "74000",
            "04367"
        ]
    },
    {
        "id": 465,
        "expression": "^(?!000)([0-6]\\d{2}|7([0-6]\\d|7[012]))([ -]?)(?!00)\\d\\d\\3(?!0000)\\d{4}$",
        "description": "This regex validates U.S. social security numbers, within the range of numbers that have been currently allocated.",
        "matches": [
            "078-05-1120",
            "078 05 1120",
            "078051120"
        ],
        "non_matches": [
            "987-65-4320",
            "000-00-0000",
            "(555) 555-5555"
        ]
    },
    {
        "id": 471,
        "expression": "^([0-9a-zA-Z]([-.\\w]*[0-9a-zA-Z])*@([0-9a-zA-Z][-\\w]*[0-9a-zA-Z]\\.)+[a-zA-Z]{2,9})$",
        "description": "regex to validate email address\nnoteworthy:\n(1) It allows usernames with 1 or 2 alphanum characters, or 3+ chars can have -._ in the middle. username may NOT start/end with -._ or any other non alphanumeric character.\n(2) It allows heirarchical domain names (e.g. me@really.big.com). Similar -._ placement rules there.\n(3) It allows 2-9 character alphabetic-only TLDs (that oughta cover museum and adnauseum :&gt;).\n(4) No IP email addresses though -- I wouldn't Want to accept that kind of address.",
        "matches": [
            "e@eee.com",
            "eee@e-e.com",
            "eee@ee.eee.museum"
        ],
        "non_matches": [
            ".@eee.com",
            "eee@e-.com",
            "eee@ee.eee.eeeeeeeeee"
        ]
    },
    {
        "id": 473,
        "expression": "^\\d+(?:\\.\\d{0,2})?$",
        "description": "Matches positive whole numbers with exactly zero or two decimal points if a . is present. Useful for checking currency amounts, such 5 or 5.00 or 5.25.",
        "matches": [
            "1",
            "1.23",
            "1234.45"
        ],
        "non_matches": [
            "a1.34",
            "1.23a",
            "a"
        ]
    },
    {
        "id": 478,
        "expression": "[^A-Za-z0-9]",
        "description": "To detect non-alphanumeric characters (for new username/password validation, for instance):\nmonkey(AT)greyledge.net\n14-Oct-2003 11:26",
        "matches": [
            "!@#$",
            "%^&amp;*",
            "'&gt;&lt;?.,&quot;"
        ],
        "non_matches": [
            "ABC123abc",
            "abc123ABC",
            "abc0132ABC"
        ]
    },
    {
        "id": 482,
        "expression": "^([a-zA-Z]+(.)?[\\s]*)$",
        "description": "This regular expression matches titles. The length of the title has not been restricted. It allows only alphabets in the title and takes zero or one . after the title. Also it allows trailing spaces.",
        "matches": [
            "Mr.",
            "Sr",
            "Mr"
        ],
        "non_matches": [
            "Mr..",
            "12M",
            ".Mr"
        ]
    },
    {
        "id": 488,
        "expression": "^http://([a-zA-Z0-9_\\-]+)([\\.][a-zA-Z0-9_\\-]+)+([/][a-zA-Z0-9\\~\\(\\)_\\-]*)+([\\.][a-zA-Z0-9\\(\\)_\\-]+)*$",
        "description": "A very crude url pattern.",
        "matches": [
            "http://www.jonas.no/~webs(i)der/jon_as.php",
            "http://www.yahoo.com/net//ore"
        ],
        "non_matches": [
            "http://www./no/good",
            "imap://www.com/"
        ]
    },
    {
        "id": 489,
        "expression": "(?i:([A-D])(?!\\1)([A-D])(?!\\1|\\2)([A-D])(?!\\1|\\2|\\3)([A-D]))",
        "description": "This regex validates a string of non-repeating characters A, B, C, D.",
        "matches": [
            "abcd",
            "dbca",
            "badc"
        ],
        "non_matches": [
            "abba",
            "baaa",
            "cabb"
        ]
    },
    {
        "id": 490,
        "expression": "^((31(?! (FEB|APR|JUN|SEP|NOV)))|((30|29)(?! FEB))|(29(?= FEB (((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))|(0?[1-9])|1\\d|2[0-8]) (JAN|FEB|MAR|MAY|APR|JUL|JUN|AUG|OCT|SEP|NOV|DEC) ((1[6-9]|[2-9]\\d)\\d{2})$",
        "description": "Validates date format by DD MMM YYYY. Validates days for each month also.\nEnsures that month is uppercase.",
        "matches": [
            "09 MAY 1981",
            "28 JAN 2004",
            "8 JUL 2006"
        ],
        "non_matches": [
            "29 FEB 2003",
            "28 Oct 2000",
            "9 APR 03"
        ]
    },
    {
        "id": 492,
        "expression": "^(\\d|,)*\\d*$",
        "description": "matches 0 and all positive integers only. will accept comma formatting only.",
        "matches": [
            "1234",
            "1,234",
            "1,234,567"
        ],
        "non_matches": [
            "1234.0",
            "-1234",
            "$1234"
        ]
    },
    {
        "id": 493,
        "expression": "%[\\-\\+0\\s\\#]{0,1}(\\d+){0,1}(\\.\\d+){0,1}[hlI]{0,1}[cCdiouxXeEfgGnpsS]{1}",
        "description": "This regular expression matches &quot;c&quot; format strings for printf/scanf functions.",
        "matches": [
            "%s%02d",
            "%s",
            "%04lX"
        ],
        "non_matches": [
            "%5.f",
            "%++X",
            "%@d"
        ]
    },
    {
        "id": 495,
        "expression": ".\\{\\d\\}",
        "description": "String formater matching.",
        "matches": [
            "The quick {0} fox {1} over the lazy dog."
        ],
        "non_matches": [
            "The {b} is wrong"
        ]
    },
    {
        "id": 496,
        "expression": "^([0-9]*\\,?[0-9]+|[0-9]+\\,?[0-9]*)?$",
        "description": "Integer numbers with decimals. Only positives match. This expression doesn't match numbers with group separators",
        "matches": [
            "1234,50",
            "0,70",
            ",03"
        ],
        "non_matches": [
            "1.234,50",
            "-234,50"
        ]
    },
    {
        "id": 497,
        "expression": "^(\\d{1,2})(\\s?(H|h)?)(:([0-5]\\d))?$",
        "description": "Validates hours and minutes. Allows for entry in the form of hours:minutes with optional minutes and optional hours indicator (H or h).",
        "matches": [
            "1h",
            "1:45",
            "45"
        ],
        "non_matches": [
            "1a",
            "145",
            "1:99"
        ]
    },
    {
        "id": 498,
        "expression": "^(((\\d{1,3})(,\\d{3})*)|(\\d+))(.\\d+)?$",
        "description": "validates numbers, with or without decimal places, and comma 1000 separators.",
        "matches": [
            "9999999",
            "99999.99999",
            "99,999,999.9999"
        ],
        "non_matches": [
            "9999.",
            "9,99,99999.999",
            "999.9999.9999"
        ]
    },
    {
        "id": 499,
        "expression": "^\\d{1,8}$|^\\d{1,3},\\d{3}$|^\\d{1,2},\\d{3},\\d{3}$",
        "description": "Validates numeric input of 99,999,999 to 0 with or without commas. but no decimal places. Very simple, but not bad for a novice.",
        "matches": [
            "1000",
            "12,345",
            "12,345,678"
        ],
        "non_matches": [
            "1.1",
            "1,10",
            "123,888,888"
        ]
    },
    {
        "id": 500,
        "expression": "((([0][1-9]|[12][\\d])|[3][01])[-/]([0][13578]|[1][02])[-/][1-9]\\d\\d\\d)|((([0][1-9]|[12][\\d])|[3][0])[-/]([0][13456789]|[1][012])[-/][1-9]\\d\\d\\d)|(([0][1-9]|[12][\\d])[-/][0][2][-/][1-9]\\d([02468][048]|[13579][26]))|(([0][1-9]|[12][0-8])[-/][0][2][-/][1-9]\\d\\d\\d)",
        "description": "Date validation in the dd/mm/yyyy format for years 1000+ (i.e 999 or 0999 not matching) and taking february leap years into account.",
        "matches": [
            "12/12/2003",
            "29-02-2004",
            "31-03-1980"
        ],
        "non_matches": [
            "29/02/2003",
            "31-04-2002",
            "10-10-0999"
        ]
    },
    {
        "id": 501,
        "expression": "(^\\$(\\d{1,3},?(\\d{3},?)*\\d{3}(\\.\\d{1,3})?|\\d{1,3}(\\.\\d{2})?)$|^\\d{1,2}(\\.\\d{1,2})? *%$|^100%$)",
        "description": "Matches either an explicitly input percentage or dollar amount, variety of formats of currency borrowed from another example on this board. This is useful when you want to prompt the user to specify either dollars or percent using only one field, and want to validate the entered text is one or the other.",
        "matches": [
            "$1000.00",
            "100%",
            "50%"
        ],
        "non_matches": [
            "%100",
            ".5%",
            "100"
        ]
    },
    {
        "id": 502,
        "expression": "^(?=[^\\d_].*?\\d)\\w(\\w|[!@#$%]){7,20}",
        "description": "This regex can be used to restrict passwords to a length of 8 to 20 aplhanumeric characters and select special characters. The password also can not start with a digit, underscore or special character and must contain at least one digit.",
        "matches": [
            "password1",
            "pa$$word2",
            "pa!@#$%3"
        ],
        "non_matches": [
            "password",
            "1stpassword",
            "$password#"
        ]
    },
    {
        "id": 507,
        "expression": "^[A-Z].*$",
        "description": "Test string to verify it begins with an upper-case letter.",
        "matches": [
            "Lewis",
            "Edward",
            "Moten"
        ],
        "non_matches": [
            "lewis",
            "1moten",
            "@home"
        ]
    },
    {
        "id": 510,
        "expression": "^[01]?[- .]?\\(?[2-9]\\d{2}\\)?[- .]?\\d{3}[- .]?\\d{4}$",
        "description": "U. S. or Canadian telephone number regular expression. &lt;BR&gt;\n&lt;BR&gt;\n// # Checks phone numbers for validity &lt;BR&gt;\n// [01]? # optional '0', or '1' &lt;BR&gt;\n// [- .]? # optional separator is either a dash, a space, or a period. &lt;BR&gt;\n// \\(? # optional parentheses &lt;BR&gt;\n// [2-9] # first # of the area code must not be a '0' or '1' &lt;BR&gt;\n// \\d{2} # next 2 digits of area code can be 0-9 &lt;BR&gt;\n// \\)? # optional parentheses &lt;BR&gt;\n// [- .]? # optional separator is either a dash, a space, or a period. &lt;BR&gt;\n// \\d{3} # 3-digit prefix &lt;BR&gt;\n// [- .]? # optional separator is either a dash, a space, or a period. &lt;BR&gt;\n// \\d{4} # 4-digit station number &lt;BR&gt;",
        "matches": [
            "18008793262",
            "800-879-3262",
            "0-800.879.3262"
        ],
        "non_matches": [
            "879 3262",
            "077 879 3262",
            "879-3262"
        ]
    },
    {
        "id": 511,
        "expression": "^((\\(?0\\d{4}\\)?\\s?\\d{3}\\s?\\d{3})|(\\(?0\\d{3}\\)?\\s?\\d{3}\\s?\\d{4})|(\\(?0\\d{2}\\)?\\s?\\d{4}\\s?\\d{4}))(\\s?\\#(\\d{4}|\\d{3}))?$",
        "description": "UK phone number. Allows 3, 4 or 5 digit regional prefix, with 8, 7 or 6 digit phone number respectively, plus optional 3 or 4 digit extension number prefixed with a # symbol. Also allows optional brackets surrounding the regional prefix and optional spaces between appropriate groups of numbers.",
        "matches": [
            "01222 555 555",
            "(010) 55555555 #2222",
            "0122 555 5555#222"
        ],
        "non_matches": [
            "01222 555 5555",
            "(010) 55555555 #22",
            "0122 5555 5555#222"
        ]
    },
    {
        "id": 512,
        "expression": "(^N/A$)|(^[-]?(\\d+)(\\.\\d{0,3})?$)|(^[-]?(\\d{1,3},(\\d{3},)*\\d{3}(\\.\\d{1,3})?|\\d{1,3}(\\.\\d{1,3})?)$)",
        "description": "This pattern matches a decimal value with up to 3 digits after the decimal. Comma is allowed as a thousands separator but not required. N/A is also allowed.",
        "matches": [
            "405.234",
            "50",
            "213123.456",
            "-1",
            "N/A"
        ],
        "non_matches": [
            "bathreader",
            "this is N/A",
            "3.14159",
            "+10"
        ]
    },
    {
        "id": 517,
        "expression": "^([A-HK-PRSVWY][A-HJ-PR-Y])\\s?([0][2-9]|[1-9][0-9])\\s?[A-HJ-PR-Z]{3}$",
        "description": "UK vehicle registration system currently in use (as defined by the DVLA and put into effect from September 2001, and therefore does not allow registrations prior to this date).",
        "matches": [
            "AB51DVL",
            "AB 51 DVL"
        ],
        "non_matches": [
            "AZ01DLQ",
            "AZ 01 DLQ"
        ]
    },
    {
        "id": 518,
        "expression": "^([A-Z]{3}\\s?(\\d{3}|\\d{2}|d{1})\\s?[A-Z])|([A-Z]\\s?(\\d{3}|\\d{2}|\\d{1})\\s?[A-Z]{3})$",
        "description": "UK vehicle registration system prior to September 2001. Allows both older suffix and the later prefix formats in simple form, with optional spaces.",
        "matches": [
            "ABC123A",
            "A 123 ABC"
        ],
        "non_matches": [
            "AB123A",
            "A 123 AB"
        ]
    },
    {
        "id": 519,
        "expression": "^([1-9]{1}[0-9]{0,7})+((,[1-9]{1}[0-9]{0,7}){0,1})+$",
        "description": "Validate a comma delimited string of integer between 1 and 99999999 (change {0,7} to whatever you need). No zero leading.",
        "matches": [
            "1,2,3455,12345678",
            "23045,34678,2892",
            "1,2,99999999"
        ],
        "non_matches": [
            "01,234,567",
            "123,0445,3434,",
            "121,,1212,,12,"
        ]
    },
    {
        "id": 520,
        "expression": "^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,15}$",
        "description": "Password matching expression. Password must be at least 8 characters, no more than 15 characters, and must include at least one upper case letter, one lower case letter, and one numeric digit.",
        "matches": [
            "aaaa1234AAAA",
            "12aaAA12",
            "aaaaa12345AAAAA"
        ],
        "non_matches": [
            "aaaaa123456AAAAA",
            "12aaAA1",
            "12aaaa12"
        ]
    },
    {
        "id": 521,
        "expression": "^([0-9a-zA-Z]([-.\\w]*[0-9a-zA-Z])*@(([0-9a-zA-Z])+([-\\w]*[0-9a-zA-Z])*\\.)+[a-zA-Z]{2,9})$",
        "description": "Email validation based on Rob Eberhardt's (Thanks, Rob!) email expression, but allows single letter subdomains...",
        "matches": [
            "bob@smith.com",
            "bob@j.smith.museum",
            "bob.smith@a-1.smith.com"
        ],
        "non_matches": [
            "bob@.com",
            "bob@-a.smith.com"
        ]
    },
    {
        "id": 523,
        "expression": "^[a-zA-Z0-9\\s]+$",
        "description": "Alphanumeric expression with spaces",
        "matches": [
            "123asd",
            "111 ee11e",
            "223 eeddd23"
        ],
        "non_matches": [
            "12' ggg",
            "&lt;&gt;dfdg 444",
            "dfgdfg/dfgd"
        ]
    },
    {
        "id": 524,
        "expression": "^([2-9])(\\d{2})(-?|\\040?)(\\d{4})( ?|\\040?)(\\d{1,4}?|\\040?)$",
        "description": "A regular expression that validates the any format of fixed telephone numbers inside Lima - Peru, including an optional extension of at least one number up to four numbers.",
        "matches": [
            "263-8854",
            "5660578 1235",
            "622-4588 21"
        ],
        "non_matches": [
            "1227585",
            "4224586 50124",
            "0554499"
        ]
    },
    {
        "id": 525,
        "expression": "^([8-9])([1-9])(\\d{2})(-?|\\040?)(\\d{4})$",
        "description": "A regular expression that validates the any of the new formats of cellular phones numbers in Peru, allows an optional dash in the middle of the number.",
        "matches": [
            "8874-2544",
            "99106800",
            "84509955"
        ],
        "non_matches": [
            "6540-9985",
            "77329390",
            "725-2763"
        ]
    },
    {
        "id": 526,
        "expression": "^(\\$)?((\\d+)|(\\d{1,3})(\\,\\d{3})*)(\\.\\d{2,})?$",
        "description": "This pattern handles currency including the following:\noptional period with two or more digits to the right of the period\noptional commas\noptional dollar sign($)",
        "matches": [
            "$3,333,333,333",
            "$333333",
            "$3,333.33"
        ],
        "non_matches": [
            "3,33",
            "3333,333,333",
            "333.3"
        ]
    },
    {
        "id": 527,
        "expression": "^(?!\\d[1]{2}|[5]{3})([2-9]\\d{2})([. -]*)\\d{4}$",
        "description": "Validates *usable* US telephone numbers (possibly Canadian and Caribbean Islands as well?) Numbers cannot beginning with zero, one, (any number)11, or 555. It will allow either a hyphen, space or period as a separator.\nTechnically (and contrary to popular belief) most 555- numbers ARE valid numbers [see http://www.nanpa.com/nas/public/form555MasterReport.do?method=display555MasterReport ] but they are unlikely to be used by normal folks. Therefore, excluding them with this regex is useful to prevent bogus/fraudulent telephone numbers in forms.\nFYI, the fictitious 555- numbers used in the movies and TV are only in the range of 555-0100 through 555-0199. Not very many, huh?",
        "matches": [
            "222-2222",
            "295-5000"
        ],
        "non_matches": [
            "555-1234",
            "411-5555",
            "099-9999"
        ]
    },
    {
        "id": 529,
        "expression": "^(?:\\([2-9]\\d{2}\\)\\ ?|[2-9]\\d{2}(?:\\-?|\\ ?))[2-9]\\d{2}[- ]?\\d{4}$",
        "description": "US Phone Number: This regular expression for US phone numbers conforms to NANP A-digit and D-digit requirments (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted. Format validation accepts 10-digits without delimiters, optional parens on area code, and optional spaces or dashes between area code, central office code and station code. Acceptable formats include 2225551212, 222 555 1212, 222-555-1212, (222) 555 1212, (222) 555-1212, etc. You can add/remove formatting options to meet your needs.",
        "matches": [
            "5305551212",
            "(530) 555-1212",
            "530-555-1212"
        ],
        "non_matches": [
            "0010011212",
            "1991991212",
            "123) not-good"
        ]
    },
    {
        "id": 530,
        "expression": "^((?:(?:(?:[a-zA-Z0-9][\\.\\-\\+_]?)*)[a-zA-Z0-9])+)\\@((?:(?:(?:[a-zA-Z0-9][\\.\\-_]?){0,62})[a-zA-Z0-9])+)\\.([a-zA-Z0-9]{2,6})$",
        "description": "Captures Submatches, problem:domainname length can be longer than 64 chars, because every [a-zA-Z0-9][\\.\\-_] is only countet as one char.",
        "matches": [
            "abc@def.gh",
            "a+b_c@d-e_f.gh",
            "abc@def.ghijkl"
        ],
        "non_matches": [
            "__@__.__",
            "-a-@-b-.cd",
            "a--b@c__d.ef"
        ]
    },
    {
        "id": 531,
        "expression": "^(((\\d{4}((0[13578]|1[02])(0[1-9]|[12]\\d|3[01])|(0[13456789]|1[012])(0[1-9]|[12]\\d|30)|02(0[1-9]|1\\d|2[0-8])))|((\\d{2}[02468][048]|\\d{2}[13579][26]))0229)){0,8}$",
        "description": "Validates a date expression (or empty value) in CCYYMMDD format, checking a leap year from 00000101 A.D. to 99991231",
        "matches": [
            "20041231",
            "20040229"
        ],
        "non_matches": [
            "20043112",
            "2003/04/02"
        ]
    },
    {
        "id": 532,
        "expression": "^(?=\\d)(?:(?:31(?!.(?:0?[2469]|11))|(?:30|29)(?!.0?2)|29(?=.0?2.(?:(?:(?:1[6-9]|[2-9]\\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00)))(?:\\x20|$))|(?:2[0-8]|1\\d|0?[1-9]))([-./])(?:1[012]|0?[1-9])\\1(?:1[6-9]|[2-9]\\d)?\\d\\d(?:(?=\\x20\\d)\\x20|$))?(((0?[1-9]|1[012])(:[0-5]\\d){0,2}(\\x20[AP]M))|([01]\\d|2[0-3])(:[0-5]\\d){1,2})?$",
        "description": "DateTime Validator. This RE validates both dates and/or times patterns. Days in Feb. are also validated for Leap years. Dates: in dd/mm/yyyy or d/m/yy format between 1/1/1600 - 31/12/9999. Leading zeroes are optional. Date separators can be either matching dashes(-), slashes(/) or periods(.) Times: in the hh:MM:ss AM/PM 12 hour format (12:00 AM - 11:59:59 PM) or hh:MM:ss military time format (00:00:00 - 23:59:59). The 12 hour time format: 1) may have a leading zero for the hour. 2) Minutes and seconds are optional for the 12 hour format 3) AM or PM is required and case sensitive. Military time 1) must have a leading zero for all hours less than 10. 2) Minutes are manditory. 3) seconds are optional. Datetimes: combination of the above formats. A date first then a time separated by a space. ex) dd/mm/yyyy hh:MM:ss This RE is an variation of one of my other Datetime (mm/dd/yyyy) validator already in this library http://www.regexlib.com/REDetails.aspx?regexp_id=369, so the same rules for leap year apply. All 4 digit year and all two digit years except 00, which might not be a leap year.",
        "matches": [
            "31/12/2003 11:59:59 PM",
            "29-2-2004",
            "01:45:02"
        ],
        "non_matches": [
            "12/31/2003",
            "29.02.2005",
            "13:30 PM"
        ]
    },
    {
        "id": 535,
        "expression": "^(\\x22|\\x27)((?!\\1).|\\1{2})*\\1$",
        "description": "The regex validate a quoted string in VBScript or Ansi SQL. The string may contain the containing quote character if it is escaped by being doubled up.\nIn VB/VBScript two double quotes within a string enclosed in double qoutes translate into one double quote within the string\nIn SQL two single quotes within a string enclosed in single qoutes translate into one single quote within the string",
        "matches": [
            "\"To quote Yoda (\"\"Do, or do not. There is no 'try'\"\" )\""
        ],
        "non_matches": [
            "'This won't validate'",
            "\"He said \"Ok.\"\""
        ]
    },
    {
        "id": 537,
        "expression": "^1000([.][0]{1,3})?$|^\\d{1,3}$|^\\d{1,3}([.]\\d{1,3})$|^([.]\\d{1,3})$",
        "description": "allows positive none-to-3-decimal values between 0.000 and 1000.000",
        "matches": [
            ".123",
            "0.126",
            "1000.000"
        ],
        "non_matches": [
            ".1234",
            "0.1b6",
            "1000.001"
        ]
    },
    {
        "id": 538,
        "expression": "^(\\-)?1000([.][0]{1,3})?$|^(\\-)?\\d{1,3}$|^(\\-)?\\d{1,3}([.]\\d{1,3})$|^(\\-)?([.]\\d{1,3})$",
        "description": "allows positive and negative none-to-3-decimal values between -1000.000 and 1000.000",
        "matches": [
            "123.456",
            "-0.125",
            "-1000.000"
        ],
        "non_matches": [
            "123.4567",
            "-0.1b5",
            "-1000.001"
        ]
    },
    {
        "id": 542,
        "expression": "^(((ht|f)tp(s?))\\://)?(www.|[a-zA-Z].)[a-zA-Z0-9\\-\\.]+\\.(com|edu|gov|mil|net|org|biz|info|name|museum|us|ca|uk)(\\:[0-9]+)*(/($|[a-zA-Z0-9\\.\\,\\;\\?\\'\\\\\\+&amp;%\\$#\\=~_\\-]+))*$",
        "description": "Version 1.3.0: I needed a regexp to validate URL's without the ht(f)tp(s):// and include North American domains (like .us and .ca) and there didn't seem to be one available...so I created one. It will also work with ASP QueryStrings and anchor URL's. If you have a problem with the expression or have any suggestions to improve, please write me and let me know. Added .uk domain and expression now allows for URLs that contain JSP session IDs. 4/14/04 - added ability to include URLs that start with server names.",
        "matches": [
            "www.blah.com:8103",
            "www.blah.com/blah.asp?sort=ASC",
            "www.blah.com/blah.htm#blah"
        ],
        "non_matches": [
            "www.state.ga",
            "http://www.blah.ru"
        ]
    },
    {
        "id": 544,
        "expression": "(^[a-zA-Z0-9]+://)",
        "description": "Use in a .net Regex.Split() to pull the protocol out of a url into the first array entry.",
        "matches": [
            "myprot://server/path.asp"
        ],
        "non_matches": [
            "server/path.asp"
        ]
    },
    {
        "id": 545,
        "expression": "^\\$?\\-?([1-9]{1}[0-9]{0,2}(\\,\\d{3})*(\\.\\d{0,2})?|[1-9]{1}\\d{0,}(\\.\\d{0,2})?|0(\\.\\d{0,2})?|(\\.\\d{1,2}))$|^\\-?\\$?([1-9]{1}\\d{0,2}(\\,\\d{3})*(\\.\\d{0,2})?|[1-9]{1}\\d{0,}(\\.\\d{0,2})?|0(\\.\\d{0,2})?|(\\.\\d{1,2}))$|^\\(\\$?([1-9]{1}\\d{0,2}(\\,\\d{3})*(\\.\\d{0,2})?|[1-9]{1}\\d{0,}(\\.\\d{0,2})?|0(\\.\\d{0,2})?|(\\.\\d{1,2}))\\)$",
        "description": "currency format that allows optional $, optional &quot;-&quot;(MinusSignNegative) OR &quot;()&quot; (ParenNegative) but not both, optional cents, and optional commas separating thousands. Minus sign can be before or after $, but parens must be outside the $. UPDATED: now fails to match a &quot;$&quot; without any further numbers",
        "matches": [
            "($4,000.00)",
            "-$4000.00",
            "-$400.00"
        ],
        "non_matches": [
            "4,00.000",
            "abc",
            "$"
        ]
    },
    {
        "id": 547,
        "expression": "^((\\d{1,2})?([.][\\d]{1,2})?){1}[%]{1}$",
        "description": "for checking a value is between 99.99% and 00.00%",
        "matches": [
            "99.99%",
            "9%",
            ".09%"
        ],
        "non_matches": [
            "99",
            "9.%"
        ]
    },
    {
        "id": 550,
        "expression": "(^[A-Za-z])|(\\s)([A-Za-z])",
        "description": "This expression will return the first letter of each word in a string. Best used if you need to get initials from a name.\n&quot;James Kramer&quot; = &quot;J K&quot; &amp; &quot;Sir Richard Branson&quot; = &quot;S R B&quot; &amp; &quot;33 yoYo 654 ma&quot; = &quot;y m&quot;",
        "matches": [
            "James Kramer",
            "Sir Richard Branson",
            "33 yoYo 654 ma"
        ],
        "non_matches": [
            "33 66 4ju"
        ]
    },
    {
        "id": 567,
        "expression": "^(([a-zA-Z]:)|(\\\\{2}\\w+)\\$?)(\\\\(\\w[\\w ]*.*))+\\.(txt|TXT)$",
        "description": "It matches .jpg files. It allows for a dot in the path. A dot may occur in such directories as: C:\\Documents and Settings\\roman.lukyanenko\\Desktop\\stuff\\b_card2.txt or C:\\Windows\\Microsoft.NET etc",
        "matches": [
            "C:\\Documents and Settings\\roman.lukyanenko\\Desktop\\stuff\\b_card2.txt"
        ],
        "non_matches": [
            "C:\\file.doc"
        ]
    },
    {
        "id": 569,
        "expression": "^(((\\d{4})(0[13578]|10|12)(0[1-9]|[12][0-9]|3[01]))|((\\d{4})(0[469]|11)([0][1-9]|[12][0-9]|30))|((\\d{4})(02)(0[1-9]|1[0-9]|2[0-8]))|(([02468][048]00)(02)(29))|(([13579][26]00) (02)(29))|(([0-9][0-9][0][48])(02)(29))|(([0-9][0-9][2468][048])(02)(29))|(([0-9][0-9][13579][26])(02)(29))|(00000000)|(88888888)|(99999999))?$",
        "description": "it's for date in the format: &quot;yyyymmdd&quot; and it validates the empty string and some special values (00000000,88888888,99999999) but you can delete these last values. It works with leap years.",
        "matches": [
            "20041212",
            "20040229",
            "88888888"
        ],
        "non_matches": [
            "20040230",
            "20041330"
        ]
    },
    {
        "id": 571,
        "expression": "^(0{0,1}[1-9]|[12][0-9]|3[01])[- /.](0{0,1}[1-9]|1[012])[- /.](\\d{2}|\\d{4})$",
        "description": "Validates dates formatted like &quot;dd.mm.yyyy&quot; or &quot;dd.mm.yy&quot;. Also the separators &quot;/&quot; and &quot;-&quot; are validated &quot;ok&quot;. This expression does not check leap years!\nI did this expression cause I could hardly find any date regex that supports those &quot;dot-formats&quot;.",
        "matches": [
            "1.1.2004",
            "03.07.04",
            "1-03-03"
        ],
        "non_matches": [
            "0.13.2004",
            "1.1.200",
            "32.0.03"
        ]
    },
    {
        "id": 577,
        "expression": "^0[234679]{1}[\\s]{0,1}[\\-]{0,1}[\\s]{0,1}[1-9]{1}[0-9]{6}$",
        "description": "The regex matches the UAE land phone numbers. Checks the area codes[04,02,06...etc] strictly. Force user to input phone numbers in strict manner(it take input 04 3452488, but not 04______spaces_______3452488)",
        "matches": [
            "04 3452488",
            "04 -3452488",
            "04 - 3452499"
        ],
        "non_matches": [
            "01 -3452488",
            "04 34524888",
            "08 3452488"
        ]
    },
    {
        "id": 578,
        "expression": "(^[a-fA-F]+[+-]?$)",
        "description": "Letter Grade scores A-F + and -",
        "matches": [
            "a+",
            "A",
            "F-"
        ],
        "non_matches": [
            "z",
            "6",
            "D +"
        ]
    },
    {
        "id": 580,
        "expression": "^((\\+){0,1}91(\\s){0,1}(\\-){0,1}(\\s){0,1}){0,1}98(\\s){0,1}(\\-){0,1}(\\s){0,1}[1-9]{1}[0-9]{7}$",
        "description": "The Regex validate the mobile numbers in India.\nGives flexibility to user to enter numbers in different format like\n+919847444225, +91-98-45017381, 9844111116, 98 44111112, 98-44111116\n###Enjoy REGEX###",
        "matches": [
            "+919847444225",
            "+91-98-44111112",
            "98 44111116"
        ],
        "non_matches": [
            "+919800444225",
            "+947444225",
            "44111116"
        ]
    },
    {
        "id": 582,
        "expression": "^([0-5]?\\d?\\d?\\d?\\d|6[0-4]\\d\\d\\d|65[0-4]\\d\\d|655[0-2]\\d|6553[0-5])$",
        "description": "match for 0 - 65535",
        "matches": [
            "0",
            "65535",
            "59999"
        ],
        "non_matches": [
            "123456",
            "69999",
            "65599"
        ]
    },
    {
        "id": 583,
        "expression": "^(((0?[1-9]|[12]\\d|3[01])[\\.\\-\\/](0?[13578]|1[02])[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}))|((0?[1-9]|[12]\\d|30)[\\.\\-\\/](0?[13456789]|1[012])[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}))|((0?[1-9]|1\\d|2[0-8])[\\.\\-\\/]0?2[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}))|(29[\\.\\-\\/]0?2[\\.\\-\\/]((1[6-9]|[2-9]\\d)?(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)|00)))$",
        "description": "DD.MM.YY or DD.MM.YYYY\nseparator could be on choice '.' '/' or '-'\nleap years compatible, 00 is treated as year 2000.",
        "matches": [
            "29.2.04",
            "29/02-2004",
            "3.4.05"
        ],
        "non_matches": [
            "29.2.03",
            "2902.2004",
            "12.31.1975"
        ]
    },
    {
        "id": 589,
        "expression": "((\\(\\d{3,4}\\)|\\d{3,4}-)\\d{4,9}(-\\d{1,5}|\\d{0}))|(\\d{4,12})",
        "description": "telphone number check.",
        "matches": [
            "0833-1234567-8888",
            "(0833)1234567-8888",
            "12345678"
        ],
        "non_matches": [
            "ceocio",
            "!@$@#$"
        ]
    },
    {
        "id": 590,
        "expression": "^[{|\\(]?[0-9a-fA-F]{8}[-]?([0-9a-fA-F]{4}[-]?){3}[0-9a-fA-F]{12}[\\)|}]?$",
        "description": "Specifier Format of Guid Values that this RegEx supports: 32 digits: [xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx] 32 digits separated by hyphens: [xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx] 32 digits separated by hyphens, enclosed in brackets: [{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}] 32 digits separated by hyphens, enclosed in parentheses: [(xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)]",
        "matches": [
            "914D226A-2F5B-4944-934D-96BBE6571977",
            "{914D226A-2F5B-4944-934D-96BBE6571977}"
        ],
        "non_matches": [
            "914D226A-2F5B-4944-XXXX-96BBE6571977",
            "{914D226A-2F5B-4944-XXXX-96BBE6571977}"
        ]
    },
    {
        "id": 604,
        "expression": "^(([a-z][0-9])|([0-9][a-z])|([a-z0-9][a-z0-9\\-]{1,2}[a-z0-9])|([a-z0-9][a-z0-9\\-](([a-z0-9\\-][a-z0-9])|([a-z0-9][a-z0-9\\-]))[a-z0-9\\-]*[a-z0-9]))\\.(co|me|org|ltd|plc|net|sch|ac|mod|nhs|police|gov)\\.uk$",
        "description": "UK domain names. Includes the following restrictions from Nominet as at time of posting:\n1.Only a-z, 0-9 and hyphen may be used.\n2.First or last character may not be a hyphen.\n3.Third and fourth characters may not both be hyphens.\n4.Third level domain may not be a single character.\n5.Third level domain may not be two letters or two numbers.\n6.Third level domain may be one letter and one number.\nThis does not yet include the following restrictions:\n1.Whole domain may not be longer than 64 characters in length.\n2.Third level domain may not duplicate any top/second level domain.",
        "matches": [
            "zeropanic.co.uk",
            "z2.co.uk",
            "1-1.org.uk"
        ],
        "non_matches": [
            "zeropanic.com",
            "z.co.uk",
            "zz.co.uk"
        ]
    },
    {
        "id": 605,
        "expression": "^(ht|f)tp((?<=http)s)?://((?<=http://)www|(?<=https://)www|(?<=ftp://)ftp)\\.(([a-z][0-9])|([0-9][a-z])|([a-z0-9][a-z0-9\\-]{1,2}[a-z0-9])|([a-z0-9][a-z0-9\\-](([a-z0-9\\-][a-z0-9])|([a-z0-9][a-z0-9\\-]))[a-z0-9\\-]*[a-z0-9]))\\.(co|me|org|ltd|plc|net|sch|ac|mod|nhs|police|gov)\\.uk$",
        "description": "UK domains with protocol for http/https/ftp. Based on my previous expression, this allows the subdomain &quot;www&quot; for the http/https protocols, or &quot;ftp&quot; for the ftp protocol only.",
        "matches": [
            "http://www.zeropanic.co.uk",
            "ftp://ftp.sunsite.ac.uk",
            "https://www.z2.co.uk"
        ],
        "non_matches": [
            "gopher://www.z2.co.uk",
            "http://ftp.z2.co.uk",
            "ftp://www.z2.co.uk"
        ]
    },
    {
        "id": 607,
        "expression": "^(?:\\([2-9]\\d{2}\\)\\ ?|(?:[2-9]\\d{2}\\-))[2-9]\\d{2}\\-\\d{4}$",
        "description": "This US phone number edit with restricted format options: Accepts optional parens on area code with or without following space, and dashes between area code, central office code and station code. Formats include only (222) 555-1212 (with or without a space) and 222-555-1212. Conforms to NANP A-digit and D-digit requirements (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted.",
        "matches": [
            "(234) 555-1212",
            "(234)555-1212",
            "234-555-1212"
        ],
        "non_matches": [
            "(234)5551212",
            "234 555 1212",
            "234) 555-1212"
        ]
    },
    {
        "id": 610,
        "expression": "^([0-1]?\\d|2[0-3]):([0-5]\\d)$",
        "description": "Time in 24h format; minutes must be two digits; hours may be one or two digits",
        "matches": [
            "3:23",
            "03:23",
            "16:59"
        ],
        "non_matches": [
            "12:2",
            "12:76",
            "33:12"
        ]
    },
    {
        "id": 619,
        "expression": "^(\\d{3}-\\d{3}-\\d{4})*$",
        "description": "This expression is a very simplex expression that allows null values or 3 digits, dash, 3 digits, dash, 4 digits. It validates a basic US phone number. Written by Jason N. Gaylord.",
        "matches": [
            "555-555-1212",
            "123-456-7890"
        ],
        "non_matches": [
            "555.555.1212",
            "(555) 555-1212",
            "5555551212"
        ]
    },
    {
        "id": 620,
        "expression": "^(\\d{2}-\\d{2})*$",
        "description": "This expression is a simplex expression that checks to see if a value is a valid phone system terminal number. It allows a null value or 2 digits, dash, 2 digits. Written by Jason N. Gaylord.",
        "matches": [
            "00-00",
            "54-68"
        ],
        "non_matches": [
            "1235",
            "0",
            "5-789"
        ]
    },
    {
        "id": 621,
        "expression": "(\\s|\\n|^)(\\w+://[^\\s\\n]+)",
        "description": "will match free floating valid protocol + urls in text ... will not touch the ones wrapped in a tag, so that you can auto-link the ones that aren't :) couple of things to know :\n1. if the url is next to a tag this won't work (eg : &lt;br&gt;http://www.acme.com), the url must either start with a \\s, \\n or any character other than &gt;.\n2. the pattern will match the preceding \\s and \\n too, so when you replace put them back in place $1 will either be \\s or \\n, $2 will be the exact match\nvb usage :\nset re = New RegExp\nre.Pattern =&quot;(\\s|\\n|^)(\\w+://[^\\s\\n]+)&quot;\nstrResult = re.Replace(strText, &quot;$1&lt;a href='$2' target='_new'&gt;$2&lt;/a&gt;&quot;)",
        "matches": [
            "http://www.acme.com",
            "ftp://ftp.acme.com/hede",
            "gopher://asdfasd.asdfasdf"
        ],
        "non_matches": [
            "&lt;a href=&quot;http://acme.com&quot;&gt;http://www.acme.com&lt;/a&gt;",
            "&lt;br&gt;http://www.acme."
        ]
    },
    {
        "id": 623,
        "expression": "[0-9]{4}[A-Z]{2}",
        "description": "Match for dutch zipcodes.\nDutch zipcodes are always in the format of 4 digits and 2 letters.",
        "matches": [
            "1000AB",
            "3035KA",
            "9999ZZ"
        ],
        "non_matches": [
            "AA1000",
            "Z1000",
            "1000-CC"
        ]
    },
    {
        "id": 626,
        "expression": "^(((((0[1-9])|(1\\d)|(2[0-8]))/((0[1-9])|(1[0-2])))|((31/((0[13578])|(1[02])))|((29|30)/((0[1,3-9])|(1[0-2])))))/((20[0-9][0-9]))|((((0[1-9])|(1\\d)|(2[0-8]))/((0[1-9])|(1[0-2])))|((31/((0[13578])|(1[02])))|((29|30)/((0[1,3-9])|(1[0-2])))))/((19[0-9][0-9]))|(29/02/20(([02468][048])|([13579][26])))|(29/02/19(([02468][048])|([13579][26]))))$",
        "description": "This expression is an improved version of J&#246;rg Maag. It checks a date field in the Australian DD/MM/YYYY format. Besides, it also validates leap year between 1900 and 2099.",
        "matches": [
            "29/02/1992",
            "29/02/2000",
            "29/02/2004"
        ],
        "non_matches": [
            "29/02/1892",
            "29/02/2100",
            "29/02/3004"
        ]
    },
    {
        "id": 627,
        "expression": "(((0[1-9]|[12][0-9]|3[01])([/])(0[13578]|10|12)([/])([1-2][0,9][0-9][0-9]))|(([0][1-9]|[12][0-9]|30)([/])(0[469]|11)([/])([1-2][0,9][0-9][0-9]))|((0[1-9]|1[0-9]|2[0-8])([/])(02)([/])([1-2][0,9][0-9][0-9]))|((29)(\\.|-|\\/)(02)([/])([02468][048]00))|((29)([/])(02)([/])([13579][26]00))|((29)([/])(02)([/])([0-9][0-9][0][48]))|((29)([/])(02)([/])([0-9][0-9][2468][048]))|((29)([/])(02)([/])([0-9][0-9][13579][26])))",
        "description": "This is the Brazilian Date Format.\nDD/MM/YYYY with the right days per month.\nDates &gt;=1900 &lt;=2999.",
        "matches": [
            "29/02/2004",
            "31/01/1900",
            "31/01/2999"
        ],
        "non_matches": [
            "29/02/2003",
            "12042004",
            "20/04/04"
        ]
    },
    {
        "id": 634,
        "expression": "^([1-9]|[1-9]\\d|100)$",
        "description": "This pattern matches whole numbers 1-100.",
        "matches": [
            "1",
            "50",
            "100"
        ],
        "non_matches": [
            "0",
            ".5",
            "101"
        ]
    },
    {
        "id": 635,
        "expression": "^(20|21|22|23|[01]\\d|\\d)(([:.][0-5]\\d){1,2})$",
        "description": "24 hour clock as prefered by MS-SQL, allows for shorter more human methods of writing time (no preceding zero or seconds required).\nMS-SQL prefers semi-colon although this accepts full stops for users ease of use.",
        "matches": [
            "09:00:00",
            "09.00",
            "9:00"
        ],
        "non_matches": [
            "9:00AM"
        ]
    },
    {
        "id": 637,
        "expression": "^[a-zA-Z]+((\\s|\\-)[a-zA-Z]+)?$",
        "description": "This regex validates a persons first name. Acceptable names include compound names with a hyphen or a space in them.",
        "matches": [
            "Bobbie Sue",
            "Ana-Claire",
            "BobbyJoe"
        ],
        "non_matches": [
            "Billy - Joe",
            "Billy Jr.",
            "Thos."
        ]
    },
    {
        "id": 638,
        "expression": "^[a-zA-Z]+((((\\-)|(\\s))[a-zA-Z]+)?(,(\\s)?(((j|J)|(s|S))(r|R)(\\.)?|II|III|IV))?)?$",
        "description": "This regex validates a persons last name. Acceptable names can include compound names seperated by a hyphen or a space.",
        "matches": [
            "Jones, Jr",
            "Casey-Jones",
            "Casey-Jones, IV"
        ],
        "non_matches": [
            "Jones, IV.",
            "Jones , Jr",
            "Casey-Jones-Hall"
        ]
    },
    {
        "id": 639,
        "expression": "(((0[123456789]|10|11|12)([/])(([1][9][0-9][0-9])|([2][0-9][0-9][0-9]))))",
        "description": "This is an new data Validation to MM/YYYY from 1900 to 2999 this is an validation expression to Client From MOnth/Year.",
        "matches": [
            "01/1900",
            "10/1990",
            "12/2999"
        ],
        "non_matches": [
            "1/1900",
            "12/1899",
            "01/3000"
        ]
    },
    {
        "id": 640,
        "expression": "^(([1-9]{1})|([0-1][0-9])|([1-2][0-3])):([0-5][0-9])$",
        "description": "Matches 24 hour time format.",
        "matches": [
            "00:00",
            "23:59",
            "10:10"
        ],
        "non_matches": [
            "24:00",
            "00:60",
            "25:61"
        ]
    },
    {
        "id": 641,
        "expression": "^(([1-9]{1})|([0-1][1-2])|(0[1-9])|([1][0-2])):([0-5][0-9])(([aA])|([pP]))[mM]$",
        "description": "Matches 12 hour time format",
        "matches": [
            "1:00Am",
            "12:59pM",
            "05:05pm"
        ],
        "non_matches": [
            "00:00am",
            "05:60pm",
            "1:00"
        ]
    },
    {
        "id": 642,
        "expression": "(^[0]{1}$|^[-]?[1-9]{1}\\d*$)",
        "description": "This is a regular expression I used to validate negative and positive WHOLE numbers, including 0.",
        "matches": [
            "0",
            "123",
            "-123"
        ],
        "non_matches": [
            "001",
            "-012",
            "-002"
        ]
    },
    {
        "id": 644,
        "expression": "[:]{1}[-~+o]?[)&gt;]+",
        "description": "This ist the Expression for a happy smiley. It should find all the usual writings of the emotion icon :)",
        "matches": [
            ":)))))",
            ":+&gt;",
            ":o)"
        ],
        "non_matches": [
            ";o)",
            ":-("
        ]
    },
    {
        "id": 645,
        "expression": "^\\d?\\d'(\\d|1[01])&quot;$",
        "description": "Height notation for feet (') and inches(&quot;)",
        "matches": [
            "6'3&quot;",
            "5'11&quot;",
            "10'0&quot;"
        ],
        "non_matches": [
            "9 Feet 2 inches",
            "5'12&quot;",
            "5'2 1/2&quot;"
        ]
    },
    {
        "id": 647,
        "expression": "^-?\\d*(\\.\\d+)?$",
        "description": "Matches all positive &amp; negative decimal floating point numbers, to any magnitude. Allows empty string.",
        "matches": [
            "4.4",
            ".4",
            "-.4"
        ],
        "non_matches": [
            ".",
            "...",
            "zero"
        ]
    },
    {
        "id": 650,
        "expression": "^(ht|f)tp(s?)\\:\\/\\/[a-zA-Z0-9\\-\\._]+(\\.[a-zA-Z0-9\\-\\._]+){2,}(\\/?)([a-zA-Z0-9\\-\\.\\?\\,\\'\\/\\\\\\+&amp;%\\$#_]*)?$",
        "description": "Cheap and cheerful URL checker. Requires a http/https/ftp at the start and will then allow anything starting with at least a &lt;something&gt;.&lt;something&gt;.&lt;something&gt; then valid characters separated by dots and slashes",
        "matches": [
            "http://www.thedaddy.org",
            "http://forum.thedaddy.org/index.html",
            "ftp://hows.it.going_buddy/checkit/o"
        ],
        "non_matches": [
            "www.thedaddy.org",
            "http://hello",
            "ftp://check.it"
        ]
    },
    {
        "id": 651,
        "expression": ".+\\.([^.]+)$",
        "description": "Get any file extension...",
        "matches": [
            "foo.bar",
            "more.foo.bar"
        ],
        "non_matches": [
            ".",
            "bar"
        ]
    },
    {
        "id": 652,
        "expression": "^[0-9]*[1-9]+$|^[1-9]+[0-9]*$",
        "description": "This Expression checks if the value is an integer, positive, not zero and not a decimal.\nVery handy for use when people need to fill in whole numbers, like when ordering car parts on a website (you dont want your customers to order -10 tires or 0.7 mirrors..",
        "matches": [
            "1",
            "00000428123",
            "1230000"
        ],
        "non_matches": [
            "0",
            "00000000",
            "any text or +, - or any other character"
        ]
    },
    {
        "id": 653,
        "expression": "\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*([,;]\\s*\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*)*",
        "description": "Validates 1 or more email addresses. Email addresses can be delimited with either comma or semicolon. White space is allowed after delimiter, but not necessary. I needed this to allow my users to specify multiple email addresses if they choose to do so.",
        "matches": [
            "lewis@moten.com",
            "lewis@moten.com, me@lewismoten.com",
            "lewis@moten.com;me@lewismoten.com"
        ],
        "non_matches": [
            "lewis@@moten.com"
        ]
    },
    {
        "id": 654,
        "expression": "^(\\(?[0-9]{3}[\\)-\\.]?\\ ?)?[0-9]{3}[-\\.]?[0-9]{4}$",
        "description": "Simple US phone number matching, allowing area code or not. Allows spaces, dashes, dots, or none of the above. Area code, if entered, can be surrounded by parenthesis or not.",
        "matches": [
            "(555) 555-5555",
            "555.555.5555",
            "555-5555"
        ],
        "non_matches": [
            "(555)-555-5555"
        ]
    },
    {
        "id": 655,
        "expression": "^(\\-)?\\d*(\\.\\d+)?$",
        "description": "Matches all positive decimal floating negative/non-negative numbers. Allows empty string.",
        "matches": [
            "0.55",
            "21232.00",
            "-89.20"
        ],
        "non_matches": [
            "asdf",
            "+0.33"
        ]
    },
    {
        "id": 656,
        "expression": "^((?:.*(?!\\d))*(?:\\D*)?)(\\d+)$",
        "description": "Matches the number at the end of the string.",
        "matches": [
            "123",
            "aaa123",
            "aaa123aaa123"
        ],
        "non_matches": [
            "aaa",
            "aaa123aaa"
        ]
    },
    {
        "id": 657,
        "expression": "^(ht|f)tp((?<=http)s)?://((?<=http://)www|(?<=https://)www|(?<=ftp://)ftp)\\.(([a-z][0-9])|([0-9][a-z])|([a-z0-9][a-z0-9\\-]{1,2}[a-z0-9])|([a-z0-9][a-z0-9\\-](([a-z0-9\\-][a-z0-9])|([a-z0-9][a-z0-9\\-]))[a-z0-9\\-]*[a-z0-9]))\\.(co|me|org|ltd|plc|net|sch|ac|mod|nhs|police|gov)\\.uk(:\\d+)?\\/?$",
        "description": "UK http/https/ftp URI. Based on my previous expression, this one takes an optional port number and optional trailing slash.",
        "matches": [
            "http://www.zeropanic.co.uk/",
            "http://www.zeropanic.co.uk:81/",
            "http://www.zeropanic.co.uk:81"
        ],
        "non_matches": [
            "http://www.zeropanic.com:81/"
        ]
    },
    {
        "id": 660,
        "expression": "^([0-9a-fA-F]{1,2})(\\s[0-9a-fA-F]{1,2})*$",
        "description": "Expression validating a series of hex codes (byte values) separated by spaces.",
        "matches": [
            "1b 2e",
            "1B 70 00 90 F0"
        ],
        "non_matches": [
            "gh 4b",
            "1G 70 00 UU"
        ]
    },
    {
        "id": 662,
        "expression": "&lt;(?:[^&quot;']+?|.+?(?:&quot;|').*?(?:&quot;|')?.*?)*?&gt;",
        "description": "This will match all tags in a string, it's good for stripping HTML or XML tags to get the plain text.It works with attributes that include javascript or &quot;&lt;&gt;&quot;.\nIt will match all these\n&lt;hr size=&quot;3&quot;\nnoshade\ncolor=&quot;#000000&quot;\nalign=&quot;left&quot;&gt;\n&lt;p style=&quot;margin-top:0px;margin-bottom:0px&quot;\nalign=&quot;center&quot;&gt;&lt;font face=&quot;Times New Roman&quot;\nsize=&quot;5&quot;&gt;&lt;b&gt;UNITED STATES&lt;/b&gt;&lt;/font&gt;&lt;/p&gt;\n&lt;input type=button onclick='if(n.value&gt;5)do_this();'&gt; not this &lt;br&gt; &lt;input type=button onclick=&quot;n&gt;5?a():b();&quot; value=test&gt; not this &lt;br&gt; &lt;input type=button onclick=&quot;n&gt;5?a(\\&quot;OK\\&quot;):b('Not Ok');&quot; value=test&gt; not this &lt;br&gt; &lt;input type=button onclick='n&gt;5' value=test onmouseover=&quot;n&lt;5&amp;&amp;n&gt;8&quot; onmouseout='if(n&gt;5)alert(\\'True\\');else alert(&quot;False&quot;)'&gt; not this &lt;br&gt;",
        "matches": [
            "&lt;input type=button onclick='n&gt;5' value=test onmouseover=&quot;n&lt;5&amp;&amp;n&gt;8&quot; onm"
        ],
        "non_matches": [
            "haven't found any exceptions yet"
        ]
    },
    {
        "id": 665,
        "expression": "^[a-zA-Z]+(([\\'\\,\\.\\- ][a-zA-Z ])?[a-zA-Z]*)*\\s+&lt;(\\w[-._\\w]*\\w@\\w[-._\\w]*\\w\\.\\w{2,3})&gt;$|^(\\w[-._\\w]*\\w@\\w[-._\\w]*\\w\\.\\w{2,3})$",
        "description": "This Works good until we want a multiple email address validator, I am working on it to make it work with the multiple email address, If anyone can work on this part as to validate a multiple email address then that will produce a very good expression, i think the best of this kind. AIM - to Validate Mohit &lt;myadav@yahoo.com&gt;; Rohit &lt;ryadav@yahoo.com&gt;; .........(any number of times)",
        "matches": [
            "Mohit &lt;myadav@yahoo.com&gt;",
            "Xon &lt;JON@jon.com&gt;",
            "Xon@something.com"
        ],
        "non_matches": [
            "mohit&lt;myadav@yahoo.com&gt;",
            "Xon &lt;JON@jon.com&gt;, tom &lt;jon@jon.com&gt;",
            "Xon@somthing.com,"
        ]
    },
    {
        "id": 673,
        "expression": "^(smtp)\\.([\\w\\-]+)\\.[\\w\\-]{2,3}$",
        "description": "Matches basic SMTP server names.",
        "matches": [
            "smtp.yahoo.com",
            "smtp.charter.net"
        ],
        "non_matches": [
            "pop.yahoo.com"
        ]
    },
    {
        "id": 675,
        "expression": "(?=\\d)^(?:(?!(?:10\\D(?:0?[5-9]|1[0-4])\\D(?:1582))|(?:0?9\\D(?:0?[3-9]|1[0-3])\\D(?:1752)))((?:0?[13578]|1[02])|(?:0?[469]|11)(?!\\/31)(?!-31)(?!\\.31)|(?:0?2(?=.?(?:(?:29.(?!000[04]|(?:(?:1[^0-6]|[2468][^048]|[3579][^26])00))(?:(?:(?:\\d\\d)(?:[02468][048]|[13579][26])(?!\\x20BC))|(?:00(?:42|3[0369]|2[147]|1[258]|09)\\x20BC))))))|(?:0?2(?=.(?:(?:\\d\\D)|(?:[01]\\d)|(?:2[0-8])))))([-.\\/])(0?[1-9]|[12]\\d|3[01])\\2(?!0000)((?=(?:00(?:4[0-5]|[0-3]?\\d)\\x20BC)|(?:\\d{4}(?!\\x20BC)))\\d{4}(?:\\x20BC)?)(?:$|(?=\\x20\\d)\\x20))?((?:(?:0?[1-9]|1[012])(?::[0-5]\\d){0,2}(?:\\x20[aApP][mM]))|(?:[01]\\d|2[0-3])(?::[0-5]\\d){1,2})?$",
        "description": "mm/dd/yyyy hh:MM:ss Datetime for all AD years, including leap years.\nJavascript safe version of http://regexlib.com/REDetails.aspx?regexp_id=644. Please see that regex for details of what is being checked",
        "matches": [
            "11/24/0004 11:59 PM",
            "2.29.2008",
            "02:50:10"
        ],
        "non_matches": [
            "12/33/1020",
            "2/29/2005",
            "13:00 AM"
        ]
    },
    {
        "id": 676,
        "expression": "^(?=\\d)(?:(?!(?:(?:0?[5-9]|1[0-4])(?:\\.|-|\\/)10(?:\\.|-|\\/)(?:1582))|(?:(?:0?[3-9]|1[0-3])(?:\\.|-|\\/)0?9(?:\\.|-|\\/)(?:1752)))(31(?!(?:\\.|-|\\/)(?:0?[2469]|11))|30(?!(?:\\.|-|\\/)0?2)|(?:29(?:(?!(?:\\.|-|\\/)0?2(?:\\.|-|\\/))|(?=\\D0?2\\D(?:(?!000[04]|(?:(?:1[^0-6]|[2468][^048]|[3579][^26])00))(?:(?:(?:\\d\\d)(?:[02468][048]|[13579][26])(?!\\x20BC))|(?:00(?:42|3[0369]|2[147]|1[258]|09)\\x20BC))))))|2[0-8]|1\\d|0?[1-9])([-.\\/])(1[012]|(?:0?[1-9]))\\2((?=(?:00(?:4[0-5]|[0-3]?\\d)\\x20BC)|(?:\\d{4}(?:$|(?=\\x20\\d)\\x20)))\\d{4}(?:\\x20BC)?)(?:$|(?=\\x20\\d)\\x20))?((?:(?:0?[1-9]|1[012])(?::[0-5]\\d){0,2}(?:\\x20[aApP][mM]))|(?:[01]\\d|2[0-3])(?::[0-5]\\d){1,2})?$",
        "description": "dd/mm/yyyy hh:MM:ss Datetime for all AD years, including leap years.\nJavascript safe version of http://regexlib.com/REDetails.aspx?regexp_id=691. Please see that regex for details of what is being checked",
        "matches": [
            "31.12.6008",
            "5:30 AM",
            "30-04-1066"
        ],
        "non_matches": [
            "00/00/0000",
            "99:99:99",
            "29/02/2005"
        ]
    },
    {
        "id": 677,
        "expression": "^(?=\\d)(?:(?!(?:1582(?:\\.|-|\\/)10(?:\\.|-|\\/)(?:0?[5-9]|1[0-4]))|(?:1752(?:\\.|-|\\/)0?9(?:\\.|-|\\/)(?:0?[3-9]|1[0-3])))(?=(?:(?!000[04]|(?:(?:1[^0-6]|[2468][^048]|[3579][^26])00))(?:(?:\\d\\d)(?:[02468][048]|[13579][26]))\\D0?2\\D29)|(?:\\d{4}\\D(?!(?:0?[2469]|11)\\D31)(?!0?2(?:\\.|-|\\/)(?:29|30))))(\\d{4})([-\\/.])(0?\\d|1[012])\\2((?!00)[012]?\\d|3[01])(?:$|(?=\\x20\\d)\\x20))?((?:(?:0?[1-9]|1[012])(?::[0-5]\\d){0,2}(?:\\x20[aApP][mM]))|(?:[01]\\d|2[0-3])(?::[0-5]\\d){1,2})?$",
        "description": "yyyy/mm/dd hh:MM:ss Datetime for all AD years, including leap years.\nJavascript safe version of http://regexlib.com/REDetails.aspx?regexp_id=760. Please see that regex for details of what is being checked",
        "matches": [
            "0008-02-29",
            "2:34:59 PM",
            "9999/12/31 11:59 PM"
        ],
        "non_matches": [
            "04/04/04",
            "1:00",
            "1999/1/32"
        ]
    },
    {
        "id": 678,
        "expression": "^((\\d[-. ]?)?((\\(\\d{3}\\))|\\d{3}))?[-. ]?\\d{3}[-. ]?\\d{4}$",
        "description": "This is a pretty flexable phone number validator for US numbers. Allows optional country code and area code. Allows separation of numbers with &quot; &quot;, &quot;-&quot;, &quot;.&quot; or nothing to seperate. Area codes can be in parenthesis or not. Validates that you'll get 7, 10, or 11 digits in the way the most number of people option when writing them.",
        "matches": [
            "1(555)444-3333",
            "202.555.3333",
            "555-4444"
        ],
        "non_matches": [
            "555-222-33334",
            "1(303)5a4-5555",
            "1 202) 111-3333"
        ]
    },
    {
        "id": 679,
        "expression": "^((((H|h)(T|t)|(F|f))(T|t)(P|p)((S|s)?))\\://)?(www.|[a-zA-Z0-9].)[a-zA-Z0-9\\-\\.]+\\.[a-zA-Z]{2,6}(\\:[0-9]{1,5})*(/($|[a-zA-Z0-9\\.\\,\\;\\?\\'\\\\\\+&amp;%\\$#\\=~_\\-]+))*$",
        "description": "Matches URLS that start with numbers and any TLD that is 2 to 6 characters long. Matches most URLs. Thanks to eveyone for suggesting modifications!\nUPDATES::[Nov. 11, 2005] Now it matches uppercase and lower case protocols.\nUpdates::December 3, 2005 Added restriction to ports since they will only go up to 65535. (Thanks lorello)\nKeep the suggestions coming! Thanks for the heads up!!",
        "matches": [
            "hTtP://3iem.net/",
            "http://3iem.museum:1337/",
            "plik.co.uk"
        ],
        "non_matches": [
            "http://foobar",
            "lameurl.toolongtld"
        ]
    },
    {
        "id": 680,
        "expression": "^(((ht|f)tp(s?))\\://).*$",
        "description": "Identifies http, https, ftp, and ftps",
        "matches": [
            "http://3iem.net/",
            "https://foo.org",
            "ftps://jormahma.tk/"
        ],
        "non_matches": [
            "yahoo.com",
            "lame://protocol.us"
        ]
    },
    {
        "id": 684,
        "expression": "^(?=.*[0-9]+.*)(?=.*[a-zA-Z]+.*)[0-9a-zA-Z]{6,}$",
        "description": "Password must contain at least one letter, at least one number, and be longer than six charaters.",
        "matches": [
            "a1b2c3",
            "abcdefg123",
            "12345a"
        ],
        "non_matches": [
            "abcdefghij",
            "1234567890"
        ]
    },
    {
        "id": 688,
        "expression": "^(((((0?[1-9])|(1\\d)|(2[0-8]))\\.((0?[1-9])|(1[0-2])))|((31\\.((0[13578])|(1[02])))|((29|30)\\.((0?[1,3-9])|(1[0-2])))))\\.((20[0-9][0-9]))|(29\\.0?2\\.20(([02468][048])|([13579][26]))))$",
        "description": "Regular expression to evaluate a date in German date format (DD.MM.YYYY). Leading zeros for days and months are valid. Period from 1.1.2000 until 31.12.2099 is valid. Leap years are checked.",
        "matches": [
            "1.1.2000",
            "29.02.2004",
            "31.12.2099"
        ],
        "non_matches": [
            "1.1.1999",
            "29.02.2003",
            "01.01.2100"
        ]
    },
    {
        "id": 689,
        "expression": "(\\/\\*(\\s*|.*?)*\\*\\/)|(\\/\\/.*)",
        "description": "This regexp is used to match c++,java,etc style multi-line and single line comments.",
        "matches": [
            "/* This is a multi-line comment */",
            "// this is a single-line"
        ],
        "non_matches": [
            "/sometext",
            "/*/"
        ]
    },
    {
        "id": 693,
        "expression": "\\.txt$",
        "description": "Matches a file extention.",
        "matches": [
            "testfile.txt",
            ".txt",
            "this is a file.txt"
        ],
        "non_matches": [
            "this is not a file.trt",
            ".tst",
            ".text"
        ]
    },
    {
        "id": 697,
        "expression": "((DK|FI|HU|LU|MT|SI)(-)?\\d{8})|((BE|EE|DE|EL|LT|PT)(-)?\\d{9})|((PL|SK)(-)?\\d{10})|((IT|LV)(-)?\\d{11})|((LT|SE)(-)?\\d{12})|(AT(-)?U\\d{8})|(CY(-)?\\d{8}[A-Z])|(CZ(-)?\\d{8,10})|(FR(-)?[\\dA-HJ-NP-Z]{2}\\d{9})|(IE(-)?\\d[A-Z\\d]\\d{5}[A-Z])|(NL(-)?\\d{9}B\\d{2})|(ES(-)?[A-Z\\d]\\d{7}[A-Z\\d])",
        "description": "Matches valid VAT identification number for all current EU's member states, in format CC-xxx or CCxxx (where CC is country code and xxx actual VAT number).",
        "matches": [
            "CZ-7907111883",
            "ESA12345678",
            "FRAB123456789"
        ],
        "non_matches": [
            "CZ55912",
            "XY123456",
            "FR-IB123456789"
        ]
    },
    {
        "id": 702,
        "expression": "^((CN=['\\w\\d\\s\\-\\&amp;]+,)+(OU=['\\w\\d\\s\\-\\&amp;]+,)*(DC=['\\w\\d\\s\\-\\&amp;]+[,]*){2,})$",
        "description": "Matches the LDAP path of Microsoft Active Directory entry. Checks to ensure the ADsPath attribute is accurate.",
        "matches": [
            "CN=Joey O'Brenn,OU=Test &amp; 1,OU=Test &amp; 2,DC=support,DC=com"
        ],
        "non_matches": [
            "CN=Laurie Brenn,CN=Users,DC=support"
        ]
    },
    {
        "id": 703,
        "expression": "^(((2|8|9)\\d{2})|((02|08|09)\\d{2})|([1-9]\\d{3}))$",
        "description": "Matched Australian Postcodes, as defined by AusPost.\nMany Australian developers are unaware of the small range of 3 digit, or 0 starting postcodes.\n220 and 221 (or 0220 and 0221) are for ANU and LVR.\n800s and 900s (or 0800s and 0900s) are for NT, and parts of SA, WA.\n1000s are for big companies in Sydney, competition mailings, etc.",
        "matches": [
            "200",
            "0820",
            "2753"
        ],
        "non_matches": [
            "700",
            "0700",
            "abcd"
        ]
    },
    {
        "id": 704,
        "expression": "^(19[0-9]{2}|[2-9][0-9]{3})-((0(1|3|5|7|8)|10|12)-(0[1-9]|1[0-9]|2[0-9]|3[0-1])|(0(4|6|9)|11)-(0[1-9]|1[0-9]|2[0-9]|30)|(02)-(0[1-9]|1[0-9]|2[0-9]))\\x20(0[0-9]|1[0-9]|2[0-3])(:[0-5][0-9]){2}$",
        "description": "Checks for the format yyyy-MM-dd HH:mm:ss\nalso known as SortableDateTimePattern (conforms to ISO 8601) using local time. From 1900-01-01 00:00:00 to 9999-12-31 23:59:59. No check for leap year.",
        "matches": [
            "2004-07-12 14:25:59",
            "1900-01-01 00:00:00",
            "9999-12-31 23:59:59"
        ],
        "non_matches": [
            "04-07-12 14:25:59",
            "20004-07-12 14:25",
            "2004/07/12 14:25:59"
        ]
    },
    {
        "id": 705,
        "expression": "^(a-z|A-Z|0-9)*[^#$%^&*()']*$",
        "description": "Does not allow these characters in a string #$%^&amp;*()'",
        "matches": [
            "Test",
            "Whatever Text",
            "D://folder/file.ext"
        ],
        "non_matches": [
            "word's",
            "test#",
            "(something)"
        ]
    },
    {
        "id": 706,
        "expression": "^((?:[a-zA-Z]:)|(?:\\\\{2}\\w[-\\w]*)\\$?)\\\\(?!\\.)((?:(?![\\\\/:*?<>\"|])(?![.\\x20](?:\\\\|$))[\\x20-\\x7E])+\\\\(?!\\.))*((?:(?:(?![\\\\/:*?<>\"|])(?![ .]$)[\\x20-\\x7E])+)\\.((?:(?![\\\\/:*?<>\"|])(?![ .]$)[\\x20-\\x7E]){2,15}))?$",
        "description": "Matches drives, folders and file on a Windows OS. Folder matches must end with \\\nFolder and file names can not end with a space.\nI limited the file extension length to 15 though that not a restriction of a file's extension\nThis is a mod of Darren's regex http://www.regexlib.com/REDetails.aspx?regexp_id=357\nand my own http://www.regexlib.com/REDetails.aspx?regexp_id=137\nUpdated Feb 2005",
        "matches": [
            "C:\\",
            "\\\\Server\\share\\path\\File.txt",
            "E:\\My Files\\Are\\#1\\"
        ],
        "non_matches": [
            "C:",
            "C:\\\\\\",
            "C:\\Trailing Space \\"
        ]
    },
    {
        "id": 708,
        "expression": "(^\\d{1,5}$|^\\d{1,5}\\.\\d{1,2}$)",
        "description": "This expression evaluates simple currency values... alteast 1 digit and max 5 digits and if period then atleast one digit after period and max two digits after period",
        "matches": [
            "0",
            "00000",
            "00.00"
        ],
        "non_matches": [
            "asds",
            "000000",
            "00000."
        ]
    },
    {
        "id": 709,
        "expression": "^(\\$)?(\\s)?(\\-)?((\\d+)|(\\d{1,3})(\\,\\d{3})*)(\\.\\d{2,})?$",
        "description": "Allows either inclusion of $ symbol or not. Allows a whitespace character after the $ sysmbol or not. Allows a negative symbol in front of the starting digit or not. Allows comma separators at thousands, but nowhere else. Allows more than two decimal places.",
        "matches": [
            "$1,000.00",
            "$-1,000.00",
            "100.8766"
        ],
        "non_matches": [
            "$1a",
            "$#100.00",
            "1,00.00"
        ]
    },
    {
        "id": 711,
        "expression": "^[\\w0-9&#228;&#196;&#246;&#214;&#252;&#220;&#223;\\-_]+\\.[a-zA-Z0-9]{2,6}$",
        "description": "This RegEx can be used to varify (esp. when receiving data from forms) filenames. No Path is allowed. German Special Characters are allowed.",
        "matches": [
            "gut.txt"
        ],
        "non_matches": [
            "&amp;quatsch",
            "qua%tsch.txt",
            "auch_quatsch.test.txt"
        ]
    },
    {
        "id": 712,
        "expression": "^((ht|f)tp(s?))\\://([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]{2,6}(\\:[0-9]+)?(/\\S*)?$",
        "description": "Simple URL Validator -- allows http, https, ftp, ftps, 2-6 letter TLD, ports, any path. Sorry, no IP addresses. Not too fussy, but then, it's not too long either ;-)",
        "matches": [
            "http://www.site.com",
            "https://www.secure.com:10000",
            "ftp://ftp.site.com/pub/files/"
        ],
        "non_matches": [
            "www.site.com",
            "https://www.site.longtld",
            "ftp:/badformat.com"
        ]
    },
    {
        "id": 714,
        "expression": "^(?:(?:0?[13578]|1[02])|(?:0?[469]|11)(?!\\/31)|(?:0?2)(?:(?!\\/3[01]|\\/29\\/(?:(?:0[^48]|[13579][^26]|[2468][^048])00|(?:\\d{2}(?:0[^48]|[13579][^26]|[2468][^048]))))))\\/(?:0?[1-9]|[12][0-9]|3[01])\\/\\d{4}$",
        "description": "will match all dates in mm/dd/yyyy format. takes into account leap-years and months without 31 days.",
        "matches": [
            "2/29/2004",
            "07/16/1492",
            "12/31/1999"
        ],
        "non_matches": [
            "2/29/2003",
            "2/29/2100",
            "11/31/2003"
        ]
    },
    {
        "id": 715,
        "expression": "^\\s*-?((\\d{1,3}(\\.(\\d){3})*)|\\d*)(,\\d{1,2})?\\s?(\\u20AC)?\\s*$",
        "description": "Matches euro currency (portuguese regional options).\nUses the dot sign as the thousands separator (optional) and the comma sign as the decimal separator.\nMatches only 2 digitals after decimal.\nAlso matches negative numbers.",
        "matches": [
            "-123123,12 \u20ac",
            "12312432134",
            "-12.234.123,23"
        ],
        "non_matches": [
            "1234.12,234"
        ]
    },
    {
        "id": 722,
        "expression": "((ht|f)tp(s?))(:((\\/\\/)(?!\\/)))(((w){3}\\.)?)([a-zA-Z0-9\\-_]+(\\.(com|edu|gov|int|mil|net|org|biz|info|name|pro|museum|co\\.uk)))(\\/(?!\\/))(([a-zA-Z0-9\\-_\\/]*)?)([a-zA-Z0-9])+\\.((jpg|jpeg|gif|png)(?!(\\w|\\W)))",
        "description": "This expression matches valid image URLs. The main use for this would be in UBBC tags.\nWritten by RyanJ and Jick for FWD (http://flexwebdev.thenamesdan.com/)",
        "matches": [
            "http://www.location.com/images/image1.gif",
            "http://www.location.com/images/mainImgs/image1.png"
        ],
        "non_matches": [
            "/images/image1.jpeg",
            "http://www.location.com/images/image1.swf",
            "http://www.something.com/hello/..j"
        ]
    },
    {
        "id": 724,
        "expression": "^[a-zA-Z_]{1}[a-zA-Z0-9_@$#]*$",
        "description": "This Regex matches valid SQL identifiers, including names for Stored Procedures and the like. Note that local variables/parameters (which begin with an &quot;@&quot;) will not match this Regex, nor will temporary objects (beginning with a &quot;#&quot;), or global temporary objects (beginning with &quot;##&quot;). All other valid identifiers/variables/table names/stored procedure names/columns etc., will match. Please let me know if you find this useful or have any complaints - trash@primalblaze.com.",
        "matches": [
            "upApplicationReadContacts",
            "_Application_ReadContacts",
            "a_45$#z"
        ],
        "non_matches": [
            "upApplication ReadContacts",
            "$Application_ReadContacts",
            "a_45%$#z"
        ]
    },
    {
        "id": 725,
        "expression": "(?=([\\W]*[\\w][\\W]*\\b))\\s(?=\\d\\.|\\d\\b)",
        "description": "This RegExp matches a space (&quot; &quot;) character with lookahead condition if there is an ASCII text in front of it and it is followed by a single decimal number which in turn is followed by a dot or nothing. It's useful to seperate scientific notation numbers from a text, i.e. when classifying with the bow toolkit.\n[EDIT 18.09.2004] There was indeed an error in the second lookahead. Changed |\\b to |\\d\\b",
        "matches": [
            "ROOT 4.873624764e-34",
            "`1234567 890-= 3.8765e-34543",
            "~! @ # $ % ^ &amp; ( % )_+ 3.345e-2384754"
        ],
        "non_matches": [
            "rstuvwxyz 754.234e-23",
            "yz754.234e-23",
            "yz .234e-23"
        ]
    },
    {
        "id": 727,
        "expression": "^\\.{1}",
        "description": "simply checks to see if the first charactor is a . (dot)",
        "matches": [
            ".net",
            ".blah",
            ".anything"
        ],
        "non_matches": [
            "net",
            "net.stuff",
            "netstuff."
        ]
    },
    {
        "id": 729,
        "expression": "^\\d?\\d'(\\d|1[01])?.?(\\d|1[01])&quot;$",
        "description": "This RE matches the height in feet and inches with decimals and without decimals in it",
        "matches": [
            "5'5.5&quot;",
            "2'3&quot;",
            "9'10.4&quot;"
        ],
        "non_matches": [
            "5 feet 5.5 inches"
        ]
    },
    {
        "id": 730,
        "expression": "^[A-Za-z]{4}[ |\\-]{0,1}[0-9]{6}[ |\\-]{0,1}[0-9A-Za-z]{3}$",
        "description": "Regular expression that matches Mexican RFC's (Registro Federal de Contribuyentes).",
        "matches": [
            "LOZG7802117B9",
            "LOZG-780211-7B9",
            "LOZG780211-7B9"
        ],
        "non_matches": [
            "LO-ZG-78-02-11-7B9"
        ]
    },
    {
        "id": 731,
        "expression": "^([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4}$",
        "description": "IPv6 text representation of addresses without compression from RFC 1884. This regular expression doesn't allow IPv6 compression (&quot;::&quot;) or mixed IPv4 addresses.",
        "matches": [
            "FEDC:BA98:7654:3210:FEDC:BA98:7654:3210",
            "1080:0:0:0:8:800:200C:417A",
            "0:0:0:0:0:0:0:1"
        ],
        "non_matches": [
            "128.0.0.1",
            "FEDC:BA98:7654:3210:FEDC:BA98:7654:3210:AA31",
            "::1"
        ]
    },
    {
        "id": 732,
        "expression": "^([GB])*(([1-9]\\d{8})|([1-9]\\d{11}))$",
        "description": "Simple check of valid UK VAT Registration numbers. The standard format for UK VAT number must be 9 characters long or 12 characters if a branch trader. The GB prefix has been included as optional, but technically you should include it. The UK VAT format also includes Government Departments and Health Authorities, but I have excluded them for the moment.",
        "matches": [
            "123456789",
            "GB123456789",
            "GB123456789123"
        ],
        "non_matches": [
            "dfddf",
            "3443443",
            "34 34 3344"
        ]
    },
    {
        "id": 734,
        "expression": "^[^0-9]*(?:(\\d)[^0-9]*){10}$",
        "description": "Recently I've been forced to validate phone numbers in a variety of formats, with all sorts of whitespace, dashes, parenthesis, etc. I didn't want to hassel with matching all that junk, I just wanted the 10 numbers!\nSo I wrote this expression which captures 10 digits in a string if there are exactly 10 digits. Anything else is allowed so long as there are 10 numbers.\nIn .Net, You just loop through the Captures collection of Groups[1] of your Regex.Match object and concatenate the Capture.Value strings to get a simple, pure 10 digit phone number. ( myMatch.Groups[1].Captures )",
        "matches": [
            "1234567890",
            "585-737-8899",
            "(324)blah225-foo2587"
        ],
        "non_matches": [
            "1234567",
            "12345678901"
        ]
    },
    {
        "id": 735,
        "expression": "^[0-9]*$",
        "description": "Matches only numbers, in any length. No characters or punctuation will be matched.",
        "matches": [
            "2",
            "99",
            "15800"
        ],
        "non_matches": [
            "1,2",
            "f9",
            "a9j"
        ]
    },
    {
        "id": 736,
        "expression": "^(((((0[1-9])|(1\\d)|(2[0-8]))[/.-]((0[1-9])|(1[0-2])))|((31[/.-]((0[13578])|(1[02])))|((29|30)[/.-]((0[1,3-9])|(1[0-2])))))[/.-]((000[^0])&amp;([0-9][0-9][0-9][0-9]))|(29[/.-]02[/.-](([0-9][0-9](([02468][48])|([2468][048])|([13579][26])))|((([02468][48])|([2468][048])|([13579][26]))00))))$",
        "description": "Checks 0001-9999\nAlong with leap years\nintermediate symbols can be / or . or -\nthis can be modified easily",
        "matches": [
            "29-02/0004",
            "29/02/0004",
            "29.02.9996"
        ],
        "non_matches": [
            "29-2-0004",
            "29/02/0005",
            "29.02.0000"
        ]
    },
    {
        "id": 738,
        "expression": "^\\d{5}(-\\d{4})?$",
        "description": "Zip+4 Zipcode RegEx. You may ommit the +4 digits but you must also then ommit the hyphen/dash as well. In 1983, the Postal Service\u2122 began using an expanded ZIP Code\u2122 number called called the &quot;ZIP+4&#174;&quot; Code. The nine digits of a ZIP+4 code (e.g., 12345-6789) is broken down as follows: [123]Sectional Center or Large City. [45]Post Office\u2122 facility or Delivery Area. [-]Required &quot;dash&quot; or &quot;hyphen&quot;. [67]Sector or Several Blocks. [89]Segment or One Side of a Street. Also just FYI, ZIP codes in the northeast US frequently start with '0' or '00'. [00988-Carolina, PR] [03110-Bedford, NH]. Thanks, Ryan v-",
        "matches": [
            "98121",
            "00988",
            "12345-6789"
        ],
        "non_matches": [
            "98121-",
            "12345-678",
            "1234"
        ]
    },
    {
        "id": 739,
        "expression": "^[1-9][0-9]{0,2}$",
        "description": "All positive non-zero integers between 1 and 999. You can adjust the upper range of this expression by changing the second number (ie 2) in the {0,2} part of the expression.",
        "matches": [
            "1",
            "561",
            "999"
        ],
        "non_matches": [
            "-1",
            "0",
            "1000"
        ]
    },
    {
        "id": 741,
        "expression": "^([A-Z]|[a-z]|[0-9])(([A-Z])*(([a-z])*([0-9])*(%)*(&)*(')*(\\+)*(-)*(@)*(_)*(\\.)*)|(\\ )[^ ])+$",
        "description": "will match as long as the only chars exist in the string : A-Z,a-z,0-9,'Space' chr(32),%&amp;'+-@_.\nIt's useful for check vs Account Names where you might want to forbid entering other chars then what is in the pattern. also will not allow repeated space in the string",
        "matches": [
            "AccountName_123",
            "Account@email.com",
            "James & Dana Inc."
        ],
        "non_matches": [
            "!MYACCOUNT!",
            "{Superman}",
            "$ Money Man $"
        ]
    },
    {
        "id": 742,
        "expression": "(((0[1-9]|[12][0-9]|3[01])([.])(0[13578]|10|12)([.])([1-2][0,9][0-9][0-9]))|(([0][1-9]|[12][0-9]|30)([.])(0[469]|11)([.])([1-2][0,9][0-9][0-9]))|((0[1-9]|1[0-9]|2[0-8])([.])(02)([.])([1-2][0,9][0-9][0-9]))|((29)(\\.|-|\\/)(02)([.])([02468][048]00))|((29)([.])(02)([.])([13579][26]00))|((29)([.])(02)([.])([0-9][0-9][0][48]))|((29)([.])(02)([.])([0-9][0-9][2468][048]))|((29)([.])(02)([.])([0-9][0-9][13579][26])))",
        "description": "Usefull for SQL update and insert sentence..",
        "matches": [
            "01.01.2004",
            "30.12.2005"
        ],
        "non_matches": [
            "01/01/2004",
            "1.1.2004",
            "01-01-2004"
        ]
    },
    {
        "id": 743,
        "expression": "^[A-Za-z]{3,4}[ |\\-]{0,1}[0-9]{6}[ |\\-]{0,1}[0-9A-Za-z]{3}$",
        "description": "This Regex matches Mexican RFC's (Registro Federal de Contribuyentes) with 3 or 4 letters in the first section. It accepts spaces and dashes between sections.",
        "matches": [
            "LOZG7502123T7",
            "LOZG-750212-3T7",
            "LOZ 750212 3T7"
        ],
        "non_matches": [
            "LOZG750212"
        ]
    },
    {
        "id": 744,
        "expression": "^([A-Z]|[a-z]|[0-9])([A-Z]|[a-z]|[0-9]|([A-Z]|[a-z]|[0-9]|(%|&|'|\\+|\\-|@|_|\\.|\\ )[^%&'\\+\\-@_\\.\\ ]|\\.$|([%&'\\+\\-@_\\.]\\ [^\\ ]|\\ [%&'\\+\\-@_\\.][^%&'\\+\\-@_\\.])))+$",
        "description": "This works good for account names where u don't want your users to create ugly account names. 3 rules apllied in it:\n1. an account name must start with Letter or Number\n2. the only valid signs are : ^%&amp;'+-@. and (space (chr32))\n3. a sign can't be repeated by any sign execept space which can't be repeated as well.",
        "matches": [
            "AccountName_123",
            "ABC & DEF Inc.",
            "me@myemail.com"
        ],
        "non_matches": [
            "-=superman=-",
            "$$ Money Man $$",
            "Lord -- Foo"
        ]
    },
    {
        "id": 746,
        "expression": "^((\\d(\\x20)\\d{2}(\\x20)\\d{2}(\\x20)\\d{2}(\\x20)\\d{3}(\\x20)\\d{3}((\\x20)\\d{2}|))|(\\d\\d{2}\\d{2}\\d{2}\\d{3}\\d{3}(\\d{2}|)))$",
        "description": "It is an expression to valide a french num&#233;ro de s&#233;curit&#233; social (social security number translate is not sure) with or without the key.",
        "matches": [
            "181049520156962",
            "1 81 04 95 201 569 62",
            "1 81 04 95 201 569"
        ],
        "non_matches": [
            "1 81049520156962",
            "181049520156962fds",
            "1810495201569ds"
        ]
    },
    {
        "id": 747,
        "expression": "^([-]?[0-9])$|^([-]?[1][0-2])$",
        "description": "I made this to validate offsets to GMT",
        "matches": [
            "1",
            "-10",
            "10"
        ],
        "non_matches": [
            "13",
            "-25",
            "111"
        ]
    },
    {
        "id": 748,
        "expression": "^([-]?[0-9]?(\\.[0-9]{0,2})?)$|^([-]?([1][0-1])(\\.[0-9]{0,2})?)$|^([-]?([1][0-3](\\.[0]{0,2})))$",
        "description": "This was made for specifying GMT offsets with 2 decimal places. It will validate any number from -12 to 13 with 2 decimal places.",
        "matches": [
            "5",
            "-11.99",
            "12.00"
        ],
        "non_matches": [
            "13",
            "-11.999",
            "12.01"
        ]
    },
    {
        "id": 749,
        "expression": "^([01][012]|0[1-9])/([0-2][0-9]|[3][0-1])/([0-9][0-9][0-9][0-9])$",
        "description": "Regular expression that only allows expression in the format: MM/DD/YYYY",
        "matches": [
            "01/01/2004"
        ],
        "non_matches": [
            "1/1/04",
            "01/01/04",
            "03/32/2004"
        ]
    },
    {
        "id": 750,
        "expression": "&lt;!--((?!--&gt;).)*--&gt;",
        "description": "Strip (X)HTML comments",
        "matches": [
            "&lt;!-- any comments --&gt;"
        ],
        "non_matches": [
            "&lt;!- - 111 --&gt;"
        ]
    },
    {
        "id": 751,
        "expression": "\\/\\*((?!\\*\\/).)*\\*\\/",
        "description": "Strip C style block comments",
        "matches": [
            "/* comments */",
            "/*\\n*\\n*/",
            "/***********/"
        ],
        "non_matches": [
            "// comments"
        ]
    },
    {
        "id": 753,
        "expression": "(^[1]$)|(^[1]+\\d*\\.+\\d*[1-5]$)",
        "description": "Simple expression that accepts only values between 1 and 1.5",
        "matches": [
            "1",
            "1.4",
            "1.5"
        ],
        "non_matches": [
            "2",
            "1.ZZ",
            "1.6"
        ]
    },
    {
        "id": 754,
        "expression": "^(((0?[1-9]|[12]\\d|3[01])\\.(0[13578]|[13578]|1[02])\\.((1[6-9]|[2-9]\\d)\\d{2}))|((0?[1-9]|[12]\\d|30)\\.(0[13456789]|[13456789]|1[012])\\.((1[6-9]|[2-9]\\d)\\d{2}))|((0?[1-9]|1\\d|2[0-8])\\.0?2\\.((1[6-9]|[2-9]\\d)\\d{2}))|(29\\.0?2\\.((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))))$",
        "description": "I did not found a Regex for german date, so I created my own. This RE validate dates in the dd.MM.yyyy format with leap years 100% integrated valid years from 1600 to 9999. As usual, many tests have been made. I think this one should be fine.",
        "matches": [
            "1.1.2004",
            "01.01.2004",
            "29.2.2004"
        ],
        "non_matches": [
            "1/1/2004",
            "1-1-2004"
        ]
    },
    {
        "id": 755,
        "expression": "((\\d|([a-f]|[A-F])){2}:){5}(\\d|([a-f]|[A-F])){2}",
        "description": "Deisgned to verify a MAC address with hex values seperated by a colon.",
        "matches": [
            "00:00:39:F9:3C:59",
            "00:90:83:6A:B3:B7",
            "00:00:39:59:30:5C"
        ],
        "non_matches": [
            "00:0H:39:59:30:5C",
            "00:39:59:30:5C",
            "00:39:59:30:5C:BZ"
        ]
    },
    {
        "id": 756,
        "expression": "\\b-?[1-9](?:\\.\\d+)?[Ee][-+]?\\d+\\b",
        "description": "Matches standard scientific notation using E character\nScientific notation involves writing a number as the product of two numbers. The first one, the digit value, is always more than one and less than 10. The other, the exponential term, is expressed as a power of 10.",
        "matches": [
            "3.7E-11",
            "-2.384E-03",
            "9.4608e15"
        ],
        "non_matches": [
            "3.7 X 10-11",
            "-23.84E-02",
            "9.4608 x 1015"
        ]
    },
    {
        "id": 757,
        "expression": "^(?:(?:((?![0-9_])[a-zA-Z0-9_]+)\\.?)+)(?<!\\.)$",
        "description": "Matches that an input string is a valid namespace definition. It also captures each word / section in the namespace in case they are needed.\nThe rules this was created by are: 1)A series of words separated by a periods 2)does not begin or end with a period, 3)contains only letters numbers and underscores, 4) none of the words begin with a number, and 5) contains no whitespace",
        "matches": [
            "Lang.Toolkit.Configuration",
            "word_1.wo_rd2.word3.LastWord",
            "word_1.wo_rd2.wor3d"
        ],
        "non_matches": [
            "Lang.1App",
            "word_1.2wo_rd",
            "part1.2part"
        ]
    },
    {
        "id": 758,
        "expression": "&lt;!--[\\w\\W]*?--&gt;",
        "description": "This expression will find sigle or multilined HTML comments.",
        "matches": [
            "&lt;!-- comment --&gt;",
            "&lt;!-- &lt;some tag&gt; --&gt;"
        ],
        "non_matches": [
            "&lt;!- - comment --&gt;",
            "&lt;!-- ccccc"
        ]
    },
    {
        "id": 759,
        "expression": "([0]{1}[6]{1}[-\\s]*([1-9]{1}[\\s]*){8})|([0]{1}[1-9]{1}[0-9]{1}[0-9]{1}[-\\s]*([1-9]{1}[\\s]*){6})|([0]{1}[1-9]{1}[0-9]{1}[-\\s]*([1-9]{1}[\\s]*){7})",
        "description": "Matches dutch telephone numbers WITHOUT country code prefix\nTests on mobile numbers, 3 digits prefix city-codes and 4 digit prefix city codes.\n* Disallows a 0 directly after a prefix\n* Allows space or a - between prefix and telephonenumber\n* Also allows space between telephone digits to compensate the nasty habit of making telphone numbers more readable",
        "matches": [
            "06 539 439 99",
            "023-123 1233",
            "023 121 12 12"
        ],
        "non_matches": [
            "06-539-439-99",
            "05-75 46 30 50"
        ]
    },
    {
        "id": 760,
        "expression": "^(?!0,?\\d)([0-9]{2}[0-9]{0,}(\\.[0-9]{2}))$",
        "description": "Validates currency, must have two leading and two digits following a decimal point. Does not accept leading zero's.",
        "matches": [
            "10.00",
            "32.50"
        ],
        "non_matches": [
            "01.00",
            "12",
            "12.0"
        ]
    },
    {
        "id": 766,
        "expression": "^\\(0[1-9]{1}\\)[0-9]{8}$",
        "description": "This is used to validate an Australian telephone number with no other characters than the () being used. Validates area code being between 01 - 09.",
        "matches": [
            "(02)12341234",
            "(03)12341234",
            "(05)12341234"
        ],
        "non_matches": [
            "00 1234 1234",
            "00-1234-1234",
            "(00)12341234"
        ]
    },
    {
        "id": 767,
        "expression": "^[a-zA-Z]:(\\\\|(\\\\[^\\\\/\\s:*\"<>|]+)+)>",
        "description": "This pattern matches the windows console (cmd) prompt (also know as command prompt)",
        "matches": [
            "x:\\dir>",
            "x:\\dir\\another.dir>",
            "x:\\>"
        ],
        "non_matches": [
            "x:\\dir\\>",
            "x:\\dir",
            "\\dir"
        ]
    },
    {
        "id": 768,
        "expression": "[URL=[a-zA-Z0-9.:/_\\-]+\\][a-zA-Z0-9._/ ]+\\[/URL\\]",
        "description": "A simple match for BBCode type strings. I had to code my own BBCode scheme for a project that I had taken up and really this is my first RegEx so I thought that I would share. You could modify this to work with any BBCode type of string that has the [TAG=VALUE]Desc[/TAG] syntax.",
        "matches": [
            "[URL=http://www.luvs.org]Luvs.org[/URL]"
        ],
        "non_matches": [
            "http://www.luvs.org"
        ]
    },
    {
        "id": 772,
        "expression": "^((\\s|[0])\\.(\\d{0,2}\\s{0,2}))?$|^(\\.(\\d\\s){0,2})?$|^(\\s{0,4}[1]{0,1}\\.[0]{0,2}\\s{0,4})?$|^(\\s{0,4}[1]{0,1}\\s{0,4})?$|^(\\s{0,4}[0]{0,4}[1]{0,1}\\s{0,4})?$|^([0]{0,4}\\s{0,4})?$|^(\\s{0,3}[0]{0,3}\\.{1}\\d{0,2}\\s{0,2})?$",
        "description": "For a maximum of 4 characters All values between 0.00 and 1.00. Allows Spaces / zeros prefixed / suffixed. Allows entering just the integer part or the decimal part as well.\nAllows 1.0, 1.00, 1, 1., .9, .90, 0.90.",
        "matches": [
            ".99",
            "1.",
            "0.99"
        ],
        "non_matches": [
            "10",
            "0100",
            "1.01"
        ]
    },
    {
        "id": 775,
        "expression": "^[a-zA-Z][a-zA-Z0-9_]+$",
        "description": "Validate that the string contains only alphanumeric characters or an underscore. The first character cannot be anything else than alphabetic character.\nWe use that to make sure the provided string can be a variable/entity name.",
        "matches": [
            "MyVariable",
            "intWhatever",
            "Blah_Blah"
        ],
        "non_matches": [
            "1stVariable",
            "654",
            "_asdasd_234"
        ]
    },
    {
        "id": 778,
        "expression": "((([7-9])(\\d{3})([-])(\\d{4}))|(([7-9])(\\d{7})))",
        "description": "Express&#227;o para a Valida&#231;&#227;o de Telefones Celulares sem o DDD valida celulares com inicio igual a 7,8 e 9.",
        "matches": [
            "9999-9595",
            "88888787",
            "7777-6589"
        ],
        "non_matches": [
            "44445555",
            "2222-9658",
            "22223658"
        ]
    },
    {
        "id": 782,
        "expression": "^([0-9a-fA-F])*$",
        "description": "Expression validating a hex string of any length.",
        "matches": [
            "1E3",
            "82E5AAA4",
            "01ff"
        ],
        "non_matches": [
            "1g3",
            "4Z",
            "01x"
        ]
    },
    {
        "id": 783,
        "expression": "(?=^.{6,255}$)((?=.*\\d)(?=.*[A-Z])(?=.*[a-z])|(?=.*\\d)(?=.*[^A-Za-z0-9])(?=.*[a-z])|(?=.*[^A-Za-z0-9])(?=.*[A-Z])(?=.*[a-z])|(?=.*\\d)(?=.*[A-Z])(?=.*[^A-Za-z0-9]))^.*",
        "description": "THE Complex Password Filter Matching 3 of 4 Character catagories:\n1.) at least 1 upper case character\n2.) at least 1 lower case character\n3.) at least 1 numerical character\n4.) at least 1 special character\nIt also enforces a min and max length and works for .Net and script Regex implimentations.",
        "matches": [
            "Passw0rd",
            "assW@rd",
            "1B2a345@#$%"
        ],
        "non_matches": [
            "123123123",
            "Password",
            "asdf&amp;"
        ]
    },
    {
        "id": 787,
        "expression": "^[9]9\\d{10}|^[5]\\d{10}",
        "description": "This will make sure that if your number starts w. a 99 it will have 10 more digits after it and if it starts w. a 5 it will also have 10 digits after that. So if you have a number starting with 99 it must be 12 digits long if it starts with a 5 it must be 11.",
        "matches": [
            "991234567890",
            "51234567890"
        ],
        "non_matches": [
            "99123456789",
            "91234567890"
        ]
    },
    {
        "id": 788,
        "expression": "\\b((([&quot;'/,&amp;%\\:\\(\\)\\$\\+\\-\\*\\w\\000-\\032])|(-*\\d+\\.\\d+[%]*))+[\\s]+)+\\b[\\w&quot;',%\\(\\)]+[.!?](['&quot;\\s]|$)",
        "description": "Focused on scraping English sentences from HTML/Java (without having to parse).\nCorrectly matches the vast majority of English sentences. There are undoubtedly a number of cases which do not match, but I felt they were oblique enough to be omitted.\n(Surely, the fellow that commented on this script had some sentences not match, but the example he describes does correctly match, and I provide it as the fourth example.)\nCheers",
        "matches": [
            "This is an example.",
            "&quot;Matching sentence.&quot;",
            "A 9.7% increase over the last 10+ years.",
            "The vehicle has a 5.2 liter, four-wheel drive engine."
        ],
        "non_matches": [
            "Class.Function"
        ]
    },
    {
        "id": 790,
        "expression": "^([\\w-]+\\.)*?[\\w-]+@[\\w-]+\\.([\\w-]+\\.)*?[\\w]+$",
        "description": "The following pattern checks whether the input string is a valid email address in the form &quot;name@domain.com&quot;. Actually, it does not have to be a &quot;.com&quot; address. Any combination of letters following the last period are fine. Also, the email name can have a dash or be separated by one or more periods. The Domain name can also have multiple words separated by periods. Thus, it will validate bob@hotmail.com and bill.michaels@us.office.gov.",
        "matches": [
            "name@domain.com",
            "name.name2@domain.com",
            "name.name2@sub.domain.com"
        ],
        "non_matches": [
            "name.@domain.com",
            "name@.domain.com",
            ".name@domain.com"
        ]
    },
    {
        "id": 793,
        "expression": "( xmlns:.*=[&quot;,'].*[&quot;,'])|( xmlns=[&quot;,'].*[&quot;,'])",
        "description": "Matches xml namespace (xmlns) attribtutes. Works with single and double quotes, could be extended to support unquoted attributes.",
        "matches": [
            "&lt;el xmlns=&quot;http://SomeCorp/Namespace1&quot;&gt;",
            "&lt;el xmlns='http://SomeCorp/Namespace1'&"
        ],
        "non_matches": [
            "&lt;el xmlns=http://SomeCorp/Namespace1&gt;"
        ]
    },
    {
        "id": 795,
        "expression": "^[1-9]\\d*\\.?[0]*$",
        "description": "natural numbers 1, 2, 3...\n(no zeros)",
        "matches": [
            "1",
            "2",
            "3"
        ],
        "non_matches": [
            "0",
            "1.2",
            "01"
        ]
    },
    {
        "id": 796,
        "expression": "&lt;a\\s*href=(.*?)[\\s|&gt;]",
        "description": "Retrieves all anchor links in a html document, useful for spidering. You will need to do a replace of &quot; and ' after the regular expression, as the expression gets all links. As far as I know there is no way, even with \\1 groupings, of getting a condition on whether the link contains a &quot;,' or nothing at all (&quot; and ' is easy enough, but what happens if the link starts with &quot;, and has a javascript function call with a string in it). If there is, it's probably quicker to do it like this and do a string replace anyway.",
        "matches": [
            "&lt;a href=&quot;http://www.blah.com&quot;&gt;",
            "&lt;a href='../blah.html' target=&quot;_top&quot;&a"
        ],
        "non_matches": [
            "&lt;a href = http://www.idiothtmlprogrammers.com &gt;"
        ]
    },
    {
        "id": 797,
        "expression": "^([a-zA-z\\s]{4,32})$",
        "description": "This is the simplest RegEx for validating someone's name. The name can contain only alphabets(in either case) &amp; should be of minimum length 4 &amp; maximum length 32. Only white spaces are allowed apart from alphabets.",
        "matches": [
            "some body",
            "hey there",
            "hello"
        ],
        "non_matches": [
            "hi",
            "hey 27",
            "hell?"
        ]
    },
    {
        "id": 798,
        "expression": "^([Vv]+(erdade(iro)?)?|[Ff]+(als[eo])?|[Tt]+(rue)?|0|[\\+\\-]?1)$",
        "description": "This RegEx will match boolean values, either numeric or literal. It will accept MS Access &quot;-1&quot; values for &quot;true&quot;,\nand recognizes English and Brazilian Portuguese.",
        "matches": [
            "False",
            "verdadeiro",
            "0"
        ],
        "non_matches": [
            "+0",
            "1-1"
        ]
    },
    {
        "id": 799,
        "expression": "^(^(([0-9A-F]{1,4}(((:[0-9A-F]{1,4}){5}::[0-9A-F]{1,4})|((:[0-9A-F]{1,4}){4}::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,1})|((:[0-9A-F]{1,4}){3}::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,2})|((:[0-9A-F]{1,4}){2}::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,3})|(:[0-9A-F]{1,4}::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,4})|(::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,5})|(:[0-9A-F]{1,4}){7}))$|^(::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,6})$)|^::$)|^((([0-9A-F]{1,4}(((:[0-9A-F]{1,4}){3}::([0-9A-F]{1,4}){1})|((:[0-9A-F]{1,4}){2}::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,1})|((:[0-9A-F]{1,4}){1}::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,2})|(::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,3})|((:[0-9A-F]{1,4}){0,5})))|([:]{2}[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,4})):|::)((25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{0,2})\\.){3}(25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{0,2})$$",
        "description": "Matches all IPv6 text representations as defined within RFC 2373. Fairly verbose",
        "matches": [
            "::0:0:0:FFFF:129.144.52.38",
            "FEDC:BA98::3210:FEDC:BA98:7654:3210",
            "::13.1.68.3"
        ],
        "non_matches": [
            "FEDC:BA98:7654:3210:FEDC:BA98:7654:3210:1234",
            "3210:FEDC:BA98:7654:3210:1234",
            ":FEDC:BA98:7654:3210:"
        ]
    },
    {
        "id": 801,
        "expression": "^([0-9]{3,4})$",
        "description": "Allows you to check the length of a number (in this case either 3 or 4 digits).\nI found it useful when validating Credit Card Identification Codes (CVV2/CVC2/CID) which are either 3 or 4 numerical digits.",
        "matches": [
            "123",
            "1234"
        ],
        "non_matches": [
            "12",
            "12345"
        ]
    },
    {
        "id": 803,
        "expression": "^([a-zA-z\\s]{2,})$",
        "description": "This pattern matches is for validating Names, Cities, States, Countries etc that require only alphabet inputs with white spaces. It requires atleast 2 characters &amp; there's no limit on maximum number of characters.",
        "matches": [
            "Amit Gupta",
            "Some Body"
        ],
        "non_matches": [
            "A",
            "Someplace23",
            "New-Jersey"
        ]
    },
    {
        "id": 804,
        "expression": "^\\+?972(\\-)?0?[23489]{1}(\\-)?[^0\\D]{1}\\d{6}$",
        "description": "Matches an israely phone number with country code. With or without the plus sign. Also allows two or one digit in city code. Checks for a valid city code (02,03,04,08,09)",
        "matches": [
            "+972-4-8253055",
            "972-4-8615466",
            "972-04-8564521"
        ],
        "non_matches": [
            "04-5487665",
            "05-455665545",
            "456884624"
        ]
    },
    {
        "id": 805,
        "expression": "^((0?[1-9]|1[012])(:[0-5]\\d){1,2}(\\ [AaPp][Mm]))$",
        "description": "This is a simple expression used to match a normal 12 hour clock, requires AM/PM in any or mixed case and requires a space before the AM or PM and minutes are required.",
        "matches": [
            "1:45 am",
            "12:01 aM",
            "01:23 pm"
        ],
        "non_matches": [
            "13:34 am",
            "1:60 am",
            "13:45"
        ]
    },
    {
        "id": 808,
        "expression": "((\\s*([^,{]+)\\s*,?\\s*)*?){((\\s*([^:]+)\\s*:\\s*([^;]+?)\\s*;\\s*)*?)}",
        "description": "will break out a valid CSS stylesheet into it's components. Groups on each style, all selectors, each selector within a comma delimited list of selectors, all properties, each property set, each property and each value. In other words, it breaks it all down for you :)\nThe only two problems I'm having with it:\nA) it is ignorant of comment blocks. so if you have styles within a /* */ block, it'll pick those up.\nB) the first style following a comment block is not parsed correctly (it incorrectly includes the comment as a selector\nbest thing to do would be to use another regexp to remove all comments before processing with this one",
        "matches": [
            "div#main { position:relative; width:809px; margin-left:auto; margin-right:auto; padding:0; }"
        ],
        "non_matches": [
            "-----"
        ]
    },
    {
        "id": 814,
        "expression": "^\\d{5}((-|\\s)?\\d{4})?$",
        "description": "Single field zip code validator, useful for Web Forms. Allows user to enter 5-digit or 5-digit plus 4 zip code, with hyphen or space or NO space between last 4 digits.",
        "matches": [
            "92078-4705",
            "920784705",
            "92078 4705"
        ],
        "non_matches": [
            "9027x",
            "902",
            "92078.4705"
        ]
    },
    {
        "id": 815,
        "expression": "^\\d{5}((\\-|\\s)?\\d{4})?$",
        "description": "Single field zip code validator useful for web forms, where user may enter 5 digit or 9 digit zip code, and may use hyphen, space, or no space between the first 5 digits and last 4 digits.",
        "matches": [
            "92078",
            "92078-4705",
            "92078 4705"
        ],
        "non_matches": [
            "920781",
            "920a87",
            "920"
        ]
    },
    {
        "id": 816,
        "expression": "^(\\([2-9]|[2-9])(\\d{2}|\\d{2}\\))(-|.|\\s)?\\d{3}(-|.|\\s)?\\d{4}$",
        "description": "Telephone validator allowing user to enter 10 digit telephone number with segments of number separated by hyphens, periods or spaces. Also braces allowed around area code.",
        "matches": [
            "213-123-1234",
            "2131231234",
            "(213) 123-1234"
        ],
        "non_matches": [
            "123-123-1234"
        ]
    },
    {
        "id": 817,
        "expression": "[1-2][0|9][0-9]{2}[0-1][0-9][0-3][0-9][-][0-9]{4}",
        "description": "Swedish person number. Don't work on persons older then 100 years, but they are so few that it shouldn't be a problem. Easy to fix, but I choose not to accept oldies...",
        "matches": [
            "19740609-7845",
            "19811116-7845",
            "20010913-7598"
        ],
        "non_matches": [
            "21003612-9999",
            "18790505-4545",
            "19740641-5559"
        ]
    },
    {
        "id": 822,
        "expression": "^([0]?[1-9]|[1][0-2])[./-]([0]?[1-9]|[1|2][0-9]|[3][0|1])[./-]([0-9]{4}|[0-9]{2})$",
        "description": "Validate american date formats: mm/dd/yyyy or m/d/yy or m.d.yyyy with separators: . - /\nValid dates only! m (1-12)/ d (1-31)/ y (0..)\n(rizzipereira.com.br)\nFor Brazilian date format: http://www.regexlib.com/REDetails.aspx?regexp_id=250",
        "matches": [
            "10.03.1979",
            "12/30/2004",
            "01/01/2004"
        ],
        "non_matches": [
            "09--02--2004",
            "15-15-2004",
            "13/12/2004"
        ]
    },
    {
        "id": 823,
        "expression": "^[0-9]{4}-(((0[13578]|(10|12))-(0[1-9]|[1-2][0-9]|3[0-1]))|(02-(0[1-9]|[1-2][0-9]))|((0[469]|11)-(0[1-9]|[1-2][0-9]|30)))$",
        "description": "Matches the date format &quot;YYYY-mm-dd&quot; and also validates month and number of days in a month. All leap year dates &quot;YYYY-02-29&quot; passes trough. Could easily be changed to another format.",
        "matches": [
            "2004-04-30",
            "2004-02-29"
        ],
        "non_matches": [
            "2004-04-31",
            "2004-02-30"
        ]
    },
    {
        "id": 825,
        "expression": "([0]{1}[6]{1}[-\\s]*[1-9]{1}[\\s]*([0-9]{1}[\\s]*){7})|([0]{1}[1-9]{1}[0-9]{1}[0-9]{1}[-\\s]*[1-9]{1}[\\s]*([0-9]{1}[\\s]*){5})|([0]{1}[1-9]{1}[0-9]{1}[-\\s]*[1-9]{1}[\\s]*([0-9]{1}[\\s]*){6})",
        "description": "Meets dutch phone number requirements.. One posted here before didn't allow the 0 after the first digit of the call ID (so the second number or later after the prefix), which should be allowed. I modified that one to meet full requirements now..\nEnjoy!!",
        "matches": [
            "06 12345678",
            "010-1234560",
            "0111-101234"
        ],
        "non_matches": [
            "05-43021212",
            "123-4567890",
            "1234567890"
        ]
    },
    {
        "id": 827,
        "expression": "^((?:2[0-5]{2}|1\\d{2}|[1-9]\\d|[1-9])\\.(?:(?:2[0-5]{2}|1\\d{2}|[1-9]\\d|\\d)\\.){2}(?:2[0-5]{2}|1\\d{2}|[1-9]\\d|\\d)):(\\d|[1-9]\\d|[1-9]\\d{2,3}|[1-5]\\d{4}|6[0-4]\\d{3}|654\\d{2}|655[0-2]\\d|6553[0-5])$",
        "description": "IPv4 ip:port checker, I hope it will help you. $1 - IP, $2 - port. More to come, maybe :)",
        "matches": [
            "127.0.0.1:80",
            "255.255.255.0:21",
            "1.0.0.0:1"
        ],
        "non_matches": [
            "0.0.0.0:1",
            "256.1.1.1:20",
            "127.0.0.1:65536"
        ]
    },
    {
        "id": 831,
        "expression": "^(9,)*([1-9]\\d{2}-?)*[1-9]\\d{2}-?\\d{4}$",
        "description": "Validates US or Canadian phone numbers with the use of &quot;-&quot; or numbers stuck together. No parantheses allowed as well as spaces. Area code is optional. The &quot;9,&quot; is optional as well, which on some phone systems is needed to dial out.",
        "matches": [
            "9,5143393044",
            "9,514-339-3044",
            "339-3044"
        ],
        "non_matches": [
            "9,339 3044",
            "514 440 2009",
            "(514) 440-2009"
        ]
    },
    {
        "id": 833,
        "expression": "^\\-?\\(?([0-9]{0,3}(\\,?[0-9]{3})*(\\.?[0-9]*))\\)?$",
        "description": "Match a positive or negative decimal value with any precision and scale. Allows for left-padded zeroes, commas as group separator, negative sign (-) or parenthesis to indicate negative number.",
        "matches": [
            "0.123",
            "(1234.123)",
            "-01,200"
        ],
        "non_matches": [
            "2.3.123",
            "1,23.45"
        ]
    },
    {
        "id": 834,
        "expression": "^[-+]?[0-9]\\d{0,2}(\\.\\d{1,2})?%?$",
        "description": "Required and regular expression validator. For supporting\n-999.99 to +999.99 . Positive and Negative integer/ decimal validations. Percentage sign is also supported. Will not allow empty strings. Can increase/decrease the range as you need.",
        "matches": [
            "12.3",
            "123",
            "-123.45"
        ],
        "non_matches": [
            "-",
            "10.1234",
            "-1234"
        ]
    },
    {
        "id": 836,
        "expression": "^([0-9]{5})([\\-]{1}[0-9]{4})?$",
        "description": "Validates against a U.S. postal code in either a 5 digit format or a 5 dash 4 format.",
        "matches": [
            "18017",
            "18017-1401"
        ],
        "non_matches": [
            "1801A",
            "18017-",
            "18017-152A"
        ]
    },
    {
        "id": 837,
        "expression": "^([4]{1})([0-9]{12,15})$",
        "description": "Validate against a visa card number. All visa cards start with a 4 and are followed by 12 to 15 more numbers.",
        "matches": [
            "4125632152365",
            "418563256985214",
            "4125632569856321"
        ],
        "non_matches": [
            "3125652365214",
            "41256321256",
            "42563985632156322"
        ]
    },
    {
        "id": 838,
        "expression": "^([51|52|53|54|55]{2})([0-9]{14})$",
        "description": "Validate against any mastercard number. All MC's start with a number between 51 and 55 and are followed by 14 other numbers.",
        "matches": [
            "5125632154125412",
            "5225632154125412",
            "5525632154125412"
        ],
        "non_matches": [
            "5625632154125412",
            "4825632154125412",
            "6011632154125412"
        ]
    },
    {
        "id": 839,
        "expression": "^([34|37]{2})([0-9]{13})$",
        "description": "Validate against any american express number. All american express numbers start with either a 34 or 37, followed by 13 other numbers.",
        "matches": [
            "341256321524212",
            "371524254523125"
        ],
        "non_matches": [
            "425152365212542",
            "34256321523621",
            "3712563212523651"
        ]
    },
    {
        "id": 840,
        "expression": "^([6011]{4})([0-9]{12})$",
        "description": "Validate against any discover card number. All DC's start with 6011 and are followed by 12 other numbers.",
        "matches": [
            "6011212541254121",
            "6011523654125685"
        ],
        "non_matches": [
            "5021152365212541",
            "601126523652321",
            "60112563212563215"
        ]
    },
    {
        "id": 841,
        "expression": "^([30|36|38]{2})([0-9]{12})$",
        "description": "Validate against any diner's club card. All diner club cards start with 30,36, or 38, followed by 12 other numbers.",
        "matches": [
            "30125212365212",
            "36125212365212",
            "38125212365212"
        ],
        "non_matches": [
            "301252123652121",
            "40256631125452",
            "361251254125212"
        ]
    },
    {
        "id": 842,
        "expression": "([^\\.\\?\\!]*)[\\.\\?\\!]",
        "description": "Finds sentences (assuming they end with a full stop, question mark or exclamation mark).",
        "matches": [
            "This is a series of sentences.",
            "They end predictably!",
            "Where would we be without punctuation?"
        ],
        "non_matches": [
            "This sentence just trails off"
        ]
    },
    {
        "id": 844,
        "expression": "^(([A-Z]{1,2}[0-9]{1,2})|([A-Z]{1,2}[0-9][A-Z]))\\s?([0-9][A-Z]{2})$",
        "description": "Matches UK postcodes of the below formats. The space is optional.\nAN NAA\nAAN NAA\nANN NAA\nANA NAA\nAANA NAA\nAANN NAA",
        "matches": [
            "A11AA",
            "AA1A 1AA",
            "AA11 1AA"
        ],
        "non_matches": [
            "AAA 1AA",
            "AA11A 1AA",
            "AAA1AA"
        ]
    },
    {
        "id": 848,
        "expression": "(\\S+)\\x20{2,}(?=\\S+)",
        "description": "Trim Inside. This pattern can be used with a replace value of &quot;$1 &quot; to remove multiple consecutive spaces between characters and replace with a single space. Trailing and leading spaces are NOT altered.",
        "matches": [
            "Too  Many spaces."
        ],
        "non_matches": [
            "No extra spaces",
            "No Extra spaces Inside"
        ]
    },
    {
        "id": 849,
        "expression": "^(?:[ -~]{10,25}(?:$|(?:[\\w!?.])\\s))",
        "description": "Word Break. This regex can be used to break a long line of text on a full word. The qualifiers specify the minimum and maximum number of character allow before the break and can be changed according to your need. Blogge about this here http://regexadvice.com/blogs/mash/archive/2005/02/09/324.aspx",
        "matches": [
            "This is just a simple sample"
        ],
        "non_matches": [
            "A sample"
        ]
    },
    {
        "id": 851,
        "expression": "^[0-9]{4}((0[1-9])|(1[0-2]))$",
        "description": "Match a string in CCYYMM/YYYYMM format.",
        "matches": [
            "200401",
            "000001",
            "200412"
        ],
        "non_matches": [
            "aaa",
            "20040123",
            "200414"
        ]
    },
    {
        "id": 852,
        "expression": "(^[a-zA-Z][a-zA-Z0-9_]*)|(^[_][a-zA-Z0-9_]+)",
        "description": "This pattern can be used for validating a string as a valid element name (e.g. variable or class name) in Microsoft .NET. See also http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vbcn7/html/vbconelementnames.asp",
        "matches": [
            "var",
            "_withunder_score99",
            "TeSt"
        ],
        "non_matches": [
            "_",
            "123abc",
            "9"
        ]
    },
    {
        "id": 853,
        "expression": "^[^\\\\\\./:\\*\\?\\\"<>\\|]{1}[^\\\\/:\\*\\?\\\"<>\\|]{0,254}$",
        "description": "Validates a long filename using Windows' rules. Requires one valid filename character other than &quot;.&quot; for the first character and then any number of valid filename characters up to a total length of 255 characters. Unresolved is how to prevent the last character from being a &quot;.&quot; while still meeting all the features that this regex does now.",
        "matches": [
            "abcd.jpg",
            "a b239.abcd ef12983 298",
            "a....23498"
        ],
        "non_matches": [
            ".abcde.jpg",
            "abcde?.jpg",
            "c:\\abcde.jpg"
        ]
    },
    {
        "id": 858,
        "expression": "^\\\\([^\\\\]+\\\\)*[^\\/:*?&quot;&lt;&gt;|]?$",
        "description": "Orginally on this site search for Path, go to next page\nyou see a reg expression for ^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)*[^\\/:*?&quot;&lt;&gt;|]+\\.htm(l)?$\nwhich I modified with this one to disallow drive specification.",
        "matches": [
            "\\temp\\",
            "\\temp\\content\\",
            "\\Program Files\\"
        ],
        "non_matches": [
            "a:\\Temp\\",
            "\\Temp\\Content",
            "c:\\Program Files\\"
        ]
    },
    {
        "id": 859,
        "expression": "^-?[0-9]{0,2}(\\.[0-9]{1,2})?$|^-?(100)(\\.[0]{1,2})?$",
        "description": "Matches a negative or positive percentage between 0 and 100 (inclusive). Accepts up to 2 decimal places.",
        "matches": [
            "12.34",
            "100.00",
            "-2.1"
        ],
        "non_matches": [
            "101.1",
            "10.123",
            "100.10"
        ]
    },
    {
        "id": 860,
        "expression": "href=[\\&quot;\\']?((?:[^&gt;]|[^\\s]|[^&quot;]|[^'])+)[\\&quot;\\']?",
        "description": "This will match just about everything after href=\nIts good if you just need a list of all the href= values",
        "matches": [
            "href=&quot;http://www.google.com/tsunami_relief.html&quot;",
            "href=/preferences?hl=en",
            "href=&quot;ht"
        ],
        "non_matches": [
            "src=blah blah"
        ]
    },
    {
        "id": 861,
        "expression": "\\b(?:a(?:[nst]|re|nd)?|b[ey]|f(?:or|rom)|i[nst]?|o[fnr]|t(?:o|hat|he|his)|w(?:as|h(?:at|en|ere|ich|o)|i(?:th|ll)))\\b",
        "description": "Removes &quot;stop&quot; or &quot;delete&quot; words that google removes from search strings. Ordinarily have no search significance. I used this to remove the words in my own web search application. Take out the ?: for grouping.\nI've tested this a bit, yet this is my 1st regex that I've ever written. It's working fine for me.",
        "matches": [
            "by",
            "when",
            "or"
        ],
        "non_matches": [
            "bye",
            "craptastic",
            "nor"
        ]
    },
    {
        "id": 862,
        "expression": "^([0-1])*$",
        "description": "Expression validating a Binary string of any length",
        "matches": [
            "10101000",
            "01010000",
            "100000001"
        ],
        "non_matches": [
            "01000200",
            "00021000",
            "e10000000"
        ]
    },
    {
        "id": 863,
        "expression": "^([0-7])*$",
        "description": "Expression validating a octal string of any length.",
        "matches": [
            "1357",
            "445005",
            "101"
        ],
        "non_matches": [
            "900508",
            "7FFF",
            "599D"
        ]
    },
    {
        "id": 865,
        "expression": "^([0-9a-fA-F]){8}$",
        "description": "Hex number/string validation method for the Electronic Serial Number(ESN) used in Cellular Phone products.",
        "matches": [
            "8ECCA04F",
            "82E5AAA4",
            "82e5aaa4"
        ],
        "non_matches": [
            "8ECCAOF",
            "82E5AA4",
            "82e5aaa45"
        ]
    },
    {
        "id": 867,
        "expression": "^(?:[a-zA-Z0-9_'^&amp;/+-])+(?:\\.(?:[a-zA-Z0-9_'^&amp;/+-])+)*@(?:(?:\\[?(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))\\.){3}(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\]?)|(?:[a-zA-Z0-9-]+\\.)+(?:[a-zA-Z]){2,}\\.?)$",
        "description": "this will validate most legal email addresses, even allows for some discouraged but perfectly legal characters in local part; allows IP domains with optional []; keeps final tld at a minmum of 2 chars; non capturing groups for efficiency",
        "matches": [
            "you.me.hello@somewhere.else.cc",
            "joe_smith@here.com.",
            "me@[24.111.232.1]"
        ],
        "non_matches": [
            ".me.you@here.com",
            ".murat@62.59.114.103.nl",
            "test_case@here*555%there.com"
        ]
    },
    {
        "id": 869,
        "expression": "(02\\d\\s?\\d{4}\\s?\\d{4})|(01\\d{2}\\s?\\d{3}\\s?\\d{4})|(01\\d{3}\\s?\\d{5,6})|(01\\d{4}\\s?\\d{4,5})",
        "description": "Validates UK domestic landline phone numbers.\nValid formats are:\n029 99999999 or 029 9999 9999; 0199 9999999 or 0199 999 9999; 01999 99999; 01999 999999; 019999 9999; 019999 99999. These formats are taken from the official guidelines from Ofcom, the organisation responsible for UK telecoms issues. Brackets are not valid and STD code must be entered.",
        "matches": [
            "020 1234 5678",
            "0123 4567890",
            "01234 456789"
        ],
        "non_matches": [
            "02476 123456",
            "0845 123456",
            "07712 345678"
        ]
    },
    {
        "id": 870,
        "expression": "(077|078|079)\\s?\\d{2}\\s?\\d{6}",
        "description": "Validates UK mobile phone numbers. Valid formats are `077', `078' or `079' followed by another 8 digits, with an optional space after the dialling code and/or between the 4th and 5th characters of the remainder of the number. These formats are taken from the official guidelines from Ofcom, the organisation responsible for UK telecoms issues. Brackets are not valid and STD code must be entered.",
        "matches": [
            "07713 345678",
            "078 12345678",
            "079 12345678"
        ],
        "non_matches": [
            "02344 123456",
            "0121 292929",
            "012345 6789"
        ]
    },
    {
        "id": 875,
        "expression": "^[\\.\\w&#230;&#248;&#229;-]+@([a-z&#230;&#248;&#229;0-9]+([\\.-]{0,1}[a-z&#230;&#248;&#229;0-9]+|[a-z&#230;&#248;&#229;0-9]?))+\\.[a-z]{2,6}$",
        "description": "Well it pretty much accepts all kinds of users, about the domain i didn't write it special for any TLD so there's no length defined, ohh and it accepts some IDN stuff",
        "matches": [
            "afdaas-ddas----asddas____...@asd.asd.asd.asd.asd.com",
            "a@a.aa",
            ".@microsoft.sun.apple.com"
        ],
        "non_matches": [
            "aaaaaaa@.-com",
            "aaaaaaa@adf.-com",
            "aaaaaaa@"
        ]
    },
    {
        "id": 876,
        "expression": "^((0[1-9])|(1[0-2]))$",
        "description": "Matches month, requires that months 1-9 have a leading 0",
        "matches": [
            "01",
            "02",
            "12"
        ],
        "non_matches": [
            "1",
            "2",
            "13"
        ]
    },
    {
        "id": 877,
        "expression": "^\\s*-?(\\d*\\.)?([0-2])?[0-9]:([0-5])?[0-9]:([0-5])?[0-9](\\.[0-9]{1,7})?\\s*$",
        "description": "This should be the pattern described in the documentation for the .NET TimeSpan.Parse method - generally parses time spans.\nFrom the .NET docs:\npublic static TimeSpan Parse(string s);\nThe s parameter contains a specification of the form:\n[ws][-][d.]hh:mm:ss[.ff][ws]\nItems in square brackets ([ and ]) are optional, colons and periods (: and .) are literal characters, and other items are as follows.\nItem Description\nws optional white space\n&quot;-&quot; optional minus sign indicating a negative time\n&quot;d&quot; optional days\n&quot;hh&quot; hours, ranging from 0 to 23\n&quot;mm&quot; minutes, ranging from 0 to 59\n&quot;ss&quot; seconds, ranging from 0 to 59\n&quot;ff&quot; optional fractional seconds, from 1 to 7 decimal digits",
        "matches": [
            "10:12:34",
            "932323.9:00:32.3420"
        ],
        "non_matches": [
            "10:20:80"
        ]
    },
    {
        "id": 879,
        "expression": "^([1-9]{0,1})([0-9]{1})(\\.[0-9])?$",
        "description": "Matches numbers 0 through 99.9\nAllows only one preceding zero and does not require the decimal point",
        "matches": [
            "1",
            "1.1",
            "0.1"
        ],
        "non_matches": [
            "01",
            "01.1",
            "0.10"
        ]
    },
    {
        "id": 880,
        "expression": "^(eth[0-9]$)|(^eth[0-9]:[1-9]$)",
        "description": "regex to validate unix device names (linux). useful for scripts using ifconfig or stuff",
        "matches": [
            "eth0",
            "eth0:4",
            "eth4:9"
        ],
        "non_matches": [
            "eth0:",
            "eth0:0",
            "eth0:1d"
        ]
    },
    {
        "id": 881,
        "expression": "^\\.([rR]([aA][rR]|\\d{2})|(\\d{3})?)$",
        "description": "RAR file extensions.\nWorks also with '*.part01.rar' given '.rar' to be the file extension.\nDoes not support volumes exceed 101 for s## (r99, s00, s01, ...) serie.",
        "matches": [
            ".RAr",
            ".r01",
            ".012"
        ],
        "non_matches": [
            ".rxr",
            ".a01",
            ".0112"
        ]
    },
    {
        "id": 882,
        "expression": "^(X(-|\\.)?0?\\d{7}(-|\\.)?[A-Z]|[A-Z](-|\\.)?\\d{7}(-|\\.)?[0-9A-Z]|\\d{8}(-|\\.)?[A-Z])$",
        "description": "Matches Spanish CIF, NIF and NIE formats. Recognises separation of letters with the hyphen or period.\nFormat CIF: [1 letter][7 numbers][1 number or letter]\nFormat NIF: [8 numbers][1 letter]\nFormat NIE: X[possible 0][7 numbers][1 letter]\nNote that this expression does not check for the validity of the NIF/CIF/NIE... there are some control characters in there and I don't know how they work.\nGenerally I always strip out any non-alphanumeric characters (hyphens, periods, etc.) and convert to upper case before checking validity and before saving to data storage.\nPlease post improvements or errors if you find them!",
        "matches": [
            "X01343567-D",
            "B-6116622G",
            "43544122-R"
        ],
        "non_matches": [
            "43.544.122-R"
        ]
    },
    {
        "id": 884,
        "expression": "([0-9]+\\.[0-9]*)|([0-9]*\\.[0-9]+)|([0-9]+)",
        "description": "This is just a very simple matcher for real numbers.",
        "matches": [
            "123.456",
            ".123",
            "123"
        ],
        "non_matches": [
            ".",
            "apple",
            "pear"
        ]
    },
    {
        "id": 885,
        "expression": "^((([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}:[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){5}:([0-9A-Fa-f]{1,4}:)?[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){4}:([0-9A-Fa-f]{1,4}:){0,2}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){3}:([0-9A-Fa-f]{1,4}:){0,3}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){2}:([0-9A-Fa-f]{1,4}:){0,4}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}((\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b)\\.){3}(\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b))|(([0-9A-Fa-f]{1,4}:){0,5}:((\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b)\\.){3}(\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b))|(::([0-9A-Fa-f]{1,4}:){0,5}((\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b)\\.){3}(\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b))|([0-9A-Fa-f]{1,4}::([0-9A-Fa-f]{1,4}:){0,5}[0-9A-Fa-f]{1,4})|(::([0-9A-Fa-f]{1,4}:){0,6}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){1,7}:))$",
        "description": "Matches full and compressed IPv6 addresses as defined in RFC 2373 (http://www.faqs.org/rfcs/rfc2373.html). No useful captures.\nVarious implementations require different terminators. (i.e. ^-$ or \\b-\\b)",
        "matches": [
            "FEDC:BA98:7654:3210:FEDC:BA98:7654:3210",
            "1080::8:800:200C:417A",
            "::FFFF:129.144.52.38"
        ],
        "non_matches": [
            "FEDC::7654:3210::BA98:7654:3210",
            "FEDC:BA98:7654:3210",
            "::"
        ]
    },
    {
        "id": 888,
        "expression": "^(\\$|)([1-9]+\\d{0,2}(\\,\\d{3})*|([1-9]+\\d*))(\\.\\d{2})?$",
        "description": "By combining the contributions from Bri Gipson and Michael Ash in this site. I have come up with this RE to exclude the zero dollar amounts such as $0.00, 0.00, 0, etc.",
        "matches": [
            "$1,234,567.00",
            "$1234567.00",
            "1234567.00"
        ],
        "non_matches": [
            "$1,2345,67.00",
            "$0",
            "$0.00"
        ]
    },
    {
        "id": 889,
        "expression": "(((ht|f)tp(s?):\\/\\/)|(www\\.[^ \\[\\]\\(\\)\\n\\r\\t]+)|(([012]?[0-9]{1,2}\\.){3}[012]?[0-9]{1,2})\\/)([^ \\[\\]\\(\\),;&quot;'&lt;&gt;\\n\\r\\t]+)([^\\. \\[\\]\\(\\),;&quot;'&lt;&gt;\\n\\r\\t])|(([012]?[0-9]{1,2}\\.){3}[012]?[0-9]{1,2})",
        "description": "v2\nA general purpose expresion to find url's (improved).\nAdd heads to first part, example:\n((imap:|(ht|f)tp(s?):\\/\\/)|(www\\.\nto find url's like imap://www.com/, so ip's. No ipv6 (yet)",
        "matches": [
            "www.domain.com",
            "http://www.blah.ru",
            "https://192.168.0.2:80/users/~fname.lname/file.ext"
        ],
        "non_matches": [
            "imap://.com"
        ]
    },
    {
        "id": 890,
        "expression": "^(\\$|)([1-9]\\d{0,2}(\\,\\d{3})*|([1-9]\\d*))(\\.\\d{2})?$",
        "description": "Combine Michael Ash's US Dollar amount and Bri Gipson's eliminating zero input to create this RE to accept Optional leading dollar sign, optional well-formed comma separator dollar amount with no zero amount allowed.\n*** Correction: Remove the &quot;+&quot; otherwise it will incorrectly matches 4 leading digits like 1234,345,678.00 03-03-2005",
        "matches": [
            "$1,234,567.89",
            "1234567.89",
            "$9.99"
        ],
        "non_matches": [
            "$1,2345,67.89",
            "$1234,345,678.0",
            "0"
        ]
    },
    {
        "id": 891,
        "expression": "^((Fred|Wilma)\\s+Flintstone|(Barney|Betty)\\s+Rubble)$",
        "description": "Match the full names of the four main characters of The Flintstones.",
        "matches": [
            "Fred Flintstone",
            "Barney Rubble",
            "Betty Rubble"
        ],
        "non_matches": [
            "The Great Gazoo",
            "Mr. Slate",
            "Dino"
        ]
    },
    {
        "id": 892,
        "expression": "^(([a-zA-Z0-9_\\-\\.]+)@([a-zA-Z0-9_\\-\\.]+)\\.([a-zA-Z]{2,5}){1,25})+([;.](([a-zA-Z0-9_\\-\\.]+)@([a-zA-Z0-9_\\-\\.]+)\\.([a-zA-Z]{2,5}){1,25})+)*$",
        "description": "this will accept multiple email ids separated only by semi-colons (anyway u can change it).",
        "matches": [
            "te_s-t@ts.co.in;te_s-t@ts.co.in;te_s-t@ts.co.in"
        ],
        "non_matches": [
            "nospace@between.mailids.in ; only@semi.colons.com"
        ]
    },
    {
        "id": 893,
        "expression": "(\\b)(\\w+(\\b|\\n|\\s)){3}",
        "description": "This script attempts to return phrases from a string (Example above looks for {3} word phrases) Combine this with some .Net code, you can display most popular X word phrases in a string.\n-If anyone can help me count &quot;Phrase and Phrase as 2 instances of Phrase please contact me",
        "matches": [
            "three blind mice",
            "see how they run"
        ],
        "non_matches": [
            "three blind",
            "they run"
        ]
    },
    {
        "id": 894,
        "expression": "(^\\([0]\\d{2}\\))(\\d{6,7}$)",
        "description": "Validator for New Zealand Mobile phone numbers. Will look for the first number being a 0 and must be a number or either 6 or 7 digits long after to initial (021) suffix",
        "matches": [
            "(021)1234567",
            "(021)123456",
            "(000)000000"
        ],
        "non_matches": [
            "(123)1234567",
            "025123456",
            "0252345678"
        ]
    },
    {
        "id": 895,
        "expression": "^([1-9]|1[0-2]|0[1-9]){1}(:[0-5][0-9][aApP][mM]){1}$",
        "description": "Very simple expression to validate time on a 12 hour clock, this expression is valid for client-side script validations (RegularExpressionValidator - ASP.NET).",
        "matches": [
            "08:00AM",
            "10:00am",
            "7:00pm"
        ],
        "non_matches": [
            "13:00pm",
            "12:65am"
        ]
    },
    {
        "id": 896,
        "expression": "^([0-9a-zA-Z]+[-._+&amp;])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,6}$",
        "description": "A short and sweet email address validator. Checks that the username starts and ends with an alphanumeric character, allows a few non-repeating 'special characters' (namely -, ., _, +, &amp;) and checks for a sensible domain name (2-6 character TLD required). Some unconventional, yet technically valid, addresses will not be matched, but this is only a simple expression ;-)",
        "matches": [
            "test@test.com",
            "nerdy.one@science.museum",
            "ready&amp;set@go.com.au"
        ],
        "non_matches": [
            ".test.@test.com",
            "spammer@[203.12.145.68]",
            "bla@bla"
        ]
    },
    {
        "id": 897,
        "expression": "^[0-9]*(\\.)?[0-9]+$",
        "description": "it will check for the +ve decimal numbers",
        "matches": [
            "1",
            "123",
            "132.132"
        ],
        "non_matches": [
            "1.2.2",
            "-123"
        ]
    },
    {
        "id": 898,
        "expression": "^[a-zA-Z0-9]+$",
        "description": "it will check for alphanumeric (Alpha Numeric) values.",
        "matches": [
            "adad1213",
            "1231dfadfa",
            "dfad123dfasdfs"
        ],
        "non_matches": [
            "dfa@#12313",
            "*(*sdfasdfadfd",
            "$fffsdg121ddd#$f1q"
        ]
    },
    {
        "id": 900,
        "expression": "\\{CHBLOCK\\:(.*?\\})",
        "description": "Litle regexp for my portal engie. Only cut the {CHBLOCK:'modulename'} item",
        "matches": [
            "{CHBLOCK:sdgs}",
            "{CHBLOCK:sdgs}sdg{CHBLOCK:sdgs}"
        ],
        "non_matches": [
            "{CHBLOCK}",
            "{CHBLOCK:sdgs"
        ]
    },
    {
        "id": 901,
        "expression": "^(((0[1-9]|[12]\\d|3[01])\\/(0[13578]|1[02])\\/((19|[2-9]\\d)\\d{2}))|((0[1-9]|[12]\\d|30)\\/(0[13456789]|1[012])\\/((19|[2-9]\\d)\\d{2}))|((0[1-9]|1\\d|2[0-8])\\/02\\/((19|[2-9]\\d)\\d{2}))|(29\\/02\\/((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))))$",
        "description": "dd/MM/yyyy with leap years 100% integrated Valid years : from 1900 to 9999.\nAs usual, many tests have been made.\nThis was requested by a user :\nhttp://www.regexlib.com/REDetails.aspx?regexp_id=409",
        "matches": [
            "29/02/2000",
            "30/04/2003",
            "01/01/2003"
        ],
        "non_matches": [
            "29/02/2001",
            "30-04-2003",
            "1/1/1899"
        ]
    },
    {
        "id": 902,
        "expression": "(?i)(pharmacy)|((p(.{1,3})?h(.{1,3})?a(.{1,3})?r(.{1,3)?m(.{1,3})?a(.{1,3})?c(.{1,3})?y))",
        "description": "AntiSpam: matches variations on the word &quot;pharmacy&quot;",
        "matches": [
            "phaaarmacy",
            "pphhaarrmmaaccyy",
            "ppharmacy"
        ],
        "non_matches": [
            "armacy"
        ]
    },
    {
        "id": 903,
        "expression": "^[a-z]+([a-z0-9-]*[a-z0-9]+)?(\\.([a-z]+([a-z0-9-]*[a-z0-9]+)?)+)*$",
        "description": "A simple regex which should validate a domain name according to RFC 1035\nupdated to match domain names with hyphens",
        "matches": [
            "www.domain.com",
            "w123.d42omain.c43om",
            "ww-w.d-omain.com"
        ],
        "non_matches": [
            "1www.domain.com",
            "www.1domain.com",
            "www.domain.com-"
        ]
    },
    {
        "id": 904,
        "expression": "\\w{5,255}",
        "description": "This is User Name &amp; Password validation expression. It does not allow blank spaces as well as special characters like $#%@&amp;*(){}+",
        "matches": [
            "aa123_ter12",
            "aa4587",
            "784566"
        ],
        "non_matches": [
            "123*-/ mksj"
        ]
    },
    {
        "id": 907,
        "expression": "\\b((?:0[1-46-9]\\d{3})|(?:[1-357-9]\\d{4})|(?:[4][0-24-9]\\d{3})|(?:[6][013-9]\\d{3}))\\b",
        "description": "This is my attempt to find out valid german postal codes (PLZ or Postleitzahlen).\nAfter the German Unification the numbers were changed to a five digit system. The postal codes starts with the two digit &quot;Leitzahl&quot;. This is a number between 00 and 99 excluding the not yet used numbers: 00, 05, 43 and 62! After that follows directly a three digit number, 000-999.\nComments welcome. This works for me, however I think it could be written more compact, but could not figure out how ;-)\nFor more information on german postal codes see:\nhttp://de.wikipedia.org/wiki/Liste_der_Postleitbereiche_Deutschland\nhttp://de.wikipedia.org/wiki/Postleitzahl_%28Deutschland%29\nhttp://en.wikipedia.org/wiki/List_of_postal_codes_in_Germany",
        "matches": [
            "12556",
            "01550",
            "80796"
        ],
        "non_matches": [
            "05234",
            "8973",
            "62980"
        ]
    },
    {
        "id": 909,
        "expression": "(^[+]?\\d*\\.?\\d*[1-9]+\\d*$)|(^[+]?[1-9]+\\d*\\.\\d*$)",
        "description": "Accepts only positive decimal values. Zero and negative numbers are non-matching.Allows zeros after last non-zero numeric value after decimal place for significant digits",
        "matches": [
            "01.23",
            "0.15",
            "0.1568"
        ],
        "non_matches": [
            "0",
            "-0.18",
            ".0"
        ]
    },
    {
        "id": 911,
        "expression": "^(((((((0?[13578])|(1[02]))[\\.\\-/]?((0?[1-9])|([12]\\d)|(3[01])))|(((0?[469])|(11))[\\.\\-/]?((0?[1-9])|([12]\\d)|(30)))|((0?2)[\\.\\-/]?((0?[1-9])|(1\\d)|(2[0-8]))))[\\.\\-/]?(((19)|(20))?([\\d][\\d]))))|((0?2)[\\.\\-/]?(29)[\\.\\-/]?(((19)|(20))?(([02468][048])|([13579][26])))))$",
        "description": "Simple American date format mm-dd-yyyy or mm-dd-yy, no time. Date range is 1900 --&gt; 2099. Is enough for my purposes. Incorectly validates 02-29-1900. I created this to validate dates on a web form where the likely range will be 2000--&gt;2020. Seperators can be '.','/' or '-'\nAnyone know the rules for operator precedence for regex syntax?",
        "matches": [
            "02-29-2004",
            "1/31/1997",
            "1-2-03"
        ],
        "non_matches": [
            "02-29-2003",
            "04-31-2003",
            "31-03-05"
        ]
    },
    {
        "id": 912,
        "expression": "^[^\\\\\\/\\?\\*\\&quot;\\'\\&gt;\\&lt;\\:\\|]*$",
        "description": "Validation of a Folder Name. Excludes all forbidden characters",
        "matches": [
            "321321321 dasds"
        ],
        "non_matches": [
            "/\\3fsdfsd"
        ]
    },
    {
        "id": 913,
        "expression": "^([2-9]\\d{3}((0[1-9]|1[012])(0[1-9]|1\\d|2[0-8])|(0[13456789]|1[012])(29|30)|(0[13578]|1[02])31)|(([2-9]\\d)(0[48]|[2468][048]|[13579][26])|(([2468][048]|[3579][26])00))0229)$",
        "description": "yyyyMMdd with leap year validation, starting from year 2000 only.\nThe length of the expression is minimized, but still validates all entries.\nIf you want it with years like 1600 or separators, just ask :)",
        "matches": [
            "20000101",
            "20051231",
            "20040229"
        ],
        "non_matches": [
            "19990101",
            "20053112",
            "20050229"
        ]
    },
    {
        "id": 914,
        "expression": "^(\\d{2}((0[1-9]|1[012])(0[1-9]|1\\d|2[0-8])|(0[13456789]|1[012])(29|30)|(0[13578]|1[02])31)|([02468][048]|[13579][26])0229)$",
        "description": "yyMMdd with leap years.\nMinimized expression.\nAs we have only 2 numbers for the years, dates 1600, 2000, etc are still validated.",
        "matches": [
            "001231",
            "000229",
            "040229"
        ],
        "non_matches": [
            "003112",
            "000431",
            "010229"
        ]
    },
    {
        "id": 915,
        "expression": "^([01]\\d|2[0123])([0-5]\\d){2}$",
        "description": "HHmmss without any separators. Hours in 24h format.",
        "matches": [
            "235959",
            "000000",
            "012345"
        ],
        "non_matches": [
            "240000",
            "23:59:59",
            "236060"
        ]
    },
    {
        "id": 916,
        "expression": "(^\\d*\\.?\\d*[0-9]+\\d*$)|(^[0-9]+\\d*\\.\\d*$)",
        "description": "This matches all positive decimal values. There was one here already which claimed to but would fail on value 0.00 which is positive AFAIK...",
        "matches": [
            "0.00",
            "1.23",
            "4.56"
        ],
        "non_matches": [
            "-1.03",
            "-0.01",
            "-0.00"
        ]
    },
    {
        "id": 918,
        "expression": "^(((0[1-9]|1[012])/(0[1-9]|1\\d|2[0-8])|(0[13456789]|1[012])/(29|30)|(0[13578]|1[02])/31)/[2-9]\\d{3}|02/29/(([2-9]\\d)(0[48]|[2468][048]|[13579][26])|(([2468][048]|[3579][26])00)))$",
        "description": "MM/dd/yyyy with 100% leap year validation starting from year 2000.\nIf this one doesn't fit your needs, just tell me.\nSorry for starting &quot;only&quot; from year 2000, this is so simple to change this, please ask if needed.\nEnjoy",
        "matches": [
            "02/29/2000",
            "02/29/2004",
            "12/31/2001"
        ],
        "non_matches": [
            "02/29/2100",
            "02/29/2001",
            "1/1/2001"
        ]
    },
    {
        "id": 919,
        "expression": "^\\-?[0-9]{1,3}(\\,[0-9]{3})*(\\.[0-9]+)?$|^[0-9]+(\\.[0-9]+)?$",
        "description": "Formatted Number with \",\" as thousand separator and \".\" as decimal separator. now accept numbers without separators of thousands.",
        "matches": [
            "10,000,000.123",
            "3.14159265"
        ],
        "non_matches": [
            "2.7,1828183"
        ]
    },
    {
        "id": 923,
        "expression": "[AaEeIiOoUuYy]",
        "description": "This simple reg-ex accepts any vowel letter.",
        "matches": [
            "a",
            "o",
            "e"
        ],
        "non_matches": [
            "z",
            "x",
            "w"
        ]
    },
    {
        "id": 926,
        "expression": "^(?=.*[1-9].*$)\\d{0,7}(?:\\.\\d{0,9})?$",
        "description": "Allows up to seven digits to the left and up to nine digits to the right of an optional decimal place.\nLeading zeros on the left of the decimal are accepted.\nOnly positive values are accepted.",
        "matches": [
            "1",
            "0123456.123456789",
            ".123456789"
        ],
        "non_matches": [
            ".0123456789",
            "0.0",
            "-1"
        ]
    },
    {
        "id": 928,
        "expression": "((http\\://|https\\://|ftp\\://)|(www.))+(([a-zA-Z0-9\\.-]+\\.[a-zA-Z]{2,4})|([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}))(/[a-zA-Z0-9%:/-_\\?\\.'~]*)?",
        "description": "This RE matches the web links which begin http://, ftp://, https:// or www.\nYou can edit this disadvantage easy...",
        "matches": [
            "www.diskusneforum.sk",
            "http://diskusneforum.sk",
            "ftp://23.45.267.189/"
        ],
        "non_matches": [
            "diskusneforum.sk",
            "localhost"
        ]
    },
    {
        "id": 929,
        "expression": "^\\$( )*\\d*(.\\d{1,2})?$",
        "description": "Validates US currency but allows for spaces between the dollar sign and dollar amount. If there is cents the period validates to two decimal places",
        "matches": [
            "$100.00",
            "$100",
            "$10.25"
        ],
        "non_matches": [
            "100.",
            "$10.233",
            "$10."
        ]
    },
    {
        "id": 930,
        "expression": "/\\*.+?\\*/",
        "description": "Searches for SQL comments within a T-SQL statement...",
        "matches": [
            "/* This is a T-SQL comment! */"
        ],
        "non_matches": [
            "SELECT * FROM Customers"
        ]
    },
    {
        "id": 932,
        "expression": "^([1-9]{1}(([0-9])?){2})+(,[0-9]{1}[0-9]{2})*$",
        "description": "Matchs comma delimited numbers. Easily changed to allow for other delimiters. (Edit &quot;,&quot;)\nDoes not allow a leading 0\nDoes not allow groups of numbers with less than 3 numbers, exculding the first group.",
        "matches": [
            "123,123,123,123",
            "100,120,000,010,011",
            "1,123,123,123"
        ],
        "non_matches": [
            "012,123,123,123",
            "12343,1244,4,12",
            ",123,123,123"
        ]
    },
    {
        "id": 933,
        "expression": "\\{\\\\\\*\\\\bkmkstart\\s(.*?)\\}",
        "description": "Applied to a .RTF document, returns all the names of the# bookmarks. Useful to retrieve# dinamically# the list of bookmarks from a document.",
        "matches": [
            "{\\*\\bkmkstart TagAmountDigits}",
            "({\\*\\bkmkstart TagAmountText}"
        ],
        "non_matches": [
            "{\\*\\bkmkend TagAmountText}"
        ]
    },
    {
        "id": 936,
        "expression": "\"[^\"\\r\\n]*\"",
        "description": "returns string between two quotes",
        "matches": [
            "Return Parent.DB.GetDataReader(\"CauseImmediateGet\", MyIncidentEventTypeID)"
        ],
        "non_matches": [
            "Return Parent.DB.GetDataReader(CauseImmediateGet\", MyIncidentEventTypeID)"
        ]
    },
    {
        "id": 937,
        "expression": "^\\d{3}-\\d{7}[0-6]{1}$",
        "description": "Airway bill no that allows only the format 999-99999998 and does not allow the last digit to be 7,8,9.",
        "matches": [
            "999-99999995",
            "123-47859683",
            "156-78965422"
        ],
        "non_matches": [
            "123-47859689",
            "9999999999",
            "9588-58964"
        ]
    },
    {
        "id": 940,
        "expression": "(^[0-9]*[1-9]+[0-9]*\\.[0-9]*$)|(^[0-9]*\\.[0-9]*[1-9]+[0-9]*$)|(^[0-9]*[1-9]+[0-9]*$)",
        "description": "Positive real number greater than zero.",
        "matches": [
            "0.01",
            "010001.011010",
            ".234"
        ],
        "non_matches": [
            "0.00 OR .",
            "010001.011010E",
            "1.234.5"
        ]
    },
    {
        "id": 943,
        "expression": "(a(?:[cdefgilmnoqrstuwxz]|ero|(?:rp|si)a)|b(?:[abdefghijmnorstvwyz]iz)|c(?:[acdfghiklmnoruvxyz]|at|o(?:m|op))|d[ejkmoz]|e(?:[ceghrstu]|du)|f[ijkmor]|g(?:[abdefghilmnpqrstuwy]|ov)|h[kmnrtu]|i(?:[delmnoqrst]|n(?:fo|t))|j(?:[emop]|obs)|k[eghimnprwyz]|l[abcikrstuvy]|m(?:[acdeghklmnopqrstuvwxyz]|il|obi|useum)|n(?:[acefgilopruz]|ame|et)|o(?:m|rg)|p(?:[aefghklmnrstwy]|ro)|qa|r[eosuw]|s[abcdeghijklmnortuvyz]|t(?:[cdfghjklmnoprtvwz]|(?:rav)?el)|u[agkmsyz]|v[aceginu]|w[fs]|y[etu]|z[amw])",
        "description": "This regexp matches all existing TLDs (Top-Level Domains) according to IANA specifications as of 14/07/2007.",
        "matches": [
            "all ccTLDs (Country-Code Top-Level Domains)",
            "all gTLDs (Generic Top-Level Domains)",
            ".arpa"
        ],
        "non_matches": [
            "n.o.n - e.x.i.s.t.i.n.g T.L.D.s"
        ]
    },
    {
        "id": 946,
        "expression": "^((\\d|\\d\\d|[0-1]\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|\\d\\d|[0-1]\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|\\d\\d|[0-1]\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|\\d\\d|[0-1]\\d\\d|2[0-4]\\d|25[0-5]))$",
        "description": "Matches valids TCP/IP-Adresses",
        "matches": [
            "1.198.0.1",
            "100.10.0.1",
            "200.200.123.123"
        ],
        "non_matches": [
            "..12.23",
            "a.23.345",
            "400.500.300.300"
        ]
    },
    {
        "id": 947,
        "expression": "^(((0?[1-9]|1[012])/(0?[1-9]|1\\d|2[0-8])|(0?[13456789]|1[012])/(29|30)|(0?[13578]|1[02])/31)/(19|[2-9]\\d)\\d{2}|0?2/29/((19|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|(([2468][048]|[3579][26])00)))$",
        "description": "MM/dd/yyyy with 100% leap years. Valid since year 1900.\nMM and DD could have 1 or 2 digits : M/d/yyyy or MM/d/yyyy or M/dd/yyyy\nThis was a request from a user in http://www.regexlib.com/REDetails.aspx?regexp_id=1038",
        "matches": [
            "01/31/1905",
            "1/9/1900",
            "2/29/1904"
        ],
        "non_matches": [
            "31/01/2005",
            "02/29/2005",
            "2/29/2005"
        ]
    },
    {
        "id": 948,
        "expression": "^(?=.*\\d)(?=.*[a-zA-Z])(?!.*[\\W_\\x7B-\\xFF]).{6,15}$",
        "description": "Password validator\nRequires 6-20 characters including at least 1 upper or lower alpha, and 1 digit.\nIt should disallow just about everything else, inluding extended characters.",
        "matches": [
            "abc123",
            "BA99342bob",
            "1232z123311"
        ],
        "non_matches": [
            "abcdef",
            "123456",
            "123'ABC"
        ]
    },
    {
        "id": 949,
        "expression": "^([a-zA-Z].*|[1-9].*)\\.(((j|J)(p|P)(g|G))|((g|G)(i|I)(f|F)))$",
        "description": "Regular expression to limit types of files accepted. This example matches .jpg and .gif files only.",
        "matches": [
            "filename.jpg",
            "FileName.JPG",
            "filename.gif"
        ],
        "non_matches": [
            "filename.png",
            "filename.xxx",
            "filename.bmp"
        ]
    },
    {
        "id": 950,
        "expression": "^[^']*?\\&lt;\\s*Assembly\\s*:\\s*AssemblyVersion\\s*\\(\\s*&quot;(\\*|[0-9]+.\\*|[0-9]+.[0-9]+.\\*|[0-9]+.[0-9]+.[0-9]+.\\*|[0-9]+.[0-9]+.[0-9]+.[0-9]+)&quot;\\s*\\)\\s*\\&gt;.*$",
        "description": "Matches the AssemblyVersion attribute in an Assembly.vb file. The version value is captured.",
        "matches": [
            "&lt;Assembly: AssemblyVersion(&quot;1.0.*&quot;)&gt; (all version formats, i.e.: * to 1.0.0.0)"
        ],
        "non_matches": [
            "'&lt;Assembly: AssemblyVersion(&quot;1.0.*&quot;)&gt; (commented lines)"
        ]
    },
    {
        "id": 952,
        "expression": "^(\\$\\ |\\$)?((0|00|[1-9]\\d*|([1-9]\\d{0,2}(\\,\\d{3})*))(\\.\\d{1,4})?|(\\.\\d{1,4}))$",
        "description": "Allows for a dollar sign with no space after, a dollar sign with a space after, and no dollar sign. Also makes sure theres no more than 4 decimal places. Takes out leading zeros if the number isn't 0, and protects against blank entries.",
        "matches": [
            "$ 123.4",
            "$00.5",
            "200,000"
        ],
        "non_matches": [
            "$012,234.44",
            "-39.05",
            "$45,23,330.00"
        ]
    },
    {
        "id": 954,
        "expression": "^[A-Z1-9]{5}-[A-Z1-9]{5}-[A-Z1-9]{5}-[A-Z1-9]{5}-[A-Z1-9]{5}$",
        "description": "Simple Microsoft product key check.",
        "matches": [
            "12345-12345-12345-12345-12345",
            "ABCDE-ABCDE-ABCDE-ABCDE-ABCDE",
            "AB5DE-AB5DE-AB5DE-AB5DE-AB5DE"
        ],
        "non_matches": [
            "12345-123-123456-12345",
            "ABC-ABCDEF-ABCDE-ABCDE",
            "12AB5-ABC-12AB567-12AB5"
        ]
    },
    {
        "id": 957,
        "expression": "&amp;\\#x0*(0|1|2|3|4|5|6|7|8|B|C|E|F|10|11|12|13|14|15|16|17|18|19|1A|1B|1C|1D|1E|1F);",
        "description": "Can be used to match on (and strip out) low-order non-printable ASCII characters (ASCII 0-31) from string data prior to adding to an XML document. Useful when using parsers like Microsoft's MSXML3 that strictly enforce W3C specification on allowable characters. Does not match on ASCII 9 (horiz tab), 10 (carriage return), 13 (line feed).",
        "matches": [
            "&amp;#x2;",
            "&amp;#x001F;"
        ],
        "non_matches": [
            "&amp;#x0020;",
            "&amp;#xDFFF;"
        ]
    },
    {
        "id": 965,
        "expression": "(^(\\d{2}.\\d{3}.\\d{3}/\\d{4}-\\d{2})|(\\d{14})$)|(^(\\d{3}.\\d{3}.\\d{3}-\\d{2})|(\\d{11})$)",
        "description": "Validador de CPF ou CNPJ brasileiro. Utilizado em campos que podem receber os dois valores, como um campo de busca, que pode buscar por CPF ou CNPJ, como era o meu caso.\n[00.000.000/0000-00], [123.456.789-98],[00000000000000] e [12345678998]\nEnjoy! =)",
        "matches": [
            "00.000.000/0000-00",
            "123.456.789-98",
            "12345678901234"
        ],
        "non_matches": [
            "12.123.123.0001.12",
            "123.456.789.89"
        ]
    },
    {
        "id": 966,
        "expression": "^([1-9]{1}[\\d]{0,2}(\\.[\\d]{3})*(\\,[\\d]{0,2})?|[1-9]{1}[\\d]{0,}(\\,[\\d]{0,2})?|0(\\,[\\d]{0,2})?|(\\,[\\d]{1,2})?)$",
        "description": "Numera&#231;&#227;o usar para valores moeda brasileira e de outras regi&#245;es. Dinheiro, money...\nEnjoy! =)",
        "matches": [
            "123,02",
            "123.456,02",
            "123.456.789,02"
        ],
        "non_matches": [
            "123,003",
            "123,123.02"
        ]
    },
    {
        "id": 968,
        "expression": "(^[A-Z]{1,2}[0-9]{1,}:{1}[A-Z]{1,2}[0-9]{1,}$)|(^\\$(([A-Z])|([a-z])){1,2}([0-9]){1,}:{1}\\$(([A-Z])|([a-z])){1,2}([0-9]){1,}$)|(^\\$(([A-Z])|([a-z])){1,2}(\\$){1}([0-9]){1,}:{1}\\$(([A-Z])|([a-z])){1,2}(\\$){1}([0-9]){1,}$)",
        "description": "Matching any valid MS Excel range",
        "matches": [
            "A1:BB10",
            "$A1:$BB10",
            "$A$1:$BB$10"
        ],
        "non_matches": [
            "$A1:BB10"
        ]
    },
    {
        "id": 969,
        "expression": "(^[A-Z]{1,2}[0-9]{1,}:{1}[A-Z]{1,2}[0-9]{1,}$)|(^\\$(([A-Z])|([a-z])){1,2}([0-9]){1,}:{1}\\$(([A-Z])|([a-z])){1,2}([0-9]){1,}$)|(^\\$(([A-Z])|([a-z])){1,2}(\\$){1}([0-9]){1,}:{1}\\$(([A-Z])|([a-z])){1,2}(\\$){1}([0-9]){1,}$)",
        "description": "A regular expression for any valid MS Excel range",
        "matches": [
            "A1:BB10",
            "$A1:$BB10",
            "$A$1:$BB$10"
        ],
        "non_matches": [
            "$A1:BB10"
        ]
    },
    {
        "id": 970,
        "expression": "\\\\\\\\\\w+?(?:\\\\[\\w\\s$]+)+",
        "description": "Detect windows share path (unc path)",
        "matches": [
            "\\\\server\\share\\subdir1\\subdir2;",
            "&quot;\\\\server\\share$\\subdir1 with space\\subdir2&quot;"
        ],
        "non_matches": [
            "\\server\\share"
        ]
    },
    {
        "id": 971,
        "expression": "(^\\d*\\.\\d{2}$)",
        "description": "If you need a textbox to allow only positive numbers with two decimal places, try this. I wanted the user to be able to enter any type of currency amount (US of course) but also have two decimal places for database field.",
        "matches": [
            "12.56",
            "0.25",
            "156.56"
        ],
        "non_matches": [
            "-123.45",
            "1.023",
            "1.2"
        ]
    },
    {
        "id": 972,
        "expression": "^[NS]([0-8][0-9](\\.[0-5]\\d){2}|90(\\.00){2})\\040[EW]((0\\d\\d|1[0-7]\\d)(\\.[0-5]\\d){2}|180(\\.00){2})$",
        "description": "Validate location, latitude and longitude separated by space, where latitude is expressed as compass direction (N or S),degrees,minutes,seconds and longitude is expressed as compassdirection (E or W) ,degrees,minutes,seconds.\nRange check for minutes and seconds (0-59),\nmax.latitude 90.00.00, max longitude 180.00.00",
        "matches": [
            "N90.00.00 E180.00.00",
            "S34.59.33 W179.59.59",
            "N00.00.00 W000.00.00"
        ],
        "non_matches": [
            "N91.00.00 E181.00.00",
            "Z34.59.33 W179.59.59",
            "N00.00.00 W181.00.00"
        ]
    },
    {
        "id": 975,
        "expression": "((xmlns:.*?=[&quot;,'].*?[&quot;,'])|(xmlns=[&quot;,'].*?[&quot;,']))",
        "description": "XML Namespace ( xmlns ) matcher. Properly matches one or more of either xmlns=&quot;blah&quot; or xmlns:blah=&quot;blooey&quot; .\n(for c#, make sure to escape the double-quotes.)",
        "matches": [
            "&lt;Registry xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:xsi=&quot;http://www.w3.or"
        ],
        "non_matches": [
            "&lt;Registry someattrib=&quot;test&quot; /&gt;"
        ]
    },
    {
        "id": 976,
        "expression": "(?<=,)\\s*(?=,)|^(?=,)|[^\\\"]{2,}(?=\\\")|([^,\\\"]+(?=,|$))",
        "description": "Use for parsing CSV files exported from MS Excel, This program adds or not quotes, so it's more complicated..\nUse for parsing individual lines, the Regex doesn't capture end of line (supposed to ($) but not made it in the testing so you cannot parse the whole file.\nRead a line and split it, with this regex",
        "matches": [
            ",Casa en condominio / Traspaso,\"$270,000 \",\"mn,\",\"Toluca,\",\"67 m2"
        ],
        "non_matches": [
            "\"\""
        ]
    },
    {
        "id": 977,
        "expression": "/\\*((?!\\*/)[\\d\\D\\s])*\\*/",
        "description": "Matches /* style comments */.\nMatches whitespace (so can detect tabs, etc.)\nProblems with nested comments.",
        "matches": [
            "/* CSS comments */",
            "/* multi-line SQL/CSS/Etc comments */"
        ],
        "non_matches": [
            "&lt;!-- doesn't match --&gt;",
            "-- won't match and //won't match"
        ]
    },
    {
        "id": 979,
        "expression": "(?=^.{6,10}$)(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[!@#$%^&amp;*()_+}{&quot;:;'?/&gt;.&lt;,])(?!.*\\s).*$",
        "description": "This regular expression match can be used for validating strong password. It expects atleast 1 small-case letter, 1 Capital letter, 1 digit, 1 special character and the length should be between 6-10 characters. The sequence of the characters is not important. This expression follows the above 4 norms specified by microsoft for a strong password.",
        "matches": [
            "1A2a$5",
            "1234567Tt#",
            "Tsd677%"
        ],
        "non_matches": [
            "Tt122",
            "1tdfy34564646T*"
        ]
    },
    {
        "id": 984,
        "expression": "^(102[0-3]|10[0-1]\\d|[1-9][0-9]{0,2}|0)$",
        "description": "Port Numbers: Well Known Ports: 0 through 1023. Matches numbers in range of 0 through 1023.",
        "matches": [
            "0",
            "123",
            "1023"
        ],
        "non_matches": [
            "1024",
            "9999",
            "99999"
        ]
    },
    {
        "id": 985,
        "expression": "^(4915[0-1]|491[0-4]\\d|490\\d\\d|4[0-8]\\d{3}|[1-3]\\d{4}|[2-9]\\d{3}|1[1-9]\\d{2}|10[3-9]\\d|102[4-9])$",
        "description": "Port Numbers: Registered Ports: 1024 through 49151. Matches numbers in range of 1024 through 49151.",
        "matches": [
            "1024",
            "49151",
            "30100"
        ],
        "non_matches": [
            "1023",
            "49152",
            "50000"
        ]
    },
    {
        "id": 986,
        "expression": "^(6553[0-5]|655[0-2]\\d|65[0-4]\\d\\d|6[0-4]\\d{3}|5\\d{4}|49[2-9]\\d\\d|491[6-9]\\d|4915[2-9])$",
        "description": "Port Numbers: Dynamic and/or Private Ports: 49152 through 65535. Matches numbers in range of 49152 through 65535.",
        "matches": [
            "49152",
            "65535",
            "50000"
        ],
        "non_matches": [
            "49151",
            "65536",
            "66000"
        ]
    },
    {
        "id": 987,
        "expression": "^(4915[0-1]|491[0-4]\\d|490\\d\\d|4[0-8]\\d{3}|[1-3]\\d{4}|[1-9]\\d{0,3}|0)$",
        "description": "Port Numbers: Well Known Ports &amp; Registered Ports: 0 through 49151. Matches numbers in range of 0 through 49151.",
        "matches": [
            "0",
            "1023",
            "49151"
        ],
        "non_matches": [
            "49152",
            "50000",
            "60000"
        ]
    },
    {
        "id": 988,
        "expression": "^(6553[0-5]|655[0-2]\\d|65[0-4]\\d\\d|6[0-4]\\d{3}|[1-5]\\d{4}|[1-9]\\d{0,3}|0)$",
        "description": "Port Numbers: Well Known Ports, Registered Ports &amp; Dynamic and/or Private Ports: 0 through 65536. Matches numbers in range of 0 through 65536.",
        "matches": [
            "1023",
            "49151",
            "65535"
        ],
        "non_matches": [
            "65536",
            "66000",
            "67000"
        ]
    },
    {
        "id": 989,
        "expression": "^((([hH][tT][tT][pP][sS]?|[fF][tT][pP])\\:\\/\\/)?([\\w\\.\\-]+(\\:[\\w\\.\\&%\\$\\-]+)*@)?((([^\\s\\(\\)\\<\\>\\\\\\\"\\.\\[\\]\\,@;:]+)(\\.[^\\s\\(\\)\\<\\>\\\\\\\"\\.\\[\\]\\,@;:]+)*(\\.[a-zA-Z]{2,4}))|((([01]?\\d{1,2}|2[0-4]\\d|25[0-5])\\.){3}([01]?\\d{1,2}|2[0-4]\\d|25[0-5])))(\\b\\:(6553[0-5]|655[0-2]\\d|65[0-4]\\d{2}|6[0-4]\\d{3}|[1-5]\\d{4}|[1-9]\\d{0,3}|0)\\b)?((\\/[^\\/][\\w\\.\\,\\?\\'\\\\\\/\\+&%\\$#\\=~_\\-@]*)*[^\\.\\,\\?\\\"\\'\\(\\)\\[\\]!;<>{}\\s\\x7F-\\xFF])?)$",
        "description": "Matches a URL string by: protocol,subdomain,domain,ip address,port number,path and/or filename",
        "matches": [
            "http://regexlib.com",
            "https://regexlib.com:80",
            "66.129.120.94/Search.aspx"
        ],
        "non_matches": [
            "http:/regexlib.com",
            "https://regexlib.com:65536",
            "66.129.120.256/Search.aspx."
        ]
    },
    {
        "id": 990,
        "expression": "^((0?[1-9]|1[012])(\\s*:\\s*([0-5]\\d))?(\\s*:\\s*([0-5]\\d))?(\\s*([AaPp])[Mm]?)$|(2[0-3]|[1]\\d|0?\\d)(\\s*:\\s*([0-5]\\d))(\\s*:\\s*([0-5]\\d))?)$",
        "description": "Matches a time string. A loose validation for easy user entry. Saves the information needed for a correct time setting.",
        "matches": [
            "3:00:59",
            "12pm",
            "6:30 a"
        ],
        "non_matches": [
            "12",
            "25pm",
            "6:60 a"
        ]
    },
    {
        "id": 991,
        "expression": "(^[0-9]{0,10}$)",
        "description": "Good For Validating Phone numbers that are 0 to 9 in length",
        "matches": [
            "123456",
            "12354",
            "456443"
        ],
        "non_matches": [
            "456abcd"
        ]
    },
    {
        "id": 992,
        "expression": "&lt;a[a-zA-Z0-9 =&quot;'.:;?]*(name=){1}[a-zA-Z0-9 =&quot;'.:;?]*\\s*((/&gt;)|(&gt;[a-zA-Z0-9 =&quot;'&lt;&gt;.:;?]*&lt;/a&gt;))",
        "description": "This expression matches only valid html anchors. Those are anchors with an attribute name=. Such anchor can be closed either with &lt;/a&gt; or with /&gt;.\nIf someone can help - one thing still missing is not matching html tags with parameter href, becazse such should be considered as non valid anchors.",
        "matches": [
            "&lt;a name=&quot;anchorName&quot;&gt;Anchor&lt;/a&gt;",
            "&lt;a name=anchorName /&gt;"
        ],
        "non_matches": [
            "&lt;a href=&quot;somewhere&quot;&gt;",
            "&lt;a href&gt;",
            "&lt;a name /&gt;"
        ]
    },
    {
        "id": 993,
        "expression": "^\\$?([1-9][0-9]{3,}(\\.\\d{2})?|(\\d{1,3}\\,\\d{3}|\\d{1,3}\\,\\d{3}(\\.\\d{2})?)|(\\d{1,3}\\,\\d{3}|\\d{1,3}\\,\\d{3}\\,\\d{3}(\\.\\d{2})?)*)?$",
        "description": "Currency which cannot be less than $1000 and lower than a billion.",
        "matches": [
            "$1000",
            "$1,000,000.00",
            "9,999"
        ],
        "non_matches": [
            "999.00",
            "$1,000,000,000.00",
            "5.00"
        ]
    },
    {
        "id": 995,
        "expression": "(([a-zA-Z]{3}[0-9]{3})|(\\w{2}-\\w{2}-\\w{2})|([0-9]{2}-[a-zA-Z]{3}-[0-9]{1})|([0-9]{1}-[a-zA-Z]{3}-[0-9]{2})|([a-zA-Z]{1}-[0-9]{3}-[a-zA-Z]{2}))",
        "description": "Dutch licenceplate check also including scooters#\nABC123#\n12-AB-AB#\n12-ABC-1#\n1-ABC-12#\nA-123-AB#",
        "matches": [
            "ABC123",
            "12-AB-AB",
            "12-ABC-1"
        ],
        "non_matches": [
            "12ABAB",
            "12ABC1",
            "1ABC12"
        ]
    },
    {
        "id": 996,
        "expression": "(\\/\\*(\\s*|.*?)*\\*\\/)|(--.*)",
        "description": "This pattern will match any multi-line or single line comments in TSQL (Stored Procedures or SPROC's) in MS SQL Server.",
        "matches": [
            "/* My Comment */",
            "-- A single line comment"
        ],
        "non_matches": [
            "*/ Won't work /*",
            "// Not likely",
            "- uh uh"
        ]
    },
    {
        "id": 997,
        "expression": "(:[a-z]{1}[a-z1-9\\$#_]*){1,31}",
        "description": "This matches oracle binding variables in SQL. Not sure if it is the same with other RDBMS'",
        "matches": [
            ":x",
            ":x1",
            ":x#2$"
        ],
        "non_matches": [
            ":1x",
            ":@x",
            ":*ac"
        ]
    },
    {
        "id": 998,
        "expression": "^([A-Z\\d]{3})[A-Z]{2}\\d{2}([A-Z\\d]{1})([X\\d]{1})([A-Z\\d]{3})\\d{5}$",
        "description": "US vehicle VIN numbers for vehicles with GVW &lt; 10k lbs",
        "matches": [
            "WDBCA45EXKA478654"
        ],
        "non_matches": [
            "WDBCA45EXKA47865a"
        ]
    },
    {
        "id": 999,
        "expression": "(?<!\\\\)\\[(\\\\\\[|\\\\\\]|[^\\[\\]]|(?<!\\\\)\\[.*(?<!\\\\)\\])*(?<!\\\\)\\]",
        "description": "This regular expression will find the highest level groups within recursive tokens. For instance, if I have &quot;This is [just [an] example] of the [expression]&quot;, it'll find [just [an] example] and [expression], and nothing else. It will also not find an escaped bracket expression. If you want to replace the bracket with curly braces or parenthesis, be careful. As an example, curly braces will be: (?&lt;!\\\\)\\{(\\\\\\{|\\\\\\}|[^\\{\\}]|(?&lt;!\\\\)\\{.*(?&lt;!\\\\)\\})*(?&lt;!\\\\)\\}",
        "matches": [
            "[just]",
            "[just [an] example]"
        ],
        "non_matches": [
            "\\[just]"
        ]
    },
    {
        "id": 1000,
        "expression": "^[0-9,+,(), ,]{1,}(,[0-9]+){0,}$",
        "description": "It could be used to validate local as well as International Phone nos where the number my be preceeding by + sign for(00) and may have brackets to accept the city code like (22).It will also accept space in between like 001 116 23314",
        "matches": [
            "0091(22) 31544",
            "+1 (116) 23314",
            "+91(22)311545"
        ],
        "non_matches": [
            "91 (22) abc21",
            "+91 (abc) 23321",
            "00111623314abc"
        ]
    },
    {
        "id": 1001,
        "expression": "^(.){0,20}$",
        "description": "This limits an HTML textarea to only be 20 characters. Built for an ASP:regularexpression tag to validate a textarea.",
        "matches": [
            "I match",
            "I match 2"
        ],
        "non_matches": [
            "hey I don't match at all"
        ]
    },
    {
        "id": 1003,
        "expression": "^((\\d|[1-9]\\d|2[0-4]\\d|25[0-5]|1\\d\\d)(?:\\.(\\d|[1-9]\\d|2[0-4]\\d|25[0-5]|1\\d\\d)){3})$",
        "description": "validates a simple ip v4 address. including 0.0.0.0 or 255.255.255.255. leading 0 is and numbers above 255 are forbitten.",
        "matches": [
            "0.0.0.0",
            "255.255.255.255",
            "168.129.2.255"
        ],
        "non_matches": [
            "02.234.2.1",
            "168.192.0.256",
            "1233.0.0.1"
        ]
    },
    {
        "id": 1006,
        "expression": "^\\+?\\(?\\d+\\)?(\\s|\\-|\\.)?\\d{1,3}(\\s|\\-|\\.)?\\d{4}$",
        "description": "Simply matches a telephone number. Not meant to be extremly accurate but more for q uick match or extracting from a body of text. Does not support extensions",
        "matches": [
            "555 5555",
            "(555) 555-5555",
            "+555 5555555"
        ],
        "non_matches": [
            "+ 55 5555",
            "() 555 5555"
        ]
    },
    {
        "id": 1007,
        "expression": "^\\+?\\(?\\d+\\)?(\\s|\\-|\\.)?\\d{1,3}(\\s|\\-|\\.)?\\d{4}$",
        "description": "Simply matches a telephone number. Not meant to be extremly accurate but more for q uick match or extracting from a body of text. Does not support extensions",
        "matches": [
            "555 5555",
            "(555) 555-5555",
            "+555 5555555"
        ],
        "non_matches": [
            "+ 55 5555",
            "() 555 5555"
        ]
    },
    {
        "id": 1008,
        "expression": "^[1-9]+[0-9]*$",
        "description": "Allows only positive numbers, greater than zero",
        "matches": [
            "1",
            "10",
            "135"
        ],
        "non_matches": [
            "0",
            "-1",
            "aaa"
        ]
    },
    {
        "id": 1009,
        "expression": "(?=^.{6,51}$)([A-Za-z]{1})([A-Za-z0-9!@#$%_\\^\\&amp;\\*\\-\\.\\?]{5,49})$",
        "description": "This expression was originally developed for user names. Matching text must have 6 - 50 characters, cannot contain spaces, must begin with an alpha character, can contain mixed case alpha, digits, and the following special characters:\n! @ # $ % ^ &amp; * - . _ ?",
        "matches": [
            "aB!@#%&amp;^$.?*-0123456789Yz",
            "user@somedomain.com",
            "Excla!Us_er"
        ],
        "non_matches": [
            "1234567890",
            "aB1()[]{};:'&quot;,&lt;&gt;/\\_=0Yz",
            "!exclaUser"
        ]
    },
    {
        "id": 1010,
        "expression": "([^a-zA-Z0-9])",
        "description": "(Corrected)\nThis pattern will match 1 instance of a NON-alphanumeric character. This is very handy to use when y\nou want to filter input only by alphanumeric characters, by using Regex.Replace.\nHowever, when used in a Regex.Replace, it will replace all instances of non-alphanumeric characters\nwith specified character.",
        "matches": [
            "Test!",
            "This will match",
            "H3llo$"
        ],
        "non_matches": [
            "Test",
            "Thiswillnotmatch",
            "H3llo"
        ]
    },
    {
        "id": 1011,
        "expression": "^([a-zA-Z][a-zA-Z\\&amp;amp;\\-\\.\\'\\s]*|)$",
        "description": "This expression will allow Letters, periods, apostrophe, dashes.",
        "matches": [
            "muk.dub'ey-j ava"
        ],
        "non_matches": [
            "muk_12 dubey`.ja"
        ]
    },
    {
        "id": 1012,
        "expression": "\\b(get)\\b.*{",
        "description": "This piece of regex catches the if the open braces are not placed the line under a get command",
        "matches": [
            "get {"
        ],
        "non_matches": [
            "get"
        ]
    },
    {
        "id": 1013,
        "expression": "\\bfor\\b.*[A-Za-z][&lt;&gt; ][\\d]",
        "description": "This regex catches the hard-coded for blocks",
        "matches": [
            "for (i=1;i&lt;7;i++)"
        ],
        "non_matches": [
            "for (i=1;i&lt;MyEnd;i++)"
        ]
    },
    {
        "id": 1014,
        "expression": "\\b(byte|char|short|long|float|int|double|decimal|bool|string)\\b.*\\s[a-zA-Z](?=;)",
        "description": "This regex catches if the variable isn't initialized when it is declared",
        "matches": [
            "int a;"
        ],
        "non_matches": [
            "int a =5;"
        ]
    },
    {
        "id": 1015,
        "expression": "(\\bprotected\\b.*(public))|(\\bprivate\\b.*(protected))|(\\bprivate\\b.*(public))",
        "description": "This regex catches illegal precedence order of declerations of a class",
        "matches": [
            "class SomeClass:private BaseClass1, public BaseClass2, protected BaseClass3"
        ],
        "non_matches": [
            "class SomeClass:public BaseClass1, protected BaseClass2, private BaseClass3"
        ]
    },
    {
        "id": 1016,
        "expression": "\\b(\\w+).\\1",
        "description": "This regex catches the redundacy of including class names in the name of class properties.",
        "matches": [
            "Book.BookPage"
        ],
        "non_matches": [
            "Book.Page"
        ]
    },
    {
        "id": 1017,
        "expression": "\\b(public|private|protected|internal)\\b.*(byte|char|short|long|float|int|double|decimal|bool|string)\\b.*(?=,)",
        "description": "This regex forces the programmer to make only one decleration per line.",
        "matches": [
            "private int height, width;"
        ],
        "non_matches": [
            "private int height;"
        ]
    },
    {
        "id": 1018,
        "expression": "((\\bm_[a-zA-Z\\d]*\\b)|(\\bin_[a-zA-Z\\d]*\\b)|(\\bin _[a-zA-Z\\d]*\\b))",
        "description": "This regex limits the use of any special prefix characters to indicate that the variable is scoped to the class.",
        "matches": [
            "in_name",
            "m_name"
        ],
        "non_matches": [
            "this.name"
        ]
    },
    {
        "id": 1019,
        "expression": "\\binterface\\b.*(\\bI[_]\\w*\\b)",
        "description": "This regex forbids the use of underscore in the interface decleration.",
        "matches": [
            "interface I_Point"
        ],
        "non_matches": [
            "interface IPoint"
        ]
    },
    {
        "id": 1047,
        "expression": "(<[^>]*?tag[^>]*?(?:identify_by)[^>]*>)((?:.*?(?:<[ \\r\\t]*tag[^>]*>?.*?(?:<.*?/.*?tag.*?>)?)*)*)(<[^>]*?/[^>]*?tag[^>]*?>)",
        "description": "This Pattern matches a HTML like tag and its closing tag without any childtags, that was identified by an attribute or anything identifiable (?) mark inside the opening tag.\nLook for A as Tag and 1 ans identifier. A greedy expression woulds usualy end at the A 2 closing tag, non-greedy will probably end at the A 3 end tag.\ne.g.:\n&lt;A 1&gt;\n&lt;A 2&gt;\n&lt;A 2&gt;dfgdfg&lt;/A&gt;\n&lt;/A&gt;\n&lt;Z&gt;&lt;/Z&gt;\n&lt;/A&gt;\n&lt;A 3&gt;\n&lt;/A&gt;\nReturns:\n0 Full Match\n1 Whole starttag\n2 Content inside the tag\n3 Whole endtag\nP.S.: I use it in a parser, to find tags and add code to them, without to know the code, the content or any further infomation.",
        "matches": [
            "<tag name=\"identify_by\">jskdfjkfb</tag>"
        ],
        "non_matches": [
            "have a look at the description."
        ]
    },
    {
        "id": 1049,
        "expression": "(?<=(?:\\\\))[a-zA-Z0-9\\-\\s_]*(?=(?:\\.\\w*$))",
        "description": "WINDOWS ONLY\nUseful to get the filename whenever you get it from anysource, recommended for non-critical filename-dependant applications.",
        "matches": [
            "c:\\program files\\anyfolder\\file.xls",
            "c:\\program files\\any.folder\\file with weird name_.xls"
        ],
        "non_matches": [
            "c:\\program files\\anyfolder\\file*.xls",
            "c:\\program files\\anyfolder\\file?.xls",
            "c:\\program files\\anyfo"
        ]
    },
    {
        "id": 1051,
        "expression": "&lt;!\\[CDATA\\[([^\\]]*)\\]\\]&gt;",
        "description": "for getting cdata from and xml document.\ncdata returns in $1.\nit's not perfect as you can see from the non-matching examples. improvements needed - but this works for most scenario's.",
        "matches": [
            "&lt;![CDATA[ gobbledy gook ]]&gt;",
            "&lt;![CDATA[ gobbledy &amp; more gook ]]&gt;"
        ],
        "non_matches": [
            "&lt;![CDATA[ gobbledy ] gook ]]&gt;",
            "&lt;![CDATA[ gobbledy ]] gook ]]&gt;"
        ]
    },
    {
        "id": 1053,
        "expression": "\\s(type|name|value)=(?:(\\w+)|(?:&quot;(.*?)&quot;)|(?:\\'(.*)\\'))",
        "description": "Returns the three most important attributes from an HTML &lt;input&gt; tag: 'type', 'name' and 'value'. Supports attribute values that are double- or single-quoted or unquoted. Returns four references, the first being the name of the attribute, and the other three being the value, of which only one will be populated based on the way the value was quoted.",
        "matches": [
            "&lt;input type=&quot;text&quot; value='somevalue' name=fred&gt;"
        ],
        "non_matches": [
            "Any attributes that aren't &quot;type&quot;, &quot;name&quot;, or &quot;value&quot;"
        ]
    },
    {
        "id": 1058,
        "expression": "&lt;select(.|\\n)*?selected(.|\\n)*?&gt;(.*?)&lt;/option&gt;(.|\\n)*?&lt;/select&gt;",
        "description": "All useful examples are multi-line, so not displayed.\nthis will match any &lt;select&gt;&lt;/select&gt; block in an HTML document, and the return $3 will contain the displayed text (NOT the value of the displayed option)",
        "matches": [
            "&lt;select&gt;&lt;option selected&gt;returned text&lt;/option&gt;&lt;/select&gt;"
        ],
        "non_matches": [
            "&lt;select&gt;&lt;option&gt;returned text&lt;/option&gt;&lt;/select&gt;"
        ]
    },
    {
        "id": 1059,
        "expression": "&lt;textarea(.|\\n)*?&gt;((.|\\n)*?)&lt;/textarea&gt;",
        "description": "Matches any textarea block, and returns the text inside it.",
        "matches": [
            "&lt;textarea&gt;return&lt;/textarea&gt;"
        ],
        "non_matches": [
            "&lt;textarea&gt;returned &lt;/improperTextareaEndTag&gt;"
        ]
    },
    {
        "id": 1062,
        "expression": "^((67\\d{2})|(4\\d{3})|(5[1-5]\\d{2})|(6011))-?\\s?\\d{4}-?\\s?\\d{4}-?\\s?\\d{4}|3[4,7]\\d{13}$",
        "description": "Credit Card Matching - Matches Switch, Solo, Visa, MasterCard and Discover. Matches length and valid prefix. Accepts input optional spaces and dashes between number groups",
        "matches": [
            "5154-1234-1234-1342",
            "4444333322221111",
            "6767 1111 1111 1111"
        ],
        "non_matches": [
            "1234123412341234",
            "1111111",
            "987654321"
        ]
    },
    {
        "id": 1063,
        "expression": "^((67\\d{2})|(4\\d{3})|(5[1-5]\\d{2})|(6011))(-?\\s?\\d{4}){3}|(3[4,7])\\d{2}-?\\s?\\d{6}-?\\s?\\d{5}$",
        "description": "Credit Card Validation. Matches Switch/Solo, Visa, MasterCard and Discover in 4-4-4-4/4 4 4 4/4444 format and Amex in 4-6-5/4 6 5/465 format.\nIncludes checks for prefixes, (67 for switch/solo, 4 for visa, 51-55 for MasterCard, 37/34 for Amex and 6011 for Discover.\nMatches all major UK debit and credit cards with spaces dashes or as a continous number",
        "matches": [
            "4234 1234 1234 1234",
            "5434123412341234",
            "3712 123456 12345"
        ],
        "non_matches": [
            "1234123412341234",
            "1111111",
            "987654321"
        ]
    },
    {
        "id": 1064,
        "expression": "[^(\\&amp;)](\\w*)+(\\=)[\\w\\d ]*",
        "description": "Query string parser matches and tokenizes each name/value pair for a valid query string.",
        "matches": [
            "name1=value1&amp;name2=value2&amp;..."
        ],
        "non_matches": [
            "anyoldstring"
        ]
    },
    {
        "id": 1066,
        "expression": "\\\\red([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\\\green([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\\\blue([01]?\\d\\d?|2[0-4]\\d|25[0-5]);",
        "description": "This RegEx will match a RTF color taken from a color tabel in a RTF document (having the form '\\redXXX\\greenXXX\\blueXXX;', where XXX is a number between 0 and 255).",
        "matches": [
            "\\red76\\green157\\blue76;",
            "\\red0\\green0\\blue0;",
            "\\red120\\green120\\blue120;"
        ],
        "non_matches": [
            "\\red0\\green\\257\\blue120;",
            "\\red0\\green0\\blue0",
            "red120\\green120\\blue120;"
        ]
    },
    {
        "id": 1068,
        "expression": "&lt;script[\\s\\S]*?&lt;/script([\\s\\S]*?)&gt;",
        "description": "This pattern is intended to remove all javascript blocks from a chunk of code. EDIT: a bug is cutting off additional matches.",
        "matches": [
            "&lt;script language=&quot;Javascript&quot;&gt;&lt;!-- alert(); --&gt;&lt;/script&gt;"
        ],
        "non_matches": [
            "&lt;script&gt;"
        ]
    },
    {
        "id": 1070,
        "expression": "([,!@#$%^&*()\\[\\]]+|\\\\\\.\\.|\\\\\\\\\\.|\\.\\.\\\\\\|\\.\\\\\\|\\.\\.\\/|\\.\\/|\\/\\.\\.|\\/\\.|;|(?<![A-Z]):)",
        "description": "Checks file paths for offending characters\nA successful file path is one that does not return a match",
        "matches": [
            "C:\\invalid\\#path\\here,\\somewhere",
            "/invalid/^path/@here/",
            "C:\\..\\relative\\not\\allowed"
        ],
        "non_matches": [
            "C:\\valid\\path\\file.txt",
            "/home/user/valid/file.txt"
        ]
    },
    {
        "id": 1074,
        "expression": "(?i:[aeiou]+)\\B",
        "description": "This regular expression matches all interior vowels.\nIf used as a replace, the following strings would result:\nLets meet tomorrow -&gt; Lts mt tmrrw\nPlease come to my party -&gt; Plse cme to my prty\nI like your style -&gt; I lke yr style",
        "matches": [
            "remove all interior vowels"
        ],
        "non_matches": [
            "A"
        ]
    },
    {
        "id": 1090,
        "expression": "^[0-9]*\\/{1}[1-9]{1}[0-9]*$",
        "description": "This regular expression checks if the given string is a fraction. This does not allow 0 either in the numerator or the denominator.",
        "matches": [
            "1/2",
            "12/325"
        ],
        "non_matches": [
            "-1/2",
            "2se/4rf"
        ]
    },
    {
        "id": 1091,
        "expression": "^\\\\\\\\[\\w-]+\\\\(([\\w()-][\\w\\s()-]*[\\w()-]+)|([\\w()-]+))\\$?(\\\\(([\\w()-][\\w\\s()-]*[\\w()-]+)|([\\w()-]+)))*\\\\?$",
        "description": "Validation of a directory (not file) in UNC format\nChecks for \\\\server\\share\\subdir, where subdirs are optional.\nShare may have a $, but only at the end.\nShares and subdir may have embedded spaces.\nString may optionally have a trailing slash.",
        "matches": [
            "\\\\server\\my share\\my subdir",
            "\\\\server\\my share$\\",
            "\\\\server\\my share\\subdir1\\subdir2\\"
        ],
        "non_matches": [
            "c:\\subdir",
            "\\\\my server\\share$",
            "\\\\myserver\\share\\subdir\\file.ext"
        ]
    },
    {
        "id": 1092,
        "expression": "(?:-(?!0))?\\d+(?:(?: \\d+)?/\\d+)?",
        "description": "This regexp matches string which represents a fraction.\nThis fraction can be in these forms:<br />\n1. # or -# (not -0)<br />\n2. #/# or -#/# (not -0/#)<br />\n3. # #/# or -# #/# (not -0 #/#)",
        "matches": [
            "-1, 1, -1/2, 1/2, -1 2/3, 1 2/3",
            "0, 0/1, 1/0, 1 0/2, 1 2/0"
        ],
        "non_matches": [
            "letters",
            "negative zero",
            "/",
            "#/",
            "/#",
            "# /",
            "# #/",
            "# /#"
        ]
    },
    {
        "id": 1094,
        "expression": "^(0|([1-9]\\d{0,3}|[1-5]\\d{4}|[6][0-5][0-5]([0-2]\\d|[3][0-5])))$",
        "description": "Matches TCP port numbers from 0 to 65535. Other than '0', no leading 0's are accepted.",
        "matches": [
            "0",
            "1000",
            "65535"
        ],
        "non_matches": [
            "65536",
            "99999",
            "0123"
        ]
    },
    {
        "id": 1095,
        "expression": "^((25[0-4]|(2[0-4]|1[0-9]|[1-9]?)[0-9]\\.){3}(25[0-4]|(2[0-4]|1[0-9]|[1-9]?)[0-9]))$",
        "description": "This Regular Expression matches all valid ip-patterns.\n01.02.03.04 is not matched, as leading zeros is not valid a ip-pattern.\n255.255.255.0 is not matched, as 255 is a broadcast identifier, and as such not allowed in ip-patterns.",
        "matches": [
            "192.168.10.4",
            "130.225.56.40",
            "127.0.0.1"
        ],
        "non_matches": [
            "01.02.03.04",
            "255.255.255.0",
            "abc.def.ghi.jkl"
        ]
    },
    {
        "id": 1096,
        "expression": "^((CN=(['\\w\\d\\s\\-\\&amp;\\.]+(\\\\/)*(\\\\,)*)+,\\s*)*(OU=(['\\w\\d\\s\\-\\&amp;\\.]+(\\\\/)*(\\\\,)*)+,\\s*)*(DC=['\\w\\d\\s\\-\\&amp;]+[,]*\\s*){1,}(DC=['\\w\\d\\s\\-\\&amp;]+\\s*){1})$",
        "description": "Matches LDAP path (AdsPath) in Active Directory. Modified version of regex which has been found in library.\nAccepts spaces after , character. Also \\/ and \\, sequences (escapes) in CN or OU name are accepted.",
        "matches": [
            "CN=John Smith, OU=Acc, DC=acme, DC=com",
            "CN=John\\, Smith US\\/EXT, OU=Acc, DC=acme ,DC=com"
        ],
        "non_matches": [
            "CN=John Smith, OU=Acc, DC=acme",
            "CN=John\\, Smith\\, OU=Acc, DC=acme, DC=com"
        ]
    },
    {
        "id": 1098,
        "expression": "[ ]*=[ ]*[\\&quot;]*cid[ ]*:[ ]*([^\\&quot;&lt;&gt; ]+)",
        "description": "This is a Microsoft .NET/Mono regular expression that can be used to find the address of an embedded image inside an HTML email body.\nThe address will be the 2nd group found in the match.",
        "matches": [
            "&lt;img src=&quot;cid:00a601c57cba$14028d40$ed5cc23e&quot;&gt;",
            "background=cid:034701c5d97f$7c12fba"
        ],
        "non_matches": [
            "&lt;img src=&quot;no.jpg&quot;&gt;"
        ]
    },
    {
        "id": 1099,
        "expression": "^(([a-zA-Z]:)|(\\\\{2}\\w+)\\$?)(\\\\(\\w[\\w ]*.*))+\\.((html|HTML)|(htm|HTM))$",
        "description": "Path of files HTML and HTM",
        "matches": [
            "c:\\arquivo.html",
            "\\\\home\\arquivo232.HTML",
            "Z:\\teste.htm"
        ],
        "non_matches": [
            "c:\\arquivo.png",
            "arquivo232.HTML",
            "Z:\\teste"
        ]
    },
    {
        "id": 1101,
        "expression": "\\s?\\b((?!\\b50\\b|\\b00\\b)\\w*)\\b\\s?",
        "description": "This Expression exclude any word/code from a sentence.\nTo find out all the words except any specific codes/words use this. In this example we will exclude 50 and 00 and find all other words in the sentence.\nExample Text: &quot;Ask me 50 00 times&quot;\nMatches:Ask,me,times\nHere it ignores 50 and 00 and matches the other words. Modify according to your needs. I excluded 50 or 00.",
        "matches": [
            "ask me 50 times",
            "ask me 00 times",
            "ask me 50 00 times"
        ],
        "non_matches": [
            "..",
            "..",
            ".."
        ]
    },
    {
        "id": 1103,
        "expression": "^(([+]31|0031)\\s\\(0\\)([0-9]{9})|([+]31|0031)\\s0([0-9]{9})|0([0-9]{9}))$",
        "description": "Expression to check Dutch phone numbers. Number must start with zero and number of digits should be 10. Different area and country codes are allowed.",
        "matches": [
            "+31 0205315386",
            "0031 (0)205315386",
            "0205315386"
        ],
        "non_matches": [
            "020531538",
            "1205315386",
            "020531538677"
        ]
    },
    {
        "id": 1104,
        "expression": "^[0-9]{10}$|^\\(0[1-9]{1}\\)[0-9]{8}$|^[0-9]{8}$|^[0-9]{4}[ ][0-9]{3}[ ][0-9]{3}$|^\\(0[1-9]{1}\\)[ ][0-9]{4}[ ][0-9]{4}$|^[0-9]{4}[ ][0-9]{4}$",
        "description": "Australian phone numbers including Mobiles and common spacing used. This is used only to test normal contact numbers for residential purposes for example not information lines like 139999.\nOther Matching:\n9999999999, 9999 9999, (09)99999999",
        "matches": [
            "9999 999 999",
            "(09) 9999 9999",
            "99999999"
        ],
        "non_matches": [
            "99999999999",
            "9999999",
            "(99)99999999"
        ]
    },
    {
        "id": 1105,
        "expression": "^(N[BLSTU]|[AMN]B|[BQ]C|ON|PE|SK)$",
        "description": "Matches Canadian provincial codes. Similar to the one already posted but smaller, faster, and will correctly return the results in one match group rather than using several so it's much friendlier.",
        "matches": [
            "ON",
            "PE",
            "NB"
        ],
        "non_matches": [
            "OB",
            "NM"
        ]
    },
    {
        "id": 1107,
        "expression": "^(0?[1-9]|1[012])$",
        "description": "This will match numbers between 0 and 12. The 0? at the beginning will allow &quot;01&quot; as a valid match. This is useful for validation the month only component of a date part.",
        "matches": [
            "05",
            "5",
            "12"
        ],
        "non_matches": [
            "0",
            "1a",
            "13"
        ]
    },
    {
        "id": 1108,
        "expression": "^([12]?[0-9]|3[01])$",
        "description": "This will match numbers in the range 1-31. This is useful for matching the day component of a datetime part.",
        "matches": [
            "1",
            "20",
            "31"
        ],
        "non_matches": [
            "1a",
            "32",
            "01"
        ]
    },
    {
        "id": 1109,
        "expression": "^((18[5-9][0-9])|((19|20)[0-9]{2})|(2100))$",
        "description": "Will check to ensure the data is between 1850 and 2100.",
        "matches": [
            "1850",
            "1977",
            "2100"
        ],
        "non_matches": [
            "1800",
            "a",
            "2101"
        ]
    },
    {
        "id": 1117,
        "expression": "\\b(((?!\\d\\d\\d)\\d+|1\\d\\d|2[0-4]\\d|25[0-5])(\\b|\\.)){4}",
        "description": "match valid ip",
        "matches": [
            "192.168.0.1",
            "10.0.0.255",
            "211.100.0.0"
        ],
        "non_matches": [
            "192.256.0.1",
            "10.0.0.256",
            "211.100.0.1000"
        ]
    },
    {
        "id": 1121,
        "expression": "^(\\w+=[^\\s,=]+,)*(\\w+=[^\\s,=]+,?)?$",
        "description": "validate comma separated key/value pair",
        "matches": [
            "foo=bar",
            "foo1=bar1,foo2=bar2",
            "foo1=bar1,foo2=bar2,"
        ],
        "non_matches": [
            "foo=",
            "foo1=bar1 foo2=bar2",
            "foo1=bar1foo2=bar2"
        ]
    },
    {
        "id": 1124,
        "expression": "^(((((0[1-9])|(1\\d)|(2[0-8]))\\/((0[1-9])|(1[0-2])))|((31\\/((0[13578])|(1[02])))|((29|30)\\/((0[1,3-9])|(1[0-2])))))\\/((20[0-9][0-9])|(19[0-9][0-9])))|((29\\/02\\/(19|20)(([02468][048])|([13579][26]))))$",
        "description": "matches a date in dd/mm/yyyy format",
        "matches": [
            "01/01/2001",
            "29/02/2004"
        ],
        "non_matches": [
            "32/12/2001",
            "29/02/2005",
            "05/13/2005"
        ]
    },
    {
        "id": 1125,
        "expression": "^(0|(-?(((0|[1-9]\\d*)\\.\\d+)|([1-9]\\d*))))$",
        "description": "matches a double number",
        "matches": [
            "-0.5",
            "0.01",
            "15"
        ],
        "non_matches": [
            "01",
            "0.2.2",
            "+5"
        ]
    },
    {
        "id": 1134,
        "expression": "^(([A-Za-z]+[^0-9]*)([0-9]+[^\\W]*)([\\W]+[\\W0-9A-Za-z]*))|(([A-Za-z]+[^\\W]*)([\\W]+[^0-9]*)([0-9]+[\\W0-9A-Za-z]*))|(([\\W]+[^A-Za-z]*)([A-Za-z]+[^0-9]*)([0-9]+[\\W0-9A-Za-z]*))|(([\\W]+[^0-9]*)([0-9]+[^A-Za-z]*)([A-Za-z]+[\\W0-9A-Za-z]*))|(([0-9]+[^A-Za-z]*)([A-Za-z]+[^\\W]*)([\\W]+[\\W0-9A-Za-z]*))|(([0-9]+[^\\W]*)([\\W]+[^A-Za-z]*)([A-Za-z]+[\\W0-9A-Za-z]*))$",
        "description": "Password with minimum 1 Letter (A-Za-z), 1 Number (0-9) and Special Character (\\W). It doesn't matter the charaters position. See the Mathching Examples.\nQuestion? Write an Email to me.",
        "matches": [
            "test22!!",
            "!!test22",
            "22!!test"
        ],
        "non_matches": [
            "test22",
            "!!test",
            "22!!"
        ]
    },
    {
        "id": 1135,
        "expression": "(^(\\d+)$)|(^(\\d{1,3}[ ,\\.](\\d{3}[ ,\\.])*\\d{3}|\\d{1,3})$)",
        "description": "Searches for number greater than 0 with thousand delimiter as space, comma or period.",
        "matches": [
            "1 234 567",
            "1.234.567.890",
            "1,234"
        ],
        "non_matches": [
            "-12,990",
            "100.03",
            "0,05"
        ]
    },
    {
        "id": 1138,
        "expression": "(\\s)*(int|void|float|char|double|string)((\\s)|(\\*))*(\\&?)(\\s)+([a-z])([a-z0-9])*(\\s)*(\\()(\\s)*((int|void|float|char|double|string)((\\s)|(\\*))*(\\&?)(\\s)+([a-z])([a-z0-9])*((\\s)*[,](\\s)*(int|void|float|char|double|string)((\\s)|(\\*))*(\\&?)(\\s)+([a-z])([a-z0-9])*)*)?(\\s)*(\\))(\\s)*;",
        "description": "C++ prototipes.\nIt is necessary to write a \\s before a variable or function\nidentifier.",
        "matches": [
            "int * suma(int & x, float * p, string cad) ; )",
            "char one();",
            "float * poo(int o);"
        ],
        "non_matches": [
            "string *p();"
        ]
    },
    {
        "id": 1139,
        "expression": "(?:/\\*[\\w\\W]*?\\*/|//[^\\n]*?$|\\#[^\\n]*?$)",
        "description": "Return all comment lines (starts with //) and regions (serounded by /* */) as well as compiler arguments (#) in C# code",
        "matches": [
            "// some comment",
            "#region myRegion",
            "/* other comment */"
        ],
        "non_matches": [
            "for(int i = 0; i &lt; 10; i++)",
            "[XmlAttribute(&quot;somthing_else&quot;)",
            "String name = &quot;MyNa"
        ]
    },
    {
        "id": 1145,
        "expression": "(0[289][0-9]{2})|([1345689][0-9]{3})|(2[0-8][0-9]{2})|(290[0-9])|(291[0-4])|(7[0-4][0-9]{2})|(7[8-9][0-9]{2})",
        "description": "Accurate Australian postal code verification.\nAustralia has 4-digit numeric postal codes with the following state based specific ranges.\nACT: 0200-0299 and 2600-2639.\nNSW: 1000-1999, 2000-2599 and 2640-2914.\nNT: 0900-0999 and 0800-0899.\nQLD: 9000-9999 and 4000-4999.\nSA: 5000-5999.\nTAS: 7800-7999 and 7000-7499.\nVIC: 8000-8999 and 3000-3999.\nWA: 6800-6999 and 6000-6799.",
        "matches": [
            "0200",
            "7312",
            "2415"
        ],
        "non_matches": [
            "0300",
            "7612",
            "2915"
        ]
    },
    {
        "id": 1146,
        "expression": "([ABCEGHJKLMNPRSTVXY][0-9][ABCEGHJKLMNPRSTVWXYZ])\\ ?([0-9][ABCEGHJKLMNPRSTVWXYZ][0-9])",
        "description": "Accurate Canadian postal code format verification.\nThe format of a Canadian postal code is LDL DLD where L are alpha characters and D are numeric digits. But there are some exceptions. The letters D, F, I, O, Q and U never appear in a postal code because of their visual similarity to 0, E, 1, 0, 0, and V respectively. In addition to avoiding the six &quot;forbidden&quot; letters W and Z also do not appear as the first letter of a postal code (at least not at present).",
        "matches": [
            "M1R 4B0",
            "L0R 1B1",
            "L0R1B9"
        ],
        "non_matches": [
            "W1R 4B0",
            "L0R 1D1",
            "LOR1B9"
        ]
    },
    {
        "id": 1147,
        "expression": "((0[13-7]|1[1235789]|[257][0-9]|3[0-35-9]|4[0124-9]|6[013-79]|8[0124-9]|9[0-5789])[0-9]{3}|10([2-9][0-9]{2}|1([2-9][0-9]|11[5-9]))|14([01][0-9]{2}|715))",
        "description": "Accurate German postal code verification.\nGermany has 5-digit numeric postal codes. The expression evaluates a postal code within state based specific ranges.",
        "matches": [
            "01125"
        ],
        "non_matches": [
            "34125"
        ]
    },
    {
        "id": 1148,
        "expression": "(([A-Z]{1,2}[0-9][0-9A-Z]?)\\ ([0-9][A-Z]{2}))|(GIR\\ 0AA)",
        "description": "Accurate UK postal code format verification.\nUK postal codes have two parts. The right part is formatted as DLL (L:letter D:digit) and the left part has six alternative formats: LD, LDL, LDD, LLD, LLDL and LLDD. There is only one exception to these formats: GIR 0AA.",
        "matches": [
            "M2 5BQ",
            "EC1A 1HQ",
            "GIR 0AA"
        ],
        "non_matches": [
            "M2 BQ5",
            "E31A 1HQ",
            "GIR0AA"
        ]
    },
    {
        "id": 1164,
        "expression": "(NL-?)?[0-9]{9}B[0-9]{2}",
        "description": "VAT Numbers format verification (The Netherlands) with support for optional member state definition.",
        "matches": [
            "NL123456789B12"
        ],
        "non_matches": [
            "NL123456789012"
        ]
    },
    {
        "id": 1165,
        "expression": "^\\s*([\\(]?)\\[?\\s*\\d{3}\\s*\\]?[\\)]?\\s*[\\-]?[\\.]?\\s*\\d{3}\\s*[\\-]?[\\.]?\\s*\\d{4}$",
        "description": "US 10-Digit Phone number matching.\n*Requires Area Code\n*Brackets optional, supports: () and []\n*seperators optional, supports: - and .\n*whitespace optional",
        "matches": [
            "6105551515",
            "(610) 555 - 1212",
            "[610]555.1212"
        ],
        "non_matches": [
            "1 (610) 555-1212",
            "(610) 555-1212 ext*"
        ]
    },
    {
        "id": 1167,
        "expression": "^(([a-zA-Z0-9]+([\\-])?[a-zA-Z0-9]+)+(\\.)?)+[a-zA-Z]{2,6}$",
        "description": "Checks domain names. This will match all of the valid domains. It will accept TLD's that are from 2 to 6 characters. You can not have more then one dash or period next to each other. Also it will not let you have dashes at end of the words.",
        "matches": [
            "www.domain.com",
            "your-domain.com",
            "www.sub-domain.your-domain.museum"
        ],
        "non_matches": [
            ".domain.com",
            "your---domain.com",
            "www.-sub-.com"
        ]
    },
    {
        "id": 1177,
        "expression": "^(([a-zA-Z]+\\d+)|(\\d+[a-zA-Z]+))[a-zA-Z0-9]*$",
        "description": "Password validator that validates the password contains 1 letter (regardless of case) and 1 number",
        "matches": [
            "Password1",
            "1Password",
            "1Password1"
        ],
        "non_matches": [
            "*Password1",
            "*1Password*",
            "*1Password1*"
        ]
    },
    {
        "id": 1179,
        "expression": "^((0?[1-9])|((1)[0-1]))?((\\.[0-9]{0,2})?|0(\\.[0-9]{0,2}))$",
        "description": "This Regular Expression allows the user to enter a value to represent the imperial measurement of Inches.\nThe expression won't allow and value of 12 or above (otherwise it would be a foot!), and has the option of having a decimal value upto 2 decimal places.\nMy first Regular Expression so go easy on me!! :)",
        "matches": [
            "11.99",
            "05.5",
            "5"
        ],
        "non_matches": [
            "12",
            "12.00",
            "2.587"
        ]
    },
    {
        "id": 1180,
        "expression": "(?=^.{8,30}$)(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[!@#$%^&amp;*()_+}{&quot;&quot;:;'?/&gt;.&lt;,]).*$",
        "description": "Password filter that matches the NSA Password filter DLL ENPASFILT.DLL.\nAt least 1 small-case letter\nAt least 1 Capital letter\nAt least 1 digit\nAt least 1 special character\nLength should be between 8-30 characters.\nSpaces allowed\nThe sequence of the characters is not important.",
        "matches": [
            "Pa$$w0rd"
        ],
        "non_matches": [
            "Pa$$word"
        ]
    },
    {
        "id": 1189,
        "expression": "^(?=.*[a-zA-Z].*[a-zA-Z])(?=.*\\d.*\\d)[a-zA-Z0-9]{6,20}$",
        "description": "Password matching expression. Password must consists of at least 6 characters and not more than 20 characters. Password must contain only letters and digits. Password must contain at least 2 digits and at least 2 letters.",
        "matches": [
            "a1b2c3"
        ],
        "non_matches": [
            "aaaaa1"
        ]
    },
    {
        "id": 1196,
        "expression": "^([\\w]+@([\\w]+\\.)+[a-zA-Z]{2,9}(\\s*;\\s*[\\w]+@([\\w]+\\.)+[a-zA-Z]{2,9})*)$",
        "description": "Validates a semi colon delimited list of email addresses. Appropriate for use with .NET Web.Mail.MailMessage fields (To, BCC, CC)",
        "matches": [
            "test1@site.sub.edu ;user@site2.com"
        ],
        "non_matches": [
            "test1site.sub.edu ;@site2.com"
        ]
    },
    {
        "id": 1199,
        "expression": "^(?:(?:[+\\-]?\\$?)|(?:\\$?[+\\-]?))?(?:(?:\\d{1,3}(?:(?:,\\d{3})|(?:\\d))*(?:\\.(?:\\d*|\\d+[eE][+\\-]\\d+))?)|(?:\\.\\d+(?:[eE][+\\-]\\d+)?))$",
        "description": "This regex will validate the given string is numeric",
        "matches": [
            "$123.1234",
            ".123",
            ".123e+01"
        ],
        "non_matches": [
            "asdf",
            ",",
            "1,1",
            "."
        ]
    },
    {
        "id": 1209,
        "expression": "^100$|^\\d{0,2}(\\.\\d{1,2})? *%?$",
        "description": "It matches % value from 0 - 100. The two decimal places are used.",
        "matches": [
            "100",
            "99.99",
            "00",
            "20.99"
        ],
        "non_matches": [
            "101",
            "22.1111"
        ]
    },
    {
        "id": 1212,
        "expression": "<\\?xml.*</note>",
        "description": "This will find any XML within a string starting with the <?xml header and ending with the closing root tag. Replace </note> with your closing root tag. (use singleline and case insensitive) - I use this to pull xml written in a web document.",
        "matches": [
            "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></note>"
        ],
        "non_matches": [
            "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></BADnote>"
        ]
    },
    {
        "id": 1213,
        "expression": "^(([1-4][0-9])|(0[1-9])|(5[0-2]))\\/[1-2]\\d{3}$",
        "description": "This pattern can be used to validate a numeric week (between 01 and 52) and four digit year (valid years between 1000 and 2999) separated by a slash in the form of WW/YYYY.",
        "matches": [
            "47/2006"
        ],
        "non_matches": [
            "00/3005"
        ]
    },
    {
        "id": 1217,
        "expression": "<img[^>]* src=\\\"([^\\\"]*)\\\"[^>]*>",
        "description": "It searches for a IMG tag and group information about source of image.",
        "matches": [
            "<img src=\"joka.jpg\" /> <img src=\"joka.jpg\">"
        ],
        "non_matches": [
            "<img> <img src=dada>"
        ]
    },
    {
        "id": 1219,
        "expression": "^((((((0[13578])|(1[02]))[\\s\\.\\-\\/\\\\]?((0[1-9])|([12][0-9])|(3[01])))|(((0[469])|(11))[\\s\\.\\-\\/\\\\]?((0[1-9])|([12][0-9])|(30)))|((02)[\\s\\.\\-\\/\\\\]?((0[1-9])|(1[0-9])|(2[0-8]))))[\\s\\.\\-\\/\\\\]?(((([2468][^048])|([13579][^26]))00)|(\\d\\d\\d[13579])|(\\d\\d[02468][^048])|(\\d\\d[13579][^26])))|(((((0[13578])|(1[02]))[\\s\\.\\-\\/\\\\]?((0[1-9])|([12][0-9])|(3[01])))|(((0[469])|(11))[\\s\\.\\-\\/\\\\]?((0[1-9])|([12][0-9])|(30)))|((02)[\\s\\.\\-\\/\\\\]?((0[1-9])|([12][0-9]))))[\\s\\.\\-\\/\\\\]?(((([2468][048])|([13579][26]))00)|(\\d\\d[2468][048])|(\\d\\d[13579][26])|(\\d\\d0[48]))))$",
        "description": "This was made for use in javascript to detect MMDDYYYY formatted text. It tests all valid dates, including 31 vs 30 days in a month and the 28 vs 29 leap year rules which exclude centennial years not divisible by 400 and years not divisible by 4.",
        "matches": [
            "02292000"
        ],
        "non_matches": [
            "02291700"
        ]
    },
    {
        "id": 1221,
        "expression": "^(\\d{4})\\D?(0[1-9]|1[0-2])\\D?([12]\\d|0[1-9]|3[01])(\\D?([01]\\d|2[0-3])\\D?([0-5]\\d)\\D?([0-5]\\d)?)?$",
        "description": "Regex to match the ISO Date Format. The time part is optional, including the seconds, as are all of the delimiters (although they must be non-numeric). Each part of the date will be returned as a selection e.g. \\1 will contain the Year, \\2 will contain the Month.",
        "matches": [
            "2006-12-31 17:58:00",
            "20061231175800",
            "2006-12-31"
        ],
        "non_matches": [
            "2006-13-36 25:61:62"
        ]
    },
    {
        "id": 1223,
        "expression": "^[$]?[0-9]*(\\.)?[0-9]?[0-9]?$",
        "description": "Should match prices with or without a dollar sign.",
        "matches": [
            "4.42",
            "$4.42"
        ],
        "non_matches": [
            "asdf"
        ]
    },
    {
        "id": 1224,
        "expression": "^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-2]) ([0-1][0-9]|2[0-4]):([0-4][0-9]|5[0-9]):([0-4][0-9]|5[0-9])$",
        "description": "it will match a valid date & time string which looks like this : 2006-12-31 23:59:59",
        "matches": [
            "2006-12-31 23:59:59"
        ],
        "non_matches": [
            "2006-13-31 4:59:65"
        ]
    },
    {
        "id": 1227,
        "expression": "^.*(([^\\.][\\.][wW][mM][aA])|([^\\.][\\.][mM][pP][3]))$",
        "description": "Matches a file name to be either a .wma or .mp3 file. This can be used to check file uploads to make sure they are of a certain type. Substitute letters where appropriate for specific file types. This is a better solution (I think) than #343. Works in Javascript and C#.",
        "matches": [
            "thisfile.mp3",
            "tH@tfile.wma"
        ],
        "non_matches": [
            "whatever.exe",
            "somethingelse.mpa",
            "thisagain.wm3",
            "filenamemp3",
            "filename..mp3",
            "filename.wmap3"
        ]
    },
    {
        "id": 1230,
        "expression": "^\\d+(\\.\\d+)?$",
        "description": "Matches any unsigned floating point number/numeric string.",
        "matches": [
            "123",
            "3.14159"
        ],
        "non_matches": [
            "abc",
            "-3.14159",
            "3.4.2",
            ".234",
            "."
        ]
    },
    {
        "id": 1239,
        "expression": "[A-Z0-9]{5}\\d[0156]\\d([0][1-9]|[12]\\d|3[01])\\d[A-Z0-9]{3}[A-Z]{2}",
        "description": "Matches the UK Drivers License format as laid down by the DVLA / dvla. See http://www.govtalk.gov.uk/gdsc/html/frames/default.htm Matches: 1. Must be 16 characters 2. First 5 characters are alphanumeric. 3. Next 6 characters must be numeric 4. Next 3 characters are alphanumeric 5. Last 2 characters are alpha 6. Second character of numeric section can only be 0, 1, 5 or 6. 7. Fourth and fifth characters of numeric section must be in the range 01 to 31.",
        "matches": [
            "JOHNS711215GG9SY"
        ],
        "non_matches": [
            "JOHNS731215GG9SY"
        ]
    },
    {
        "id": 1242,
        "expression": "^(3276[0-7]|327[0-5]\\d|32[0-6]\\d{2}|3[01]\\d{3}|[12]\\d{4}|[1-9]\\d{3}|[1-9]\\d{2}|[1-9]\\d|\\d)$",
        "description": "Checks that the input is a positive integer in the range 0-32767",
        "matches": [
            "32767",
            "0",
            "999"
        ],
        "non_matches": [
            "99999",
            "-1",
            "abc"
        ]
    },
    {
        "id": 1244,
        "expression": "^\\+[0-9]{1,3}\\([0-9]{3}\\)[0-9]{7}$",
        "description": "The OAGIS standard has a format for phone and fax as +###(###)#######. For details on standard see the open applications group.",
        "matches": [
            "+555(555)5555555",
            "+1(800)5555555"
        ],
        "non_matches": [
            "555"
        ]
    },
    {
        "id": 1246,
        "expression": "([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4}|(\\d{1,3}\\.){3}\\d{1,3}",
        "description": "Matches all IPV6 and IPV4 addresses. Doesn't limit IPV4 to just values of 255. Doesn't allow IPV6 compression.",
        "matches": [
            "0:123:af00:ffff:0C67:0:0:8787",
            "0:0:0:0:0:0:0:1",
            "0.0.0.1",
            "999.999.999.999"
        ],
        "non_matches": [
            "::1"
        ]
    },
    {
        "id": 1251,
        "expression": "^(H(P|T|U|Y|Z)|N(A|B|C|D|F|G|H|J|K|L|M|N|O|R|S|T|U|W|X|Y|Z)|OV|S(C|D|E|G|H|J|K|M|N|O|P|R|S|T|U|W|X|Y|Z)|T(A|F|G|L|M|Q|R|V)){1}\\d{4}(NE|NW|SE|SW)?$|((H(P|T|U|Y|Z)|N(A|B|C|D|F|G|H|J|K|L|M|N|O|R|S|T|U|W|X|Y|Z)|OV|S(C|D|E|G|H|J|K|M|N|O|P|R|S|T|U|W|X|Y|Z)|T(A|F|G|L|M|Q|R|V)){1}(\\d{4}|\\d{6}|\\d{8}|\\d{10}))$",
        "description": "This pattern validates a British Ordnance Survey Grid/Tile/Sheet Reference Number. Information on the range of possible values can be found here: http://www.ordnancesurvey.co.uk/oswebsite/gps/information/coordinatesystemsinfo/guidetonationalgrid/page17.html. Grid Ref, Tile Ref, Sheet Ref.",
        "matches": [
            "NA1234SE"
        ],
        "non_matches": [
            "AA1234SE"
        ]
    },
    {
        "id": 1253,
        "expression": "^~/[0-9a-zA-Z_][0-9a-zA-Z/_-]*\\.[0-9a-zA-Z_-]+$",
        "description": "Matches the app relative path of a file. This will work for relative paths of URLs. Not very complicated but will work to do basic validation.",
        "matches": [
            "~/myPage.htm",
            "~/123._aBc2",
            "~/Hello_World-Page.aspx"
        ],
        "non_matches": [
            "mybadPage.htm",
            "~/.Not",
            "~/Very.",
            "~/Good"
        ]
    },
    {
        "id": 1254,
        "expression": "<title>+(.*?)</title>",
        "description": "This pattern could intercept the value of the tag title in every web pages, it could be found in $1.",
        "matches": [
            "<title>this title</title>"
        ],
        "non_matches": [
            "any other tags"
        ]
    },
    {
        "id": 1255,
        "expression": "<meta[\\s]+[^>]*?name[\\s]?=[\\s\\\"\\']+(.*?)[\\s\\\"\\']+content[\\s]?=[\\s\\\"\\']+(.*?)[\\\"\\']+.*?>",
        "description": "This pattern intercept meta tags, the name can be found in $1 the content value in $2.",
        "matches": [
            "<meta name=\"Author\" content=\"xxxxxx\"> <meta name=\"description\" content=\"xxxxxxxxx\"> <meta name=\"keywords\" content=\"xxxxxxxxx\"> <meta name=\"country\" content=\"IT\">"
        ],
        "non_matches": [
            "any other tags"
        ]
    },
    {
        "id": 1257,
        "expression": "<h([1-6])>([^<]*)</h([1-6])>",
        "description": "This regex find valid <h1-6> html tags",
        "matches": [
            "<h2>test2</h2><h3>test3</h3>"
        ],
        "non_matches": [
            "<h>test1</h>"
        ]
    },
    {
        "id": 1260,
        "expression": "\\b[1-9]{1}[0-9]{1,5}-\\d{2}-\\d\\b",
        "description": "This is a more robust regex for matching Chemical Abstract Service (CAS) Numbers. This distinguishes between CAS numbers and other identifiers (e.g. EC number).",
        "matches": [
            "50-00-0"
        ],
        "non_matches": [
            "200-001-8"
        ]
    },
    {
        "id": 1263,
        "expression": "(\\A|\\s)(((>[:;=+])|[>:;=+])[,*]?[-~+o]?(\\)+|\\(+|\\}+|\\{+|\\]+|\\[+|\\|+|\\\\+|/+|>+|<+|D+|[@#!OoPpXxZS$03])|>?[xX8][-~+o]?(\\)+|\\(+|\\}+|\\{+|\\]+|\\[+|\\|+|\\\\+|/+|>+|<+|D+))(\\Z|\\s)",
        "description": "Matches all common horizontal smileys facing from left to right in its own \"word\". To match horizontal smileys in the reverse direction (.ie D:) see horozontal smileys (reverse).",
        "matches": [
            ">:3 +D :*-((( =P"
        ],
        "non_matches": [
            ":=( :)))()))"
        ]
    },
    {
        "id": 1264,
        "expression": "(\\A|\\s)((\\)+|\\(+|\\}+|\\{+|\\]+|\\[+|\\|+|\\\\+|/+|>+|<+|D+|[@#!OoXxZS$0])[-~+o]?[,*]?((<[:;=+])|[<:;=+])|(\\)+|\\(+|\\}+|\\{+|\\]+|\\[+|\\|+|\\\\+|/+|>+|<+|D+)[-~+o]?[xX8]<?)(\\Z|\\s)",
        "description": "Matches all common horizontal smileys from right to left in its own \"word\".",
        "matches": [
            "D: ]]=<"
        ],
        "non_matches": [
            ":D #=>"
        ]
    },
    {
        "id": 1265,
        "expression": "(\\A|\\s)[({\\[]*([\\^\\*\\-@#$%<>XxVvOo0ZzTt+'\u00ac](_+|\\.)[\\^\\*\\-@#$%<>XxVvOo0ZzTt+'\u00ac]|\\._\\.|[\\^\\*@#$%<>XxVOo0ZTt']\\-[\\^\\*@#$%<>XxVOo0ZTt']|>>|><|<<|o[O0]|[O0]o)[)}\\]]*[;.?]*['\"]?(\\Z|\\s)",
        "description": "Matches all common vertical smileys in a \"word\".",
        "matches": [
            "[(-_-)];;;;;? .___. t-t T.T X_O oO *.*???? \u00ac_\u00ac >>"
        ],
        "non_matches": [
            "Xx --- \u00ac-\u00ac <> -.....-"
        ]
    },
    {
        "id": 1267,
        "expression": "^(\\d)?[ ]*[\\(\\.\\-]?(\\d{3})[\\)\\.\\-]?[ ]*(\\d{3})[\\.\\- ]?(\\d{4})[ ]*(x|ext\\.?)?[ ]*(\\d{1,7})?$",
        "description": "Requires area code. Allows extension. Any common US format works. If you prefer not to require area code, use this: ^(\\d)?[ ]*[\\(\\.\\-]?(\\d{3})?[\\)\\.\\-]?[ ]*(\\d{3})[\\.\\- ]?(\\d{4})[ ]*(x|ext\\.?)?[ ]*(\\d{1,7})?$",
        "matches": [
            "1 (123) 123-1234 ext. 1234567",
            "1 (123) 123-1234",
            "(123) 123-1234",
            "(123)123.1234",
            "1-123-123-1234",
            "1231231234"
        ],
        "non_matches": [
            "123/1234 L. 12345678"
        ]
    },
    {
        "id": 1268,
        "expression": ".*(\\.[Jj][Pp][Gg]|\\.[Gg][Ii][Ff]|\\.[Jj][Pp][Ee][Gg]|\\.[Pp][Nn][Gg])",
        "description": "This expression should work to validate that an uploaded file's extension is either jpg, gif, or png.",
        "matches": [
            "foo.gif",
            "foo.jpg",
            "foo.png"
        ],
        "non_matches": [
            "foo.txt",
            "foo.zip",
            "foo.exe"
        ]
    },
    {
        "id": 1278,
        "expression": "^[-+]?(\\d?\\d?\\d?,?)?(\\d{3}\\,?)*$",
        "description": "This pattern matches on Integer values. Handles leading positive or negative signs. Supports commas where only the leading group can have less than three digits.",
        "matches": [
            "+1",
            "-2",
            "3,000",
            "1,234,567"
        ],
        "non_matches": [
            "A",
            "1,23",
            "2,34,567",
            "1.0"
        ]
    },
    {
        "id": 1284,
        "expression": "^([0-1](?:\\.\\d)|[0-1](?:\\,\\d)|(2\\.0)|(2\\,0))$",
        "description": "Had to handle both \",\" and \".\" as separator in a validationscript where values are between 0.0 and 2.0 like in results of Swedish H\u00f6gskoleprov (SAT).",
        "matches": [
            "0,0",
            "0.0",
            "1,9",
            "2.0"
        ],
        "non_matches": [
            "2,1",
            "1",
            "3",
            "a"
        ]
    },
    {
        "id": 1296,
        "expression": "^[2-9]{1}[0-9]{1}((?<!1)[1]|[0]|[2-9]){1}\\b",
        "description": "According to NANPA (North American Numbering Plan Administration): The format of an area code is NXX, where N is any digit 2 through 9 and X is any digit 0 through 9. N11 are ERCs, called service codes, and are not used as area codes. This regex checks for these conditions. However, this regex does not check for N9X which are reserved for expansion in the future nor 37X or 96X which are also reserved for potential expansion in the future.",
        "matches": [
            "513"
        ],
        "non_matches": [
            "211"
        ]
    },
    {
        "id": 1300,
        "expression": "<script.*/*>|</script>|<[a-zA-Z][^>]*=['\"]+javascript:\\w+.*['\"]+>|<\\w+[^>]*\\son\\w+=.*[ /]*>",
        "description": "Matches any opening or closing script tags, inline javascript: tags, inline on<function> (ex: onClick) tags.\nMATCHES:\n<a href=\"javascript:alert('test0');\">\n<a href='javascript:alert(\"test1\");'>\n<a href=\"#\" onClick=\"alert('test2');\" />\n<script language=\"javascript\" src=\"somewhere.js\">\n<script language=\"javascript\" src=\"somewhere.js\" />\n<script>\n</script>",
        "matches": [
            "<a href=\"javascript:alert('test0');\"> or <a href=\"#\" onClick=\"alert('test');\" /> etc..."
        ],
        "non_matches": [
            "This should not appear because in javascript: you can use the < operator or the > operator."
        ]
    },
    {
        "id": 1313,
        "expression": "^[a-zA-Z0-9\\040]+$",
        "description": "It will allow for alphanumeric characters only, with the exception of spacing.",
        "matches": [
            "Website Users"
        ],
        "non_matches": [
            "Website Users!"
        ]
    },
    {
        "id": 1314,
        "expression": "^\\$([0]|([1-9]\\d{1,2})|([1-9]\\d{0,1},\\d{3,3})|([1-9]\\d{2,2},\\d{3,3})|([1-9],\\d{3,3},\\d{3,3}))([.]\\d{1,2})?$|^\\(\\$([0]|([1-9]\\d{1,2})|([1-9]\\d{0,1},\\d{3,3})|([1-9]\\d{2,2},\\d{3,3})|([1-9],\\d{3,3},\\d{3,3}))([.]\\d{1,2})?\\)$|^(\\$)?(-)?([0]|([1-9]\\d{0,6}))([.]\\d{1,2})?$",
        "description": "Matches number with optional commas and decimal places. Allows only max 7 digits before decimal and max 2 digits after decimal. Does not allow numbers beginning with 0 e.g., $0,234,567 but allows $0.05",
        "matches": [
            "($1,234,567.89)",
            "$1,234,567.89",
            "$1234567.89",
            "$-1234567.89"
        ],
        "non_matches": [
            "$1,234,567.890",
            "$12345678.90",
            "$023,456.78"
        ]
    },
    {
        "id": 1315,
        "expression": "^[a-z0-9!$'*+\\-_]+(\\.[a-z0-9!$'*+\\-_]+)*@([a-z0-9]+(-+[a-z0-9]+)*\\.)+([a-z]{2}|aero|arpa|biz|cat|com|coop|edu|gov|info|int|jobs|mil|mobi|museum|name|net|org|pro|travel)$",
        "description": "Checks email format against RFC 3696 (http://tools.ietf.org/html/rfc3696). Allows all characters described in Sections 2 and 3 of the RFC EXCEPT those described in Section 4.3 as unsafe for mailto URLs without encoding. Allows any 2-letter TLD plus any of the current gTLDs as listed at http://www.icann.org/registries/top-level-domains.htm. Does not accept quoted strings in the local part or IP addresses in lieu of the domain name. Does not enforce length limits. Intended to be used as case-insensitive. Comments are appreciated!",
        "matches": [
            "bob@smith.com",
            "bob.j@j.smith.museum",
            "!$'*+-_@a--1.ca"
        ],
        "non_matches": [
            ".bob@smith.com",
            "bob..j@smith.com",
            "bob@-smith.com"
        ]
    },
    {
        "id": 1317,
        "expression": "^(((\\(\\d{3}\\)|\\d{3})( |-|\\.))|(\\(\\d{3}\\)|\\d{3}))?\\d{3}( |-|\\.)?\\d{4}(( |-|\\.)?([Ee]xt|[Xx])[.]?( |-|\\.)?\\d{4})?$",
        "description": "with or without area code (of various forms)(does not allow for unbalanced parens in the area code). With or without an extension (of various forms). Does not allow for leading or trailing space.",
        "matches": [
            "(123)-456-7890 Ext 1234",
            "123-456-7890",
            "(123).456.7890",
            "123.456.7890",
            "1234567890ext1234",
            "123-456 7890 X 1234"
        ],
        "non_matches": [
            "123)4567890",
            "800callcat",
            "123456789"
        ]
    },
    {
        "id": 1319,
        "expression": "^[http|ftp|wap|https]{3,5}:\\//\\www\\.\\w*\\.[com|net]{2,3}$",
        "description": "it validates a simple URL like http://www.google.com , ftp://www.soso.com",
        "matches": [
            "http://www.google.com"
        ],
        "non_matches": [
            "httpp://wwww.go.com.in"
        ]
    },
    {
        "id": 1320,
        "expression": "(?i)^((((0[1-9])|([12][0-9])|(3[01])) ((JAN)|(MAR)|(MAY)|(JUL)|(AUG)|(OCT)|(DEC)))|((((0[1-9])|([12][0-9])|(30)) ((APR)|(JUN)|(SEP)|(NOV)))|(((0[1-9])|([12][0-9])) FEB))) \\d\\d\\d\\d ((([0-1][0-9])|(2[0-3])):[0-5][0-9]:[0-5][0-9])$",
        "description": "Validates datetimes in an internationally resilient form that is still readable by the average person.",
        "matches": [
            "01 JAN 2006 13:00:00"
        ],
        "non_matches": [
            "31 FEB 10 03:00:00 PM"
        ]
    },
    {
        "id": 1326,
        "expression": "^(\\d{4})[.](0{0,1}[1-9]|1[012])[.](0{0,1}[1-9]|[12][0-9]|3[01])[.](\\d{2})$",
        "description": "capture labels having format yyyy.mm.dd.nn here nn is for number s from 00 to 99",
        "matches": [
            "2006.10.09.05"
        ],
        "non_matches": [
            "06.13.32.123"
        ]
    },
    {
        "id": 1332,
        "expression": "^((\\d{2}(([02468][048])|([13579][26]))[\\-\\/\\s]?((((0?[13578])|(1[02]))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])))))|(\\d{2}(([02468][1235679])|([13579][01345789]))[\\-\\/\\s]?((((0?[13578])|(1[02]))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\\-\\/\\s]?((0?[1-9])|(1[0-9])|(2[0-8]))))))(\\s(((0?[1-9])|(1[0-9])|(2[0-3]))\\:([0-5][0-9])((\\s)|(\\:([0-5][0-9])))?))?$",
        "description": "Date YYYY-MM-DD (optional time HH:MM(optional seconds :SS)). Was borrowed from this [http://regexlib.com/REDetails.aspx?regexp_id=390] but changed to use 24 hour time and optional seconds. You can use / - or space for date delimiters, so 2004-12-31 works just as well as 2004/12/31. Checks leap year from 1901 to 2099.",
        "matches": [
            "2006-1-20",
            "2006/01/20",
            "2006-01-20 15:30",
            "2006-01-20 15:30:21"
        ],
        "non_matches": [
            "2003-2-29",
            "2003-13-02",
            "2003-2-2 10:72:30"
        ]
    },
    {
        "id": 1333,
        "expression": "^\\$?\\d{1,3}(,?\\d{3})*(\\.\\d{1,2})?$",
        "description": "Just a small pattern to make sure commas are in the rite place (if present). Only allows one decimal to be suffixed with with 1 or 2 digits. Also optional dollar sign may proceed value.",
        "matches": [
            "$1,000,000.00"
        ],
        "non_matches": [
            "43,3.245"
        ]
    },
    {
        "id": 1334,
        "expression": "^[0-3][0-9][0-1]\\d{3}-\\d{4}?",
        "description": "This regex performs a crude test on the given input string.\nThe danish cilvil registration number consists of 10 numeric characters and one special character '-'. The format is DDMMYY-XXXX.",
        "matches": [
            "010380-2343",
            "120454-5467",
            "390178-3434"
        ],
        "non_matches": [
            "1223876776",
            "4023100923"
        ]
    },
    {
        "id": 1341,
        "expression": "^(([1-9]{1}\\d{0,2},(\\d{3},)*\\d{3})|([1-9]{1}\\d{0,}))$",
        "description": "Matches whole numbers only, including comma separated. Does not allow leading zeros. To match comma separated numbers only, change \"\\d{0,}\" to \"\\d{0,2}\". To match 0, add \"|([0])\" before \")$\". If you want to use it with Java's regexp match(), remove \"^(\" and \")$\" since they are not needed.",
        "matches": [
            "10",
            "1000",
            "1,000",
            "10,000,000"
        ],
        "non_matches": [
            "01",
            "001,000",
            "1000,000"
        ]
    },
    {
        "id": 1349,
        "expression": "([a-zA-Z0-9_\\-\\.]+)(@[a-zA-Z0-9_\\-\\.]+)",
        "description": "matches any email address, where a @ is contained",
        "matches": [
            "kis.hajnalka@gmail.com"
        ],
        "non_matches": [
            "www.google.com"
        ]
    },
    {
        "id": 1350,
        "expression": "(?:(?:(?:http|ftp|gopher|telnet|news)://)(?:w{3}\\.)?(?:[a-zA-Z0-9/;\\?&=:\\-_\\$\\+!\\*'\\(\\|\\\\~\\[\\]#%\\.])+)",
        "description": "an expression to match internet addresses with one of the known protocolls (http, ftp, gopher, telnet, news)",
        "matches": [
            "http://ifi.lmu.de",
            "ftp://leo.org",
            "gopher://gopher.com"
        ],
        "non_matches": [
            "www.google.com"
        ]
    },
    {
        "id": 1351,
        "expression": "(?:(?:[a-zA-Z0-9/;\\?&=:\\-_\\$\\+!\\*'\\(\\|\\\\~\\[\\]#%\\.](?!www))+(?:\\.[Cc]om|\\.[Ee]du|\\.[gG]ov|\\.[Ii]nt|\\.[Mm]il|\\.[Nn]et|\\.[Oo]rg|\\.[Bb]iz|\\.[Ii]nfo|\\.[Nn]ame|\\.[Pp]ro|\\.[Aa]ero|\\.[cC]oop|\\.[mM]useum|\\.[Cc]at|\\.[Jj]obs|\\.[Tt]ravel|\\.[Aa]rpa|\\.[Mm]obi|\\.[Aa]c|\\.[Aa]d|\\.[aA]e|\\.[aA]f|\\.[aA]g|\\.[aA]i|\\.[aA]l|\\.[aA]m|\\.[aA]n|\\.[aA]o|\\.[aA]q|\\.[aA]r|\\.[aA]s|\\.[aA]t|\\.[aA]u|\\.[aA]w|\\.[aA]z|\\.[aA]x|\\.[bB]a|\\.[bB]b|\\.[bB]d|\\.[bB]e|\\.[bB]f|\\.[bB]g|\\.[bB]h|\\.[bB]i|\\.[bB]j|\\.[bB]m|\\.[bB]n|\\.[bB]o|\\.[bB]r|\\.[bB]s|\\.[bB]t|\\.[bB]v|\\.[bB]w|\\.[bB]y|\\.[bB]z|\\.[cC]a|\\.[cC]c|\\.[cC]d|\\.[cC]f|\\.[cC]g|\\.[cC]h|\\.[cC]i|\\.[cC]k|\\.[cC]l|\\.[cC]m|\\.[cC]n|\\.[cC]o|\\.[cC]r|\\.[cC]s|\\.[cC]u|\\.[cC]v|\\.[cC]x|\\.[cC]y|\\.[cC]z|\\.[dD]e|\\.[dD]j|\\.[dD]k|\\.[dD]m|\\.[dD]o|\\.[dD]z|\\.[eE]c|\\.[eE]e|\\.[eE]g|\\.[eE]h|\\.[eE]r|\\.[eE]s|\\.[eE]t|\\.[eE]u|\\.[fF]i|\\.[fF]j|\\.[fF]k|\\.[fF]m|\\.[fF]o|\\.[fF]r|\\.[gG]a|\\.[gG]b|\\.[gG]d|\\.[gG]e|\\.[gG]f|\\.[gG]g|\\.[gG]h|\\.[gG]i|\\.[gG]l|\\.[gG]m|\\.[gG]n|\\.[gG]p|\\.[gG]q|\\.[gG]r|\\.[gG]s|\\.[gG]t|\\.[gG]u|\\.[gG]w|\\.[gG]y|\\.[hH]k|\\.[hH]m|\\.[hH]n|\\.[hH]r|\\.[hH]t|\\.[hH]u|\\.[iI]d|\\.[iI]e|\\.[iI]l|\\.[iI]m|\\.[iI]n|\\.[iI]o|\\.[iI]q|\\.[iI]r|\\.[iI]s|\\.[iI]t|\\.[jJ]e|\\.[jJ]m|\\.[jJ]o|\\.[jJ]p|\\.[kK]e|\\.[kK]g|\\.[kK]h|\\.[kK]i|\\.[kK]m|\\.[kK]n|\\.[kK]p|\\.[kK]r|\\.[kK]w|\\.[kK]y|\\.[kK]z|\\.[lL]a|\\.[lL]b|\\.[lL]c|\\.[lL]i|\\.[lL]k|\\.[lL]r|\\.[lL]s|\\.[lL]t|\\.[lL]u|\\.[lL]v|\\.[lL]y|\\.[mM]a|\\.[mM]c|\\.[mM]d|\\.[mM]g|\\.[mM]h|\\.[mM]k|\\.[mM]l|\\.[mM]m|\\.[mM]n|\\.[mM]o|\\.[mM]p|\\.[mM]q|\\.[mM]r|\\.[mM]s|\\.[mM]t|\\.[mM]u|\\.[mM]v|\\.[mM]w|\\.[mM]x|\\.[mM]y|\\.[mM]z|\\.[nN]a|\\.[nN]c|\\.[nN]e|\\.[nN]f|\\.[nN]g|\\.[nN]i|\\.[nN]l|\\.[nN]o|\\.[nN]p|\\.[nN]r|\\.[nN]u|\\.[nN]z|\\.[oO]m|\\.[pP]a|\\.[pP]e|\\.[pP]f|\\.[pP]g|\\.[pP]h|\\.[pP]k|\\.[pP]l|\\.[pP]m|\\.[pP]n|\\.[pP]r|\\.[pP]s|\\.[pP]t|\\.[pP]w|\\.[pP]y|\\.[qP]a|\\.[rR]e|\\.[rR]o|\\.[rR]u|\\.[rR]w|\\.[sS]a|\\.[sS]b|\\.[sS]c|\\.[sS]d|\\.[sS]e|\\.[sS]g|\\.[sS]h|\\.[Ss]i|\\.[sS]j|\\.[sS]k|\\.[sS]l|\\.[sS]m|\\.[sS]n|\\.[sS]o|\\.[sS]r|\\.[sS]t|\\.[sS]v|\\.[sS]y|\\.[sS]z|\\.[tT]c|\\.[tT]d|\\.[tT]f|\\.[tT]g|\\.[tT]h|\\.[tT]j|\\.[tT]k|\\.[tT]l|\\.[tT]m|\\.[tT]n|\\.[tT]o|\\.[tT]p|\\.[tT]r|\\.[tT]t|\\.[tT]v|\\.[tT]w|\\.[tT]z|\\.[uU]a|\\.[uU]g|\\.[uU]k|\\.[uU]m|\\.[uU]s|\\.[uU]y|\\.[uU]z|\\.[vV]a|\\.[vV]c|\\.[vV]e|\\.[vV]g|\\.[vV]i|\\.[vV]n|\\.[vV]u|\\.[wW]f|\\.[wW]s|\\.[yY]e|\\.[yY]t|\\.[yY]u|\\.[zZ]a|\\.[zZ]m|\\.[zZ]w))",
        "description": "here are specified all the top level domains. In fact, this expression gets the urls only till the TLD.",
        "matches": [
            "webmail.ifi.lmu.de"
        ],
        "non_matches": [
            "kis.hajnalka"
        ]
    },
    {
        "id": 1356,
        "expression": "^M{0,1}T{0,1}W{0,1}(TH){0,1}F{0,1}S{0,1}(SU){0,1}$",
        "description": "Matches a string if it is valid in the form of MWF or TTHS. Maybe used for validating the \"days part\" of a class schedule field. The string should only accept any of the ff set of letters: 'M' 'T' 'W' 'TH' 'F' 'S' 'SU' . Only one instance of these set of letters is accepted.",
        "matches": [
            "MWF",
            "TTHS",
            "MT",
            "WFS",
            "MFSU"
        ],
        "non_matches": [
            "MM",
            "WM",
            "FTH",
            "SM"
        ]
    },
    {
        "id": 1357,
        "expression": "^(([0][0-9]|[1][0-2])|[0-9]):([0-5][0-9])( *)((AM|PM)|(A|P))$",
        "description": "Matches a string if it is a valid time in the format of \"HH:MM AM\" or \"HH:MM A\".",
        "matches": [
            "1:30 AM",
            "01:20 AM",
            "10:00A",
            "11:50P"
        ],
        "non_matches": [
            "13:00 A",
            "01:5 AM"
        ]
    },
    {
        "id": 1358,
        "expression": "^\\$?(([1-9],)?([0-9]{3},){0,3}[0-9]{3}|[0-9]{0,16})(\\.[0-9]{0,3})?$",
        "description": "Currency expression, accepts 4 commas and 4 groups of 3 numbers and 1 number before the first comma, this first number will have to be different from zero. It accepts a number of, two or three decimal. It accepts zero numbers after the point. You can change the number of groups and numbers accespts before and after the point.",
        "matches": [
            "1234.23",
            "1,234.245",
            "1."
        ],
        "non_matches": [
            "12,12,0.00",
            "0,123.99"
        ]
    },
    {
        "id": 1360,
        "expression": "\\d{2,4}",
        "description": "\\d{2,4} matches at least 2 but no more than 4 digits",
        "matches": [
            "123",
            "12",
            "1234"
        ],
        "non_matches": [
            "1"
        ]
    },
    {
        "id": 1362,
        "expression": "^-?\\d+(\\.\\d+)?$",
        "description": "Matches any unsigned or signed floating point number/numeric string.",
        "matches": [
            "123",
            "3.14159",
            "-1.2"
        ],
        "non_matches": [
            "abc",
            "3.4.2",
            ".234",
            ""
        ]
    },
    {
        "id": 1366,
        "expression": "^[\"a-zA-Z0-9\\040]+$",
        "description": "Accepts words or quoted phrases for search strings. Stops SQL injection.",
        "matches": [
            "2 words \"Search String\""
        ],
        "non_matches": [
            "hi' or 1=1--"
        ]
    },
    {
        "id": 1372,
        "expression": "^(?:(A[KLRZ]|C[AOT]|D[CE]|FL|GA|HI|I[ADLN]|K[SY]|LA|M[ADEINOST]|N[CDEHJMVY]|O[HKR]|P[AR]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY]))$",
        "description": "Just a simple US State regex. Requires valid 2 letter abbreviations.",
        "matches": [
            "CO",
            "GA",
            "TX"
        ],
        "non_matches": [
            "A",
            "ZZ",
            "Florida"
        ]
    },
    {
        "id": 1378,
        "expression": "(?<=>)[A-Z]{2}[\\d|\\w]{9}\\d{1}(?=(<))",
        "description": "ISIN must be located inside a html tag eg. <td>JP3756600007</td>. Just remove the (..) at the beginning and the end if you wish to match all ISINs.",
        "matches": [
            ">JP3756600007< without brackets"
        ],
        "non_matches": [
            "JP3756600007"
        ]
    },
    {
        "id": 1380,
        "expression": "<(?![!/]?[ABIU][>\\s])[^>]*>",
        "description": "Used to return all the html tags and closing tags in a section of html. Can be used to replace all the tags with nothing or itterate through them.",
        "matches": [
            "<u><b>hello</b></u>"
        ],
        "non_matches": [
            "hello"
        ]
    },
    {
        "id": 1381,
        "expression": "((<body)|(<BODY))([^>]*)>",
        "description": "find the body-tag of a html page",
        "matches": [
            "<body><BODY bgcolor=\"#ffffff\" text=\"#000000\" marginwidth=\"0\" marginheight=\"0\">"
        ],
        "non_matches": [
            "all non body tags"
        ]
    },
    {
        "id": 1385,
        "expression": "^<a[^>]*(http://[^\"]*)[^>]*>([ 0-9a-zA-Z]+)</a>$",
        "description": "This pattern matches link tags in html and returns the contents of the href attribute and the text of the link.",
        "matches": [
            "<a href=\"http://www.google.com\">Google</a>"
        ],
        "non_matches": [
            "<a name=\"bookmark\">something</a>"
        ]
    },
    {
        "id": 1388,
        "expression": "(?:(?:(?:04|06|09|11)\\/(?:(?:[012][0-9])|30))|(?:(?:(?:0[135789])|(?:1[02]))\\/(?:(?:[012][0-9])|30|31))|(?:02\\/(?:[012][0-9])))\\/(?:19|20|21)[0-9][0-9]",
        "description": "Matches dates in mm/dd/yyyy format. Matches only valid dates -except is unable to test for a leapyear. Always allows February 29th. Allows years from 1901 to 2199.",
        "matches": [
            "02/21/1972",
            "12/31/2199",
            "09/04/1901"
        ],
        "non_matches": [
            "02/31/1999",
            "02-21-1972",
            "06/31/2001"
        ]
    },
    {
        "id": 1389,
        "expression": "^\\d{1,2}\\.\\d{3}\\.\\d{3}[-][0-9kK]{1}$",
        "description": "Verifica que un RUT tenga el formato 00.000.000-X, despues de comprobar el formato ser\u00e1 necesario validar su d\u00edgito verificador.",
        "matches": [
            "12.025.365-6",
            "5.698.124-k",
            "7.999.647-K"
        ],
        "non_matches": [
            "125.326.452-1",
            "15.336.054-H",
            "15254587k"
        ]
    },
    {
        "id": 1394,
        "expression": "<!--\\s*\\#\\s*include\\s+(file|virtual)\\s*=\\s*([\"'])([^\"'<>\\|\\b]+/)*([^\"'<>/\\|\\b]+)\\2\\s*-->",
        "description": "Works with virtual or file include type and double or single quotes. Breaks out include type, include file path, and include file name.",
        "matches": [
            "<!--#include file=\"include/js/common.js\"--> <!-- # include virtual = 'test header.inc' -->"
        ],
        "non_matches": [
            "<!--#include file='header.inc\"-->"
        ]
    },
    {
        "id": 1395,
        "expression": "(?<=\\d{7}_).+((?=\\x5B\\d\\x5D)|.{3})",
        "description": "Although written specifically to strip Newzbin version 2 and 3 prefixes and the [1] IE adds in Newsbin from NZB file names, this expression can be modified to search for any prefix/suffix combination. It also provides an example of using of grouping constructs to remove matching text.",
        "matches": [
            "msgid_0000000_Any_Text[1]",
            "0000000_Any_Text"
        ],
        "non_matches": [
            "msgid 0000000",
            "messageid",
            "000000"
        ]
    },
    {
        "id": 1402,
        "expression": "<\\s*?[^>]+\\s*?>",
        "description": "This simple pattern is useful for removing all HTML tags with or without atributes. It has no removing white spaces",
        "matches": [
            "< html >",
            "< div style=\"title_1\" class='number'>",
            "< div style=\"title_1\" class='number' >",
            "< img src=\"img.gif\" / >"
        ],
        "non_matches": [
            "Plain text"
        ]
    },
    {
        "id": 1404,
        "expression": "^(?=.*[a-z].*[a-z])(?=.*[A-Z].*[A-Z])(?=.*\\d.*\\d)(?=.*\\W.*\\W)[a-zA-Z0-9\\S]{9,}$",
        "description": "This pattern requires at least two lowercase letters, two uppercase letters, two digits, and two special characters. There must be a minimum of 9 characters total, and no white space characters are allowed.",
        "matches": [
            "A1!B2@cde"
        ],
        "non_matches": [
            "ABC!@#123"
        ]
    },
    {
        "id": 1406,
        "expression": "(<(?:.*?)\\s)href\\s*=([\\s\"'])*/?([^\\2:#]+?)\\2((?:.*?)>)",
        "description": "This expression matches all HREF relative paths, but not full URLs or dead # links. It can be used for selecting paths that need to be updated in HTML that has replaced from its original page onto a new one. It matches the entire containing tag with the following groups: 1 - the start of the containing tag through the space before the attribute, 2 - the delimiter between the attribute's equal sign and its value (e.g. a double quote), 3 - the attribute value, 4 - the remainder of the tag after the closing attribute value delimiter.",
        "matches": [
            "<a href=\"joe's test.htm\" />",
            "<a href='/test2.htm'>",
            "<a href = test2.htm />"
        ],
        "non_matches": [
            "<a href=\"http://www.test.com/test.htm\" />",
            "<a href = '#' />"
        ]
    },
    {
        "id": 1408,
        "expression": "(refs|references|re|closes|closed|close|see|fixes|fixed|fix|addresses) #(\\d+)(( and |, | & | )#(\\d+))*",
        "description": "This expression can be used to set the bugtraq:logrexep property of a subversion repository. It uses the format supported by trac and enables for example tortoisesvn to transform the issue numbers used in the commit messages into links pointing to the issue in the bugtracker.",
        "matches": [
            "fix #313",
            "references #1024 and #1337"
        ],
        "non_matches": [
            "fixed 313",
            "refer #1024"
        ]
    },
    {
        "id": 1410,
        "expression": "\\d{2}[.]{1}\\d{2}[.]{1}[0-9A-Za-z]{1}",
        "description": "This pattern match the Italian Istat Ateco Code (Codice Istat) updated to Istat Declaration Ateco 2004",
        "matches": [
            "22.12.0",
            "18.24.C"
        ],
        "non_matches": [
            "22.12_D",
            "12.56",
            "1A.56.1"
        ]
    },
    {
        "id": 1411,
        "expression": "IT\\d{2}[ ][a-zA-Z]\\d{3}[ ]\\d{4}[ ]\\d{4}[ ]\\d{4}[ ]\\d{4}[ ]\\d{3}|IT\\d{2}[a-zA-Z]\\d{22}",
        "description": "International Bank Account Number (IBAN) Italian. Identify Bank account in Italy.",
        "matches": [
            "IT28 W800 0000 2921 0064 5211 151",
            "IT28W8000000292100645211151"
        ],
        "non_matches": [
            "IT28-W800-0000-2921-0064-5211-151"
        ]
    },
    {
        "id": 1412,
        "expression": "^\\w[a-zA-Z0-9\u00f6\u00e4\u00fc\u00d6\u00c4\u00dc\\.\\-_]+@[a-zA-Z0-9\u00f6\u00e4\u00fc\u00d6\u00c4\u00dc\\-_]+?\\.[a-zA-Z]{2,3}$",
        "description": "allows numbers, umlauts, dots and bars",
        "matches": [
            "t\u00e4st.inf\u00f6@t\u00fcst-1234.de"
        ],
        "non_matches": [
            "t\u00e4st.inf\u00f6@t\u00fcst-1234.123"
        ]
    },
    {
        "id": 1413,
        "expression": "^(([a-zA-Z]\\:)|(\\\\))(\\\\{1}|((\\\\{1})[^\\\\]([^/:*?<>\"|]*))+)$",
        "description": "Checks for a valid Filepath, either located on a local drive or a UNC share on the network. Use the following string to include the regex within a XML defintion file: RegEx=\"^([a-zA-Z]\\:)|(\\\\)(\\\\{1}|((\\\\{1})[^\\\\]([^/:*?&lt;&gt;&quot;|]*(?&lt;!\\[\\])))+)$\"/> (encode the appropiate HTML characters like <,>,\" with the appropiate HTML codes < = (ampersand)lt; > = (ampersand)gt; \" = (ampersand)quote;",
        "matches": [
            "C:\\SomeFilePatt",
            "\\\\SomeServer\\SomeShare"
        ],
        "non_matches": [
            "C:",
            "\\SomeServer"
        ]
    },
    {
        "id": 1414,
        "expression": "(^4\\d{12}$)|(^4[0-8]\\d{14}$)|(^(49)[^013]\\d{13}$)|(^(49030)[0-1]\\d{10}$)|(^(49033)[0-4]\\d{10}$)|(^(49110)[^12]\\d{10}$)|(^(49117)[0-3]\\d{10}$)|(^(49118)[^0-2]\\d{10}$)|(^(493)[^6]\\d{12}$)",
        "description": "Matches Visa CC types 13 or 16 digits starting with 4 including Visa CC, Visa ATM only, Visa Electron and Visa Delta. Safe for international and will NOT match \"^(49)\" Switch debit cards.",
        "matches": [
            "4111111111111111"
        ],
        "non_matches": [
            "4903020000000008"
        ]
    },
    {
        "id": 1425,
        "expression": "(^(5[0678])\\d{11,18}$)|(^(6[^05])\\d{11,18}$)|(^(601)[^1]\\d{9,16}$)|(^(6011)\\d{9,11}$)|(^(6011)\\d{13,16}$)|(^(65)\\d{11,13}$)|(^(65)\\d{15,18}$)|(^(49030)[2-9](\\d{10}$|\\d{12,13}$))|(^(49033)[5-9](\\d{10}$|\\d{12,13}$))|(^(49110)[1-2](\\d{10}$|\\d{12,13}$))|(^(49117)[4-9](\\d{10}$|\\d{12,13}$))|(^(49118)[0-2](\\d{10}$|\\d{12,13}$))|(^(4936)(\\d{12}$|\\d{14,15}$))",
        "description": "Matches any of Solo, Switch or Maestro. International safe. Will not match on Discover, Visa or Mastercard. For example; Most recommendations for matching Visa are that they start with \"4\". If outside the US, this are incomplete on will falsly ID most Switch cards as Visa.",
        "matches": [
            "6334500000000003"
        ],
        "non_matches": [
            "6011000000000004"
        ]
    },
    {
        "id": 1426,
        "expression": "(^\\-|\\+)?([1-9]{1}[0-9]{0,2}(\\,\\d{3})*|[1-9]{1}\\d{0,})$|^0?$",
        "description": "Allows any integer, signed (+/-) or not, with or without commas, or zero (0), or blank.",
        "matches": [
            "1,250",
            "+235",
            "-1",
            "0"
        ],
        "non_matches": [
            "abc",
            "-0",
            "1,0"
        ]
    },
    {
        "id": 1428,
        "expression": "^(97(8|9))?\\d{9}(\\d|X)$",
        "description": "Validates both ISBN 10 and ISBN 13 numbers, and confirms ISBN 13 numbers start with only 978 or 979.",
        "matches": [
            "0672317249",
            "9780672317248"
        ],
        "non_matches": [
            "0-672-31724-9",
            "5555555555555"
        ]
    },
    {
        "id": 1430,
        "expression": "(\\[([^/].*?)(=(.+?))?\\](.*?)\\[/\\2\\]|\\[([^/].*?)(=(.+?))?\\])",
        "description": "Matches BBCode, non-recursive. You must recursively run the pattern with each resulting subpattern to get all the tag.",
        "matches": [
            "[img]path[/img] (opened), [url=path]text[/url] (opened/args), [br] (closed), [img=path] (closed/args), [font size=50]text[/font] (opened, attribs)"
        ],
        "non_matches": [
            "[/b]"
        ]
    },
    {
        "id": 1431,
        "expression": "\"(\"\"|[^\"])*\"",
        "description": "This will match the VB-style quoted string. That means to use \" in the quoted string you must use \"\" instead.",
        "matches": [
            "\"\" \"Hello\" \"\"\"Wow\"\", he said\" \"\"\"\"\"\""
        ],
        "non_matches": [
            "\"Unclosed"
        ]
    },
    {
        "id": 1433,
        "expression": "[^\\d^\\-^\\,^\\x20]+",
        "description": "Just a beginner....here's something I'm using to emulate the Microsoft \"Print\" functionality, where you can enter page numbers to print seperated by commas or specify a range using the \"-\" symbol. The expression checks across a whole string looking for anything that is NOT equal to a number, a minus symbol, a comma and a space character. You can use this expression to do a quick true-false check to see if the user has entered a valid string / page numbers. Later you could then write a routine to sort and / or process the input. Nothing fancy but might help someone. Comments welcome.",
        "matches": [
            "abcABC ! *$%&/()"
        ],
        "non_matches": [
            "123456789 ,-"
        ]
    },
    {
        "id": 1434,
        "expression": "(^\\*\\.[a-zA-Z][a-zA-Z][a-zA-Z]$)|(^\\*\\.\\*$)",
        "description": "Matching any file extension.",
        "matches": [
            "*.doc",
            "*.DOC",
            "*.*"
        ],
        "non_matches": [
            "*.docDOC",
            "*.*d"
        ]
    },
    {
        "id": 1436,
        "expression": "^([A-Za-z\\-]+)\\s+(\\w+)\\s+([A-Za-z0-9_\\-\\.]+)\\s+([A-Za-z0-9_\\-\\.]+)\\s+(\\d+)\\s+(.{3} [0-9 ]{2} ([0-9][0-9]:[0-9][0-9]| [0-9]{4}))\\s+(.+)$",
        "description": "GLOB the output of an \"ls -l\" command to extract specific details. It takes into account issues with older files/directories having a year in place of an hour:minute entry.",
        "matches": [
            "drwxr-xr-x 5 user dba 1024 Sep 24 21:24 dirname"
        ],
        "non_matches": [
            "drwxr-xr-x 5 user dba 1024 Sep 24_21:24 dirname"
        ]
    },
    {
        "id": 1439,
        "expression": "^[\\w]{1,}$",
        "description": "alphanumeric - no space allowed - requires at least one character",
        "matches": [
            "a123b"
        ],
        "non_matches": [
            "a 1"
        ]
    },
    {
        "id": 1446,
        "expression": "^[ISBN]{4}[ ]{0,1}[0-9]{1}[-]{1}[0-9]{3}[-]{1}[0-9]{5}[-]{1}[0-9]{0,1}$",
        "description": "Expression to check for a valid ISBN number",
        "matches": [
            "ISBN 0-596-00681-0"
        ],
        "non_matches": [
            "Anything that's not in the above format"
        ]
    },
    {
        "id": 1449,
        "expression": "(^10\\.)|(^172\\.1[6-9]\\.)|(^172\\.2[0-9]\\.)|(^172\\.3[0-1]\\.)|(^192\\.168\\.)|(^127\\.0\\.0\\.1)",
        "description": "It matches private IP addresses. Private IP addresses (as defined by RFC 1918) are not routable on public Internet. This would help if you want to grant some previlege only to the users from within local network. ***Importnat*** This pattern assumes that the input is a valid IP address. You many need to make sure the input is a valid IP address.",
        "matches": [
            "10.12.0.19",
            "172.21.0.23",
            "192.168.0.2"
        ],
        "non_matches": [
            "222.12.3.24",
            "172.12.0.12"
        ]
    },
    {
        "id": 1457,
        "expression": "^(GIR|[A-Z]\\d[A-Z\\d]?|[A-Z]{2}\\d[A-Z\\d]?)[ ]??(\\d[A-Z]{0,2})??$",
        "description": "This will validate a partial postcode beginning with the postal district on up to the whole postcode, returning the two halves in sub-expressions. The main purpose is to return a valid postal district from a partial or whole postcode. The real value in this regex lies in the fact that it will process the postcode correctly regardless of whether or not the space in present after the district. So the accepted formats are A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (and the same 6 formats without the space are also accepted). Requires postcodes to be upper-case.",
        "matches": [
            "W1A1AB"
        ],
        "non_matches": [
            "WWW1AB"
        ]
    },
    {
        "id": 1458,
        "expression": "^(GIR|[A-Z]\\d[A-Z\\d]??|[A-Z]{2}\\d[A-Z\\d]??)[ ]??(\\d[A-Z]{2})$",
        "description": "Validates a complete UK postcode. Returns the two halves in sub-expressions. Supports the following 7 formats: A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (** And the same 7 formats without the space are also accepted). (requires postcodes to be upper-case)",
        "matches": [
            "GIR0AA"
        ],
        "non_matches": [
            "WWW1AB"
        ]
    },
    {
        "id": 1461,
        "expression": "((?!(This|It|He|She|[MTWFS][a-z]+day|[JF][a-z]+ary|March|April|May|June|July|August|[SOND][a-z]+ber))(?:[A-Z]+\\.\\s?)*(?:(?:[a-zA-Z]+-?)?[A-Z][a-zA-Z]+)(?:(\\b\\s?((?:[a-zA-Z]+-?)?[A-Z][a-zA-Z]+|[A-Z]+\\.|on|of|the|von|der|van|de|bin|and))*(?:\\s*(?:[a-zA-Z]+-?)?[A-Z][a-zA-Z]+))?)",
        "description": "Tries to find the proper nouns in a text",
        "matches": [
            "George W. Bush, al-Qaeda, VIII. Henry, United States of America, U.S. Department of Justice"
        ],
        "non_matches": [
            "other non-proper nouns"
        ]
    },
    {
        "id": 1466,
        "expression": "^[0-9]+[NnSs] [0-9]+[WwEe]$",
        "description": "This tests, are entered AW coordinates in correct short format, and it has no world info",
        "matches": [
            "0N 0W"
        ],
        "non_matches": [
            "aw 0N 0W"
        ]
    },
    {
        "id": 1467,
        "expression": "^(([+-]?)(?=\\d|\\.\\d)\\d*(\\.\\d*)?([Ee]([+-]?([12]?\\d\\d?|30[0-8])))?)?$",
        "description": "SqlServer seems to throw an error when using higher than e308 for e-309 it just makes the value = 0. Either way, this regexp seems to work for me. and allows for empty string as well. To negate the empty string pass through in asp.net just add a required field validator--if your already program asp.net you probably already know that though : ) .",
        "matches": [
            "-9.9e-308",
            "9.9",
            "9"
        ],
        "non_matches": [
            "-9.9e-309"
        ]
    },
    {
        "id": 1468,
        "expression": "^([0-1]?[0-9]|[2][0-3]):([0-5][0-9])$",
        "description": "Checks time in 24 hours notation, however this one is shorter than the ones I found on regexplib",
        "matches": [
            "23:00",
            "12:21",
            "0:00"
        ],
        "non_matches": [
            "24:00",
            "23:60",
            "0:60"
        ]
    },
    {
        "id": 1469,
        "expression": "https?://(?!\\S*?domainname\\.tld/)\\S*?/",
        "description": "This type of filter can be used if you're trying to get rid of results from a report or something not originating from a given domain of the format domainname.tld. Anything matching the pattern can then be excluded, deleted, etc. (Like with a Google Mini, GSA, or site auditing software)",
        "matches": [
            "http://www.domainname2.tld2/",
            "http://sub.domainname3.tld3/",
            "https://secure.domainname4.tld4/",
            "http://domainname5.tld5/"
        ],
        "non_matches": [
            "http://www.domainname.tld/",
            "http://sub.domainname.tld/",
            "https://secure.domainname.tld/",
            "http://domainname.tld/"
        ]
    },
    {
        "id": 1473,
        "expression": "https?://[\\w./]+\\/[\\w./]+\\.(bmp|png|jpg|gif)",
        "description": "match web pictrue's address,must be full path,include http head.",
        "matches": [
            "http://image2.sina.com.cn/home/07index/sinahome_ws_035.gif"
        ],
        "non_matches": [
            "img src=\"images/1.jpg\""
        ]
    },
    {
        "id": 1474,
        "expression": "^([0-9][,]?)*([0-9][0-9])$",
        "description": "This pattern matches numbers separated by comma",
        "matches": [
            "100,200"
        ],
        "non_matches": [
            ",,100",
            "100,,222",
            "100,,,"
        ]
    },
    {
        "id": 1476,
        "expression": "<(/)?(a|abbr|acronym|address|applet|area|b|base|basefont|bdo|big|blockquote|body|br|button|caption|center|cite|code|col|colgroup|dd|del|dir|div|dfn|dl|dt|em|fieldset|font|form|frame|frameset|h[1-6]|head|hr|html|i|iframe|img|input|ins|isindex|kbd|label|legend|li|link|map|menu|meta|noframes|noscript|object|ol|optgroup|option|p|param|pre|q|s|samp|script|select|small|span|strike|strong|style|sub|sup|table|tbody|td|textarea|tfoot|th|thead|title|tr|tt|u|ul|var|xmp){1}(\\s(\\\"[^\\\"]*\\\"*|[^>])*)*>",
        "description": "This should match all valid HTML 4.01 tags as a browser would recognize. If you miss a 2nd \" it will continue until it finds one to pair with, so if it doesn't find one, it continues until the end. This is how most browsers work I believe. It does have a few flaws, it will match </img> and </input> which is weird, but perhaps I'll fix that eventually.",
        "matches": [
            "</a> <h2 > </h2 asfsdf> <a href=\"abc>>123\">"
        ],
        "non_matches": [
            "< /a> </h 2 asfsdf> <ahref=\"abc123\">"
        ]
    },
    {
        "id": 1479,
        "expression": "^(?=(.*[a-z]){1,})(?=(.*[\\d]){1,})(?=(.*[\\W]){1,})(?!.*\\s).{7,30}$",
        "description": "The basic expression requires at least 1 lower case, 1 upper case, 1 numeric, 1 non-word and no whitespace.\n<br /><br />\nThe format of the expression lends itself to being parameterised, thus in C# I have a method that returns a modified pattern based on passed in parameters e.g.\n<br /><br />return \"^(?=(.*[a-z]){\" + minLowerCase.ToString() + \",})\"<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ \"(?=(.*[\\d]){\" + minNumeric.ToString() + \",})\"<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ \".{\" + minLength.ToString() + \",\" + maxLength.ToString() + \"}$\");<br /><br />Its then possible to set the password strength via configuration files which require strong passwords in production environments, but allow weaker passwords in development environments.",
        "matches": [
            "qW1@xxx"
        ],
        "non_matches": [
            "qwerty123"
        ]
    },
    {
        "id": 1483,
        "expression": "</?(a|abbr|acronym|address|applet|area|b|base|basefont|bdo|big|blockquote|body|br|button|caption|center|cite|code|col|colgroup|dd|del|dir|div|dfn|dl|dt|em|fieldset|font|form|frame|frameset|h[1-6]|head|hr|html|i|iframe|img|input|ins|isindex|kbd|label|legend|li|link|map|menu|meta|noframes|noscript|object|ol|optgroup|option|p|param|pre|q|s|samp|script|select|small|span|strike|strong|style|sub|sup|table|tbody|td|textarea|tfoot|th|thead|title|tr|tt|u|ul|var|xmp)\\b((\\\"[^\\\"]*\\\"|\\'[^\\']*\\')*|[^\\\"\\'>])*>",
        "description": "This is very similar to my other expression, except it only matches tags that a browser would read, so if you have an extra \" in the tag, it will not count it, and move onto the next possibility.",
        "matches": [
            "</a> <h2 > </a asdfs> </h2 asfsdf> <a href=\"abc>>123\">"
        ],
        "non_matches": [
            "< /a> </h 2 asfsdf> <ahref=\"abc\"123\">"
        ]
    },
    {
        "id": 1484,
        "expression": "^([0-1]?[0-9]{1}/[0-3]?[0-9]{1}/20[0-9]{2})$",
        "description": "This regular expression will validate most (current & future) date options. The weaknesses with this one is that it will allow the days to go up to 39 and does not account for leap year. Also, the months can go up to 19, instead of our commonly accepted 12 month year. :) I designed this expression to validate dates from the year 2000 to 2099. I do not plan on this same code being in place in 2099, so I hope this is sufficient enough...",
        "matches": [
            "2/14/2001",
            "12/29/2099",
            "19/39/2000"
        ],
        "non_matches": [
            "12/29/1999",
            "20/40/2100"
        ]
    },
    {
        "id": 1485,
        "expression": "^\\d+\\*\\d+\\*\\d+$",
        "description": "one or more numbers, asterisk, one or more numbers, asterisk, one or more numbers, no letters or punctuation other than asterisks.",
        "matches": [
            "123*4578*8908650"
        ],
        "non_matches": [
            "12a*9999*9096"
        ]
    },
    {
        "id": 1486,
        "expression": "^((http|https|ftp):\\/\\/)?((.*?):(.*?)@)?([a-zA-Z0-9][a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])((\\.[a-zA-Z0-9][a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])*)(:([0-9]{1,5}))?((\\/.*?)(\\?(.*?))?(\\#(.*))?)?$",
        "description": "Validates and extracts URI components.\nProtocol is optional.\nUsername & Password is optional.\nHost regex was taken from Remi Sabourin and follows RFC1035 except that it allows hostnames greater than 253 chars.\nAlso TLD length is not restriced.\nPort number is optional.\nAbsolute Path is optional, and also extracts the optional querystring and optional anchor reference.",
        "matches": [
            "http://john:@www.domain.com:8080/index.html?param=value#Page1"
        ],
        "non_matches": [
            "http://www.domain.com:/",
            "www-.domain.com"
        ]
    },
    {
        "id": 1489,
        "expression": "^100(\\.0{0,2}?)?$|^\\d{0,2}(\\.\\d{0,2})?$",
        "description": "Matches percentages from 0-100 inclusive with two decimal places.",
        "matches": [
            "0",
            "100",
            "100.00",
            "45.45"
        ],
        "non_matches": [
            "101",
            "-5",
            "45.456"
        ]
    },
    {
        "id": 1490,
        "expression": "(?=^.{1,254}$)(^(?:(?!\\d+\\.|-)[a-zA-Z0-9_\\-]{1,63}(?<!-)\\.?)+(?:[a-zA-Z]{2,})$)",
        "description": "Validates MS FQDNs. 1) Entire fqdn less than 255 chars. 2) Host and domain names may contain an underscore. 3) 1st char can be a number. 4) No part can be all numbers. 5) Allows any TLD Works in C#. Based on Remi Sabourin's regex. Based on anonymous feedback I've corrected it to no longer match domains that start or end with a hyphen.",
        "matches": [
            "host.domain.com",
            "_host.domain.com",
            "1host-2._ldap.domain.com"
        ],
        "non_matches": [
            "33.domain.com",
            "host..com",
            "a-.com"
        ]
    },
    {
        "id": 1492,
        "expression": "^((0[1-9])|(1[0-2]))\\/((0[1-9])|(1[0-9])|(2[0-9])|(3[0-1]))\\/(\\d{4})$",
        "description": "This regular expressions matches dates in the format MM/DD/YYYY where MM can be 01 to 12, DD can be 01 to 31 and YYYY is always 4 digits long.",
        "matches": [
            "12/25/2007",
            "11/07/1517",
            "02/25/2727"
        ],
        "non_matches": [
            "1/27/1977",
            "00/01/000",
            "15/07/2002"
        ]
    },
    {
        "id": 1493,
        "expression": "(src|href|action)=\"(?!http://|#|mailto:|&)([^/#\"])",
        "description": "If when making a website you need to find your relative paths, this regex will find them. You can use the follow to make them absolute:\n\\1=\"/\\2",
        "matches": [
            "src=\"images\"",
            "href=\"index.html\"",
            "action=\"process.php\""
        ],
        "non_matches": [
            "src=\"/images\"",
            "href=\"/index.html\"",
            "action=\"/process.php\"",
            "href=\"http://www.google.com\"",
            "href=\"mailto:ceo@ceo.com\"",
            "href=\"#\"",
            "href=\"\"",
            "href=\"&name=test\""
        ]
    },
    {
        "id": 1494,
        "expression": "^([A-Z][a-z]+)\\s([A-Z][a-zA-Z-]+)$",
        "description": "The pattern matches what would at least appear to be a first and last name, with an optional hyphenated last name. There is an obvious flaw that it can't distinguish between actual names and any two words that start with capital letters as noted in the matching text. Also, two part first names like \"Mary Jo\" can cause problems.",
        "matches": [
            "John Smith",
            "Jane Smith-Doe",
            "John McSmith",
            "Abc Xyz"
        ],
        "non_matches": [
            "john smith",
            "J Smith",
            "Mrs. Doe"
        ]
    },
    {
        "id": 1495,
        "expression": "[0-9]{4}-([0][0-9]|[1][0-2])-([0][0-9]|[1][0-9]|[2][0-9]|[3][0-1])",
        "description": "This function does basic testing for the YYYY-MM-DD date format.",
        "matches": [
            "1981-10-16"
        ],
        "non_matches": [
            "1981-13-10"
        ]
    },
    {
        "id": 1496,
        "expression": "(UPDATE\\s+)(\\w+)\\s+(SET)\\s+([\\w+\\s*=\\s*\\w+,?\\s*]+)\\s+(WHERE.+)",
        "description": "Use with \"/i\" flag (case-insensitive) to match any valid SQL UPDATE statement, and to parse it into it's component parts. Most useful will be group $2, the table name, group $4, the field=value list, and group $5, the WHERE clause.",
        "matches": [
            "UPDATE table1 SET field1=value1,field2=value WHERE field4=value4"
        ],
        "non_matches": [
            "UPDATE table1 SET field1=value1,field2=value"
        ]
    },
    {
        "id": 1502,
        "expression": "ISBN(?:-13)?:?\\x20*(?=.{17}$)97(?:8|9)([ -])\\d{1,5}\\1\\d{1,7}\\1\\d{1,6}\\1\\d$",
        "description": "This regex matches the new 13 digit ISBN. The ISBN number must be preceded by the text \"ISBN:\" or \"ISBN-13:\" , the colon is optional. The proper lengthes of the ISBN elements is checked. The is no check for the validity of the check digit.",
        "matches": [
            "ISBN-13: 978-1-4028-9462-6"
        ],
        "non_matches": [
            "ISBN-10: 1-4028-9462-7"
        ]
    },
    {
        "id": 1503,
        "expression": "(INSERT INTO\\s+)(\\w+)(\\s+\\()([\\w+,?\\s*]+)(\\)\\s+VALUES\\s+\\()(['?\\w+'?,?\\s*]+)(\\))",
        "description": "Use with \"/i\" flag (case-insensitive) to match a fully qualified SQL INSERT statement, and to parse it into it's component parts. Group $2 will contain the table name, $4 the field list, and $6 the value list.",
        "matches": [
            "INSERT INTO table (field1, field2) VALUES (value1, value2)"
        ],
        "non_matches": [
            "INSERT INTO table VALUES (value1, value2)"
        ]
    },
    {
        "id": 1504,
        "expression": "(INSERT INTO\\s+)(\\w+)(\\s+\\()([\\w+,?\\s*]+)(\\)\\s+VALUES\\s+)((\\(['?\\w+'?,?\\s*]+\\)\\,?;?\\s*)+)",
        "description": "Use with \"/i\" flag (case-insensitive) to match a fully qualified SQL INSERT statement, and to parse it into it's component parts. Group $2 will contain the table name, $4 the field list, and $6 the all of the value lists.",
        "matches": [
            "INSERT INTO table (field1, field2) VALUES (value1, value2); (value3, value4) or INSERT INTO table (field1, field2) VALUES (value1, value2), (value3, value4)"
        ],
        "non_matches": [
            "INSERT INTO table VALUES (value1, value2)"
        ]
    },
    {
        "id": 1512,
        "expression": "^(((19|20)(([0][48])|([2468][048])|([13579][26]))|2000)[\\-](([0][13578]|[1][02])[\\-]([012][0-9]|[3][01])|([0][469]|11)[\\-]([012][0-9]|30)|02[\\-]([012][0-9]))|((19|20)(([02468][1235679])|([13579][01345789]))|1900)[\\-](([0][13578]|[1][02])[\\-]([012][0-9]|[3][01])|([0][469]|11)[\\-]([012][0-9]|30)|02[\\-]([012][0-8])))$",
        "description": "This regex match dates in the international standard date notation by ISO (IS0 8601). It can validate any dates between 1900-01-01 and 2099-12-31 ant take account of leap years. The format is mandatory and the hyphen is needed. You could easily change it to accept other separators. It has been tested with Regex Coach and PHP.",
        "matches": [
            "1900-01-01",
            "2099-12-31",
            "2004-02-29"
        ],
        "non_matches": [
            "20060526",
            "1900-02-29",
            "2100-01-01"
        ]
    },
    {
        "id": 1515,
        "expression": "^(-?)(((\\d{1,3})(,\\d{3})*)|(\\d+))(\\.\\d{1,2})?$",
        "description": "This RegEx checks whether the input is a number or not. Number may contain commas a seperators, can contain one or two decimal places and can be positive or negative.",
        "matches": [
            "100,000,000.00",
            "-100,000,000.00",
            "100,000,000",
            "-100,000,000",
            "100000000.00",
            "-100000000.00",
            "100000000",
            "-100000000"
        ],
        "non_matches": [
            "100,000,00.00",
            "1000.000",
            "1000."
        ]
    },
    {
        "id": 1520,
        "expression": "^1?[1-2]$|^[1-9]$|^[1]0$",
        "description": "Get one and two numeric digits between 1 and 12 inclusive, positive numbers only (Zeros are excluded and so is values higher than 12).",
        "matches": [
            "1",
            "6",
            "12"
        ],
        "non_matches": [
            "-1",
            "0",
            "13"
        ]
    },
    {
        "id": 1522,
        "expression": "&(?![a-z]+;|#\\d+;)",
        "description": "Single & character is not valid in HTML or XHTML code. In this case you can replace this character with its entity (if & character is not member of other entity [&amp;#353;]). example: preg_replace('/&(?!amp;)/', '&amp;amp;', $str).\n(thanks to mr. Mrva)",
        "matches": [
            "&"
        ],
        "non_matches": [
            "&amp;amp;",
            "&amp;quot;",
            "&amp;#353;",
            "&blah;",
            "&amp;copy;"
        ]
    },
    {
        "id": 1523,
        "expression": "^((http|https|ftp)\\://|www\\.)[a-zA-Z0-9\\-\\.]+\\.[a-zA-Z]{2,4}(/[a-zA-Z0-9\\-\\._\\?=\\,\\'\\+%\\$#~]*[^\\.\\,\\)\\(\\s])*$",
        "description": "Matches any valid URLs which can activate links in a text.",
        "matches": [
            "www.something.com",
            "http://something.com/something?action=delete",
            "http://www.something.com/~etc"
        ],
        "non_matches": [
            "http://www.something.com/,",
            "wwww.something.com",
            ""
        ]
    },
    {
        "id": 1524,
        "expression": "[({]?(0x)?[0-9a-fA-F]{8}([-,]?(0x)?[0-9a-fA-F]{4}){2}((-?[0-9a-fA-F]{4}-?[0-9a-fA-F]{12})|(,\\{0x[0-9a-fA-F]{2}(,0x[0-9a-fA-F]{2}){7}\\}))[)}]?",
        "description": "It matches all strings that the .NET Framework API \"new Guid(string guid)\" can recognize. A String that contains a GUID in one of the following formats ('d' represents a hexadecimal digit whose case is ignored):",
        "matches": [
            "ca761232ed4211cebacd00aa0057b223",
            "CA761232-ED42-11CE-BACD-00AA0057B223",
            "{CA761232-ED42-11CE-BACD-00AA0057B223}",
            "(CA761232-ED42-11CE-BACD-00AA0057B223)",
            "{0xCA761232,0xED42,0x11CE,{0xBA,0xCD,0x00,0xAA,0x00,0x57,0xB2,0x23}}"
        ],
        "non_matches": [
            "Invalid guids"
        ]
    },
    {
        "id": 1530,
        "expression": "^(([1-9][0-9]*)|((([0])|([1-9][0-9]*))\\.[0-9]+)|((([1-9][0-9]*)|((([0])|([1-9][0-9]*))\\.[0-9]+))\\:)*(([1-9][0-9]*)|((([0])|([1-9][0-9]*))\\.[0-9]+)))$",
        "description": "Accepts a colon-delimited string of positive integers and/or decimal numbers in any combination. Spaces are not permitted. Decimal numbers of less than 1 must be prefixed with a zero (e.g. accepts 0.1, but not .1), and numbers with a trailing decimal point are not accepted (e.g. accepts 3.0, but not 3.). A lone zero is not accpeted (e.g. accepts 1.02:3:4.5, but not 1.02:0:4.5). Developed from a similar expression by Steven Smith on this site.",
        "matches": [
            "1.2",
            "0.1:0.5:56:6.70",
            "3:6.78954:1:2:3"
        ],
        "non_matches": [
            "0.1:.5:56",
            "-6.70:3.",
            "5: 0.1:0"
        ]
    },
    {
        "id": 1536,
        "expression": "^(( )*\\\u00a3{0,1}( )*)\\d*(.\\d{1,2})?$",
        "description": "This expression is for matching the currency input. The \u00a3 is optional. e.g. \u00a312.12, \u00a3 12.12, 12.12, 12.",
        "matches": [
            "\u00a3123.00"
        ],
        "non_matches": [
            "$123.00"
        ]
    },
    {
        "id": 1537,
        "expression": "^\\({0,1}((0|\\+61)(2|4|3|7|8)){0,1}\\){0,1}(\\ |-){0,1}[0-9]{2}(\\ |-){0,1}[0-9]{2}(\\ |-){0,1}[0-9]{1}(\\ |-){0,1}[0-9]{3}$",
        "description": "Australian phone number validator. Accepts all forms of Australian phone numbers in different formats (area code in brackets, no area code, spaces between 2-3 and 6-7th digits, +61 international dialing code). Checks that area codes are valid (when entered).",
        "matches": [
            "0403111111",
            "(03) 1111 1111",
            "+61403111111",
            "02 9111 1111",
            "0403 111 111",
            "91111111"
        ],
        "non_matches": [
            "9111 11111",
            "99 1111 1111"
        ]
    },
    {
        "id": 1538,
        "expression": "(http(s?)://|[a-zA-Z0-9\\-]+\\.)[a-zA-Z0-9/~\\-]+\\.[a-zA-Z0-9/~\\-_,&\\?\\.;]+[^\\.,\\s<]",
        "description": "This regex avoids matching typical mistakes where a sentence ends but there is no space after the full stop (period). Other regexes will think any two words with a dot in between is a URL! My regex does not require http:// and if there isn't http:// it will need to find AT LEAST two dots to guarantee its likely to be a URL and not a sentence that's missing a space like this.It will match www.test.com, http://test.com, test.com/index.htm but it will NOT match test.com. It will not match a dot or a comma at the very end which some people may type when including a URL in a sentence like this www.test.com, or this www.test.com.",
        "matches": [
            "sub.test.com"
        ],
        "non_matches": [
            "test.com"
        ]
    },
    {
        "id": 1539,
        "expression": "^N[1-9][0-9]{0,4}$|^N[1-9][0-9]{0,3}[A-Z]$|^N[1-9][0-9]{0,2}[A-Z]{2}$",
        "description": "FAA Tail Numbers as described here: http://www.faa.gov/licenses_certificates/aircraft_certification/aircraft_registry/special_nnumbers/",
        "matches": [
            "N12345"
        ],
        "non_matches": [
            "N123456"
        ]
    },
    {
        "id": 1540,
        "expression": "^((\\(?\\+45\\)?)?)(\\s?\\d{2}\\s?\\d{2}\\s?\\d{2}\\s?\\d{2})$",
        "description": "This should help in finding european style phone numbers (without hyphens), particularly danish numbers with consist of 8 digits, and can be separated by a whitespace.",
        "matches": [
            "(+45) 35 35 35 35",
            "+45 35 35 35 35",
            "35 35 35 35",
            "35353535"
        ],
        "non_matches": [
            "(45)35353535",
            "4535353535"
        ]
    },
    {
        "id": 1542,
        "expression": "^[^\\s]+@[^\\.][^\\s]{1,}\\.[A-Za-z]{2,10}$",
        "description": "Simple email regex following some liberal email address validation. Requires non-whitespace name (but allows any other character), an @ symbol, then a non-period character, then some non-whitespace text (but allows just about everything else), and finishes with a tld that is 2 to 10 chars long. Two-characters is the universal minimum, 10 seemed like a good upper limit for now and allows room to grow. You can use this for a quick sanity check. Yes, the user can still enter invalid email addys, but then they won't get their emails, will they?",
        "matches": [
            "foo-bar@foo.the.20.bars.com"
        ],
        "non_matches": [
            "foo bar@foo.com",
            "foobar@.com",
            "foo@bar.c"
        ]
    },
    {
        "id": 1549,
        "expression": "\\d\\d?\\d?\\.\\d\\d?\\d?\\.\\d\\d?\\d?\\.\\d\\d?\\d?",
        "description": "Quick and simple way of matching a well-formed IPV4 (dotted quad) ip address.",
        "matches": [
            "192.168.1.19"
        ],
        "non_matches": [
            "19x.168.1.19"
        ]
    },
    {
        "id": 1553,
        "expression": "^((0|[1-9]+[0-9]*)-(0|[1-9]+[0-9]*);|(0|[1-9]+[0-9]*);)*?((0|[1-9]+[0-9]*)-(0|[1-9]+[0-9]*)|(0|[1-9]+[0-9]*)){1}$",
        "description": "Matches any range of numbers according to the format x;x-xx where \"x\" is a number between 0 and 9, however 0 may not be a the starting digit of a multi-digit number (i.e. 001). The format specifies that a range is denoted by x-x (numbers are seperated by a hyphen) and multiple range specification or single numbers may be seperated by a semi-colon \";\".",
        "matches": [
            "0",
            "0-3",
            "1;2",
            "1;2-3",
            "2-3;10",
            "1-2;3-40"
        ],
        "non_matches": [
            "1;",
            "2-3;",
            "a;1",
            "2-3;a",
            "001-3",
            "1-003"
        ]
    },
    {
        "id": 1566,
        "expression": "^\\d*[0-9](\\.\\d?[0-9])?$",
        "description": "Allow Decimal values as [decimal](*, 2), scale length between 0 and 2",
        "matches": [
            "87645.09",
            "87645.9",
            "87645.10",
            "87645"
        ],
        "non_matches": [
            "87645.091",
            "87645."
        ]
    },
    {
        "id": 1567,
        "expression": "^((\\d{0,1}[0-9](\\.\\d{0,1}[0-9])?)|(100))$",
        "description": "Allow Percentage with optional scale (max length of 2) between (00.00 and 100)",
        "matches": [
            "00.00",
            "00",
            "99.99",
            "99.5",
            "100"
        ],
        "non_matches": [
            "99.",
            "100.1"
        ]
    },
    {
        "id": 1570,
        "expression": "^([0-9]{4})-([0-1][0-9])-([0-3][0-9])\\s([0-1][0-9]|[2][0-3]):([0-5][0-9]):([0-5][0-9])$",
        "description": "SQL datetime format tester YYYY-MM-DD HH:MM:SS",
        "matches": [
            "2007-07-01 01:01:01",
            "2007-08-04 18:01:01"
        ],
        "non_matches": [
            "2007-07-01",
            "2007/07/01",
            "2007-08-04 24:00:00",
            "2007/07/01 12:12"
        ]
    },
    {
        "id": 1579,
        "expression": "(^[0][.]{1}[0-9]{0,}[1-9]+[0-9]{0,}$)|(^[1-9]+[0-9]{0,}[.]?[0-9]{0,}$)",
        "description": "This pattern will match any positive number(Real or Integer). It will not match ZERO or any variation of zero (ie 0.00)",
        "matches": [
            "0.003",
            "34",
            "6.000",
            "7.3"
        ],
        "non_matches": [
            "0.0",
            "-34",
            "-23.00",
            "0",
            "-0.30"
        ]
    },
    {
        "id": 1582,
        "expression": "(<(tag1|tag2)[^>]*\\/?>)[\\w\\S\\s]*?(<\\/(?:\\2)>)",
        "description": "This will remove the InnerHTML of a tag. For instance, if you wanted to clear all paragraphs and h1 tags on a page, you would simply put in \"p\" and \"h1\" into those tags, and they would end up looking like <h1></h1> <p></p> <p></p>. It's useful when you're doing work based off a template and you need to get back to the original template.",
        "matches": [
            "<tag1>Lorem ipsum dolor sit amet</tag1>"
        ],
        "non_matches": [
            "<tag1>Lorem ipsum doler</othertag>"
        ]
    },
    {
        "id": 1585,
        "expression": "([0-9a-zA-Z]([-.\\w]*[0-9a-zA-Z])*@([0-9a-zA-Z][-\\w]*[0-9a-zA-Z]\\.)+[a-zA-Z]{2,9})$",
        "description": "This pattern validates email address. it allows (1)numeric characters and underscore(_) in an address.(2)numeric characters in domain name. it doesn't match user names with a dot(.). doesn;t allow username starting or ending with @ underscore.",
        "matches": [
            "san_z@asg.com",
            "xy_z@123g.co.in",
            "san@ss.com.in"
        ],
        "non_matches": [
            "ssaa_s@asg.c",
            "a@a.com",
            "san@s.co.in",
            "san@apr.com.in.i"
        ]
    },
    {
        "id": 1586,
        "expression": "^(5[1-5]\\d{2})\\d{12}|(4\\d{3})(\\d{12}|\\d{9})$",
        "description": "A simple regex to check for only Visa and MasterCard with no dashes or spaces. Visa starts with a 4 and is 13 or 16 digits long, MasterCard starts with a 51 through 55 and is 16 digits long. I noticed that some of the other formulas don't account for Visa being valid with only 13 digits. I used this for a PayPal processor (which doesn't allow dashes or spaces) and modified it from others on this site. Enjoy.",
        "matches": [
            "5555555555554444",
            "5105105105105100",
            "4012888888881881",
            "4222222222222"
        ],
        "non_matches": [
            "123412341234",
            "4222-2222-2222-2222",
            "visa",
            "41231234123412345"
        ]
    },
    {
        "id": 1587,
        "expression": "\"[^\"]+\"",
        "description": "Finds strings enclosed in double quotations",
        "matches": [
            "\"MatchingText\""
        ],
        "non_matches": [
            "NonMatchingText"
        ]
    },
    {
        "id": 1588,
        "expression": "(15(8[48]|9[26]))|((1[6-9]|[2-9]\\d)(0[48]|[13579][26]|[2468][048]))|(([2468][048]|16|3579[26])00)",
        "description": "Validates four-digit leap years after 1582 (when Pope Gregory XIII switched to the Gregorian calendar). The last recognized leap year is 9996, so no worries with the y3k bug.",
        "matches": [
            "1584",
            "2000",
            "2048"
        ],
        "non_matches": [
            "1200",
            "1580",
            "1941",
            "1800"
        ]
    },
    {
        "id": 1589,
        "expression": "^\\d{4}(\\/|-)([0][1-9]|[1][0-2])(\\/|-)([0][1-9]|[1-2][0-9]|[3][0-1])$",
        "description": "This regular expressions matches dates of the form YYYY/XX/ZZ ,where YYYY is always 4 digits long, XX can be 01 to 12 and ZZ can be 01 to 31",
        "matches": [
            "2007/01/20",
            "0001/02/31",
            "9999-12-31"
        ],
        "non_matches": [
            "01/1/01",
            "99-9-9",
            "2008-00-00"
        ]
    },
    {
        "id": 1592,
        "expression": "^[-+]?\\d+(\\.\\d{2})?$",
        "description": "It accepts only two integer after a decimal point. The number may be in Positive or negative.",
        "matches": [
            "+1212.14",
            "-12.13",
            "122.45"
        ],
        "non_matches": [
            "1212.4564",
            "-11.5858",
            "12.000"
        ]
    },
    {
        "id": 1593,
        "expression": "^((((19[0-9][0-9])|(2[0-9][0-9][0-9]))([-])(0[13578]|10|12)([-])(0[1-9]|[12][0-9]|3[01]))|(((19[0-9][0-9])|(2[0-9][0-9][0-9]))([-])(0[469]|11)([-])([0][1-9]|[12][0-9]|30))|(((19[0-9][0-9])|(2[0-9][0-9][0-9]))([-])(02)([-])(0[1-9]|1[0-9]|2[0-8]))|(([02468][048]00)([-])(02)([-])(29))|(([13579][26]00)([-])(02)([-])(29))|(([0-9][0-9][0][48])([-])(02)([-])(29))|(([0-9][0-9][2468][048])([-])(02)([-])(29))|(([0-9][0-9][13579][26])([-])(02)([-])(29)))$",
        "description": "This regex checks if a date is in ISO-format (yyyy-mm-dd). Leap year should be checked too. Date has to be between 1900-01-01 and 2999-12-31.",
        "matches": [
            "1900-01-01",
            "2025-03-15",
            "2999-12-31"
        ],
        "non_matches": [
            "1890-01-01",
            "2008-19-45",
            "3000-01-01"
        ]
    },
    {
        "id": 1594,
        "expression": "^(((0[1-9]|[12][0-9]|3[01])([\\.])(0[13578]|10|12)([\\.])((19[0-9][0-9])|(2[0-9][0-9][0-9])))|(([0][1-9]|[12][0-9]|30)([\\.])(0[469]|11)([\\.])((19[0-9][0-9])|(2[0-9][0-9][0-9])))|((0[1-9]|1[0-9]|2[0-8])([\\.])(02)([\\.])((19[0-9][0-9])|(2[0-9][0-9][0-9])))|((29)([\\.])(02)([\\.])([02468][048]00))|((29)([\\.])(02)([\\.])([13579][26]00))|((29)([\\.])(02)([\\.])([0-9][0-9][0][48]))|((29)([\\.])(02)([\\.])([0-9][0-9][2468][048]))|((29)([\\.])(02)([\\.])([0-9][0-9][13579][26])))$",
        "description": "This regex checks if a date is in german date format (dd.mm.yyyy). Leap year should be checked too. Date has to be between 01.01.1900 and 31.12.2999.",
        "matches": [
            "01.01.1900",
            "20.11.2009",
            "31.12.2999"
        ],
        "non_matches": [
            "01.01.1890",
            "11.20.2009",
            "01.01.3000"
        ]
    },
    {
        "id": 1597,
        "expression": "^(http(?:s)?\\:\\/\\/[a-zA-Z0-9]+(?:(?:\\.|\\-)[a-zA-Z0-9]+)+(?:\\:\\d+)?(?:\\/[\\w\\-]+)*(?:\\/?|\\/\\w+\\.[a-zA-Z]{2,4}(?:\\?[\\w]+\\=[\\w\\-]+)?)?(?:\\&[\\w]+\\=[\\w\\-]+)*)$",
        "description": "A simple but powerful URL validating regex. Accepts multiple sub-domains and sub-directories. Even accept query strings.\nNow accept ports! Accepts HTTP or HTTPS.\nAlso accepts optional \"/\" on end of address.",
        "matches": [
            "http://website.com",
            "http://subdomain.web-site.com/cgi-bin/perl.cgi?key1=value1&key2=value2"
        ],
        "non_matches": [
            "http://website.com/perl.cgi?key=",
            "http://web-site.com/cgi-bin/perl.cgi?key1=value1&key2"
        ]
    },
    {
        "id": 1599,
        "expression": "^(http\\:\\/\\/[a-zA-Z0-9\\-\\.]+\\.[a-zA-Z]{2,3}(?:\\/\\S*)?(?:[a-zA-Z0-9_])+\\.(?:jpg|jpeg|gif|png))$",
        "description": "A nice little regex to verify a URL pointing towards an image. Can be useful.",
        "matches": [
            "http://website.com/directory/image.gif"
        ],
        "non_matches": [
            "www.website.com/image.php"
        ]
    },
    {
        "id": 1601,
        "expression": "[0-9][0-9][0-9][0-9]-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])\\s{1}(0[0-9]|1[0-9]|2[0-3]):([0-5][0-9])",
        "description": "Validation of date (YYYY-MM-DD format) and time (HH:MM format) with one space between both blocks. I'm not able (with this) to validate the correct last day of each month. Anyway, it helps :-)",
        "matches": [
            "2007-01-01 00:00"
        ],
        "non_matches": [
            "2007-1-1 0:0"
        ]
    },
    {
        "id": 1606,
        "expression": "(?:\\([2-9][0-8]\\d\\)\\ ?|[2-9][0-8]\\d[\\-\\ \\.\\/]?)[2-9]\\d{2}[- \\.\\/]?\\d{4}\\b",
        "description": "Matches NANP requirements for valid telephone numbers in the USA, its territories, Canada, Bermuda, and 16 Caribbean nations.<br>\nArea code: [2-9][0-8][0-9]<br>\nExchange code: [2-9][0-9][0-9]<br>\nStation code: [0-9][0-9][0-9][0-9]<br>\nAccepts common phone number separators like parentheses, dash/hyphen, slash, period, and space. Stops matching at any word boundary, including end of line. Adapted from Don Johnston's pattern.",
        "matches": [
            "8296399623",
            "741 556-4630",
            "319.380.3232",
            "(859)673.5793",
            "660/471.5749"
        ],
        "non_matches": [
            "(195)979-5873",
            "763 027 5552",
            "596 270.0326",
            "8915551212"
        ]
    },
    {
        "id": 1611,
        "expression": "^(.{0,}(([a-zA-Z][^a-zA-Z])|([^a-zA-Z][a-zA-Z])).{4,})|(.{1,}(([a-zA-Z][^a-zA-Z])|([^a-zA-Z][a-zA-Z])).{3,})|(.{2,}(([a-zA-Z][^a-zA-Z])|([^a-zA-Z][a-zA-Z])).{2,})|(.{3,}(([a-zA-Z][^a-zA-Z])|([^a-zA-Z][a-zA-Z])).{1,})|(.{4,}(([a-zA-Z][^a-zA-Z])|([^a-zA-Z][a-zA-Z])).{0,})$",
        "description": "Passwords with at least 1 letter, at least 1 non-letter, and at least 6 characters in length. It is lenthy with a repeating pattern so that I could validate all three conditions in one expression without using a lookahead, \"?=\", which are not handled correctly in Internet Explorer.",
        "matches": [
            "12345a",
            "abcde*",
            "ABC123"
        ],
        "non_matches": [
            "12ab",
            "abcdef",
            "123456"
        ]
    },
    {
        "id": 1618,
        "expression": "^([0-9]{0,5}|[0-9]{0,5}\\.[0-9]{0,3})$",
        "description": "This regular expression is intended to limit numeric entries by allowed places before and after the decimal point. It also recognizes whole numbers. In this example the value cannot exceed 99999.999. To change the range, simply edit the numbers in curly braces. For example, to allow 7 digits (millions) before the decimal point, change both instances of {0,5} to {0,7}. Likewise, to change the decimals from allowing thousandths (3 digits) to just hundreths, change the {0,3} to {0,2}. This can be useful for numeric fields in SQL. This example was made to accommodate a numeric(8,3) field definition.",
        "matches": [
            "0",
            "1",
            "1.55",
            "54321.123",
            ".12"
        ],
        "non_matches": [
            "abc",
            "654321",
            "12..34",
            ".1234"
        ]
    },
    {
        "id": 1621,
        "expression": "^((?:\\?[a-zA-Z0-9_]+\\=[a-zA-Z0-9_]+)?(?:\\&[a-zA-Z0-9_]+\\=[a-zA-Z0-9_]+)*)$",
        "description": "This is a very simple regex that check the query part of a string. That is to say anything after the \"?\" at the end of an URL.",
        "matches": [
            "?key=value",
            "?key1=value1&key2=value2"
        ],
        "non_matches": [
            "key=value",
            "?key=value&"
        ]
    },
    {
        "id": 1625,
        "expression": "^[^\\x00-\\x1f\\x21-\\x26\\x28-\\x2d\\x2f-\\x40\\x5b-\\x60\\x7b-\\xff]+$",
        "description": "Matches common ASCII names without special characters.",
        "matches": [
            "Sir. Isaac Newton",
            "Tom O'Leary"
        ],
        "non_matches": [
            "Mar!y Ann",
            "Bob_1",
            "~!@#$%^&*()_+=-0987654321`{}[]",
            "\\;:\"<>?,/"
        ]
    },
    {
        "id": 1632,
        "expression": "(?=[-_a-zA-Z0-9]*?[A-Z])(?=[-_a-zA-Z0-9]*?[a-z])(?=[-_a-zA-Z0-9]*?[0-9])[-_a-zA-Z0-9]{6,}",
        "description": "Tests if the input consists of 6 or more letters, digits, underscores and hyphens. The input must contain at least one upper case ltter, one lower case letter and one digit.",
        "matches": [
            "M0_k3y",
            "Pa-sW0rd",
            "S1mPl3"
        ],
        "non_matches": [
            "MonKey",
            "PassWord",
            "simple"
        ]
    },
    {
        "id": 1633,
        "expression": "(?<!^)(?=[A-Z])",
        "description": "Used with the Regex.Split() function in .NET, this will easily split a camelCase word on the upper case letters, while not dropping any characters. (That makes it different from most split() functions -- it does not drop any characters.) More details in my blog - http://blogs.lotterypost.com/speednet/2007/08/simple-function-to-split-camelcase-words.htm",
        "matches": [
            "camelCase"
        ],
        "non_matches": [
            "<empty string>"
        ]
    },
    {
        "id": 1636,
        "expression": "^((192\\.168\\.0\\.)(1[7-9]|2[0-9]|3[0-2]))$",
        "description": "This expression matches IP Addresses between 192.168.0.17 - 192.168.0.32 which is a block range of 16 addresses. I created this expression for Google Analytics to filter out hits from our companies office.",
        "matches": [
            "192.168.0.17",
            "192.168.0.24",
            "192.168.0.32"
        ],
        "non_matches": [
            "192.168.0.16",
            "192.168.0.33"
        ]
    },
    {
        "id": 1638,
        "expression": "^(\\$)?((\\d{1,5})|(\\d{1,3})(\\,\\d{3})*)(\\.\\d{1,2})?$",
        "description": "This regular expression is used for validating five digit numeric value which can be an amount $ separated with , sign.",
        "matches": [
            "80,000.00",
            "80,000",
            "80000",
            "80.00",
            "$80000.00"
        ],
        "non_matches": [
            "800,00.00",
            "80.000",
            "$8,0000.00"
        ]
    },
    {
        "id": 1642,
        "expression": "^(([0-9])|([0-2][0-9])|([3][0-1]))\\/(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\/\\d{4}$",
        "description": "This regular expressions matches dates of the form dd/MMM/yyyy where dd can be 1 or 2 digits long, MMM is a month abbreviation, and yyyy is always 4 digits long.",
        "matches": [
            "1/Feb/2007",
            "03/Jun/2007",
            "31/Dec/2007"
        ],
        "non_matches": [
            "1/2/2007",
            "03/Jun/07",
            "31-Dec-2007"
        ]
    },
    {
        "id": 1643,
        "expression": "^((4(\\d{12}|\\d{15}))|(5\\d{15})|(6011\\d{12})|(3(4|7)\\d{13}))$",
        "description": "Matches Visa, American Express, Discover, and Mastercard only.",
        "matches": [
            "4111111111111",
            "4111111111111111",
            "5111111111111111",
            "6011111111111111",
            "341111111111111",
            "371111111111111"
        ],
        "non_matches": [
            "411111111111",
            "51111111111111111",
            "6111111111111111",
            "321111111111111",
            "381111111111111"
        ]
    },
    {
        "id": 1644,
        "expression": "^\\{?[a-fA-F\\d]{32}\\}?$",
        "description": "Matches only a 32 character hex string (Eg. MD5). Based off Chris Craft's expression:-)",
        "matches": [
            "09f8814c757a00f14efdb70e45f851d1"
        ],
        "non_matches": [
            "46345678901234567890aaaabbbbbbzj"
        ]
    },
    {
        "id": 1653,
        "expression": "^(9\\d{2})([ \\-]?)([7]\\d|8[0-8])([ \\-]?)(\\d{4})$",
        "description": "U.S. Individual Taxpayer Identification Number (ITIN) as defined in December 2006. The valid range is 900-70-0000 through 999-88-9999, all numeric values. This regular expression will accept anything in this range with space, dash or no separators.",
        "matches": [
            "900700000",
            "900 70 0000",
            "900-70-0000"
        ],
        "non_matches": [
            "899700000",
            "",
            "900-89-0000",
            "900-69-0000"
        ]
    },
    {
        "id": 1654,
        "expression": "^(?:((31\\/(Jan|Mar|May|Jul|Aug|Oct|Dec))|((([0-2]\\d)|30)\\/(Jan|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec))|(([01]\\d|2[0-8])\\/Feb))|(29\\/Feb(?=\\/((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))\\/((1[6-9]|[2-9]\\d)\\d{2})$",
        "description": "Matches dates in the form of DD/MMM/YYYY. It also handles leap years. Days are 2 digits; months are case sensitive with first character upper-case and next 2 characters lower-case; year is 4 digits.",
        "matches": [
            "01/Mar/2007",
            "16/Dec/2007",
            "29/Feb/2008"
        ],
        "non_matches": [
            "1/Mar/2007",
            "16/Dec/07",
            "29/Feb/2007"
        ]
    },
    {
        "id": 1656,
        "expression": "^((\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*)\\s*[,]{0,1}\\s*)+$",
        "description": "This will validate multiple email addresses that are comma delimited. You can change it to use commas or semilcolons. If you have to worry about a lot of special characters, you may have to edit it a little bit. It allows white space before and after the comma.",
        "matches": [
            "Test@host.com",
            "email1@host.com,email2@host.com,email3@host.com",
            "email1@host.com, email2@host.com , email3@host.com"
        ],
        "non_matches": [
            "test@test",
            "test@host.com,test@",
            "test@ host.com"
        ]
    },
    {
        "id": 1657,
        "expression": "(?=^.{8,}$)(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?!.*\\s)[0-9a-zA-Z!@#$%^&*()]*$",
        "description": "This regular expression can be used for validating a strong password. It expects at least 1 lowercase letter, 1 uppercase letter, and 1 digit. It will also allow for some special characters. The length should be greater than 8 characters. The sequence of the characters is not important.",
        "matches": [
            "Password1",
            "1Passwor",
            "passworD1",
            "2passWord",
            "Pass2Word",
            "pa1SS2word",
            "!1qAzxsw2"
        ],
        "non_matches": [
            "q3w4e5er",
            "asdfg",
            "asdfghjkl;",
            "ag asg ag",
            "d36234724",
            "mko)+OKM1"
        ]
    },
    {
        "id": 1658,
        "expression": "<body[\\d\\sa-z\\W\\S\\s]*>",
        "description": "This will find the open body tag regardless of any properties or Event Handlers associated with it. This is great for global implementations of analytics or anything that needs to be placed after the body tag.",
        "matches": [
            "<body>"
        ],
        "non_matches": [
            "<br>"
        ]
    },
    {
        "id": 1660,
        "expression": "^((\\.)?([a-zA-Z0-9_-]?)(\\.)?([a-zA-Z0-9_-]?)(\\.)?)+$",
        "description": "Allows letters,numbers,hyphens,periods and underscores. Such as : Aa.Aa.Aa, .Aa.Aa. , -Aa-Aa- , _Aa_Aa_ , Aa_Aa_Aa , Aa-Aa-Aa , . , - , _\nI was asked by my client for this scenario to allow letters,numbers,hyphens,periods and underscores in User ID field in web application.",
        "matches": [
            "_-.aAa._-.aAa_-."
        ],
        "non_matches": [
            "special charachters"
        ]
    },
    {
        "id": 1662,
        "expression": "(\\s{1,})",
        "description": "Matches all chars that are made up of one or more spaces. I found this useful when people were trying to make string length bypasses using consecutive spaces.",
        "matches": [
            "(one or more spaces)"
        ],
        "non_matches": [
            "non-space"
        ]
    },
    {
        "id": 1663,
        "expression": "[-]?[1-9]\\d{0,16}\\.?\\d{0,2}|[-]?[0]?\\.[1-9]{1,2}|[-]?[0]?\\.[0-9][1-9]",
        "description": "Needed to be able to validate positive and numeric values that equate to SQL Server data type decimal(18, 2) but the value could not be 0. This regex does that. If you need to change the precision or scale have at it.",
        "matches": [
            "-9999999999999999.99",
            "9999999999999999.99",
            "1",
            "1.00",
            "0.52",
            "0.02"
        ],
        "non_matches": [
            "0",
            "0.0",
            "0.00"
        ]
    },
    {
        "id": 1664,
        "expression": "([0-9a-z_-]+[\\.][0-9a-z_-]{1,3})$",
        "description": "Will match a Windows filename containing alphanumerics, hyphens (-) and underscores (_). There is no length limit on the first part of the filename, but the extension must be between 1 and 3 characters.",
        "matches": [
            "open_01.pdf, 00153._-, _abc_.--1"
        ],
        "non_matches": [
            "readme.e$e, save6^.doc, open_01., .txt, leisure.docx"
        ]
    },
    {
        "id": 1665,
        "expression": "^[A-Z\u00c4\u00d6\u00dc]{1,3}\\-[ ]{0,1}[A-Z]{0,2}[0-9]{1,4}[H]{0,1}",
        "description": "This one checks if the value is a possible german License Plate. The trailing H stands for Historical cars.",
        "matches": [
            "F-RM373, W\u00dc-Z1, K- 07333,HN-WK11H"
        ],
        "non_matches": [
            "MOS-AS"
        ]
    },
    {
        "id": 1668,
        "expression": "(a|A)",
        "description": "Big or small A letter",
        "matches": [
            "aaa"
        ],
        "non_matches": [
            "bbb"
        ]
    },
    {
        "id": 1683,
        "expression": "^([A-Z]+[a-zA-Z]*)(\\s|\\-)?([A-Z]+[a-zA-Z]*)?(\\s|\\-)?([A-Z]+[a-zA-Z]*)?$",
        "description": "That is just an improved expression for handling capitalized names. Improvement #1 - Allowed using names consisting of 3 parts. Improvement #2 - Introduced restriction that the name must start from capital character.",
        "matches": [
            "Rana Mohsin Ali"
        ],
        "non_matches": [
            "rana Mohsin Ali"
        ]
    },
    {
        "id": 1690,
        "expression": "^([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])([Z]|\\.[0-9]{4}|[-|\\+]([0-1][0-9]|2[0-3]):([0-5][0-9]))?$",
        "description": "This is a pattern that matches the time format as recomended by the w3c for XML formats",
        "matches": [
            "12:00:12",
            "01:12:19Z",
            "23:59:00-06:00",
            "18:30:13+01:00",
            "16:06:02.1234"
        ],
        "non_matches": [
            "1:20:13",
            "12:03",
            "24:00:00"
        ]
    },
    {
        "id": 1693,
        "expression": "^[-]?((1[6789]|[2-9][0-9])[0-9]{2}-(0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01]))T([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])([Z]|\\.[0-9]{4}|[-|\\+]([0-1][0-9]|2[0-3]):([0-5][0-9]))?$|^[-]?((1[6789]|[2-9][0-9])[0-9]{2}-(0[469]|11)-(0[1-9]|[12][0-9]|30))T([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])([Z]|\\.[0-9]{4}|[-|\\+]([0-1][0-9]|2[0-3]):([0-5][0-9]))?$|^[-]?((16|[248][048]|[3579][26])00)|(1[6789]|[2-9][0-9])(0[48]|[13579][26]|[2468][048])-02-(0[1-9]|1[0-9]|2[0-9])T([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])([Z]|\\.[0-9]{4}|[-|\\+]([0-1][0-9]|2[0-3]):([0-5][0-9]))?$|^[-]?(1[6789]|[2-9][0-9])[0-9]{2}-02-(0[1-9]|1[0-9]|2[0-8])T([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])([Z]|\\.[0-9]{4}|[-|\\+]([0-1][0-9]|2[0-3]):([0-5][0-9]))?$",
        "description": "This pattern matches valid w3c compatible datetime values from 1600 to 9999 in the form of [-]YYYY-MM-DDTHH:MM:SS[.ssss|[[+|-][HH:MM]][Z] also takes into account leap years.",
        "matches": [
            "2007-11-02T18:00:00.1234",
            "2000-02-29T12:00:12+03:00"
        ],
        "non_matches": [
            "2005-01-20",
            "23:00:00"
        ]
    },
    {
        "id": 1696,
        "expression": "^(([0-9]|1[0-9]|2[0-4])(\\.[0-9][0-9]?)?)$|([2][5](\\.[0][0]?)?)$",
        "description": "this is reg expression for 0.00 to 25.00",
        "matches": [
            "12",
            "13.1",
            "23.99",
            "8.99",
            "25.00"
        ],
        "non_matches": [
            "26",
            "25.01",
            "-2",
            "8.",
            ""
        ]
    },
    {
        "id": 1697,
        "expression": "^[\\w0-9]+( [\\w0-9]+)*$",
        "description": "Allows \"words\" with alphanumeric characters, including the underscore _ character. Disallows leading or trailing spaces, also doubled-up spaces within the text. If you want to disallow the underscore character, you can replace the two occurrences of \\w with a-zA-Z",
        "matches": [
            "Test 000"
        ],
        "non_matches": [
            "Punctuation! Or doubled up, leading or trailing spaces"
        ]
    },
    {
        "id": 1698,
        "expression": "^((([\\(]?[2-9]{1}[0-9]{2}[\\)]?)|([2-9]{1}[0-9]{2}\\.?)){1}[ ]?[2-9]{1}[0-9]{2}[\\-\\.]{1}[0-9]{4})([ ]?[xX]{1}[ ]?[0-9]{3,4})?$",
        "description": "This regex matches US and CAN phone numbers with area code and optional 3 or 4 digit PBX extention. It does not check for validity of area code or exchange number, other than for starting with a 0 or 1.",
        "matches": [
            "(555) 687-6076 X 1234",
            "(555) 687-6076",
            "555.687.5511x1234"
        ],
        "non_matches": [
            "555.687.6076 ext 1234"
        ]
    },
    {
        "id": 1704,
        "expression": "^[1-9]{1}[0-9]{0,2}([\\.\\,]?[0-9]{3})*$",
        "description": "Matches whole numbers with the two most common thousands-separators (comma and period). Will not handle decimals.",
        "matches": [
            "1,000",
            "1.000",
            "1",
            "10",
            "100",
            "1000"
        ],
        "non_matches": [
            "1,00",
            "1,0",
            "1,,000",
            ".1",
            "10."
        ]
    },
    {
        "id": 1706,
        "expression": "([A-HJ-PR-Y]{2}([0][1-9]|[1-9][0-9])|[A-HJ-PR-Y]{1}([1-9]|[1-2][0-9]|30|31|33|40|44|55|50|60|66|70|77|80|88|90|99|111|121|123|222|321|333|444|555|666|777|888|999|100|200|300|400|500|600|700|800|900))[ ][A-HJ-PR-Z]{3}$",
        "description": "UK Vehicle Registration Plate / Number Plate format as specified by the DVLA. Accepts both \"Prefix\" and \"New\" style. Allows only valid DVLA number combinations as not all are supported. Registration number must be exactly as is displayed on car, hence all letters must be in uppercase and a space seperating the two sets of characters.",
        "matches": [
            "AB12 RCY",
            "CD07 TES",
            "S33 GTT",
            "Y999 FVB"
        ],
        "non_matches": [
            "ab12 rcy",
            "CD07 TIS",
            "S34 GTT",
            "Z999 FVB"
        ]
    },
    {
        "id": 1709,
        "expression": "^\\$YYYY\\$\\$MM\\$\\$DD\\$$",
        "description": "Date Format notations. Mostly used in DB applications where rigorous pattern matching for DATE is required.",
        "matches": [
            "$YYYY$$MM$$DD$"
        ],
        "non_matches": [
            "$YY$$MM$$DD$"
        ]
    },
    {
        "id": 1715,
        "expression": "^[1-9]\\d?-\\d{7}$",
        "description": "Accepts valid EIN numbers. It could use a bit of tweaking because these are the current valid prefixes allowed. 1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 65, 66, 67, 68, 71, 72, 73, 74, 75, 76, 77, 80, 81, 82, 83, 84, 85, 87, 88, 90, 91, 92, 93, 94, 95, 98, 99",
        "matches": [
            "55-5555555",
            "1-2345678",
            "99-9999999"
        ],
        "non_matches": [
            "00-1111111",
            "my-einnumb",
            "5-55555"
        ]
    },
    {
        "id": 1716,
        "expression": "^[a-zA-Z0-9\\-\\.]+\\.([a-zA-Z]{2,3})$",
        "description": "validates after dot operator. matches atleast 2 char and max 3 char.www dot is rejected.",
        "matches": [
            "yahoo.com",
            "ABC.COM",
            "abc.au"
        ],
        "non_matches": [
            "yahoo.c",
            "ABC.argv"
        ]
    },
    {
        "id": 1723,
        "expression": "(\\[a url=\\\"[^\\[\\]\\\"]*\\\"\\])([^\\[\\]]+)(\\[/a\\])",
        "description": "Matches well-formed tags.",
        "matches": [
            "[a url=\"http://www.example-domain.com\"]link text[/a]; [a url=\"\"]link text[/a]"
        ],
        "non_matches": [
            "[a]link text[/a]; [a url= \"\"]link text[/a]"
        ]
    },
    {
        "id": 1726,
        "expression": "(<b>)([^<>]+)(</b>)",
        "description": "Gets simple tags without parameters",
        "matches": [
            "<b>important</b>; <b>anything that should be in bold</b>"
        ],
        "non_matches": [
            "<b >important</b>; <b>important<b>"
        ]
    },
    {
        "id": 1730,
        "expression": "(?!.*([abcde]).*\\1)^[abcde]{5}$",
        "description": "Let's say that you have a series of characters \"abcde\" and you want to match all strings that could be comprised of those characters with each character used exactly once. This could loosely be termed an anagram matcher, although if the string contains duplicate letters it would require modification of this pattern. In the example case we have a string \"abcde\" and we want to match any permutation of \"abcde\". Note that the \"5\" used in the pattern indicates the number of characters specified in the character set \"abcde\", \"5\" would still be used if \"abcde\" would be replaced with \"a-e\" since there would still be 5 characters in the series. If you are curious about how to require duplicates in the pattern (to match all permutations of \"apple\" for example) I would use (?=^.*p.*p$)(?!.*([ale]).*\\1)^[aple]{5}$",
        "matches": [
            "abcde",
            "dbcae",
            "edcba"
        ],
        "non_matches": [
            "abcbe"
        ]
    },
    {
        "id": 1736,
        "expression": "^[-+]?([0-9]{1,3}[,]?)?([0-9]{3}[,]?)*[.]?[0-9]*$",
        "description": "matches numeric value with optional +/- , optional decimal point, and optional commas",
        "matches": [
            "-12,345,678,012.98765"
        ],
        "non_matches": [
            "1,45.098"
        ]
    },
    {
        "id": 1739,
        "expression": "([\\r\\n ]*//[^\\r\\n]*)+",
        "description": "Matches groups of single-line code comments. Comment sections will be returned as a single match.",
        "matches": [
            "// code comments"
        ],
        "non_matches": [
            "Code"
        ]
    },
    {
        "id": 1740,
        "expression": "(@\\s*\".*?\")|(\"([^\"\\\\]|\\\\.)*?\")",
        "description": "Matches C# string literals; verbatin and or normal.",
        "matches": [
            "\"text\" \"te\\\"xt\" @\"text\""
        ],
        "non_matches": [
            "text"
        ]
    },
    {
        "id": 1742,
        "expression": "^[A-Z]$",
        "description": "Matches one Upper-case US ASCII Letter.",
        "matches": [
            "A",
            "B",
            "Z"
        ],
        "non_matches": [
            "a",
            "1",
            "AA"
        ]
    },
    {
        "id": 1744,
        "expression": "^\\d+\\.\\d\\.\\d[01]\\d[0-3]\\d\\.[1-9]\\d*$",
        "description": "4 part version numbers",
        "matches": [
            "0.0.60829.1",
            "100.3.60931.5",
            "5.1.11219.7"
        ],
        "non_matches": [
            "1.1.60849.1",
            "0.20.10.60810",
            "1.1.11219.0"
        ]
    },
    {
        "id": 1751,
        "expression": "^(((0[1-9]{1})|(1[0-2]{1}))\\/?(([0-2]{1}[1-9]{1})|(3[0-1]{1}))\\/?(([12]{1}[0-9]{1})?[0-9]{2}) ?(([01]{1}[0-9]{1})|(2[0-4]{1}))\\:?([0-5]{1}[0-9]{1}))$",
        "description": "This will validate any date (does not check for number of days in month, just 31 days or less) in almost any format as long as the order follows month, day, year, hour, minute, and each part has at least 2 digits.",
        "matches": [
            "01/15/07 1745",
            "011507 1745",
            "01/15/2007 17:45",
            "0115071745"
        ],
        "non_matches": [
            "13/15/07 1745",
            "013207 1745",
            "01/15/2007 25:45",
            "0115071762"
        ]
    },
    {
        "id": 1756,
        "expression": "^(([A-Z])([a-zA-Z0-9]+)?)(\\:)(\\d+)$",
        "description": "Validate if server and port is valid.",
        "matches": [
            "MyServer:8080"
        ],
        "non_matches": [
            "1Server:A1",
            "Server:AAA"
        ]
    },
    {
        "id": 1762,
        "expression": "(^([0-9]*[.][0-9]*[1-9]+[0-9]*)$)|(^([0-9]*[1-9]+[0-9]*[.][0-9]+)$)|(^([1-9]+[0-9]*)$)",
        "description": "If you want to check for positive and nonzero real numbers (both integer and decimal are supported).",
        "matches": [
            "1.234",
            "1234",
            "0.123",
            "01.2345"
        ],
        "non_matches": [
            "0",
            "0.0",
            "-123.45",
            "-12345",
            "abc123",
            "12..34"
        ]
    },
    {
        "id": 1763,
        "expression": "^[1-9]\\d*\\.?[0]*$",
        "description": "It just omit 0 as the single number when it accepts all other Numbers",
        "matches": [
            "2",
            "23",
            "340"
        ],
        "non_matches": [
            "0"
        ]
    },
    {
        "id": 1776,
        "expression": "^(((0[1-9]|[12]\\d|3[01])[\\s\\.\\-\\/](0[13578]|1[02])[\\s\\.\\-\\/]((19|[2-9]\\d)\\d{2}))|((0[1-9]|[12]\\d|30)[\\s\\.\\-\\/](0[13456789]|1[012])[\\s\\.\\-\\/]((19|[2-9]\\d)\\d{2}))|((0[1-9]|1\\d|2[0-8])[\\s\\.\\-\\/]02[\\s\\.\\-\\/]((19|[2-9]\\d)\\d{2}))|(29[\\s\\.\\-\\/]02[\\s\\.\\-\\/]((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))))$",
        "description": "Checks date in format dd-mm-yyyy. Seperation characters can be -/. and space.\ndd and mm HAVE to be two characters. Year has to be four characters and minimum 1900.\nExpression handles leap year as well",
        "matches": [
            "20-02-1975",
            "20.02.1975",
            "20/02/1975",
            "20 02 1975",
            "20-12/1975"
        ],
        "non_matches": [
            "20-12-1899",
            "29-02-2002",
            "28-2-2008"
        ]
    },
    {
        "id": 1777,
        "expression": "^(0[1-9]|[12][0-9]|3[01])-(0[1-9]|11|12|10)-(19[0-9]{2})$",
        "description": "This is regular expression that check for a particular date match in the following format respectively: DD-MM-YYYY and is only valid for the years between 1900 - 1999\nHint: good for validating age above 9-years old",
        "matches": [
            "31-01-1923",
            "12-05-1987",
            "26-10-1901"
        ],
        "non_matches": [
            "07/10/1998",
            "04-07-98",
            "1-3-1806",
            "1985-01-07"
        ]
    },
    {
        "id": 1778,
        "expression": "^[a-zA-Z0-9\\.\\s]{3,}$",
        "description": "This expression check the input of simple text string from a-z,A-Z and number from 0 to 9 and the dot(.).\nBut the minimum insert is of 3 character.",
        "matches": [
            "abc.123",
            ".abc",
            "123."
        ],
        "non_matches": [
            "12",
            "a1",
            "@#%&\u00a3\"^"
        ]
    },
    {
        "id": 1780,
        "expression": "^(((?!\\(800\\))(?!\\(888\\))(?!\\(877\\))(?!\\(866\\))(?!\\(900\\))\\(\\d{3}\\) ?)|(?!800)(?!888)(?!877)(?!866)(?!900)(\\d{3}-))?\\d{3}-\\d{4}",
        "description": "This pattern matches US phone numbers but excludes numbers that are 800 or 900 numbers. It excludes the following area codes 800, 888,877,866, and 900.",
        "matches": [
            "123-554-1247, (455)521-5482"
        ],
        "non_matches": [
            "800-585-1234, (866)958-4221"
        ]
    },
    {
        "id": 1785,
        "expression": "^((?:\\/[a-zA-Z0-9]+(?:_[a-zA-Z0-9]+)*(?:\\-[a-zA-Z0-9]+)*)+)$",
        "description": "An overly simple UNIX based path regex. The path must begin with a forward slash. The path segments may not lead or end with an underscore or dash which is a good thing. They also can not be doubled (__ or --). Another good thing. I've omitted all the punctuation that RFC allows until further notice.",
        "matches": [
            "/users/web/mysite/web/cgi-bin"
        ],
        "non_matches": [
            "/users/web/my site/web/cgi-bin",
            "users/web/mysite/web/cgi-bin/"
        ]
    },
    {
        "id": 1786,
        "expression": "^([a-zA-Z0-9]+(?: [a-zA-Z0-9]+)*)$",
        "description": "This is a very basic regex for a simple subject or title. It must begin and end with a word character and may contain spaces. No punctuation :(",
        "matches": [
            "My Category"
        ],
        "non_matches": [
            "any nonword character and leading/trailing spaces"
        ]
    },
    {
        "id": 1787,
        "expression": "^((31(?!([-])(Feb|Apr|June?|Sep|Nov)))|((30|29)(?!([-])Feb))|(29(?=([-])Feb([-])(((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))|(0?[1-9])|1\\d|2[0-8])([-])(Jan|Feb|Ma(r|y)|Apr|Ju(l|n)|Aug|Oct|(Sep|Nov|Dec))([-])((1[6-9]|[2-9]\\d)\\d{2}\\s(([0-1]?[0-9])|([2][0-3])):([0-5]?[0-9])(:([0-5]?[0-9]))?)$",
        "description": "This expression matches date and time (24 hour) both in format dd-MMM-yyyy HH:mm:ss. Only the short form of month is allowed i.e. Jan not January. The month names are also case sensitive. The second part of the time is optional. Also the leading zeros for day, hour, minute and seconds are optional.",
        "matches": [
            "31-Jan-2008 1:30:00",
            "29-Feb-2008 01:45:45",
            "30-Sep-2007 23:59"
        ],
        "non_matches": [
            "31-Jan-2008 24:30:00",
            "29-Feb-2007 01:45:45",
            "3-Sep-2007 23:60:60"
        ]
    },
    {
        "id": 1793,
        "expression": "^\\s*-?(\\d{0,7}|10[0-5]\\d{0,5}|106[0-6]\\d{0,4}|1067[0-4]\\d{0,3}|10675[0-1]\\d{0,2}|((\\d{0,7}|10[0-5]\\d{0,5}|106[0-6]\\d{0,4}|1067[0-4]\\d{0,3}|10675[0-1]\\d{0,2})\\.)?([0-1]?[0-9]|2[0-3]):[0-5]?[0-9](:[0-5]?[0-9](\\.\\d{1,7})?)?)\\s*$",
        "description": "Can be used to pre-validate strings before calling the TimeSpan.Parse() method in the .Net framework, to ensure that the string can be parsed without throwing an exception. The regex uses capturing groups instead of non-capturing groups so that it can easily be used as a pattern in XML Schema by simply removing the ^$ from the beginning/end.\nThis expression fully checks or enforces the [ws][-]{d|[d.]hh:mm[:ss[.ff]] }[ws] format as described in the MSDN help. It even checks the upper/lower boundaries on day values (10675199 days.)",
        "matches": [
            "00:00:15",
            "23:59:59",
            "23:59:59.9999999",
            "-00:00:00",
            "365",
            "-365",
            "7.00:00:00.0000000",
            "5:5:5",
            "10:10",
            "21:15",
            "19:1",
            "00:10",
            "0",
            "10675199.23:59:59.9999999",
            "-10675199.23:59:59.9999999",
            "10599999",
            "10669999",
            "10674999",
            "10675099"
        ],
        "non_matches": [
            "1.23:59:60",
            "24:00",
            "23:59:59.00000000",
            "00:00:60",
            "24:00:00",
            "25:00:00",
            "10675200",
            "10676000",
            "10680000",
            "10700000",
            "11000000"
        ]
    },
    {
        "id": 1795,
        "expression": "\\x26(?!((amp\\x3B)|(nbsp\\x3B)|(lt\\x3B)|(gt\\x3B)|(copy\\x3B)|(reg\\x3B)|(cent\\x3B)|(deg\\x3B)|(deg\\x3B)|(micro\\x3B)|(middot\\x3B)|(not\\x3B)|(para\\x3B)|(plusmn\\x3B)|(pound\\x3B)|(raquo\\x3B)|(sect\\x3B)|(yen\\x3B)|([\\x23][0-9]{1,3}\\x3B)|(lsquo\\x3B)|(rsquo\\x3B)|(sbquo\\x3B)|(ldquo\\x3B)|(rdquo\\x3B)|(bdquo\\x3B)|(dagger\\x3B)|(Dagger\\x3B)|(permil\\x3B)|(lsaquo\\x3B)|(rsaquo\\x3B)|(spades\\x3B)|(clubs\\x3B)|(hearts\\x3B)|(diams\\x3B)|(oline\\x3B)|(larr\\x3B)|(uarr\\x3B)|(rarr\\x3B)|(darr\\x3B)|(trade\\x3B)|([\\x23]x2122\\x3B)|(quot\\x3B)|(frasl\\x3B)|(ndash\\x3B)|(mdash\\x3B)|(iexcl\\x3B)|(cent\\x3B)|(curren\\x3B)|(brvbar\\x3B)|(brvbar\\x3B)|(uml\\x3B)|(die\\x3B)|(ordf\\x3B)|(laquo\\x3B)|(not\\x3B)|(shy\\x3B)|(macr\\x3B)|(hibar\\x3B)|(sup2\\x3B)|(sup3\\x3B)|(acute\\x3B)|(micro\\x3B)|(cedil\\x3B)|(sup1\\x3B)|(ordm\\x3B)|(raquo\\x3B)|(frac14\\x3B)|(frac12\\x3B)|(frac34\\x3B)|(iquest\\x3B)|(Agrave\\x3B)|(Aacute\\x3B)|(Acirc\\x3B)|(Atilde\\x3B)|(Auml\\x3B)|(Aring\\x3B)|(AElig\\x3B)|(Ccedil\\x3B)|(Egrave\\x3B)|(Eacute\\x3B)|(Ecirc\\x3B)|(Euml\\x3B)|(Igrave\\x3B)|(Iacute\\x3B)|(Icirc\\x3B)|(Iuml\\x3B)|(ETH\\x3B)|(Ntilde\\x3B)|(Ograve\\x3B)|(Oacute\\x3B)|(Ocirc\\x3B)|(Otilde\\x3B)|(Ouml\\x3B)|(times\\x3B)|(Oslash\\x3B)|(Ugrave\\x3B)|(Uacute\\x3B)|(Ucirc\\x3B)|(Uuml\\x3B)|(Yacute\\x3B)|(THORN\\x3B)|(szlig\\x3B)|(agrave\\x3B)|(aacute\\x3B)|(acirc\\x3B)|(atilde\\x3B)|(auml\\x3B)|(aring\\x3B)|(aelig\\x3B)|(ccedil\\x3B)|(egrave\\x3B)|(eacute\\x3B)|(ecirc\\x3B)|(euml\\x3B)|(igrave\\x3B)|(iacute\\x3B)|(icirc\\x3B)|(iuml\\x3B)|(eth\\x3B)|(ntilde\\x3B)|(ograve\\x3B)|(oacute\\x3B)|(ocirc\\x3B)|(otilde\\x3B)|(ouml\\x3B)|(divide\\x3B)|(oslash\\x3B)|(ugrave\\x3B)|(uacute\\x3B)|(ucirc\\x3B)|(uuml\\x3B)|(yacute\\x3B)|(thorn\\x3B)|(yuml\\x3B)|(Alpha\\x3B)|(Alpha\\x3B)|(Beta\\x3B)|(beta\\x3B)|(Gamma\\x3B)|(gamma\\x3B)|(Delta\\x3B)|(delta\\x3B)|(Epsilon\\x3B)|(epsilon\\x3B)|(Zeta\\x3B)|(zeta\\x3B)|(Eta\\x3B)|(eta\\x3B)|(Iota\\x3B)|(iota\\x3B)|(Kappa\\x3B)|(kappa\\x3B)|(Lambda\\x3B)|(lambda\\x3B)|(Mu\\x3B)|(mu\\x3B)|(Nu\\x3B)|(nu\\x3B)|(Xi\\x3B)|(xi\\x3B)|(Omicron\\x3B)|(omicron\\x3B)|(Pi\\x3B)|(pi\\x3B)|(Rho\\x3B)|(rho\\x3B)|(Sigma\\x3B)|(sigma\\x3B)|(Tau\\x3B)|(tau\\x3B)|(Upsilon\\x3B)|(upsilon\\x3B)|(Phi\\x3B)|(phi\\x3B)|(Chi\\x3B)|(chi\\x3B)|(Psi\\x3B)|(psi\\x3B)|(Omega\\x3B)|(omega\\x3B)))",
        "description": "This expression will match ampersands('&') that are not part an HTML Special Character string.",
        "matches": [
            "&"
        ],
        "non_matches": [
            "&amp; &psi; &#24;"
        ]
    },
    {
        "id": 1799,
        "expression": "^(1?(?: |\\-|\\.)?(?:\\(\\d{3}\\)|\\d{3})(?: |\\-|\\.)?\\d{3}(?: |\\-|\\.)?\\d{4})$",
        "description": "This is my simple phone number regex. There are many like it but this is mine. It accepts the most common United States phone number formats that normal people use. The number 1 at the beginning is optional and so is the separators. The separators can be a dash (-), a period (.) or a space. Putting the area code in parenthesis is also an option. That's about it.",
        "matches": [
            "1-234-567-8910",
            "(123) 456-7891",
            "123.456.7891",
            "12345678910"
        ],
        "non_matches": [
            "12-345-678-9101",
            "123-45678",
            "123456789101"
        ]
    },
    {
        "id": 1800,
        "expression": "^(\\d{5}(?:\\-\\d{4})?)$",
        "description": "Just for US zip codes. Very simple but effective regex for verifying a number that resembles a zip code. The post office number is optional.",
        "matches": [
            "12345",
            "12345-6789"
        ],
        "non_matches": [
            "1234",
            "123456",
            "12345-123",
            "12345-12345"
        ]
    },
    {
        "id": 1801,
        "expression": "^(?!000)(?!666)(?!9)\\d{3}([- ]?)(?!00)\\d{2}\\1(?!0000)\\d{4}$",
        "description": "Updated SSN regex. A very simple one for verifying a properly formatted US social security number. First three digits must be 001 - 899 and not 666. Disallows all zeros in a group.",
        "matches": [
            "123-45-6789"
        ],
        "non_matches": [
            "123-45 6789",
            "1234-56-7890",
            "123-00-7890"
        ]
    },
    {
        "id": 1803,
        "expression": "^([0-2][0-4](?:(?:(?::)?[0-5][0-9])?|(?:(?::)?[0-5][0-9](?::)?[0-5][0-9](?:\\.[0-9]+)?)?)?)$",
        "description": "This is a regular expression to check for a properly formatted time according to the international date and time notation ISO 8601. See ISO 8601 specification for more information.",
        "matches": [
            "24",
            "24:00",
            "23:59:59",
            "235959"
        ],
        "non_matches": [
            "25",
            "24:60"
        ]
    },
    {
        "id": 1804,
        "expression": "^[a-zA-Z]:\\\\(([\\w]|[\\u0621-\\u064A\\s])+\\\\)+([\\w]|[\\u0621-\\u064A\\s])+(.jpg|.JPG|.gif|.GIF|.BNG|.bng)$",
        "description": "Select File Accept Arabic and Englesh File name or Folder name",
        "matches": [
            "C:\\Documents and Settings\\mohamedantar\\\u0645\u0644\u0641\\My Pictures\\\u0635\u0648\u0631\u0629.gif"
        ],
        "non_matches": [
            ":\\Documents and Settings\\mohamedantar\\\u0645\u0644\u0641\\My Pictures\\\u0635\u0648\u0631\u0629.gif"
        ]
    },
    {
        "id": 1808,
        "expression": "^0?[0-9]?[0-9]$|^(100)$",
        "description": "Accepts all integers between 0-100",
        "matches": [
            "0",
            "00",
            "01",
            "45",
            "99",
            "100"
        ],
        "non_matches": [
            "-1",
            ".23",
            "101"
        ]
    },
    {
        "id": 1810,
        "expression": "^[-]?([1-9]{1}[0-9]{0,}(\\.[0-9]{0,2})?|0(\\.[0-9]{0,2})?|\\.[0-9]{1,2})$",
        "description": "This regular expression will match on a real / decimal / floating point / numeric string with no more than 2 digits past the decimal. The negative sign (-) is allowed. No leading zeroes or commas. It is based on a currency regular expression by Tom Persing.",
        "matches": [
            "123",
            "123.54",
            "-.54"
        ],
        "non_matches": [
            "123.543",
            "0012",
            "1,000.12"
        ]
    },
    {
        "id": 1811,
        "expression": "(\\+)?([-\\._\\(\\) ]?[\\d]{3,20}[-\\._\\(\\) ]?){2,10}",
        "description": "Telephone number filter - use to catch and replace phone numbers where you don't want them to appear.",
        "matches": [
            "(604) 789-0136",
            "+123-45678-908"
        ],
        "non_matches": [
            "01.12.23"
        ]
    },
    {
        "id": 1813,
        "expression": "^((\\'|\\\")?[a-zA-Z]+(?:\\-[a-zA-Z]+)?(?:s\\'|\\'[a-zA-Z]{1,2})?(?:(?:(?:\\,|\\.|\\!|\\?)?(?:\\2)?)|(?:(?:\\2)?(?:\\,|\\.|\\!|\\?)?))(?: (\\'|\\\")?[a-zA-Z]+(?:\\-[a-zA-Z]+)?(?:s\\'|\\'[a-zA-Z]{1,2})?(?:(?:(?:\\,|\\.|\\!|\\?)?(?:\\2|\\3)?)|(?:(?:\\2|\\3)?(?:\\,|\\.|\\!|\\?)?)))*)$",
        "description": "This is a little goofy regex to allow punctuation. I was reluctant to post it but what the heck. If it puts a smile on somebody's face then it was worth it. It works in most cases. :)",
        "matches": [
            "\"hello!\"",
            "\"hello again\"!",
            "I'm back"
        ],
        "non_matches": [
            "hello\"",
            "\"hello again!\"!",
            "I'mnot back"
        ]
    },
    {
        "id": 1814,
        "expression": "^[_a-zA-Z0-9-]+(\\.[_a-zA-Z0-9-]+)?@[a-zA-Z0-9-]+(((\\.[0-9]{1,3}){0,3})|((\\.(co|com|net|org|edu|gov|mil|aero|coop|info|museum|name|ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cx|cy|cz|de|dj|dk|dm|do|dz|ec|ee|eg|eh|er|es|et|fi|fj|fk|fm|fo|fr|fx|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nt|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|pt|pw|py|qa|re|ro|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|st|su|sv|sy|sz|tc|td|tf|tg|th|tj|tk|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|um|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|yu|za|zm|zr|zw)){1,2}))$",
        "description": "This filter is able to filter a full of address. It uses extension definition",
        "matches": [
            "qsdf.dfqsf@14.21.20.10",
            "sfdgfg@fds.co.uk",
            "fgsdg.zz@free.fr"
        ],
        "non_matches": [
            "sfdgf.sfdg.sdfg@sfdgsfdG.fr",
            "dfgs.sdf@fdg.02.01.sdf",
            "sqf.bcv@xb.nbb"
        ]
    },
    {
        "id": 1815,
        "expression": "^(\\d{4},?)+$",
        "description": "Accepts a list of 4 digits separated by commas. Used to validate a list of years. Can be easily customized to change the number of digits.",
        "matches": [
            "2001,2002,2003",
            "1999",
            "1999,2000,"
        ],
        "non_matches": [
            "123",
            "1234,e,1234",
            "1234, 1234,1234"
        ]
    },
    {
        "id": 1816,
        "expression": "(?i)^(((\\\\\\\\(\\?\\\\(UNC\\\\)?)?)([A-Z]:\\\\|([^\\\\\\/\\:\\*\\?\\\"\\<\\>\\|\\.\\s][^\\\\\\/\\:\\*\\?\\\"\\<\\>\\|]+[^\\\\\\/\\:\\*\\?\\\"\\<\\>\\|\\.\\s]\\\\){2}))|[A-Z]:\\\\)([^\\\\\\/\\:\\*\\?\\\"\\<\\>\\|\\s][^\\\\\\/\\:\\*\\?\\\"\\<\\>\\|]+[^\\\\\\/\\:\\*\\?\\\"\\<\\>\\|\\s]\\\\)*([^\\\\\\/\\:\\*\\?\\\"\\<\\>\\|\\.\\s][^\\\\\\/\\:\\*\\?\\\"\\<\\>\\|\\.]+[^\\\\\\/\\:\\*\\?\\\"\\<\\>\\|\\.\\s])(\\.[^\\\\\\/\\:\\*\\?\\\"\\<\\>\\|\\.\\s]+)*?$",
        "description": "Matches valid Windows filenames using local, network and UNC formats.",
        "matches": [
            "C:\\Program Files\\RegEx\\RegEx.exe.manifest"
        ],
        "non_matches": [
            "C:\\Filename.*"
        ]
    },
    {
        "id": 1819,
        "expression": "\\b(0?[1-9]|1[0-2])(\\/)(0?[1-9]|1[0-9]|2[0-9]|3[0-1])(\\/)(200[0-8])\\b",
        "description": "Matches the valid date format MM/DD/CCYY\nYear from 2000 to 2008 and the month will accept till 12 and the day will accept till 31",
        "matches": [
            "01/02/2006",
            "12/31/2007",
            "1/1/2008"
        ],
        "non_matches": [
            "01/02/1999",
            "13/32/2008",
            "01-31-2008"
        ]
    },
    {
        "id": 1820,
        "expression": "\\b(0?[1-9]|1[0-2])(\\-)(0?[1-9]|1[0-9]|2[0-9]|3[0-1])(\\-)(200[0-8])\\b",
        "description": "Matches the valid date format MM-DD-CCYY\nYear from 2000 to 2008 and the month will accept till 12 and the day will accept till 31",
        "matches": [
            "01-02-2006",
            "12-31-2007",
            "1-1-2008"
        ],
        "non_matches": [
            "01-02-1999",
            "13-32-2008",
            "01/31/2008"
        ]
    },
    {
        "id": 1827,
        "expression": "^(http\\:\\/\\/(?:www\\.)?[a-zA-Z0-9]+(?:(?:\\-|_)[a-zA-Z0-9]+)*(?:\\.[a-zA-Z0-9]+(?:(?:\\-|_)[a-zA-Z0-9]+)*)*\\.[a-zA-Z]{2,7}(?:\\/)?)$",
        "description": "A URL to a domain name. Only for HTTP but that can be easily changed to accept more. The dashes and underscores can only be used between text and/or digits. The slash on the end is optional. Unlike my other URL checkers this one does not allow query strings.",
        "matches": [
            "http://www.website.com/",
            "http://my-website.net",
            "http://another_site.org"
        ],
        "non_matches": [
            "www.website.com",
            "http://_website.com",
            "http://www. web--site.com"
        ]
    },
    {
        "id": 1829,
        "expression": "^([a-zA-Z0-9]+([\\.+_-][a-zA-Z0-9]+)*)@(([a-zA-Z0-9]+((\\.|[-]{1,2})[a-zA-Z0-9]+)*)\\.[a-zA-Z]{2,6})$",
        "description": "This pattern was based on this reference: http://www.remote.org/jochen/mail/info/chars.html\nThis expression allows only these symbols (+, -, _, or .) in the local part of the address, but no two consecutive symbols are allowed. The symbols behave like separators for alphanumeric atoms. The local part must begin and end with an atom. Therefore, local part cannot begin or end with a symbol.\nFor the domain name, I tested what was allowed at various domain registrars. While hyphens are allowed, domain names must abide by the following rules:\n-can't begin or end with hyphen\n-no more than two hyphens can appear consecutively",
        "matches": [
            "abc@test.com",
            "abc@test-test.info",
            "abc.d-e_f+g@a.b-c.d--e.museum"
        ],
        "non_matches": [
            "a+@test.com",
            "+a@test.com",
            "a++a@test.com",
            "abc@a---b.com",
            "abc@a---b.test.com"
        ]
    },
    {
        "id": 1830,
        "expression": "^([a-zA-Z]+)://([a-zA-Z0-9_\\-]+)((\\.[a-zA-Z0-9_\\-]+|[0-9]{1,3})+)\\.([a-zA-Z]{2,6}|[0-9]{1,3})((:[0-9]+)?)((/[a-zA-Z0-9_\\-,.;=%]*)*)((\\?[a-zA-Z0-9_\\-,.;=&%]*)?)$",
        "description": "Checks whether the entered string looks like a URI, with a specified protocol. Optionally, you can add the port number, and some GET variables.\nThe control is quite loose, but it's a choice of mine.\nComments and corrections are welcome.",
        "matches": [
            "this://is.accepted.com/?and=it&sO=K",
            "this://is.accept.ed?too=",
            "and://also.this.one:12/?is=right"
        ],
        "non_matches": [
            "this.is.NOT.accepted",
            "neither://this.is&one",
            "abs://olut.ely.no:way"
        ]
    },
    {
        "id": 1832,
        "expression": "(\\$\\s*[\\d,]+\\.\\d{2})\\b",
        "description": "Validate American Dollar Amount Format",
        "matches": [
            "$ 417,000.00",
            "$ 280.00",
            "$ 10.00"
        ],
        "non_matches": [
            "$ 12234566",
            "$ 540,453.000",
            "$ 123,000",
            "$ 200,000.0"
        ]
    },
    {
        "id": 1833,
        "expression": "\\b[1-9]\\b",
        "description": "Validate the numbers 1 to 9",
        "matches": [
            "1",
            "5",
            "9"
        ],
        "non_matches": [
            "0",
            "15",
            "19"
        ]
    },
    {
        "id": 1834,
        "expression": "\\b4[0-9]\\b",
        "description": "Validate the numbers in between 39 to 50 (i.e 40 to 49)",
        "matches": [
            "40",
            "46",
            "49"
        ],
        "non_matches": [
            "4",
            "50",
            "39"
        ]
    },
    {
        "id": 1835,
        "expression": "[^<>/?&{};#]+",
        "description": "This expression stops the characters <>/?&{};# from a string of any length passing the regular expression validator in Visual Studio thereby stopping the HttpRequestValidationException (if client side validation and javascript is on)",
        "matches": [
            "any word",
            "a",
            "a number 4382"
        ],
        "non_matches": [
            "<",
            ">",
            "/",
            "?",
            "&",
            "#",
            "{",
            "}",
            ";"
        ]
    },
    {
        "id": 1842,
        "expression": "^(100(?:\\.0{1,2})?|0*?\\.\\d{1,2}|\\d{1,2}(?:\\.\\d{1,2})?)$",
        "description": "generate percentage with 2 values after point",
        "matches": [
            "3.00",
            "100.00",
            "45"
        ],
        "non_matches": [
            "101",
            "4.678",
            "425.876"
        ]
    },
    {
        "id": 1846,
        "expression": "^(([1-9]{1}(\\d+)?)(\\.\\d+)?)|([0]\\.(\\d+)?([1-9]{1})(\\d+)?)$",
        "description": "Regular expression that accepts positive numbers with or with decimal places, but will not allow zero or 0.000",
        "matches": [
            "1",
            "25",
            "25.0",
            "25.001",
            "0.001",
            "0.234"
        ],
        "non_matches": [
            "0",
            "0.0",
            "-12"
        ]
    },
    {
        "id": 1848,
        "expression": "^(ftp|https?):\\/\\/([^:]+:[^@]*@)?([a-zA-Z0-9][-_a-zA-Z0-9]*\\.)*([a-zA-Z0-9][-_a-zA-Z0-9]*){1}(:[0-9]+)?\\/?(((\\/|\\[|\\]|-|~|_|\\.|:|[a-zA-Z0-9]|%[0-9a-fA-F]{2})*)\\?((\\/|\\[|\\]|-|~|_|\\.|,|:|=||\\{|\\}|[a-zA-Z0-9]|%[0-9a-fA-F]{2})*\\&?)*)?(#([-_.a-zA-Z0-9]|%[a-fA-F0-9]{2})*)?$",
        "description": "This pattern can be used to validate URLs starting with ftp, http or https",
        "matches": [
            "https://user:password@subdomain.domain.tld:80/~user/a_1/b.2//c%203/file.extension?query=string&with=various&param_eters&and=param,eters&with[]=brackets&and:colons&uniqid={21EC2020-3AEA-1069-A2DD-08002B30309D}"
        ],
        "non_matches": [
            "http://domain.....tld"
        ]
    },
    {
        "id": 1850,
        "expression": "^(AT){0,1}[U]{0,1}[0-9]{8}$",
        "description": "Vat number for Austria.\nFormat is\nATU12345678",
        "matches": [
            "ATU12345678",
            "ATU98752658",
            "ATU98765432"
        ],
        "non_matches": [
            "ATb12345678",
            "ATu12345678",
            "ATU 1234567"
        ]
    },
    {
        "id": 1851,
        "expression": "^(BG){0,1}([0-9]{9}|[0-9]{10})$",
        "description": "Vat number for Bulgaria. Formats are\nBG123456789\nBG1234567890",
        "matches": [
            "BG123456789",
            "BG1234567890",
            "BG1587963587"
        ],
        "non_matches": [
            "BG12349",
            "Bg1234567890",
            "BG1587963587989"
        ]
    },
    {
        "id": 1852,
        "expression": "(/\\*[\\d\\D]*?\\*/)|(\\/\\*(\\s*|.*?)*\\*\\/)|(\\/\\/.*)|(/\\\\*[\\\\d\\\\D]*?\\\\*/)|([\\r\\n ]*//[^\\r\\n]*)+",
        "description": "This regex searches multi-line, single-line, and XML comments present in C# file.",
        "matches": [
            "/* multi-line */",
            "// comment",
            "/// XML Comment"
        ],
        "non_matches": [
            "/* multi-line /*"
        ]
    },
    {
        "id": 1855,
        "expression": "(^0?[1-9]|^1[0-2])\\/(0?[1-9]|[1-2][0-9]|3[0-1])\\/(19|20)?[0-9][0-9](\\s(((0?[0-9]|1[0-9]|2[0-3]):[0-5][0-9](:[0-5][0-9])?)|((0?[0-9]|1[0-2]):[0-5][0-9](:[0-5][0-9])?\\s(AM|PM))))?$",
        "description": "Expression to validate a date with or without time in standard or 24 hour format with optional milliseconds (01/12/08 23:31:05 or 5/12/1974 11:59 PM).",
        "matches": [
            "01/28/08 22:34:12",
            "10/23/1952 5:23:01 PM",
            "6/2/02 22:59",
            "5/13/04"
        ],
        "non_matches": [
            "1/32/08",
            "12/29/005",
            "6/14/05 23:00:02 PM",
            "10/2/02 13:00 AM"
        ]
    },
    {
        "id": 1856,
        "expression": "^([a-zA-Z0-9])+\\\\{1}([a-zA-Z0-9])+$",
        "description": "Checks for the format alphanumeric\\alphanumeric",
        "matches": [
            "Admin\\user1",
            "ajit\\123",
            "123\\Ajit1"
        ],
        "non_matches": [
            "\\domain\\user",
            "domain\\\\\\user",
            "dom ain\\user"
        ]
    },
    {
        "id": 1857,
        "expression": "^((((0?[13578])|(1[02]))[\\-]?((0?[1-9]|[0-2][0-9])|(3[01])))|(((0?[469])|(11))[\\-]?((0?[1-9]|[0-2][0-9])|(30)))|(0?[2][\\-]?(0?[1-9]|[0-2][0-9])))[\\-]?\\d{2}$",
        "description": "I was looking for a date format that allowed 1 or 2 digit Month and Days and 2 digit years. I found and tweak this one\nbased off Cliff Schneide Date example.",
        "matches": [
            "03-25-08",
            "3-25-08",
            "3-1-08"
        ],
        "non_matches": [
            "03-25-2008",
            "3-25-2008",
            "3/25/2008"
        ]
    },
    {
        "id": 1863,
        "expression": "^\\s*[a-zA-Z0-9,\\s]+\\s*$",
        "description": "Will take space, number, no special characters",
        "matches": [
            "Project Name1",
            "Project 1"
        ],
        "non_matches": [
            "Project@1",
            "Project Name^111"
        ]
    },
    {
        "id": 1866,
        "expression": "^[a-zA-Z_:]+[a-zA-Z_:\\-\\.\\d]*$",
        "description": "Valid XML Node or Attribute Names start with a letter <document>, an underscore <_record> or a colon (generally avoid using a colon)\nThe next characters may be letters, digits, underscore, hyphens, periods and colons (but no whitespaces)",
        "matches": [
            "_1record",
            "MyXMLTag",
            ":ThisIsGr8"
        ],
        "non_matches": [
            "1record",
            "My XMLTag",
            "ThisIs<Gr8"
        ]
    },
    {
        "id": 1867,
        "expression": "^[1-9][0-9][0-9][0-9]$",
        "description": "Zip code validation for Switzerland.\nForces 4-digits only zipcode starting at 1000",
        "matches": [
            "1000",
            "1200",
            "8200",
            "8048",
            "9999"
        ],
        "non_matches": [
            "a-z",
            "aaaa",
            "123",
            "0000"
        ]
    },
    {
        "id": 1872,
        "expression": "(?!^[0-9]*$)(?!^[a-zA-Z]*$)^([a-zA-Z0-9]{8,10})$",
        "description": "Validates a strong password. It must be between 8 and 10 characters, contain at least one digit and one alphabetic character, and must not contain special characters",
        "matches": [
            "test1test"
        ],
        "non_matches": [
            "testtest"
        ]
    },
    {
        "id": 1873,
        "expression": "style=\"[^\"]*\"|'[^']*'",
        "description": "Get the style attribute inner text contained inside \" or ' caracters with the \"style=\" prefix.",
        "matches": [
            "style=\"width: 10px;border:0\" , style='width: 10px;border:0'"
        ],
        "non_matches": [
            "style = \"width:10px\""
        ]
    },
    {
        "id": 1877,
        "expression": "((0[1-9])|(1[0-2]))\\/(([0-9])|([0-2][0-9])|(3[0-1]))/\\d{2}",
        "description": "Validates dates in the following format: MM/DD/YY",
        "matches": [
            "01/30/08",
            "12/04/99",
            "01/05/10"
        ],
        "non_matches": [
            "13/30/05",
            "9/33/99",
            "1/05/02"
        ]
    },
    {
        "id": 1881,
        "expression": "^http[s]?://([a-zA-Z0-9\\-]+\\.)*([a-zA-Z]{3,61}|[a-zA-Z]{1,}\\.[a-zA-Z]{2})/.*$",
        "description": "Used for matching a URL and can be used for extracting the domain name from a given URL ending with '/'.\nConcat $2 and $3 to get the domain name.",
        "matches": [
            "http://www.google.com/",
            "http://google.com/",
            "http://code.google.com/",
            "http://google.co.uk/",
            "http://tx.us/"
        ],
        "non_matches": [
            "http://www.google.com;"
        ]
    },
    {
        "id": 1884,
        "expression": "^.*(yourdomain.com).*$",
        "description": "Matches the TLD of a given domain (replace yourdomain.com with whatever domain you're trying to enforce).\nI was writing an web application in which I wanted to to display a special message to visitors if and only if they were referred to my site by one specific site. However, because the specific site in question was highly dynamic, referring URLs were all over the place in terms of consistency and the only thing I knew I could count on 100% was the TLD (subdomains and file paths acceptable, so long as the TLD matches exactly).",
        "matches": [
            "yourdomain.com",
            "http://www.yourdomain.com",
            "http://subdomain.yourdomain.com/pages/manage/?act=4015876&ag=709254588456a"
        ],
        "non_matches": [
            "your-domain.com",
            "ourdomain.com",
            "yourdomain.co"
        ]
    },
    {
        "id": 1886,
        "expression": "^(\\d{1,8}|(\\d{0,8}\\.{1}\\d{1,2}){1})$",
        "description": "Validates a decimal with up to 8 whole places and up to two decimal places",
        "matches": [
            "1",
            "1.22",
            "12345678.11",
            ".34"
        ],
        "non_matches": [
            "123456789",
            "1.223234",
            "123456789.11"
        ]
    },
    {
        "id": 1894,
        "expression": "\\b(0?[1-9]|1[0-2])(\\/)(0?[1-9]|1[0-9]|2[0-9]|3[0-1])(\\/)(0[0-8])\\b",
        "description": "Matches the valid date format MM/DD/YY Year from 2000 (00) to 2008 (08) and the month will accept till 12 and the day will accept till 31",
        "matches": [
            "01/02/06",
            "12/31/07",
            "1/1/08"
        ],
        "non_matches": [
            "01/02/1999",
            "13/32/08",
            "01-31-2008"
        ]
    },
    {
        "id": 1896,
        "expression": "\\b(0[0-9]|1[0-9]|2[0-3])(\\:)(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])(\\:)(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])\\b",
        "description": "It will matches the railway time format that 00:00:00 to 23:59:59",
        "matches": [
            "00:00:00",
            "23:59:59",
            "10:00:00"
        ],
        "non_matches": [
            "24:0:00",
            "20:60:60",
            "15:00"
        ]
    },
    {
        "id": 1897,
        "expression": "\\b(0[0-9]|1[0-1])(\\:)(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])(\\:)(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])\\b",
        "description": "It will matches the Standard time format that 00:00:00 to 11:59:59",
        "matches": [
            "00:00:00",
            "11:59:59",
            "10:00:00"
        ],
        "non_matches": [
            "20:00:00",
            "10:60:60",
            "15:00"
        ]
    },
    {
        "id": 1898,
        "expression": "\\b(0[0-9]|1[0-1])(\\:)(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])(\\:)(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])\\s*(AM|PM|A|P)\\b",
        "description": "It will matches the Standard time format that 00:00:00 AM to 11:59:59 PM",
        "matches": [
            "00:00:00 AM",
            "11:59:59 PM",
            "10:00:00 AM"
        ],
        "non_matches": [
            "00:00:00",
            "11:59:59",
            "15:00 PM"
        ]
    },
    {
        "id": 1899,
        "expression": "\\b(((J(ANUARY|UNE|ULY))|FEBRUARY|MARCH|(A(PRIL|UGUST))|MAY|(SEPT|NOV|DEC)EMBER|OCTOBER))\\s*(0?[1-9]|1[0-9]|2[0-9]|3[0-1])\\s*(\\,)\\s*(200[0-9])\\b",
        "description": "VALIDATE THE DATE FORMAT FULL MONTH DAY, CCYY i.e August 30, 2006",
        "matches": [
            "JANUARY 26, 2007",
            "MARCH 1, 2001",
            "DECEMBER 31, 2005"
        ],
        "non_matches": [
            "JAN 26, 2001",
            "JULY 31 2005",
            "AUGUST 01, 08"
        ]
    },
    {
        "id": 1900,
        "expression": "\\b(((J(ANUARY|UNE|ULY))|FEBRUARY|MARCH|(A(PRIL|UGUST))|MAY|(SEPT|NOV|DEC)EMBER|OCTOBER))\\s*(0?[1-9]|1[0-9]|2[0-9]|3[0-1])\\s*(\\,)\\s*(0[0-9])\\b",
        "description": "VALIDATE THE DATE FORMAT FULL MONTH DAY, YY i.e August 30, 06 (2006)",
        "matches": [
            "JANUARY 26, 07",
            "MARCH 1, 01",
            "DECEMBER 31, 05"
        ],
        "non_matches": [
            "JAN 26, 01",
            "JULY 31 05",
            "AUGUST 01, 2008"
        ]
    },
    {
        "id": 1901,
        "expression": "\\b((J(AN|UN|UL))|FEB|MAR|(A(PR|UG))|MAY|SEP|NOV|DEC|OCT)\\s*(0?[1-9]|1[0-9]|2[0-9]|3[0-1])\\s*(\\,)\\s*(200[0-9])\\b",
        "description": "VALIDATE THE DATE FORMAT SHORT MONTH DAY, CCYY i.e Aug 30, 2006",
        "matches": [
            "JAN 26, 2007",
            "MAR 1, 2001",
            "DEC 31, 2005"
        ],
        "non_matches": [
            "JANUARY 26, 2001",
            "JUL 31 2005",
            "AUGUST 01, 08"
        ]
    },
    {
        "id": 1902,
        "expression": "\\b((J(AN|UN|UL))|FEB|MAR|(A(PR|UG))|MAY|SEP|NOV|DEC|OCT)\\s*(0?[1-9]|1[0-9]|2[0-9]|3[0-1])\\s*(\\,)\\s*(0[0-9])\\b",
        "description": "VALIDATE THE DATE FORMAT SHORT MONTH DAY, YY i.e Aug 30, 06 (2006)",
        "matches": [
            "JAN 26, 07",
            "MAR 1, 01",
            "DEC 31, 05"
        ],
        "non_matches": [
            "JANUARY 26, 01",
            "JUL 31 05",
            "AUGUST 01, 08"
        ]
    },
    {
        "id": 1903,
        "expression": "(\\+1 )?\\d{3} \\d{3} \\d{4}",
        "description": "This simple expression validates a USA phone number format where the +1 is required and that the phone number must only consist of numbers and spaces.",
        "matches": [
            "+1 808 555 1234"
        ],
        "non_matches": [
            "808-555-1234",
            "+1 (808) 555-1234"
        ]
    },
    {
        "id": 1906,
        "expression": "\\s(?=([^\"]*\"[^\"]*\"[^\"]*)*$|[^\"]*$)",
        "description": "Splits a string by spaces, except when the space is within a quote delimited set of characters. Usefull for splitting search field inputs.\nProps to killahbeez",
        "matches": [
            "\"two key\" words",
            "\"three key words",
            "three key words"
        ],
        "non_matches": [
            "\"no matches\"",
            "\"noMatches\"",
            "noMatches"
        ]
    },
    {
        "id": 1909,
        "expression": "ICON=\"[^\"]+\"",
        "description": "Remove favicon base64 data from Firefox bookmark HTML files, thereby reducing file size (useful for HTML bookmark backup and transfer).",
        "matches": [
            "<DT><A HREF=\"http://www.gmail.com/\" ADD_DATE=\"1147950005\" LAST_MODIFIED=\"1147950022\" ICON_URI=\"https://mail.google.com/favicon.ico\" ICON=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAiElEQVQ4jdWPsQ3AIAwEGYtZ2IZpvIGHoaRLm47q0wCyiY2SKspL3/mOJ4T/p8SI0TNnNKJtz5whGSUoMQLMcMOM9T7I14+UfEmHj5TUiikA4EsWGIAtMCUGvBWAWUkULFbZglrRiJREwo0IqNURDLgfjO/I2fLmJlhhN11iLngcb8GbTsHnuQAHliL7fehqZAAAAABJRU5ErkJggg==\" LAST_CHARSET=\"UTF-8\">Google Mail</A>"
        ],
        "non_matches": [
            "<DT><A HREF=\"http://flickr.com/\" ADD_DATE=\"1107635483\" LAST_VISIT=\"1189245562\" LAST_MODIFIED=\"1114539579\" LAST_CHARSET=\"UTF-8\" ID=\"rdf:#$Ppq5x3\">Flickr</A>"
        ]
    },
    {
        "id": 1912,
        "expression": "(^\\+?([1-8])?\\d(\\.\\d+)?$)|(^-90$)|(^-(([1-8])?\\d(\\.\\d+)?$))",
        "description": "Latitude must<90 >=-90",
        "matches": [
            "5.4",
            "-0.58",
            "-90",
            "+87"
        ],
        "non_matches": [
            "-120",
            "+1.4F",
            "90"
        ]
    },
    {
        "id": 1913,
        "expression": "^((1[01])|(\\d)):[0-5]\\d(:[0-5]\\d)?\\s?([apAP][Mm])?$",
        "description": "validate time\nin hh:mm:ss\nhh:mm\nhh:mm:ss pm(am,PM,AM)\n<12h",
        "matches": [
            "11:23:43PM",
            "3:25:35",
            "1:23 am"
        ],
        "non_matches": [
            "12:01:01",
            "3.14pm",
            "01:24AM"
        ]
    },
    {
        "id": 1914,
        "expression": "^<\\s*(td|TD)\\s*(\\w|\\W)*\\s*>(\\w|\\W)*</(td|TD)>$",
        "description": "match <td ***>***</td> in html,so any other html mark with<sth></sth> is just do a little change to this",
        "matches": [
            "<td>hello kitty</td>",
            "<TD WIDTH='20></TD>",
            "<TD >&NBSP;</td>"
        ],
        "non_matches": [
            "<td>< /td>",
            "<TD HELLO</td>",
            "<table></table>"
        ]
    },
    {
        "id": 1915,
        "expression": "^((([1]\\d{2})|(22[0-3])|([1-9]\\d)|(2[01]\\d)|[1-9]).(([1]\\d{2})|(2[0-4]\\d)|(25[0-5])|([1-9]\\d)|\\d).(([1]\\d{2})|(2[0-4]\\d)|(25[0-5])|([1-9]\\d)|\\d).(([1]\\d{2})|(2[0-4]\\d)|(25[0-5])|([1-9]\\d)|\\d))$",
        "description": "match ip\naddress from 1.0.0.0 to 223.255.255.255",
        "matches": [
            "192.168.0.1",
            "223.255.255.255",
            "9.0.0.0"
        ],
        "non_matches": [
            "0.10.2.52",
            "255.255.255.255",
            "127.0.257.1"
        ]
    },
    {
        "id": 1916,
        "expression": "(((0[13578]|10|12)([/])(0[1-9]|[12][0-9]|3[01])([/])([1-2][0,9][0-9][0-9]))|((0[469]|11)([/])([0][1-9]|[12][0-9]|30)([/])([1-2][0,9][0-9][0-9]))|((02)([/])(0[1-9]|1[0-9]|2[0-8])([/])([1-2][0,9][0-9][0-9]))|((02)([/])(29)(\\.|-|\\/)([02468][048]00))|((02)([/])(29)([/])([13579][26]00))|((02)([/])(29)([/])([0-9][0-9][0][48]))|((02)([/])(29)([/])([0-9][0-9][2468][048]))|((02)([/])(29)([/])([0-9][0-9][13579][26])))",
        "description": "This is the USA Date Format. MM/DD/YYYY with checking leaf year",
        "matches": [
            "05/15/2008",
            "02/29/2008"
        ],
        "non_matches": [
            "05-12-2008",
            "02/29/2007"
        ]
    },
    {
        "id": 1921,
        "expression": "^([a-zA-Z]+[\\'\\,\\.\\-]?[a-zA-Z ]*)+[ ]([a-zA-Z]+[\\'\\,\\.\\-]?[a-zA-Z ]+)+$",
        "description": "Requires a person's name including at least 2 parts. (first and last) Allows optional extra names. It allows plenty of initials as well as symbols in names. Restricts symbol usage quite a bit, but allows even names with 2 symbols. Requires last name to have at least 2 characters and cannot be an initial. Works well for filtering names on validation.",
        "matches": [
            "E.J. O'Malley",
            "Jack O'Neil",
            "Mary-Lou Elizabeth Jones"
        ],
        "non_matches": [
            "Johnathan Michael S.",
            "Prince",
            "Teddy Has-a..Fake-Name"
        ]
    },
    {
        "id": 1924,
        "expression": "((19|20)[0-9]{2})-(([1-9])|(0[1-9])|(1[0-2]))-((3[0-1])|([0-2][0-9])|([0-9]))",
        "description": "Validate the year month and day.",
        "matches": [
            "2008-12-15"
        ],
        "non_matches": [
            "1556/9/8"
        ]
    },
    {
        "id": 1925,
        "expression": "^[:*:]",
        "description": "This checks whether the string is equals to \"*\" i.e., contains only \"*(Asterisk)\" or begins with Asterisk.",
        "matches": [
            "*",
            "*Asdf"
        ],
        "non_matches": [
            "a*",
            "asdf"
        ]
    },
    {
        "id": 1927,
        "expression": "^[0-9]+\\.?[0-9]?[0-9]?[0,5]?$",
        "description": "The time should be fractional number and divisible by 0.005",
        "matches": [
            "1.005",
            "60",
            "0.08"
        ],
        "non_matches": [
            "1.009",
            "-8",
            ".005"
        ]
    },
    {
        "id": 1931,
        "expression": "^\\d+\\/?\\d*$",
        "description": "This simple expression is used to validate fractions or UK odds.\nIt will match integers, allowing 10/1 to be entered as 10, and fractions.\nIt will not match negative numbers or fractions, spaces or any alphabetical characters.",
        "matches": [
            "10",
            "2/3",
            "100/30"
        ],
        "non_matches": [
            "-10",
            "-2/3",
            "text",
            "10 / 1",
            "42/7eok"
        ]
    },
    {
        "id": 1933,
        "expression": "^(\\d{1,4}?[.]{0,1}?\\d{0,3}?)$",
        "description": "This expression validate the add of numbers with or without decimal",
        "matches": [
            "123",
            "123.1",
            "100.",
            "0.2",
            "2341.123"
        ],
        "non_matches": [
            "12345.1234",
            ".012",
            ".2893"
        ]
    },
    {
        "id": 1941,
        "expression": "^([\\u20AC]?[1-9]\\d*\\.\\d{3}(?:,\\d{2})?|[\\u20AC]?[1-9]\\d*(?:,\\d{2})?|[\\u20AC]?[1-9]\\d*)$",
        "description": "Optional Amount, with optional thousands seperator (using the point) and optional decimal comma. If decimal comma is in string, then 2 trailing digits are required. Also checks for the optional euro sign",
        "matches": [
            "1",
            "1,00",
            "1.000,00",
            "\u20ac1"
        ],
        "non_matches": [
            "1a",
            ".00,00",
            "1,0",
            "$1"
        ]
    },
    {
        "id": 1943,
        "expression": "\\b[P|p]?(OST|ost)?\\.?\\s*[O|o|0]?(ffice|FFICE)?\\.?\\s*[B|b][O|o|0]?[X|x]?\\.?\\s+[#]?(\\d+)\\b",
        "description": "Modified version of Chris Myers' regexp for po boxes. This one won't match the word \"box\" in the address. Only matches if there is a number following the po box. Also accepts a # in front of the number and other spelling variations.",
        "matches": [
            "po box 123, p.o.b. #123, box 123"
        ],
        "non_matches": [
            "123 box canyon rd"
        ]
    },
    {
        "id": 1944,
        "expression": "http[s]?://[a-zA-Z0-9.-/]+",
        "description": "Checks to make sure that entry starts with http:// or https:// and that contents are limited to alphas . - /",
        "matches": [
            "http://www.google.com",
            "https://www.google.com",
            "http://localhost/"
        ],
        "non_matches": [
            "www.google.com"
        ]
    },
    {
        "id": 1950,
        "expression": "^[-|\\+]?[0-9]{1,3}(\\,[0-9]{3})*$|^[-|\\+]?[0-9]+$",
        "description": "Integer with or without commas. Signed or unsigned.",
        "matches": [
            "1,234",
            "1234",
            "-1,234",
            "-1234"
        ],
        "non_matches": [
            "12,34",
            "1.234",
            "abc"
        ]
    },
    {
        "id": 1952,
        "expression": "^([0-9]{1}[\\d]{0,2}(\\,[\\d]{3})*(\\,[\\d]{0,2})?|[0-9]{1}[\\d]{0,}(\\,[\\d]{0,2})?|0(\\,[\\d]{0,2})?|(\\,[\\d]{1,2})?)$",
        "description": "Match any number , no characters, no empty sets, and accept zero.",
        "matches": [
            "0001",
            "12345",
            ""
        ],
        "non_matches": [
            "abcd",
            "012a"
        ]
    },
    {
        "id": 1953,
        "expression": "^(GIR ?0AA|(?:[A-PR-UWYZ](?:\\d|\\d{2}|[A-HK-Y]\\d|[A-HK-Y]\\d\\d|\\d[A-HJKSTUW]|[A-HK-Y]\\d[ABEHMNPRV-Y])) ?\\d[ABD-HJLNP-UW-Z]{2})$",
        "description": "This regex matches all valid, current UK Postcodes, including Girobank and non-geographic postcodes, irrespective of whether they contain a space. It does not include overseas territories.\nAdapted from the BS7666 postcode rules at: http://www.cabinetoffice.gov.uk/govtalk/schemasstandards/e-gif/datastandards/address/postcode.aspx",
        "matches": [
            "M1 1AA",
            "M60 1NW",
            "CR2 6XH",
            "DN55 1PT",
            "W1A 1HQ",
            "EC1A 1BB",
            "GIR 0AA"
        ],
        "non_matches": [
            "Q1 1AA",
            "M60 1CW",
            "5R2 6XH",
            "DJ55 1PT",
            "W1M 1HQ",
            "EC1D 1BB",
            "GIR 1AA"
        ]
    },
    {
        "id": 1954,
        "expression": "^(0\\.|([1-9]([0-9]+)?)\\.){3}(0|([1-9]([0-9]+)?)){1}$",
        "description": "A simple regex to check a version information string of the style 1.0.0.0",
        "matches": [
            "1.2.3.4"
        ],
        "non_matches": [
            "1.2.3",
            "01.02.03.04",
            "1.2.3.4Beta"
        ]
    },
    {
        "id": 1956,
        "expression": "^((\\$?\\-?)|(\\-?\\$?))([0-9]{1,3},([0-9]{3},)*[0-9]{3}|[0-9]+)?(\\.[0-9]*)?$",
        "description": "Matches any number which includes the US currency symbol ($), a negative sign (-), comma separators, and a decimal. It matches an unlimited number of decimal places. It does NOT reject an empty string passed to it. Credit goes to Al Kahler for posting the original expression from http://regxlib.com/REDetails.aspx?regexp_id=70 along with a fix for the decimal place.",
        "matches": [
            "$.01",
            "1,234.003",
            "834223.1",
            "$0.01",
            "-$1.50",
            "$-50.123"
        ],
        "non_matches": [
            ".0,001",
            "1,1.01",
            "1E",
            "5$"
        ]
    },
    {
        "id": 1958,
        "expression": "^[A-Z]\\d{2}(\\.\\d){0,1}$",
        "description": "This expression matches ICD-10 code",
        "matches": [
            "Z99.9",
            "Z99"
        ],
        "non_matches": [
            "Z999",
            "Z99.",
            "99"
        ]
    },
    {
        "id": 1960,
        "expression": "(((0*[1-9]|[12][0-9]|3[01])([-./])(0*[13578]|10|12)([-./])(\\d{4}))|((0*[1-9]|[12][0-9]|30)([-./])(0*[469]|11)([-./])(\\d{4}))|((0*[1-9]|1[0-9]|2[0-8])([-./])(02|2)([-./])(\\d{4}))|((29)(\\.|-|\\/)(02|2)([-./])([02468][048]00))|((29)([-./])(02|2)([-./])([13579][26]00))|((29)([-./])(02|2)([-./])([0-9][0-9][0][48]))|((29)([-./])(02|2)([-./])([0-9][0-9][2468][048]))|((29)([-./])(02|2)([-./])([0-9][0-9][13579][26])))",
        "description": "Date in DD/MM/YYYY or D/M/YYYY format.",
        "matches": [
            "01/06/2008",
            "1/1/2008"
        ],
        "non_matches": [
            "32/13/2008",
            "00/00/2005"
        ]
    },
    {
        "id": 1962,
        "expression": "(?!\\b(xx|yy)\\b)\\b[\\w]+\\b",
        "description": "Matches any word except these from alternation (xx|yy|...). Works in JavaScript",
        "matches": [
            "x",
            "xxx",
            "xxyy",
            "yyx"
        ],
        "non_matches": [
            "xx",
            "yy"
        ]
    },
    {
        "id": 1964,
        "expression": "^100$|^100.00$|^\\d{0,2}(\\.\\d{1,2})? *%?$",
        "description": "Allows percent values from 0 to 100 without the % sign. Can be used with up to 2 decimal places or without any. Also works in ASP.NET regular expression validator control.",
        "matches": [
            "0",
            "0.00",
            "50.25",
            "100",
            "100.00"
        ],
        "non_matches": [
            "100.01",
            "-1",
            "5.005"
        ]
    },
    {
        "id": 1970,
        "expression": "<\\/*?(?![^>]*?\\b(?:a|img)\\b)[^>]*?>",
        "description": "This regex will match all HTML tags except 'a' tags or 'img' tags. You can edit the list of exclusions as you see fit. I use this regex to strip all HTML tags from source data except anchor tags and image tags.",
        "matches": [
            "<script> </html> <anytag>"
        ],
        "non_matches": [
            "<a> <img /> </a>"
        ]
    },
    {
        "id": 1971,
        "expression": "<(script|style)[^>]*?>(?:.|\\n)*?</\\s*\\1\\s*>",
        "description": "This regular expression will match only <script> and <style> tags and all content between them. Use this with regex.replace to strip script blocks and style blocks from HTML source.",
        "matches": [
            "<script>test</script>, <style>test<style>"
        ],
        "non_matches": [
            "-all other html code is ignored-"
        ]
    },
    {
        "id": 1972,
        "expression": "^[1-9]{1}$|^[1-9]{1}[0-9]{1}$|^[1-3]{1}[0-6]{1}[0-5]{1}$|^365$",
        "description": "This expression allows you to select 1-365 as a numeric value for the days of the year. Must be between 1 and 365 and must be numeric",
        "matches": [
            "25",
            "363",
            "110"
        ],
        "non_matches": [
            "2.5",
            "0",
            "400"
        ]
    },
    {
        "id": 1973,
        "expression": "^.*[_A-Za-z0-9]+[\\t ]+[\\*&]?[\\t ]*[_A-Za-z0-9](::)?[_A-Za-z0-9:]+[\\t ]*\\(( *[ \\[\\]\\*&A-Za-z0-9_]+ *,? *)*\\).*$",
        "description": "This (while not perfect) locates c++ function declarations. Useful for working with large source files",
        "matches": [
            "void helloworld()",
            "FILE *MyClass::getFile()",
            "int getFibbNum (int place)"
        ],
        "non_matches": [
            "getFibbNum(3)",
            "int MyNum;",
            "for (int x=1 ... )"
        ]
    },
    {
        "id": 1974,
        "expression": "^(\\d{3}-\\d{2}-\\d{4})|(\\d{3}\\d{2}\\d{4})$",
        "description": "This will accept SSN in the form of 123-45-6789 OR 123456789.",
        "matches": [
            "123-45-6789",
            "123456789",
            "456-63-6666"
        ],
        "non_matches": [
            "123-45-459a",
            "222-2-2222",
            "222-222222"
        ]
    },
    {
        "id": 1977,
        "expression": "^(\\d?)*(\\.\\d{1}|\\.\\d{2})?$",
        "description": "Expression to validate currency formatted numbers without the currency symbol",
        "matches": [
            "153",
            "33.48",
            "786.1",
            "1567863483.33"
        ],
        "non_matches": [
            "-123",
            "8524.258",
            "eo45"
        ]
    },
    {
        "id": 1978,
        "expression": "(\\d{3}\\-\\d{2}\\-\\d{4})",
        "description": "pattern match for U.S. social security number",
        "matches": [
            "111-22-3333"
        ],
        "non_matches": [
            "11-222-3333",
            "1111-22-333"
        ]
    },
    {
        "id": 1979,
        "expression": "^([a-zA-Z])[a-zA-Z_-]*[\\w_-]*[\\S]$|^([a-zA-Z])[0-9_-]*[\\S]$|^[a-zA-Z]*[\\S]$",
        "description": "Will verify if the text is is in a valid user name format like: is alphanumeric, starts with an alphabet and contains no special characters other than underscore or dash.",
        "matches": [
            "username",
            "user123",
            "user_123",
            "user-123",
            "username123_type"
        ],
        "non_matches": [
            "123username",
            "user name",
            "_username"
        ]
    },
    {
        "id": 1984,
        "expression": "(\")([0-9]*)(\",\")([0-9]*)(\"\\))",
        "description": "This was made to change non-decimal prices at the end of a huge SQL Insert... To use to replace in DW (without quotes) use sub expression like: $2,$4)",
        "matches": [
            "\"0\",\"0\") \"999\",\"999999\")"
        ],
        "non_matches": [
            "0,0)"
        ]
    },
    {
        "id": 1986,
        "expression": "^([a-zA-Z]{5})([a-zA-Z0-9-]{3,12})",
        "description": "Validate: First five characters are letters; characters six-17 are letters, numbers, or hyphen; string length is eight characters minimum, 17 characters maximum",
        "matches": [
            "ABCDE123abc-123AB"
        ],
        "non_matches": [
            "1BCDE123abc-123AB -BCDE123abc-123AB ABCDE6789012345678"
        ]
    },
    {
        "id": 1991,
        "expression": "^((\\(\\d{3}\\) ?)|(\\d{3}-)|(\\(\\d{2}\\) ?)|(\\d{2}-)|(\\(\\d{1}\\) ?)|(\\d{1}-))?\\d{3}-(\\d{3}|\\d{4})",
        "description": "Esta es la expresion regular adaptada por mi para validar telefonos fijos chilenos de cualquier compa\u00f1ia, espero sirva a alguien",
        "matches": [
            "(041)245-9848",
            "(063)421-232"
        ],
        "non_matches": [
            "0412459848",
            "063421232"
        ]
    },
    {
        "id": 2008,
        "expression": "^([^S]|S[^E]|SE[^P]).*",
        "description": "Matches everything except lines that begin with SEP.\nNow I just need to figure out how to exclude a string that appears in the middle of a line.",
        "matches": [
            "SEk001",
            "TAK002"
        ],
        "non_matches": [
            "SEP001",
            "SEP002"
        ]
    },
    {
        "id": 2010,
        "expression": "^(([a-zA-Z]:)|(\\\\{2}\\w+)\\$?)(\\\\(\\w[\\w].*))+(.pdf)$",
        "description": "You can use this to check the valid file type you have given to the last in the expression\nlike\n^(([a-zA-Z]:)|(\\\\{2}\\w+)\\$?)(\\\\(\\w[\\w].*))+(.pdf)$\nThis will accept .pdf only\nOR\n^(([a-zA-Z]:)|(\\\\{2}\\w+)\\$?)(\\\\(\\w[\\w].*))+((.pdf)|(.doc))$\nThis will accept .pdf and .doc\nOR\n^(([a-zA-Z]:)|(\\\\{2}\\w+)\\$?)(\\\\(\\w[\\w].*))+((.pdf)|(.doc)|(.txt))$\nThis will accept .pdf , .doc and .txt",
        "matches": [
            "C:\\Documents and Settings\\chandan.kumar\\Desktop\\1004.pdf"
        ],
        "non_matches": [
            "C:\\Documents and Settings\\All Users\\Documents\\My Pictures\\Sample Pictures\\Sunset.jpg"
        ]
    },
    {
        "id": 2011,
        "expression": "^([0-1]?[0-9]{1}|2[0-3]{1}):([0-5]{1}[0-9]{1})$",
        "description": "This expression will validate if a string represents a time in 24 hour format.\nThe expression will evaluate the string from start to finish. It will not accept 24:00, use 00:00 instead.",
        "matches": [
            "1:59",
            "01:59",
            "23:59"
        ],
        "non_matches": [
            "24:00",
            "01:60",
            "01:234"
        ]
    },
    {
        "id": 2013,
        "expression": "([.])([a-z,1-9]{3,4})(\\/)",
        "description": "Returns the TLD from a URL.",
        "matches": [
            ".com/",
            ".net/",
            ".biz/",
            ".123/",
            ".mobi/"
        ],
        "non_matches": [
            ".co.uk/",
            ".org.uk/"
        ]
    },
    {
        "id": 2014,
        "expression": "^\\$?\\d{1,2}\\,\\d{3}?\\,\\d{3}?(\\.(\\d{2}))$|^\\$?\\d{1,3}?\\,\\d{3}?(\\.(\\d{2}))$|^\\$?\\d{1,3}?(\\.(\\d{2}))$",
        "description": "Needed to verify a currency amount entered has commas and two decimal spaces to the right. This has a range between 1.99 to the tens of millions. If you want to make the decimal side optional, add a question mark before the final $ in each expression.",
        "matches": [
            "1.99",
            "111,111.99",
            "11,111,111.99"
        ],
        "non_matches": [
            "1.999",
            "1111",
            "1111111",
            "11.9"
        ]
    },
    {
        "id": 2023,
        "expression": "(1)?-?\\(?\\s*([0-9]{3})\\s*\\)?\\s*-?([0-9]{3})\\s*-?\\s*([0-9]{4})\\s*",
        "description": "A very simple regex to parse 10-digit US phone numbers. Captures the leading 1 in $1, the area code in $2, the 3-digit prefix in $3, and the four-digit postfix in $4.\nThis expression DOES allow for reserved area codes (001,etc) which are not typically in use.",
        "matches": [
            "(123)456-7890",
            "1234567890",
            "123 456 7890",
            "123-456-7890",
            "(123)4567890",
            "123-4567890"
        ],
        "non_matches": [
            "123456789",
            "(1234)567890",
            "(12-3)4567890"
        ]
    },
    {
        "id": 2025,
        "expression": "^(\\+48\\s+)?\\d{3}(\\s*|\\-)\\d{3}(\\s*|\\-)\\d{3}$",
        "description": "Supported: +48 prefix (optional); separating elements with hyphen or spaces",
        "matches": [
            "+48 500-080-100",
            "500080100",
            "500 080 100"
        ],
        "non_matches": [
            "+47 100-100-100",
            "1000-100-100",
            "1000000000"
        ]
    },
    {
        "id": 2028,
        "expression": "^(.|\\r|\\n){1,10}$",
        "description": "This expression can be use to define the maximum length to a textBox.\nU can change the maximum character by replacing the last numeric value that is 10 in my example.\nJust change this number to your desired number like\n^(.|\\r|\\n){1,10}$ : for max 10 character\n^(.|\\r|\\n){1,20}$ : for max 20 character",
        "matches": [
            "ChandanKum"
        ],
        "non_matches": [
            "ChandanKuma"
        ]
    },
    {
        "id": 2031,
        "expression": "\\b[1-9]\\d{3}\\ +[A-Z]{2}\\b",
        "description": "Dutch postal codes are ranged from \"1000 AA\" to \"9999 ZZ\".",
        "matches": [
            "\"1484 EE\""
        ],
        "non_matches": [
            "\"1484EE\"",
            "\"0111 AB\"",
            "\"1484 ee\"",
            "\"1234 ABC\""
        ]
    },
    {
        "id": 2035,
        "expression": "^[a-zA-Z0-9._\\-]+@[a-z0-9\\-]+(\\.[a-z]+){1,}$",
        "description": "Matches simple e-mail addresses such as me@domain.com, me@domain.co.uk, but does not place any restrictions on TLDs other than they must be lower case and alphabetic. a-z, A-Z, 0-9, ., _, and - are all allowed on the left side of @.",
        "matches": [
            "me@test.com",
            "me@test.co.uk",
            "me@test.asdf"
        ],
        "non_matches": [
            "@test.com",
            "@.com",
            "@."
        ]
    },
    {
        "id": 2037,
        "expression": "^[a-zA-Z0-9]+[\\s]*[a-zA-Z0-9.\\-\\,\\#]+[\\s]*[a-zA-Z0-9.\\-\\,\\#]+[a-zA-Z0-9\\s.\\-\\,\\#]*$",
        "description": "US Addresses validation having atleast 3 characters ignoring any spaces. Can have hash \"#\" comma \",\" dash \"-\" dot \".\" but cannot start with these.",
        "matches": [
            "123 E DRACHMAN TUCSON AZ 12345",
            "St # 123, North AVE New York. NY 12345"
        ],
        "non_matches": [
            "-1 AVE,1, Aa",
            "#1 Street ,. 20 North,,1 AVE"
        ]
    },
    {
        "id": 2040,
        "expression": "<[^>]*>",
        "description": "This Regex Will Remove All Html Tags And Return Simple Plain Text .\nFor Example In C#.NET :\nRegex.Replace(Html, \"<[^>]*>\", string.Empty);",
        "matches": [
            "<p> Hello Ali Delshad </p>"
        ],
        "non_matches": [
            "Hello Ali Delshad"
        ]
    },
    {
        "id": 2041,
        "expression": "[\\u0600-\\u06FF]",
        "description": "This Regex chceck an input string for persian unicode character\nNote that it not work in javascript\nFor Example In C#.NET:\nRegex.IsMatch(Text, \"[\\u0600-\\u06FF]\");",
        "matches": [
            "\u0633\u0644\u0627\u0645",
            "hello \u0639\u0644\u06cc",
            "Hi 2 \u0633\u0644\u0627\u0645"
        ],
        "non_matches": [
            "Hello",
            "Ali",
            "123"
        ]
    },
    {
        "id": 2049,
        "expression": "^(?=.*\\d)(?=.*[a-z])([a-z0-9]{8,25})$",
        "description": "Password matching expression. Password must be at least 8 characters,no more then 25 characters, must include at least 1 lower case letter and 1 numeric digit. Upper case, space and punctuation marks are not allowed.",
        "matches": [
            "aaaaaaa1",
            "abcdefghijklmnoprqstu1234",
            "1234567a"
        ],
        "non_matches": [
            "aaaaaaA1",
            "0123456789kB",
            "1234567890abcde123456 A%."
        ]
    },
    {
        "id": 2050,
        "expression": "^\\s*[a-zA-Z\\s]+\\,[0-9\\s]+\\s*$",
        "description": "its validating the string as shown in example(matches).",
        "matches": [
            "navjot, 24",
            "Sweet, 23"
        ],
        "non_matches": [
            "456, abcd",
            "abcd 123"
        ]
    },
    {
        "id": 2051,
        "expression": "^(((\\d|([a-f]|[A-F])){2}:){5}(\\d|([a-f]|[A-F])){2})$|^(((\\d|([a-f]|[A-F])){2}-){5}(\\d|([a-f]|[A-F])){2})$|^$",
        "description": "Designed to verify a MAC address with no spaces allowed, hex values separated by linux style separator \":\" or by windows style separator \"-\". Also empty string entry is allowed.",
        "matches": [
            "A0:B1:C2:D3:E4:F5",
            "A0-B1-C2-D3-E4-F5",
            ""
        ],
        "non_matches": [
            "A0-B1-C2-D3-E4:F5",
            "A0 - B1 - C2 - D3 - E4 - F5",
            "A0:B1:C2:D3:E4:G5"
        ]
    },
    {
        "id": 2057,
        "expression": "^([0-9a-zA-Z]+(?:[_\\.\\-]?[0-9a-zA-Z]+)*[@](?:[0-9a-zA-Z]+(?:[_\\.\\-]?[0-9a-zA-Z]+)*\\.[a-zA-Z]{2,}|(?:\\d{1,}\\.){3}\\d{1,}))$",
        "description": "|| Only alphanum characters accepted at the beginning of the user name and domain name\n|| Does not allow 2+ adjacent non-alphanum characters\n|| IP address accepted as domain\n|| 1+ chars accepted as user name or domain",
        "matches": [
            "a@a.aa",
            "a_bc@11.0.0.5",
            "abc@a_bc.a_bc.aa",
            "1abc@1abc.aa"
        ],
        "non_matches": [
            "a__bc@abc.aa",
            "abc@a__bc.aa",
            "abc_@abc.aa",
            "abc@abc_.aa"
        ]
    },
    {
        "id": 2065,
        "expression": "^((((((0[1-9])|(1\\d)|(2[0-8]))\\.((0[123456789])|(1[0-2])))|(((29)|(30))\\.((0[13456789])|(1[0-2])))|((31)\\.((0[13578])|(1[02]))))\\.\\d{4})|((29)\\.(02)\\.\\d{2}(([02468][048])|([13579][26]))))(\\s((0\\d)|(1\\d)|(2[0-3]))\\:([0-5]\\d)\\:([0-5]\\d)\\.\\d{7})$",
        "description": "Oracle like time stamp with format:\ndd.MM.yyyy HH.mm.SS.xxxxxxx\nBased on European full proved date format with easy changeable dot separator.\nOptimized regular expresion.",
        "matches": [
            "29.02.2008 23:50:45.1234567",
            "31.03.2007 00:01:01.0000001",
            "30.04.1999 01:02:03.0000000"
        ],
        "non_matches": [
            "29.02.2009 23:50:45.1234567",
            "31.04.2007 00:01:01.0000001",
            "30.04.1999 01:02:03.0000"
        ]
    },
    {
        "id": 2069,
        "expression": "^((([sS]|[nN])[a-hA-Hj-zJ-Z])|(([tT]|[oO])[abfglmqrvwABFGLMQRVW])|([hH][l-zL-Z])|([jJ][lmqrvwLMQRVW]))([0-9]{2})?([0-9]{2})?([0-9]{2})?([0-9]{2})?([0-9]{2})?$",
        "description": "Matches standard 0- to 10-figure (non-tetrad) Ordnance Survey of Great Britain (OSGB) Grid References",
        "matches": [
            "SH",
            "OF1234567890",
            "NP1234"
        ],
        "non_matches": [
            "SH123",
            "SH12D",
            "NI1234",
            "1234"
        ]
    },
    {
        "id": 2072,
        "expression": "^(\\d|\\d{1,9}|1\\d{1,9}|20\\d{8}|213\\d{7}|2146\\d{6}|21473\\d{5}|214747\\d{4}|2147482\\d{3}|21474835\\d{2}|214748364[0-7])$",
        "description": "Matches any integer from 0 to 2147483647 (max Integer size for C#, Java, others)",
        "matches": [
            "0",
            "352533",
            "2147483647"
        ],
        "non_matches": [
            "-1",
            "2.4",
            "2147483648"
        ]
    },
    {
        "id": 2080,
        "expression": "^(\\+?)(\\d{2,4})(\\s?)(\\-?)((\\(0\\))?)(\\s?)(\\d{2})(\\s?)(\\-?)(\\d{3})(\\s?)(\\-?)(\\d{2})(\\s?)(\\-?)(\\d{2})",
        "description": "This regex will match various ways of entering a Swiss phone number along with the country code.",
        "matches": [
            "+41 44 123 12 34",
            "+41 (0) 44 123 12 34",
            "+41-44-123-1234",
            "0041 44 123 12 34"
        ],
        "non_matches": [
            "+41 0 44 123 1234",
            "+41.44.123.1234"
        ]
    },
    {
        "id": 2083,
        "expression": "(((0[123456789]|10|11|12)(([1][9][0-9][0-9])|([2][0-9][0-9][0-9]))))",
        "description": "Validates dates that are in month/year (MMYYYY) format without slashes, periods, dashes, or spaces. No special characters or letters allowed. MM values allowed are 01 thru 12. YYYY values allowed are 1900 - 2999.\nThis is an adaptation of Felipe Albacete's MM/YYYY regular expression.",
        "matches": [
            "052000",
            "122008",
            "101972",
            "041903"
        ],
        "non_matches": [
            "12/2003",
            "131997",
            "51988",
            "111899",
            "04.2004",
            "10-1965"
        ]
    },
    {
        "id": 2086,
        "expression": "^\\#?[A-Fa-f0-9]{3}([A-Fa-f0-9]{3})?$",
        "description": "Matches valid 3 or 6 character hex codes used for HTML or CSS.",
        "matches": [
            "fff",
            "#990000",
            "#cc3366",
            "#AAAAAA"
        ],
        "non_matches": [
            "#5555",
            "#ZJK000",
            "CDCDCDCD"
        ]
    },
    {
        "id": 2087,
        "expression": "^(?=.{6,})(?=.*[0-9].*)(?=.*[a-z].*).*$",
        "description": "Password of 6 symbols. Must containt at leats one non-captial letter and at least digit digit",
        "matches": [
            "abc123",
            "()()a1",
            "_ABCDa1"
        ],
        "non_matches": [
            "abcdef",
            "ab_12",
            "ABC123"
        ]
    },
    {
        "id": 2089,
        "expression": "('(?:(?:\\\\'|[^'])*)'|NULL)",
        "description": "This is useful to find single quoted strings in mysql dumps.\nIt accepts \\' inside the strings.",
        "matches": [
            "'A car'",
            "'Mary\\'s car'",
            "NULL"
        ],
        "non_matches": [
            "'asdasdasd",
            "adsfadsf",
            "23123"
        ]
    },
    {
        "id": 2090,
        "expression": "((\\d{0}[0-9]|\\d{0}[1]\\d{0}[0-2])(\\:)\\d{0}[0-5]\\d{0}[0-9](\\:)\\d{0}[0-5]\\d{0}[0-9]\\s(AM|PM))",
        "description": "Matches hours 0-12:minutes 0-59:seconds 0-59 AM|PM",
        "matches": [
            "0:00:00 AM, 11:59:59 PM,12:00:00 AM, 5:34:00 PM"
        ],
        "non_matches": [
            "1:00 AM, 5:3:00 PM, 5:34:00 P,5:34:00 Pm"
        ]
    },
    {
        "id": 2091,
        "expression": "^([0]\\d|[1][0-2]\\/([0-2]\\d|[3][0-1])\\/([2][0]\\d{2})\\s([0-1]\\d|[2][0-3])\\:[0-5]\\d\\:[0-5]\\d)?\\s(AM|am|aM|Am|PM|pm|pM|Pm)",
        "description": "Date Time with am/pm.",
        "matches": [
            "10/13/2008 12:00:00 AM",
            "10/13/2008 12:00:00 PM"
        ],
        "non_matches": [
            "10/13/2008 12:00:00"
        ]
    },
    {
        "id": 2094,
        "expression": "(?s)(?i)^(?!^.*(dont match me).*$).*$",
        "description": "will match anything EXCEPT what you replace \"dont match me\" with.\nyou can replace the last .* with whatever criteria must be matched. example matches anything.",
        "matches": [
            "almost anything at all"
        ],
        "non_matches": [
            "please dont match me; dont match me at all"
        ]
    },
    {
        "id": 2095,
        "expression": "^(([1-9]{1}[0-9]{0,5}([.]{1}[0-9]{0,2})?)|(([0]{1}))([.]{1}[0-9]{0,2})?)$",
        "description": "This will allow your app to check currency during events such as key down\n(set to decimal(8,2) only)",
        "matches": [
            "13",
            "13.",
            "13.1",
            "13.11",
            "0.",
            "0.1"
        ],
        "non_matches": [
            "01",
            ".1",
            "0.011"
        ]
    },
    {
        "id": 2101,
        "expression": "(?:^(?:-)?(?:\\d{1,3}\\.(?:\\d{3}\\.)*\\d{3})(?:\\,\\d+)?$|^(?:-)?\\d*(?:\\,\\d+)?$)",
        "description": "This validation forces a value wheter to be strict niced or plain input of a numerical value.\nThe separation per thousand should be a (.) dot and must be used exactly or never to be valid.\nCurrently this RX validates german formed values... Just switch \\, with \\. and vice versa to get valid US results.",
        "matches": [
            "10000",
            "12.123",
            "5.123,000",
            ",001",
            "1.000.000",
            "1,00"
        ],
        "non_matches": [
            "1.0000",
            "12.12.00",
            "5,123.000",
            ".001",
            "1,000,000",
            "1.00"
        ]
    },
    {
        "id": 2103,
        "expression": "^[0-3]{1}[0-9]{1}[ ]{1}(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec){1}[ ]{1}[0-9]{2}$",
        "description": "This will test to see if a date is formatted in the military style of 'dd MMM yy'",
        "matches": [
            "12 DEC 08",
            "03 jan 91",
            "30 Mar 82"
        ],
        "non_matches": [
            "41 DEC 08",
            "03 jan 1991",
            "30 Mar '82"
        ]
    },
    {
        "id": 2113,
        "expression": "^([a-zA-Z1-9]*)\\.(((a|A)(s|S)(p|P)(x|X))|((h|H)(T|t)(m|M)(l|L))|((h|H)(t|T)(M|m))|((a|A)(s|S)(p|P)))",
        "description": "Validate HTM/HTML/ASP/ASPX\ne.g. PageName.html",
        "matches": [
            "pagename.html",
            "pagename.aspx",
            "pagename.asp",
            "pagename.htm"
        ],
        "non_matches": [
            "pagename.txt,"
        ]
    },
    {
        "id": 2114,
        "expression": "(((ht|f)tp(s?):\\/\\/)(www\\.[^ \\[\\]\\(\\)\\n\\r\\t]+)|(([012]?[0-9]{1,2}\\.){3}[012]?[0-9]{1,2})\\/)([^ \\[\\]\\(\\),;&quot;\\'&lt;&gt;\\n\\r\\t]+)([^\\. \\[\\]\\(\\),;&quot;\\'&lt;&gt;\\n\\r\\t])|(([012]?[0-9]{1,2}\\.){3}[012]?[0-9]{1,2})",
        "description": "Validate URL\ne.g.\nhttp://www.sample.com,\nhttp://61.61.67.123/test.html",
        "matches": [
            "http://www.sample.com",
            "http://61.61.67.123/test.html"
        ],
        "non_matches": [
            "yahoo.com",
            "www.yahoo.com",
            "http://yahoo.com"
        ]
    },
    {
        "id": 2115,
        "expression": "([a-zA-Z1-9]*)\\.(((a|A)(s|S)(p|P)(x|X))|((h|H)(T|t)(m|M)(l|L))|((h|H)(t|T)(M|m))|((a|A)(s|S)(p|P))|((t|T)(x|X)(T|x))|((m|M)(S|s)(P|p)(x|X))|((g|G)(i|I)(F|f))|((d|D)(o|O)(c|C)))",
        "description": "Validate Filename,PageName,ImageName etc\nsuch as\nfilename.doc\nfilename.xls\npagename.aspx\npagename.asp\npagename.htm\npagename.html\nExtensions\netc ...",
        "matches": [
            "filename.doc,pagename.aspx etc"
        ],
        "non_matches": [
            "page.jpg"
        ]
    },
    {
        "id": 2116,
        "expression": "^[-+]?(?:\\d+\\.?|\\.\\d)\\d*(?:[Ee][-+]?\\d+)?$",
        "description": "Validates that a string represents a javascript number (as defined by ECMAScript 3 Specs): integer (base-10) or floating\npoint including in the exponential notation. Doesn't match the empty string.",
        "matches": [
            "23",
            "-17.e23",
            "+.199E-19",
            "10.",
            "10e10"
        ],
        "non_matches": [
            "+.e2",
            "23.17.5",
            "10e2.0",
            "22e"
        ]
    },
    {
        "id": 2117,
        "expression": "(((s*)(ftp)(s*)|(http)(s*)|mailto|news|file|webcal):(\\S*))|((www.)(\\S*))",
        "description": "Matches all kind of URIs: mailto's, http(s), (s)ftp(s), ..., or just www addresses without protocol prefix.",
        "matches": [
            "ftp://domain.com",
            "sftp://subdomain.domain.com",
            "mailto:yourname@rommel.com",
            "www.domain.be"
        ],
        "non_matches": [
            "gopher://anything.com",
            "subdomain.domain.com",
            "http//somethingforgotten.com"
        ]
    },
    {
        "id": 2118,
        "expression": "\\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])(?:.\\d{7})?[+|-](0[0-9]|1[0-2]):(00|15|30|45)",
        "description": "Complete date-time format according to the ISO 8601 standard.",
        "matches": [
            "2004-10-31T22:06:00+12:00",
            "2006-04-31T12:31:39.6230000+05:45",
            "2009-01-08T20:25:26-03:00"
        ],
        "non_matches": [
            "2009-01-09T12:23:34",
            "2009-01-09 17:45:22",
            "2009-05-32T12:67:23-15:00",
            "2009-13-32T25:76:23"
        ]
    },
    {
        "id": 2123,
        "expression": "^([0-9a-f]{4}\\.[0-9a-f]{4}\\.[0-9a-f]{4})$",
        "description": "Matches against dumps of Cisco MAC address tables on newer versions of Cisco IOS.",
        "matches": [
            "001e.1324.683f",
            "1234.abcd.1234",
            "ffff.ffff.ffff"
        ],
        "non_matches": [
            "001E.1324.683f",
            "001234.abcd.abcd",
            "abcd.1234.abcd.1234",
            "aa-bb-cc-dd-ee-ff",
            "11:22:33:44:55:66"
        ]
    },
    {
        "id": 2128,
        "expression": "^([a-zA-Z0-9]+[._-])*[a-zA-Z0-9]+@(([a-zA-Z0-9]+|([a-zA-Z0-9]+[.-])+)[a-zA-Z0-9]+\\.[a-zA-Z]{2,4}|([a-zA-Z]\\.com))$",
        "description": "Validates format of email addresses including q.com but not q.net",
        "matches": [
            "a.b-c_d@x.y-z.zz"
        ],
        "non_matches": [
            "xx@mm.c",
            "x@n.cc",
            "a..b@x-y.zz"
        ]
    },
    {
        "id": 2130,
        "expression": "^[^\\*]{0,}[\\*]{0,1}[^\\*]{0,}$",
        "description": "An expression to validate a search string which accepts a wildcard(asterik) at most once anywhere in the string.",
        "matches": [
            "search*",
            "*search",
            "se*rch",
            "search",
            "*"
        ],
        "non_matches": [
            "search**",
            "**search",
            "**",
            "s**rch",
            "s*a*ch"
        ]
    },
    {
        "id": 2132,
        "expression": "\\+44\\s\\(0\\)\\s\\d{2}\\s\\d{4}\\s\\d{4}",
        "description": "Simple expression to validate a UK phone number including country code and area code. Requires spacing.",
        "matches": [
            "+44 (0) 55 4444 3333"
        ],
        "non_matches": [
            "+44 (0) 5555555555",
            "55 4444 3333"
        ]
    },
    {
        "id": 2133,
        "expression": "\\+353\\(0\\)\\s\\d\\s\\d{3}\\s\\d{4}",
        "description": "This simple expression evaluates an Ireland phone number. It requires the country code and dialing instructions for an international call plus spaces within the number.",
        "matches": [
            "+353(0) 5 444 3333"
        ],
        "non_matches": [
            "+353(0) 55555555",
            "5 444 3333"
        ]
    },
    {
        "id": 2136,
        "expression": "(?!^0*$)(?!^0*\\.0*$)^\\d{1,10}(\\.\\d{1,2})?$",
        "description": "To validate a number of 10 digits before the decimal point and atmost 2 digits after it",
        "matches": [
            "12314",
            "12314.2",
            "12314.32"
        ],
        "non_matches": [
            "12314.212",
            "12123.222"
        ]
    },
    {
        "id": 2137,
        "expression": "(?!^0*$)(?!^0*\\.0*$)^\\d{1,10}(\\.\\d{1,2})?$",
        "description": "To validate a number of 10 digits before the decimal point and atmost 2 digits after it",
        "matches": [
            "12314",
            "12314.2",
            "12314.32"
        ],
        "non_matches": [
            "12314.212",
            "12123.222"
        ]
    },
    {
        "id": 2138,
        "expression": "(?!^0*$)(?!^0*\\.0*$)^\\d{1,10}(\\.\\d{1,2})?$",
        "description": "To validate a number of 10 digits before the decimal point and atmost 2 digits after it",
        "matches": [
            "12314",
            "12314.2",
            "12314.32"
        ],
        "non_matches": [
            "12314.212",
            "12123.222"
        ]
    },
    {
        "id": 2139,
        "expression": "(?!^0*$)(?!^0*\\.0*$)^\\d{1,10}(\\.\\d{1,2})?$",
        "description": "To validate a number of 10 digits before the decimal point and atmost 2 digits after it",
        "matches": [
            "12314",
            "12314.2",
            "12314.32"
        ],
        "non_matches": [
            "12314.212",
            "12123.222"
        ]
    },
    {
        "id": 2140,
        "expression": "(?!^0*$)(?!^0*\\.0*$)^\\d{1,10}(\\.\\d{1,2})?$",
        "description": "To validate a number of 10 digits before the decimal point and atmost 2 digits after it",
        "matches": [
            "12314",
            "12314.2",
            "12314.32"
        ],
        "non_matches": [
            "12314.212",
            "12123.222"
        ]
    },
    {
        "id": 2143,
        "expression": "^\\d*[0-9](|.\\d*[0-9]|)*$",
        "description": "Decimal like 123.23\n123.1234\n12345.456",
        "matches": [
            "123.23",
            "123.1234",
            "1234",
            "1234.456"
        ],
        "non_matches": [
            "123a.12",
            "123.34d",
            "abc"
        ]
    },
    {
        "id": 2145,
        "expression": "^[a-zA-Z0-9]+(([_][a-zA-Z0-9])?[a-zA-Z0-9]*)*$",
        "description": "This Regular Expression. I have used with ASP.NET Regular expression for validating that input string should not have special characters(e.g. $,#,@ etc.]",
        "matches": [
            "Employee",
            "Employee_Test",
            "Employee_Dept"
        ],
        "non_matches": [
            "Employee.Test",
            "Employee$Test",
            "Employee@Test"
        ]
    },
    {
        "id": 2148,
        "expression": "^(0)44[\\s]{0,1}[\\-]{0,1}[\\s]{0,1}2[\\s]{0,1}[1-9]{1}[0-9]{6}$",
        "description": "This expression will help you to match chennai telephone numbers. chennai bsnl telephone numbers will start from 2.",
        "matches": [
            "044-26320244",
            "04426320244"
        ],
        "non_matches": [
            "044-12345678",
            "123-12345678"
        ]
    },
    {
        "id": 2149,
        "expression": "^(http\\://){1}(((www\\.){1}([a-zA-Z0-9\\-]*\\.){1,}){1}|([a-zA-Z0-9\\-]*\\.){1,10}){1}([a-zA-Z]{2,6}\\.){1}([a-zA-Z0-9\\-\\._\\?\\,\\'/\\\\\\+&amp;%\\$#\\=~])*",
        "description": "This checks to see if a URL has http:// in it, and if it has either www or a subdomain before the domain and tld. Without (http\\://) it only does the latter check. Replace http by (http|https|ftp) for other protocols. Still not happy about this: http://www.www.passshouldfail.com",
        "matches": [
            "http://www.pass.com http://sub.pass.com http://www.sub.pass.com http://sub.sub.pass.com http://www.sub.sub.pass.com"
        ],
        "non_matches": [
            "fail.com",
            "www.fail.com",
            "www.www.fail.com",
            "http://fail.com",
            "http://http://fail.com",
            "http://http://www.fail.com",
            "sub.fail.com",
            "www.sub.fail.com",
            "sub.sub.fail.com",
            "www.sub.sub.fail.com"
        ]
    },
    {
        "id": 2152,
        "expression": "^Content-Type:\\s*(\\w+)\\s*/?\\s*(\\w*)?\\s*;\\s*((\\w+)?\\s*=\\s*((\".+\")|(\\S+)))?",
        "description": "Matches the Content-Type for a MIME Mail Message and a Non-Mime Mail Message",
        "matches": [
            "Content-Type: multipart/mixed; boundary=\"---myboundary\"",
            "Content-Type: multipart/mixed;boundary=---myBoundarysi3cds",
            "Content-Type: text/plain;"
        ],
        "non_matches": [
            "Content Type: multipart/mixed",
            "Content-Type: text/plain",
            "Content-Type image/jpeg;"
        ]
    },
    {
        "id": 2153,
        "expression": "^((0[123456789]|1[0-2])(0[1-3]|1[0-9]|2[0-9]))|((0[13456789]|1[0-2])(30))|((0[13578]|1[02])(31))$",
        "description": "Evaluates a date in the format of MMDD. Will evaluate month day ranges accurately with Feb going up to 29.",
        "matches": [
            "0229",
            "0331",
            "0630",
            "0902"
        ],
        "non_matches": [
            "0230",
            "0431",
            "1245",
            "1299",
            "0011"
        ]
    },
    {
        "id": 2154,
        "expression": "^(([A-Z]{1}[a-z]+([\\-][A-Z]{1}[a-z]+)?)([ ]([A-Z]\\.)){0,2}[ ](([A-Z]{1}[a-z]*)|([O]{1}[\\']{1}[A-Z][a-z]{2,}))([ ](Jr\\.|Sr\\.|IV|III|II))?)$",
        "description": "Allows:\n1) first last\n2) first mi last\n3) first mi mi last\n4) first mi O'last\n5) first mi mi O'last\n6) first-first last\n7) first-first mi last\n8) first-first mi mi last\n9) first-first mi O'last\n10)first-first mi mi O'last",
        "matches": [
            "Ryan O'Malley",
            "Joseph R. Tanner Jr.",
            "Mary-Lou E. Jones",
            "George H. W. Bush"
        ],
        "non_matches": [
            "George Herbert Walker Bush",
            "George Walker Bush",
            "RYan O'Malley",
            "Joseph Tanner, Jr.",
            "Mary-lou E. Jones"
        ]
    },
    {
        "id": 2155,
        "expression": "//.*|/\\*[\\s\\S]*?\\*/",
        "description": "Matches single line or multi-line comments.",
        "matches": [
            "// Comment here",
            "/// Comment here",
            "/* Cmment Here */",
            "/**** Comment Here ****/"
        ],
        "non_matches": [
            "/ * Comment Here */",
            "/* Comment here * /"
        ]
    },
    {
        "id": 2157,
        "expression": "^(b|B)(f|F)(p|P)(o|O)(\\s*||\\s*C(/|)O\\s*)[0-9]{1,4}",
        "description": "Matches BFPO\nAllows for BFPO with no spacing",
        "matches": [
            "BFPO 2, BFPO 2222, BFPO C/O 121, BFPO2222"
        ],
        "non_matches": [
            "bf po 1212, BFPO 22222"
        ]
    },
    {
        "id": 2160,
        "expression": "(?=^[!@#$%\\^&*()_\\-+=\\[{\\]};:<>|\\./?a-zA-Z\\d]{7,}$)(?=([!@#$%\\^&*()_\\-+=\\[{\\]};:<>|\\./?a-zA-Z\\d]*\\W+){1,})[!@#$%\\^&*()_\\-+=\\[{\\]};:<>|\\./?a-zA-Z\\d]*$",
        "description": "Regex to validate strong password for .NET MembershipProvider ValidatePassword. Regex checks for minimum required password length and for minimum required non-alphanumeric characters. Change value '7' according to MinRequiredPasswordLength and '1' to MinRequiredNonAlphanumericCharacters.",
        "matches": [
            "12345!r@r",
            "#dfgjaydh%",
            "aA1!@#$%",
            "11111#aZ"
        ],
        "non_matches": [
            "12345rfg",
            "hsjahdgs",
            "12345"
        ]
    },
    {
        "id": 2161,
        "expression": "^(([0-1]?[0-9])|([2][0-3])):([0-5][0-9])$",
        "description": "Matches a string if it is a valid time in the format of HH:MM",
        "matches": [
            "02:04",
            "16:56",
            "23:59",
            "1:01"
        ],
        "non_matches": [
            "02:00 PM",
            "PM2:00",
            "24:00"
        ]
    },
    {
        "id": 2168,
        "expression": "^[0-9]{6}-[0-9pPtTfF][0-9]{3}$",
        "description": "Other Swedish personnummer regexps do not take into account that at Swedish universities, foreigners might get special temporary personnummers with a \"P\", \"T\", or \"F\" instead of the first of the four last numbers.\nThis code fixes the problem, but does not check the validity of the date, or the last number.",
        "matches": [
            "123456-1234",
            "123456-P234",
            "123456-f234"
        ],
        "non_matches": [
            "123456-12",
            "1234561234",
            "123456"
        ]
    },
    {
        "id": 2169,
        "expression": "^\\s*(([/-9!#-'*+=?A-~-]+(?:\\.[/-9!#-'*+=?A-~-]+)*|\"(?:[^\"\\r\\n\\\\]|\\\\.)*\")@([A-Za-z][0-9A-Za-z-]*[0-9A-Za-z]?(?:\\.[A-Za-z][0-9A-Za-z-]*[0-9A-Za-z]?)*|\\[(?:[^\\[\\]\\r\\n\\\\]|\\\\.)*\\]))\\s*$",
        "description": "This validates against the RFC 2821 (SMTP) syntax unit 'Mailbox' [equiv. to addr-spec - not address - element of RFC 2822] (the one a certain critic keeps linking to validates the RFC822 'address' element which includes support for stuff like \"Group:User <address>,User <address>;\", obsolete smtp routing syntax like <@host1,@host2:user@host>, etc)\nThere are some differences. This version does not allow line breaks for continuation lines. It also applies the stricter standards of RFC 2821 (SMTP) to the domain portion of the address.\nUsername may be a quoted string (but not \"multiple\".\"quoted\".\"strings\" - RFC 2822's grammar appears to allow this but the SMTP grammar does not). Also only one piece enclosed in [Brackets] (for IP email addresses) is allowed in the domain; that is you can't have user@[1.2.3.4].[5.6.7.8] as implied by the RFC2822 but not SMTP. Whitespace is only allowed in quoted strings. It is silently ignored at the beginning or end.\nCapture group 1 is the email address, group 2 is the username, group 3 is the domain.",
        "matches": [
            "user@example.com",
            "user+sub@example.com",
            "\"user name\"@example.com",
            "user@[192.0.2.4]"
        ],
        "non_matches": [
            "no_at_sign",
            "invalid...adjacent_dots@example.com",
            "no quote@example.com",
            "user@192.0.2.4"
        ]
    },
    {
        "id": 2187,
        "expression": "^((5[1-5])([0-9]{2})((-|\\s)?[0-9]{4}){3})$",
        "description": "Validates all Mastercard numbers starting with 51-55 with a total of 16 digits. Allows for spaces and -'s.",
        "matches": [
            "5144-0000-0000-0000",
            "5343 0000 0000 0000",
            "5400000000000000"
        ],
        "non_matches": [
            "5600....",
            "4100...."
        ]
    },
    {
        "id": 2188,
        "expression": "[_\\w-]+(?:\\.[_\\w-]+)*@(?:[\\w-]+\\.)+(?:[\\w-]{2,4})(?![\\w]+)",
        "description": "matches the most of the email addresses.",
        "matches": [
            "a.a@w3.org",
            "b@sohu.com",
            "s-s@33.cc"
        ],
        "non_matches": [
            "a@b",
            "a@b.commmm",
            "a.@b.cc",
            "a@.cc",
            "dd@g.netfooooooooo...ooo"
        ]
    },
    {
        "id": 2190,
        "expression": "^(\\d)?(\\d|,)*\\.?\\d{1,2}$",
        "description": "Validates Numeric values with commas and limited decimal places. Can change the value d{1,2} to limit decimal places from 1 to n",
        "matches": [
            "1,000",
            "1,200.45",
            "4,567,567.45",
            "2450.45"
        ],
        "non_matches": [
            "$1,000",
            "1,200.45343",
            "2.5.000"
        ]
    },
    {
        "id": 2191,
        "expression": "([a-zA-Z]{2}[0-9]{1,2}\\s{0,1}[0-9]{1,2}[a-zA-Z]{2})",
        "description": "This is a simple post code regex for UK. It does a wonderfull job.",
        "matches": [
            "GL50 4ED",
            "GL504ED",
            "gl504ed",
            "gl50 4ed",
            "GL5 4ED",
            "GL5 43ED"
        ],
        "non_matches": [
            "1323",
            "3ws23"
        ]
    },
    {
        "id": 2192,
        "expression": "^([a-zA-Z]:\\\\)?[^\\x00-\\x1F\"<>\\|:\\*\\?/]+\\.[a-zA-Z]{3,4}$",
        "description": "This matches a valid windows filename. Not a valid path.I wanted something simple that covered all the bases",
        "matches": [
            "file.txt",
            "fie.txt.pdf",
            "file(with parenthesis).pdf"
        ],
        "non_matches": [
            "*file.pdf",
            "file.tx"
        ]
    },
    {
        "id": 2193,
        "expression": "(?=^.{7,20}$)(?=.*\\d)(?=.*[a-zA-Z])(?!.*\\s)[0-9a-zA-Z*$-+?_&=!%{}/'.]*$",
        "description": "Password length must be between 7 and 20 characters, include at least one alphabetic and one numeric character, and may include some special characters.",
        "matches": [
            "test1234",
            "test$%9*",
            "Test$123"
        ],
        "non_matches": [
            "testing",
            "12345678",
            "!@#$%^&*"
        ]
    },
    {
        "id": 2201,
        "expression": "^[+]\\d{1,2}\\(\\d{2,3}\\)\\d{6,8}(\\#\\d{1,10})?$",
        "description": "Phone number with country prefix +2 or +22 (one or two digits), then City code in parenthesis, like (444)? then phone number 6 to 8 digits and optional extension '#XXX' up to 10 digits",
        "matches": [
            "+7(834)4328933#890",
            "+72(834)43289323#8902892",
            "+33(834)328932"
        ],
        "non_matches": [
            "+7(834)4328933#",
            "+7(834)4328#89908",
            "+723(834)4328#89908"
        ]
    },
    {
        "id": 2203,
        "expression": "^(\\+[0-9]{2,}[0-9]{4,}[0-9]*)(x?[0-9]{1,})?$",
        "description": "This comes from our requirement to have tight clean telephone database column. This expression supports only strict format and none others.It accepts any international country code with optional extension number.",
        "matches": [
            "+17034567890",
            "+17034567890x1234",
            "+912024553455",
            "+912024553455x12",
            "+441237761457"
        ],
        "non_matches": [
            "x1234",
            "+1",
            "+123",
            "+x1234",
            "+12x12",
            "+1(703)4563245x1234"
        ]
    },
    {
        "id": 2206,
        "expression": "^([0][1-9]|[1][0-2]):[0-5][0-9] {1}(AM|PM|am|pm)$",
        "description": "Matches if the string is in hh:mm am/pm format. Also the hour and minute values should have left padding 0's if they are single digit.",
        "matches": [
            "03:45 am",
            "10:24 PM",
            "01:03 pm"
        ],
        "non_matches": [
            "8:15 am",
            "16:10",
            "10:60 pm",
            "10:13"
        ]
    },
    {
        "id": 2213,
        "expression": "[\\(]{1,}[^)]*[)]{1,}",
        "description": "Will find any texts within a string that is enclosed within parenthesis ( )",
        "matches": [
            "Test (test 1)",
            "(test)",
            "Test (test 1) Test (test 2)"
        ],
        "non_matches": [
            "Test"
        ]
    },
    {
        "id": 2215,
        "expression": "^/{1}(((/{1}\\.{1})?[a-zA-Z0-9 ]+/?)+(\\.{1}[a-zA-Z0-9]{2,4})?)$",
        "description": "This expressions was written for C#. Matches all valid Linux absolute paths (files or folders). Will not work for relative paths that do not begin with a /, Also will only match files that have extensions consisting of 2, 3, or 4 characters. Currently fails with _ . or - in the path, this will be updated at some point.",
        "matches": [
            "/mnt/share/",
            "/home/.BASH",
            "/mnt/share/pic.jpeg",
            "/mnt/share/install.sh"
        ],
        "non_matches": [
            "mnt/share",
            "//mnt///share//",
            "/mnt/share/install.installer",
            "/home\\user"
        ]
    },
    {
        "id": 2218,
        "expression": "^([0-9]{2})(01|02|03|04|05|06|07|08|09|10|11|12|51|52|53|54|55|56|57|58|59|60|61|62)(([0]{1}[1-9]{1})|([1-2]{1}[0-9]{1})|([3]{1}[0-1]{1}))/([0-9]{3,4})$",
        "description": "Law 301/1995 z. Z. SR from 14. december 1995. PIN from 1900 to 1953 have sufix with three digits, PIN beyond 1954 have four digits in sufix. In first part of woman PIN is month of birth (3rd & 4th digit) increase +50.",
        "matches": [
            "760612/5689",
            "826020/5568",
            "500101/256"
        ],
        "non_matches": [
            "680645/256",
            "707212/1258",
            "260015/4598"
        ]
    },
    {
        "id": 2222,
        "expression": "^(((([\\*]{1}){1})|((\\*\\/){0,1}(([0-9]{1}){1}|(([1-5]{1}){1}([0-9]{1}){1}){1}))) ((([\\*]{1}){1})|((\\*\\/){0,1}(([0-9]{1}){1}|(([1]{1}){1}([0-9]{1}){1}){1}|([2]{1}){1}([0-3]{1}){1}))) ((([\\*]{1}){1})|((\\*\\/){0,1}(([1-9]{1}){1}|(([1-2]{1}){1}([0-9]{1}){1}){1}|([3]{1}){1}([0-1]{1}){1}))) ((([\\*]{1}){1})|((\\*\\/){0,1}(([1-9]{1}){1}|(([1-2]{1}){1}([0-9]{1}){1}){1}|([3]{1}){1}([0-1]{1}){1}))|(jan|feb|mar|apr|may|jun|jul|aug|sep|okt|nov|dec)) ((([\\*]{1}){1})|((\\*\\/){0,1}(([0-7]{1}){1}))|(sun|mon|tue|wed|thu|fri|sat)))$",
        "description": "SUPPORTED constructions:\n[*] - all five commands;\n[number] - minutes 0...59, hours 0...23, day in month 1...31, months 1...12, day in week 0...7 (0 & 7 is sun);\n[*/nubmer] - see construction [number];\n[word] - only months (4th command) and days in week (5th command), warning this regexp is case sensitive (lower letters).\nNON SUPPORTED constructions:\n[number-number] and\n[number,number].",
        "matches": [
            "*/15 */12 30 feb 7",
            "10 * * * */2",
            "* * * * *"
        ],
        "non_matches": [
            "62 * * */2 *",
            "* * * 0 *",
            "* * * Feb *"
        ]
    },
    {
        "id": 2223,
        "expression": "^(B(A|B|C|J|L|N|R|S|Y)|CA|D(K|S|T)|G(A|L)|H(C|E)|IL|K(A|I|E|K|M|N|S)|L(E|C|M|V)|M(A|I|L|T|Y)|N(I|O|M|R|Z)|P(B|D|E|O|K|N|P|T|U|V)|R(A|K|S|V)|S(A|B|C|E|I|K|L|O|N|P|V)|T(A|C|N|O|R|S|T|V)|V(K|T)|Z(A|C|H|I|M|V))([ ]{0,1})([0-9]{3})([A-Z]{2})$",
        "description": "Case sensitive (upper)!",
        "matches": [
            "BB123AB",
            "KE 999BB"
        ],
        "non_matches": [
            "QT 123AB",
            "BB 1234AA",
            "BB001ABC"
        ]
    },
    {
        "id": 2224,
        "expression": "^([a-hA-H]{1}[1-8]{1})$",
        "description": "Letter (a - h) + number (1 - 8). Case insensitive.",
        "matches": [
            "A1",
            "a8",
            "b3"
        ],
        "non_matches": [
            "i5",
            "F9",
            "AA"
        ]
    },
    {
        "id": 2226,
        "expression": "<title>(.*?)</title>",
        "description": "This regular expression can be used to extract titles from web page",
        "matches": [
            "<title>Regular Expression Library</title>"
        ],
        "non_matches": [
            "<td>Regular Expression Library</td>"
        ]
    },
    {
        "id": 2241,
        "expression": "^([1-9]{1}|[1-9]{1}[0-9]{1,3}|[1-5]{1}[0-9]{4}|6[0-4]{1}[0-9]{3}|65[0-4]{1}[0-9]{2}|655[0-2]{1}[0-9]{1}|6553[0-6]{1})$",
        "description": "Communication ports in PC between 1 - 65536.",
        "matches": [
            "1",
            "80",
            "65536"
        ],
        "non_matches": [
            "0",
            "0999",
            "65537"
        ]
    },
    {
        "id": 2246,
        "expression": "^(0|(([1-9]{1}|[1-9]{1}[0-9]{1}|[1-9]{1}[0-9]{2}){1}(\\ [0-9]{3}){0,})),(([0-9]{2})|\\-\\-)([\\ ]{1})(\u20ac|EUR|EURO){1}$",
        "description": "Supported symbols are \u20ac or EUR or EURO (all case sensitive).",
        "matches": [
            "0,00 \u20ac",
            "1 234 567,89 EUR",
            "1,-- EURO"
        ],
        "non_matches": [
            "00,00 \u20ac",
            "1234567,89 EUR",
            "0 555,55 EURO",
            "2,2 EUR",
            "2,- EUR"
        ]
    },
    {
        "id": 2247,
        "expression": "^(big5|euc(kr|jpms)|binary|greek|tis620|hebrew|ascii|swe7|koi8(r|u)|(u|keyb)cs2|(dec|hp|utf|geostd|armscii)8|gb(k|2312)|cp(8(5(0|2)|66)|932|125(0|1|6|7))|latin(1|2|5|7)|(u|s)jis|mac(ce|roman))$",
        "description": "supported all charsets in MySQL 5.1, case sensitive (lower)",
        "matches": [
            "utf8",
            "cp1251",
            "latin7"
        ],
        "non_matches": [
            "utf-8",
            "utf16",
            "cp1252",
            "LATIN1",
            "cp 850"
        ]
    },
    {
        "id": 2250,
        "expression": "function[\\s]+[\\S]+[\\s]*([\\s]*)[\\s]*{[\\s]*([\\S]|[\\s])*[\\s]*}",
        "description": "detect javascript function in HTML",
        "matches": [
            "function displaymessage() { alert(\"Hello World!\"); }",
            "function Load_dvCont7() { loadBreaking('/Services/IncludePart/LevelOne/?T=7&Id=2007731105943979989&P=', '_dvCont7' , '1'); }"
        ],
        "non_matches": [
            "any other HTML tag"
        ]
    },
    {
        "id": 2259,
        "expression": "^(0?[1-9]|1[0-2])\\/(0?[1-9]|[1-2][0-9]|3[0-1])\\/(0[1-9]|[1-9][0-9]|175[3-9]|17[6-9][0-9]|1[8-9][0-9]{2}|[2-9][0-9]{3})$",
        "description": "Matches all dates (mm/dd/yyyy or mm/dd/yy) greater than or equal to the SQL minimum date of 01/01/1753 and less than or equal to 12/31/9999. Does not check for leap years.",
        "matches": [
            "01/01/1753",
            "9/2/09",
            "12/02/1980",
            "12/31/9999"
        ],
        "non_matches": [
            "1/1/1",
            "13/1/01",
            "01/0/2001",
            "12/31/1752",
            "1-1-1900"
        ]
    },
    {
        "id": 2262,
        "expression": "^\\d{1,3}((\\.\\d{1,3}){3}|(\\.\\d{1,3}){5})$",
        "description": "validate both IP V4 and IP V6",
        "matches": [
            "192.168.0.1",
            "000.000.000.000.000.000",
            "999.999.999.999.999.999"
        ],
        "non_matches": [
            "1.1.1.1.1",
            "1.1",
            "a.b.c.d.e.f.g"
        ]
    },
    {
        "id": 2263,
        "expression": "<(.|\\n)*?>",
        "description": "This regex will remove the HTML tags with content",
        "matches": [
            "<BR> </a>"
        ],
        "non_matches": [
            "any text without tag"
        ]
    },
    {
        "id": 2264,
        "expression": "^(((0|128|192|224|240|248|252|254).0.0.0)|(255.(0|128|192|224|240|248|252|254).0.0)|(255.255.(0|128|192|224|240|248|252|254).0)|(255.255.255.(0|128|192|224|240|248|252|254)))$",
        "description": "netmask address. I know this is nod good enough :)",
        "matches": [
            "255.255.192.0",
            "240.0.0.0",
            "255.255.255.0"
        ],
        "non_matches": [
            "255.0.192.0",
            "240.128.0.0",
            "240.255.255.0"
        ]
    },
    {
        "id": 2265,
        "expression": "^((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[0-9]{1,2})\\.){3}(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[0-9]{1,2})(/([0-9]|[0-2][0-9]|3[0-2]))$",
        "description": "ip address/netmask couple",
        "matches": [
            "192.168.0.5/24",
            "255.255.0.0/32"
        ],
        "non_matches": [
            "192.256.0.5/24",
            "255.255.0.0/40"
        ]
    },
    {
        "id": 2266,
        "expression": "\\b([A-Za-z]+) +(\\1\\b)",
        "description": "\"one one\" can be replaced with \"one\". This RE will help you in removing the duplicated successor with single word or character. The replacement string will be $1",
        "matches": [
            "one one, two two, you you, work work, I I"
        ],
        "non_matches": [
            "normal sentence"
        ]
    },
    {
        "id": 2267,
        "expression": "^[a-zA-Z][a-zA-Z0-9_\\.\\-]+@([a-zA-Z0-9-]{2,}\\.)+([a-zA-Z]{2,4}|[a-zA-Z]{2}\\.[a-zA-Z]{2})$",
        "description": "This will validate most legal e-mail adresses with the correct syntax.",
        "matches": [
            "name@website.com",
            "first_second@website.co.uk",
            "blah.blah.007@website.se"
        ],
        "non_matches": [
            "0name@website.com",
            "name&@website.net",
            "blahblah@website"
        ]
    },
    {
        "id": 2273,
        "expression": "\\b(((0[13578]|1[02])[\\/\\.-]?(0[1-9]|[12]\\d|3[01])[\\/\\.-]?(19|20)?(\\d{2}))|(0[13456789]|1[012])[\\/\\.-]?(0[1-9]|[12]\\d|30)[\\/\\.-]?(19|20)?(\\d{2}))|(02[\\/\\.-]?(0[1-9]|1\\d|2[0-8])[\\/\\.-]?(19|20)?(\\d{2}))|(02[\\/\\.-]?29[\\/\\.-]?(19|20)?((0[48]|[2468][048]|[13579][26])|(00)))\\b",
        "description": "I needed to have a way where users could type in any date format like the following: mm/dd/yyyy, mm/dd/yy, mmddyy, mmddyyyy with the ability to use \"/\" and \".\" and \"-\" or nothing as separation characters. I use this in a RegularExpression Validator control in ASP.NET",
        "matches": [
            "032103",
            "02/29/2008",
            "10.31.1990",
            "010102"
        ],
        "non_matches": [
            "2-29-00",
            "11.31.1992",
            "063178",
            "02/29/2005"
        ]
    },
    {
        "id": 2277,
        "expression": "@([_a-zA-Z]+)",
        "description": "Can be used to find SQL Server parmeters in a SQL string. Does not attempt to weed-out \"@\" characters in embedded string values.",
        "matches": [
            "SELECT COUNT(pk) FROM Employees WHERE TypeID = @Type"
        ],
        "non_matches": [
            "SELECT COUNT(pk) FROM Employees WHERE TypeID = 1"
        ]
    },
    {
        "id": 2278,
        "expression": "(\\d{2}|\\d{4})(?:\\-)?([0]{1}\\d{1}|[1]{1}[0-2]{1})(?:\\-)?([0-2]{1}\\d{1}|[3]{1}[0-1]{1})(?:\\s)?([0-1]{1}\\d{1}|[2]{1}[0-3]{1})(?::)?([0-5]{1}\\d{1})(?::)?([0-5]{1}\\d{1})",
        "description": "Will match a date accepted by MySQL datetime type.\nYears with 2 or 4 digits from any range.\nMonths with 2 digits from 00 to 12.\ndays with 2 digits from 00 to 31.\nHours with 2 digits from 00-23\nMinutes with 2 digits from 00 to 59.\nSeconds with 2 digits from 00 to 59.",
        "matches": [
            "00-00-00 00:00:00",
            "0000-00-00 00:00:00",
            "09-05-22 08:16:00",
            "1970-00-00 00:00:00",
            "20090522081600"
        ],
        "non_matches": [
            "2009-13:01 00:00:00",
            "2009-12-32 00:00:00",
            "2002-12-31 24:00:00",
            "2002-12-31 23:60:00",
            "02-12-31 23:00:60"
        ]
    },
    {
        "id": 2279,
        "expression": "^(0|[-]{1}([1-9]{1}[0-9]{0,1}|[1]{1}([0-1]{1}[0-9]{1}|[2]{1}[0-8]{1}))|(\\+)?([1-9]{1}[0-9]{0,1}|[1]{1}([0-1]{1}[0-9]{1}|[2]{1}[0-7]{1})))$",
        "description": "Not just a number, a byte type. Will match any number from range -128 to 127.",
        "matches": [
            "-128",
            "127",
            "0",
            "1",
            "-10"
        ],
        "non_matches": [
            "-129",
            "128",
            "-0",
            "+0"
        ]
    },
    {
        "id": 2281,
        "expression": "^(0|[-]{1}([1-9]{1}[0-9]{0,3}|[1-2]{1}[0-9]{1,4}|[3]{1}([0-1]{1}[0-9]{3}|[2]{1}([0-6]{1}[0-9]{2}|[7]{1}([0-5]{1}[0-9]{1}|([6]{1}[0-8]{1})))))|(\\+)?([1-9]{1}[0-9]{0,3}|[1-2]{1}[0-9]{1,4}|[3]{1}([0-1]{1}[0-9]{3}|[2]{1}([0-6]{1}[0-9]{2}|[7]{1}([0-5]{1}[0-9]{1}|([6]{1}[0-7]{1}))))))$",
        "description": "Short type, will match a short number from range -32768 to 32767.",
        "matches": [
            "-32768",
            "-10",
            "0",
            "10",
            "32767"
        ],
        "non_matches": [
            "+0",
            "-0",
            "-32769",
            "32768"
        ]
    },
    {
        "id": 2282,
        "expression": "^(0|(\\+)?([1-9]{1}[0-9]{0,3})|([1-5]{1}[0-9]{1,4}|[6]{1}([0-4]{1}[0-9]{3}|[5]{1}([0-4]{1}[0-9]{2}|[5]{1}([0-2]{1}[0-9]{1}|[3]{1}[0-5]{1})))))$",
        "description": "Will match an unsigned short number from range 0 to 65535",
        "matches": [
            "0",
            "100",
            "65535"
        ],
        "non_matches": [
            "-0",
            "+0",
            "-10",
            "65536"
        ]
    },
    {
        "id": 2284,
        "expression": "^(0|(\\+)?[1-9]{1}[0-9]{0,8}|(\\+)?[1-3]{1}[0-9]{1,9}|(\\+)?[4]{1}([0-1]{1}[0-9]{8}|[2]{1}([0-8]{1}[0-9]{7}|[9]{1}([0-3]{1}[0-9]{6}|[4]{1}([0-8]{1}[0-9]{5}|[9]{1}([0-5]{1}[0-9]{4}|[6]{1}([0-6]{1}[0-9]{3}|[7]{1}([0-1]{1}[0-9]{2}|[2]{1}([0-8]{1}[0-9]{1}|[9]{1}[0-5]{1})))))))))$",
        "description": "Will match any unsigned integer from range 0 to 4294967295",
        "matches": [
            "0",
            "1000",
            "4294967295"
        ],
        "non_matches": [
            "-100",
            "-0",
            "+0",
            "4294967296"
        ]
    },
    {
        "id": 2293,
        "expression": "^(?=.*[\\d])(?=.*[A-Z])(?=.*[a-z])[\\w\\d!@#$%_]{6,40}$",
        "description": "Password must be 6-40 characters - {6,40}\nMust have no spaces, at least 1 digit (?=.*[\\d]), at least 1 uppercase letter (?=.*[A-Z]) and at least one lowercase letter (?=.*[a-z]).\nAllows specifying special characters - !@#$%_",
        "matches": [
            "Pa5$Word",
            "HORS3y",
            "Th1$IsMyR3allYl0ngPa$$"
        ],
        "non_matches": [
            "PASSWORD",
            "password",
            "Password",
            "1234567"
        ]
    },
    {
        "id": 2294,
        "expression": "^([0-1][0-9]|[2][0-3]|[0-9]):([0-5][0-9])(?::([0-5][0-9]))?$",
        "description": "Validate hours with seconds returning mirrors correctly.",
        "matches": [
            "09:05",
            "10:00",
            "1:15",
            "00:59:00",
            "23:01:59"
        ],
        "non_matches": [
            "9:5",
            "09:1",
            "0:1",
            "0:00:0",
            "1:1:11"
        ]
    },
    {
        "id": 2295,
        "expression": "^([0-2]\\d|3[0-1]|[1-9])\\/(0\\d|1[0-2]|[1-9])\\/(\\d{4})$",
        "description": "Validate a date format: d/m/Y.\nSee examples.",
        "matches": [
            "1/05/1990",
            "01/1/2006",
            "01/01/2008",
            "5/5/2009",
            "1/1/1990",
            "29/05/2009"
        ],
        "non_matches": [
            "01/01/90",
            "32/02/2009",
            "1/13/1990",
            "0/0/2009"
        ]
    },
    {
        "id": 2296,
        "expression": "^([0-1][0-9]|2[0-3]){1}:([0-5][0-9]){1}:([0-5][0-9]){1},([0-9][0-9][0-9]){1} --> ([0-1][0-9]|2[0-3]){1}:([0-5][0-9]){1}:([0-5][0-9]){1},([0-9][0-9][0-9]){1}(.*)$",
        "description": "e. g. HH:MM:SS:ttt --> HH:MM:SS:ttt;\n$1 is start hour;\n$2 is start minute;\n$3 is start second;\n$4 is start s/1000;\n$5 is stop hour;\n$6 is stop minute;\n$7 is stop second;\n$8 is stop s/1000;",
        "matches": [
            "00:12:35,126 --> 00:12:35,526"
        ],
        "non_matches": [
            "00:59:35,126 --> 00:60:20,500",
            "00:16:20,200 --> 00:16:20,30",
            "01:01:01.000 --> 01:01:01.900"
        ]
    },
    {
        "id": 2297,
        "expression": "^\\{([1-9]{1}|[1-9]{1}[0-9]{1,}){1}\\}\\{([1-9]{1}|[1-9]{1}[0-9]{1,}){1}\\}(.*)$",
        "description": "e. g. {11510}{11810}Blah, blah, blah.;\n$1 is start;\n$2 is stop;",
        "matches": [
            "{100}{150}subtitle",
            "{1234}{1234}subtitle",
            "{1}{2}subtitle"
        ],
        "non_matches": [
            "{0100}{1000}subtitle",
            "{}{100}subtitle",
            "{500}{}subtitle"
        ]
    },
    {
        "id": 2298,
        "expression": "\"([^\\\\\"]|\\\\.)*\"",
        "description": "to get the text betwen double quotes",
        "matches": [
            "\"Ram\", \"Ram Shyam\""
        ],
        "non_matches": [
            "ram , shyam"
        ]
    },
    {
        "id": 2301,
        "expression": "^(\\$?)((\\d{1,20})|(\\d{1,2}((,?\\d{3}){0,6}))|(\\d{3}((,?\\d{3}){0,5})))$",
        "description": "This expression will allow whole dollar amounts (along with $ and ,) which are 20 digit wide. So the maximum amount will be $99,999,999,999,999,999,999. Note: This regular expression allows skipped commas, but will not allow multiple or commas at the wrong location. This can be used for all languages that have comma before the 3rd, 6th, 9th... digit.",
        "matches": [
            "$99,999,999,999,999,999,999",
            "$56,987",
            "56,123456,456"
        ],
        "non_matches": [
            "$77,8,888",
            "asadf",
            "67.98"
        ]
    },
    {
        "id": 2303,
        "expression": "^([a-zA-Z])(?=.*\\d)\\w{4,9}$",
        "description": "Check Password: 5 - 10 characters long, start with a letter and contain at least one number. No special characters",
        "matches": [
            "a2345",
            "abcd1",
            "abc123"
        ],
        "non_matches": [
            "1abc",
            "1abcd",
            "a2345678910"
        ]
    },
    {
        "id": 2304,
        "expression": "^\\w*[-]*\\w*\\\\\\w*$",
        "description": "It Accepts hyphen in the domain name",
        "matches": [
            "scandent-blr\\abc"
        ],
        "non_matches": [
            "abc"
        ]
    },
    {
        "id": 2306,
        "expression": "^http\\://www.[a-zA-Z0-9\\-\\.]+\\.[a-zA-Z]{2,3}/$",
        "description": "This regex only matches clean domain names. No path after. Ends in a forward slash. Starts with http://www. It is pretty slack on the TLD requiring a 2 or 3 letter ending. This part could be tightened up if you wanted to be restrict it to specific TLDs.",
        "matches": [
            "http://www.somedomain.co.uk/",
            "http://www.somedomain.com/",
            "http://www.dodgydomain.com.com/"
        ],
        "non_matches": [
            "http://www.somedomain.co.uk/withpath.aspx",
            "http://somedomainwithoutwww.co.uk",
            "http://www.com/",
            "www.noprotocolprefix.com/",
            "https://www.secureprotocolprefix.com/",
            "http://www.notrailingslash.co.uk",
            "HTTP://WWW.beginswithcaps.com/"
        ]
    },
    {
        "id": 2307,
        "expression": "\\.([A-Za-z0-9]{2,5}($|\\b\\?))",
        "description": "Pattern matches all file extensions from two(2) to five(5) characters in length (e.g. Adobe Illustrator [*.ai] or Extensible Hypertext Markup Language [*.xhtml]). Input can be an absolute path, relative path, URI, directory path, etc. If there are get variables in a URI input, they are ignored.",
        "matches": [
            "http://regexlib.com/Add.aspx",
            "/path/to/filename.txt",
            "TheSpanishInquisition.mpeg",
            "42.ai",
            "Dont Panic.xhtml",
            "http://localhost/webPage/index.php?variable=value"
        ],
        "non_matches": [
            "Non-extentionFileName",
            "FilenameWithOneCharacterExtension.q",
            "FIlenameWithSixOrMoreCharactersExtension.invalid"
        ]
    },
    {
        "id": 2316,
        "expression": "^[+-]?[0-9]+$",
        "description": "Single- or multi-digit signed Integer.",
        "matches": [
            "12",
            "-2",
            "+3213"
        ],
        "non_matches": [
            "abc",
            "@41",
            "43.12"
        ]
    },
    {
        "id": 2317,
        "expression": "^[+-]?\\d*(([,.]\\d{3})+)?([,.]\\d+)?([eE][+-]?\\d+)?$",
        "description": "Matches any integer or decimal number with either dot (.) or comma (,) as decimal- and thousands-separator. Also accepts Scientific notation.",
        "matches": [
            "-4,233.2832e12",
            "+232",
            "-0.12e-5"
        ],
        "non_matches": [
            "abc",
            "@41",
            "0x423"
        ]
    },
    {
        "id": 2318,
        "expression": "^(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9]{1,2})(\\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9]{1,2})){3}$",
        "description": "This matches any valid IPV4 IP Address. It includes 0-255 range checks since none of the IP components may exceed 255.",
        "matches": [
            "97.67.44.20",
            "199.154.37.214",
            "127.0.0.1"
        ],
        "non_matches": [
            "63.125.94.287",
            "140.370.a.187",
            "94.923.1"
        ]
    },
    {
        "id": 2320,
        "expression": "^.*([^\\.][\\.](([gG][iI][fF])|([Jj][pP][Gg])|([Jj][pP][Ee][Gg])|([Bb][mM][pP])|([Pp][nN][Gg])))",
        "description": "By using this we can upload only images files. This is the simplest and its execution is fast.",
        "matches": [
            "D:\\Documents and Settings\\Administrator\\Desktop\\New Folder\\60101-prep.png"
        ],
        "non_matches": [
            "D:\\Documents and Settings\\Administrator\\Desktop\\New Folder\\60101-prep.pdf"
        ]
    },
    {
        "id": 2322,
        "expression": "^#?(([a-fA-F0-9]{3}){1,2})$",
        "description": "Matches any valid 3 or 6 digit hexadecimal colour value.",
        "matches": [
            "#ff9900",
            "#abc",
            "#92fea5"
        ],
        "non_matches": [
            "ab",
            "#92a2",
            "32z"
        ]
    },
    {
        "id": 2333,
        "expression": "(\"((\\\\.)|[^\\\\\"])*\")",
        "description": "match string between chars \" \" as in source code",
        "matches": [
            "\"\"",
            "\"\\n\"",
            "\"test\"",
            "\"test 1 \\\"test 2 \\\" test 3\""
        ],
        "non_matches": [
            "test",
            "\"test",
            "\"test\\\""
        ]
    },
    {
        "id": 2334,
        "expression": "('((\\\\.)|[^\\\\'])*')",
        "description": "match string between chars ' ' as in source code",
        "matches": [
            "''",
            "'\\n'",
            "'test'",
            "'test 1 \\'test 2 \\' test 3'"
        ],
        "non_matches": [
            "test",
            "'test",
            "'test\\'"
        ]
    },
    {
        "id": 2335,
        "expression": "[0-9]{1,2}[:|\u00b0][0-9]{1,2}[:|'](?:\\b[0-9]+(?:\\.[0-9]*)?|\\.[0-9]+\\b)\"?[N|S|E|W]",
        "description": "Matches common Degree, Minute, Second coordinate values. The last part can be easily modified to be latitude or longitude specific by changing\n[N|S|E|W] to [N|S] for latitude or [E|W] for longitude.",
        "matches": [
            "12:12:12.223546\"N",
            "12:12:12.2246N",
            "15:17:6\"S",
            "12\u00b030'23.256547\"S"
        ],
        "non_matches": [
            "12.2225",
            "15.25.257S",
            "AA:BB:CC.DDS"
        ]
    },
    {
        "id": 2339,
        "expression": "^(\\d){8}$",
        "description": "UK Bank account numbers are 8 digits. One bank uses 7 digits so in the validation error message you should instruct the user to prefix with a zero of their code is too short. If you want to allow the 7 digit codes as well use this regex: http://regexlib.com/REDetails.aspx?regexp_id=2707",
        "matches": [
            "08464524",
            "45832484",
            "24899544"
        ],
        "non_matches": [
            "1234567",
            "1 5 2226 44",
            "123456789"
        ]
    },
    {
        "id": 2340,
        "expression": "^(\\d){7,8}$",
        "description": "UK Bank Account. One bank account issues 7 digit bank codes and you should prefix a 0 yourself after input. If you want strict validation of 8 characters use this regex: http://regexlib.com/REDetails.aspx?regexp_id=2706",
        "matches": [
            "1234567",
            "12345678"
        ],
        "non_matches": [
            "123456",
            "123 4567",
            "123456789"
        ]
    },
    {
        "id": 2341,
        "expression": "^[^\\s]+$",
        "description": "No whitespace is allowed in a string",
        "matches": [
            "nowhitespace",
            "onewordonly",
            "anotherexample"
        ],
        "non_matches": [
            "two words",
            "three words here",
            "anything with spaces"
        ]
    },
    {
        "id": 2342,
        "expression": "\".*?[^\"\\\\]\"(?!\")|\"\"",
        "description": "match the csharp string Syntax",
        "matches": [
            "\"C#\"",
            "\"My Club Site tag\"\",\"\"line or slogan\""
        ],
        "non_matches": [
            "C#\""
        ]
    },
    {
        "id": 2345,
        "expression": "(((((0[1-9]|[12][0-9]|3[01])/(0[13578]|1[02]))|((0[1-9]|[12][0-9]|30)/(0[469]|11))|((0[1-9]|[1][0-9]|2[0-8]))/02)/([0-9]{3}[1-9]|[0-9]{2}[1-9][0-9]{1}|[0-9]{1}[1-9][0-9]{2}|[1-9][0-9]{3}) ((([0-1][0-9])|([2][0-3]))[:][0-5][0-9]$))|(29/02/(([0-9]{2})(0[48]|[2468][048]|[13579][26])|((0[48]|[2468][048]|[3579][26])00)) ((([0-1][0-9])|([2][0-3]))[:][0-5][0-9]$)))",
        "description": "this expression validates a date-time field in European dd/mm/yyyy hh:mm format",
        "matches": [
            "29/02/2008 15:30"
        ],
        "non_matches": [
            "29/02/2009 25:62"
        ]
    },
    {
        "id": 2348,
        "expression": "^((.)(?!\\2{2,}))+$",
        "description": "This pattern matches strings where no more than two equal characters may come in succession.\nTo modify the amount of characters allowed, change the second number (the two inside \"{2,}\")to the desired limit.",
        "matches": [
            "Abba",
            "p4ssw0rd",
            "Whatever"
        ],
        "non_matches": [
            "Abbba",
            "p4sssw0rd",
            "Whateverrr"
        ]
    },
    {
        "id": 2352,
        "expression": "^[\\w_.]{5,12}$",
        "description": "validate usernames with dot or underscoures doesn't allow spaces and accept characters between 5 and 15 no other characters",
        "matches": [
            "Ahmad.egypt",
            "ahmad_egypt"
        ],
        "non_matches": [
            "Ahmad@egypt",
            "Ahmad*egypt"
        ]
    },
    {
        "id": 2353,
        "expression": "^([^\\s]){5,12}$",
        "description": "validate text against spaces and accept from 5 to 12 character",
        "matches": [
            "ahmed",
            "Muhammad",
            "Hassan"
        ],
        "non_matches": [
            "a hmed",
            "Hass an"
        ]
    },
    {
        "id": 2355,
        "expression": "^((\\+)?(\\d{2}[-])?(\\d{10}){1})?(\\d{11}){0,1}?$",
        "description": "India phone number, accept with optional +91 national code and 0 for land and mobile number prefix . Allows optional - after national code",
        "matches": [
            "+91-9764544544",
            "09764544544",
            "01087656444",
            "+91-1087656444"
        ],
        "non_matches": [
            "+91-01087656444",
            "+91-09764544544",
            "+9178786765652"
        ]
    },
    {
        "id": 2360,
        "expression": "^(([0-9]{1})|([0-9]{1}[0-9]{1})|([1-3]{1}[0-6]{1}[0-5]{1}))d(([0-9]{1})|(1[0-9]{1})|([1-2]{1}[0-3]{1}))h(([0-9]{1})|([1-5]{1}[0-9]{1}))m$",
        "description": "Duration validation similar to MS Project (5d16h45m, etc). Does not allow more than 365 days, 23 hrs or 59 min.",
        "matches": [
            "365d23h59m",
            "90d18h45m",
            "05d19h45m"
        ],
        "non_matches": [
            "366d23h45m",
            "90d24h5m",
            "90d6h60m"
        ]
    },
    {
        "id": 2370,
        "expression": "^(0?[1-9]|1[012])/([012][0-9]|[1-9]|3[01])/([12][0-9]{3})$",
        "description": "In month/day/year format. Matches valid months (1-12) and valid days (1-31) and a valid 4 digit year (from 1000-2999). $1 = month, $2 = day, $3 = year. Sadly, it doesn't check to make sure that months have a valid number of days (no Feb 30th checks, etc).",
        "matches": [
            "1/12/2003",
            "04/8/1995",
            "12/31/2035",
            "5/06/1911"
        ],
        "non_matches": [
            "13/04/2000",
            "4/32/1593",
            "",
            "5/6/98"
        ]
    },
    {
        "id": 2373,
        "expression": "^\\<(\\w){1,}\\>(.){0,}([\\</]|[\\<])(\\w){1,}\\>$",
        "description": "validates HTML tags",
        "matches": [
            "<br><b>fsd</b><br>"
        ],
        "non_matches": [
            "<br><<<<>br>"
        ]
    },
    {
        "id": 2376,
        "expression": "^(([0]?[1-9])|(1[0-2]))\\/(([0]?[1-9])|([1,2]\\d{1})|([3][0,1]))\\/[12]\\d{3}$",
        "description": "This regular expression matches the format MM/DD/YYYY. Month and Day can have an optional leading 0. Months are from 01-12, days are from 01-31, and years are from 1000-2999.",
        "matches": [
            "1/1/1999",
            "01/01/2001",
            "12/31/1900"
        ],
        "non_matches": [
            "00/12/0999",
            "13/1/2000",
            "10/0/2009"
        ]
    },
    {
        "id": 2377,
        "expression": "^(.)+\\.(jpg|jpeg|JPG|JPEG)$",
        "description": "validates jpg/jpeg picture extension",
        "matches": [
            "marko.jpg",
            "marko.pic.jpeg"
        ],
        "non_matches": [
            "marko.exe"
        ]
    },
    {
        "id": 2379,
        "expression": "[^A-Za-z0-9 ]",
        "description": "search special character form a given sting space is ignored.",
        "matches": [
            "#This Is $$## Where Your Main String Goes"
        ],
        "non_matches": [
            "This is a test"
        ]
    },
    {
        "id": 2383,
        "expression": "^([1-9]\\d{3}|0[1-9]\\d{2}|00[1-9]\\d{1}|000[1-9]{1})$",
        "description": "This RE will match all numbers between (including) 0001 and 9999. Four places of digits are mandatory in this expression.",
        "matches": [
            "0001",
            "0064",
            "0948",
            "7697"
        ],
        "non_matches": [
            "1",
            "64",
            "948"
        ]
    },
    {
        "id": 2384,
        "expression": "^([\\d]*[1-9]+[\\d]*)$",
        "description": "RE to match numbers with value greater than 0.",
        "matches": [
            "0001",
            "120064",
            "1000000",
            "1"
        ],
        "non_matches": [
            "0",
            "000000000",
            "0000"
        ]
    },
    {
        "id": 2387,
        "expression": "^[-+]?\\d+(\\.\\d)?\\d*$",
        "description": "Number(no space or thousand separator with point(.) as decimal delimiter.",
        "matches": [
            "-3",
            "3.1231",
            "+972"
        ],
        "non_matches": [
            ".3",
            "51.",
            "+3.3.1"
        ]
    },
    {
        "id": 2389,
        "expression": "((http|ftp|https|ftps):\\/\\/)?[\\w\\-_\\.]+\\.(([0-9]{1,3})|([a-zA-Z]{2,3})|(aero|arpa|asia|coop|info|jobs|mobi|museum|name|travel))+(:[0-9]+)?\\/?(([\\w\\-\\.,@^%:/~\\+#]*[\\w\\-\\@^%/~\\+#])((\\?[a-zA-Z0-9\\[\\]\\-\\._+%\\$#\\=~',]*=[a-zA-Z0-9\\[\\]\\-\\._+%\\$#\\=~',]*)+(&[a-zA-Z0-9\\[\\]\\-\\._+%\\$#\\=~',]*=[a-zA-Z0-9\\[\\]\\-\\._+%\\$#\\=~',]*)*)?)?",
        "description": "Based on the work of N H (http://regexlib.com/REDetails.aspx?regexp_id=96). Added ftps protocol, makes protocol optional, makes slash after site optional.",
        "matches": [
            "google.com",
            "http://mysite.org:80/thispage.asp",
            "ftp://ftp.upload.com/"
        ],
        "non_matches": [
            "nomatchcom"
        ]
    },
    {
        "id": 2393,
        "expression": "((\\+44\\s?\\(0\\)\\s?\\d{2,4})|(\\+44\\s?(01|02|03|07|08)\\d{2,3})|(\\+44\\s?(1|2|3|7|8)\\d{2,3})|(\\(\\+44\\)\\s?\\d{3,4})|(\\(\\d{5}\\))|((01|02|03|07|08)\\d{2,3})|(\\d{5}))(\\s|-|.)(((\\d{3,4})(\\s|-)(\\d{3,4}))|((\\d{6,7})))",
        "description": "Matches over 18 different combinations for UK phone numbers that I could find. If there are any errors please get in touch.",
        "matches": [
            "0121 111 1111",
            "+44 (0)21 444 4444",
            "07941 111 111",
            "07941 111111",
            "(+44) 121 222 3333"
        ],
        "non_matches": [
            "0121_111_3333"
        ]
    },
    {
        "id": 2397,
        "expression": "^(?-i:A[LKSZRAEP]|C[AOT]|D[EC]|F[LM]|G[AU]|HI|I[ADLN]|K[SY]|LA|M[ADEHINOPST]|N[CDEHJMVY]|O[HKR]|P[ARW]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY])$",
        "description": "Validates US state abbreviations used by the Post Office.",
        "matches": [
            "CA",
            "FL",
            "HI"
        ],
        "non_matches": [
            "Ca",
            "NK",
            "CAL"
        ]
    },
    {
        "id": 2398,
        "expression": "^([0-9]|[1-9]\\d|[1-7]\\d{2}|800)$",
        "description": "Validates if the GMAT score is in the correct range and format",
        "matches": [
            "0",
            "190",
            "800"
        ],
        "non_matches": [
            "050",
            "700.5",
            "abc",
            "801"
        ]
    },
    {
        "id": 2399,
        "expression": "^[6]\\d{7}$",
        "description": "In Singapore, the first digit must start with a \"6\", and the rest is made up of 7 digits, which means that there are 8 digits in a Singapore's telephone number.",
        "matches": [
            "61234567",
            "63829324",
            "67654321"
        ],
        "non_matches": [
            "6123-4567",
            "6-CALL-CPY",
            "6123abcd"
        ]
    },
    {
        "id": 2400,
        "expression": "^[SFTG]\\d{7}[A-Z]$",
        "description": "The National Registry Identification Number (NRIC) of Singapore is made up of the first character being a S/F/T or G. The next 2 numbers is the year of birth for people born 1967 and later. The last character is a checksum done on the numbers, and the algorithm will not be released.",
        "matches": [
            "S9912345A",
            "T1234567V",
            "F0094839P"
        ],
        "non_matches": [
            "K4928940829F",
            "T1234567",
            "M1234567C"
        ]
    },
    {
        "id": 2401,
        "expression": "([0-9]+)\\s(d)\\s(([0-1][0-9])|([2][0-3])):([0-5][0-9]):([0-5][0-9])",
        "description": "Displays duration in\n1 d 22:33:44 format. Can be modified to match some other formats e.g. 1.22:33:44 if needed. Takes a 24-hour day into account.",
        "matches": [
            "1 d 22:33:44",
            "109 d 11:02:00",
            "0 d 00:00:00"
        ],
        "non_matches": [
            "d 22:33:44",
            "1 d 24:00:00",
            "3 d 11:75:00"
        ]
    },
    {
        "id": 2403,
        "expression": "^.*(?:kumar).*$",
        "description": "This will match those string which contains the word \"kumar\"",
        "matches": [
            "my name is kumar"
        ],
        "non_matches": [
            "I am mohan"
        ]
    },
    {
        "id": 2405,
        "expression": "(\\b(10|11|12|13|14|15|16|17|18|19)[0-9]\\b)",
        "description": "Match the numbers 100 to 199",
        "matches": [
            "100 to 199"
        ],
        "non_matches": [
            "200, 300, 1, 55, 99"
        ]
    },
    {
        "id": 2406,
        "expression": "^[1-9]{1,2}(.5)?$",
        "description": "This is a simple regular expression which allows 1 to 99 in .5 increments which I originally developed for a forum post",
        "matches": [
            "1.5",
            "99.5",
            "35.5",
            "43",
            "64",
            "24"
        ],
        "non_matches": [
            ".5",
            "100",
            "0",
            "0.5",
            "34.3",
            "24.356",
            "36.55"
        ]
    },
    {
        "id": 2409,
        "expression": "https?://[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*(?:\\.[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*)*/\\S*",
        "description": "HTTP(S) URL validator with embededded multi-part host name validator, RFC-compliant but does not validate length of components or overall length. Path portion after host name is free-form and will need refinement if you want to validate it.",
        "matches": [
            "http://www.example.com/ https://localhost/whatever"
        ],
        "non_matches": [
            "http://www.example.com ftp://localhost/whatever"
        ]
    },
    {
        "id": 2410,
        "expression": "[A-Za-z0-9!#$%&'*+\\-/=?^_`{|}~]+(?:\\.[A-Za-z0-9!#$%&'*+\\-/=?^_`{|}~]+)*@[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*(?:\\.[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*)*",
        "description": "Email address validator with embededded multi-part host name validator, RFC-compliant but does not validate length of components or overall length.",
        "matches": [
            "mike@localhost sue@example.com"
        ],
        "non_matches": [
            "mike @localhost sue.@example.com"
        ]
    },
    {
        "id": 2413,
        "expression": "(?<!/)/(\\w+\\.\\w+)?$",
        "description": "Gets the file name from a URL including the \"/\". If the URL ends in \"/\" the \"/\" is matched.",
        "matches": [
            "/index.htm",
            "/",
            "/default.aspx"
        ],
        "non_matches": [
            "google.com",
            "hi everybody",
            "\\myFile.txt"
        ]
    },
    {
        "id": 2420,
        "expression": "\\d{4}\\s\\d{4}\\s\\d{4}\\s\\d{4}$",
        "description": "Validate the Wii Code format. If you like to have slashes and spaces you can change the \"\\s\" for \"[\\s-]\"",
        "matches": [
            "1234 5678 9101 1121",
            "0000 0000 0000 0000",
            "8924 3578 3248 3212"
        ],
        "non_matches": [
            "1234-5678-9101-1121",
            "ABCD EFGH IJKL MNOP",
            "ABCD-1234 IJKL-4321"
        ]
    },
    {
        "id": 2421,
        "expression": "^(?=(.*[a-zA-Z].*){2,})(?=.*\\d.*)(?=.*\\W.*)[a-zA-Z0-9\\S]{8,15}$",
        "description": "Strong passwords with min 8 - max 15 character length, at least two letters (not case sensitive), one number, one special character (all, not just defined), space is not allowed.",
        "matches": [
            "&test*81",
            "te$tPa55word",
            "testpass(7"
        ],
        "non_matches": [
            "mypassword",
            "pass%5",
            "test5324",
            "374833e**"
        ]
    },
    {
        "id": 2422,
        "expression": "^((([\\+][\\s]{0,1})|([0]{2}[\\s-]{0,1}))([358]{3})([\\s-]{0,1})|([0]{1}))(([1-9]{1}[0-9]{0,1})([\\s-]{0,1})([0-9]{2,4})([\\s-]{0,1})([0-9]{2,4})([\\s-]{0,1}))([0-9]{0,3}){1}$",
        "description": "General phone number validation for Finland.\nIt will pass old and new format numbers.\nBetween numbers space or dash can be used ones.\nnumber has to start\n+358 or 00358 or 0\nare code can be 2 or 3 digit. I could not come with better idea then this",
        "matches": [
            "003589999999",
            "00 358 999 999",
            "00 358 9999 999",
            "00 358 999 9999",
            "091212",
            "09 99 99 99"
        ],
        "non_matches": [
            "050 999 9999 9999 999",
            "151212"
        ]
    },
    {
        "id": 2425,
        "expression": "^([0-2]{0,1})([0-3]{1})(\\.[0-9]{1,2})?$|^([0-1]{0,1})([0-9]{1})(\\.[0-9]{1,2})?$|^-?(24)(\\.[0]{1,2})?$|^([0-9]{1})(\\.[0-9]{1,2})?$",
        "description": "Allows positive(non-negative) decimal values with 2 floating point values and less than or equal to 24.",
        "matches": [
            "23.50",
            "20.80",
            "23.99",
            "24.00",
            "23",
            "20"
        ],
        "non_matches": [
            "24.01",
            "25",
            "20.900",
            "-20",
            "-25.50"
        ]
    },
    {
        "id": 2426,
        "expression": "^(02\\d\\s?\\d{4}\\s?\\d{4})|((01|05)\\d{2}\\s?\\d{3}\\s?\\d{4})|((01|05)\\d{3}\\s?\\d{5,6})|((01|05)\\d{4}\\s?\\d{4,5})$",
        "description": "Based on the source listed below. I have added in the 05 prefix for allowing UK voip landlines. I dont know if the spacings are all ofcom approved like the original regex but the patterns it supports are:\n029 99999999 or 029 9999 9999; 0199 9999999 or 0199 999 9999; 01999 99999; 01999 999999; 019999 9999; 019999 99999; 0599 9999999 or 0599 999 9999; 05999 99999; 05999 999999; 059999 9999; 059999 99999;",
        "matches": [
            "020 1234 5678",
            "0123 4567890",
            "01234 456789",
            "05234 456789"
        ],
        "non_matches": [
            "02476 123456",
            "0845 123456",
            "07712 345678",
            "0800 100 2496"
        ]
    },
    {
        "id": 2427,
        "expression": "^(BE)[0-1]{1}[0-9]{9}$|^((BE)|(BE ))[0-1]{1}(\\d{3})([.]{1})(\\d{3})([.]{1})(\\d{3})",
        "description": "VAT Number BE. Assumes BE followed by 0 or 1 or ' ' the digits will grouped by xxxxxxxxxx or xxxx.xxx.xxx. If you only want VAT numbers starting with 0 then replace [0-1]{1} with [0]",
        "matches": [
            "BE 0471.339.727",
            "BE0471.339.727",
            "BE0471339727"
        ],
        "non_matches": [
            "BE 0471.3397.27",
            "BE 047133972",
            "0471339727"
        ]
    },
    {
        "id": 2430,
        "expression": "^(?=.*\\d)(?=.*[A-Za-z])(?!.*[!@#\\$%\\^&\\*\\(\\)\\+=\\|;'\"{}<>\\.\\?\\-_\\\\/:,~`]).{6,20}$",
        "description": "Validates passwords to be 6-20 characters of letter and numbers and NO special characters (that appear on the keyboard). Adjust numbers at the end and remove special characters (after the \"(?!\") as needed. Numbers appear at the END to address an IE problem with zero-width look-aheads.",
        "matches": [
            "abc123",
            "8e9272wi8",
            "WEF896wdfso"
        ],
        "non_matches": [
            "iD0notM@tch",
            "n3itherDO_!"
        ]
    },
    {
        "id": 2431,
        "expression": "\\?<.+?>",
        "description": "Matches the name portion of a named group. Useful for \"cleaning\" regular expressions for use with ASP controls (since they don't support named groups).",
        "matches": [
            "(?<myname>[a-zA-Z])"
        ],
        "non_matches": [
            "([a-zA-Z])"
        ]
    },
    {
        "id": 2439,
        "expression": "^([a-z]{2,3}(\\.[a-zA-Z][a-zA-Z_$0-9]*)*)\\.([A-Z][a-zA-Z_$0-9]*)$",
        "description": "Regular Expression for validating fully qualified Java Class Names that follows the Java Naming Conventions for widely available classes (see: http://java.sun.com/docs/books/jls/third_edition/html/names.html#6.8).\nGroup 1 gives the package name, group 3 gives the class name.",
        "matches": [
            "foo.Bar",
            "foo.bar.IFBar1",
            "wo.w_1.Ffo$o.Bar"
        ],
        "non_matches": [
            "Bar",
            "Foo.Bar",
            "foo.bar",
            "foo/Bar",
            "fooo.Bar"
        ]
    },
    {
        "id": 2440,
        "expression": "^(1(0|7|9)2?)\\.([01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\\.([01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\\.([01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])$",
        "description": "validates private ip addresses\nneeds to be a bit more refined",
        "matches": [
            "10.10.10.10",
            "192.168.16.4",
            "172.016.22.55"
        ],
        "non_matches": [
            "a.c.s.s",
            "100.10.10.10",
            "188.142.25.2",
            "651817"
        ]
    },
    {
        "id": 2441,
        "expression": "^(([a-zA-Z][a-zA-Z_$0-9]*(\\.[a-zA-Z][a-zA-Z_$0-9]*)*)\\.)?([a-zA-Z][a-zA-Z_$0-9]*)$",
        "description": "Regular Expression for validating fully qualified Java Class Names that follows the Java Naming Conventions for local classes (see: http://java.sun.com/docs/books/jls/third_edition/html/names.html#6.8).\nGroup 2 gives the package name, group 4 gives the class name.",
        "matches": [
            "Bar",
            "f.B1",
            "fo_$1.bar.Foo.bar"
        ],
        "non_matches": [
            "1Bar",
            "foo-.Bar",
            "foo/Bar"
        ]
    },
    {
        "id": 2443,
        "expression": "\\<script[^>]*>[\\w|\\t|\\r\\|\\W]*?</script>",
        "description": "match all script blocks in html file or aspx file.",
        "matches": [
            "<script type=\"text/javascript\" src=\"test.js\"></script> <script> test </script"
        ],
        "non_matches": [
            "<%=Get(\"Configurator\")%>"
        ]
    },
    {
        "id": 2444,
        "expression": "^-?\\d+([.,]?\\d+)?$",
        "description": "It just accepts negative and positive numeric entries. Dot (.) or comma (,) signs accepted only once.",
        "matches": [
            "43",
            "-43",
            "43.56",
            "-43.56",
            "43,56",
            "-43,56"
        ],
        "non_matches": [
            "ABC",
            "A43",
            "43A",
            "43.A3",
            "-43.A3",
            "43.,56",
            "43.",
            "43,",
            ",56",
            ".56"
        ]
    },
    {
        "id": 2445,
        "expression": "^\\d+([.,]?\\d+)?$",
        "description": "It just accepts only positive numbers. Also accepts Dot (.) and comma (,) signs only once.",
        "matches": [
            "43",
            "43.56",
            "43,56"
        ],
        "non_matches": [
            "ABC",
            "A43",
            "43A",
            "43.A3",
            "43.",
            "43,",
            ",56",
            ".56"
        ]
    },
    {
        "id": 2446,
        "expression": "^-?\\d+([^.,])?$",
        "description": "Accepts positive and negative integers.",
        "matches": [
            "34",
            "-34",
            "1",
            "-1",
            "1000000000",
            "-1000000000"
        ],
        "non_matches": [
            "34.5",
            "-34.5",
            "34,5",
            "-34,5",
            "34.",
            "34,",
            ".5",
            ",5"
        ]
    },
    {
        "id": 2447,
        "expression": "^\\d+([^.,])?$",
        "description": "Accepts positive integers.",
        "matches": [
            "34",
            "1",
            "1000000000"
        ],
        "non_matches": [
            "-34",
            "-1",
            "-1000000000",
            "34.5",
            "-34.5",
            "34,5",
            "-34,5",
            "34.",
            "34,",
            ".5",
            ",5"
        ]
    },
    {
        "id": 2449,
        "expression": "(?:Error|Warning|Exception)",
        "description": "Find any and all occurences of any of the three terms \"Error\" \"Warning\" \"Exception\" in a log or txt file.\nUse this as a filter with TextAnalysisTool.NET for quick parsing of log files when looking for errors",
        "matches": [
            "2009-11-07 08:04:49.401 UTC Warning w3wp.24 SoapUtilities.CreateException ThrowException: actor = http://servername.subdomain.domain.com:8530/SimpleAuthWebService/SimpleAuth.asmx, ID=9ea54fc1-1351-4fb3-a6a3-ba52d5bd4671, ErrorCode=InternalServerError, Message=, Client=?"
        ],
        "non_matches": [
            "Any log/text file that does not contain the words in the expression"
        ]
    },
    {
        "id": 2451,
        "expression": "^(?![DFIOQU])([ABCEGHJ-NPRSTVXY]\\d[A-Z][ ]\\d[A-Z]\\d)$",
        "description": "Validates Canadian postal codes.\nFormat: A9A 9A9\nCannot contain: DFIOQU\nFirst letter must be one of: ABCEGHJKLMNPRSTVXY",
        "matches": [
            "A9A 9A9",
            "T3P 6N1"
        ],
        "non_matches": [
            "D9U 1O5"
        ]
    },
    {
        "id": 2454,
        "expression": "^(ht|f)tp(s?)\\:\\/\\/(([a-zA-Z0-9\\-\\._]+(\\.[a-zA-Z0-9\\-\\._]+)+)|localhost)(\\/?)([a-zA-Z0-9\\-\\.\\?\\,\\'\\/\\\\\\+&amp;%\\$#_]*)?([\\d\\w\\.\\/\\%\\+\\-\\=\\&amp;\\?\\:\\\\\\&quot;\\'\\,\\|\\~\\;]*)$",
        "description": "Validates URL to see if the input pattern is a valid URL (ftp, http, https, etc); can be easily modified to support others such as file:/// | Pattern has been tested using .NET runtime engine | localhost literal support for windows IIS server and visal studio (2005 or later) built-in asp.net web-server",
        "matches": [
            "http://regexlib.com",
            "http://www.google.com",
            "ftp://teach.me.regex/checkpattern/o",
            "http://www.google.com/search?hl=en&source=hp&q=asp.net",
            "https://secure.mailserver.com",
            "http://localhost/mypage.html",
            "http://localhost:89783/mypage.aspx",
            "http://go.com",
            "http://forum.whoisyourdaddy.org/index.html?RegID=7449046&Daddy=dontknow&son=me"
        ],
        "non_matches": [
            "http://",
            "http://whoisyourdaddy",
            "httpOrhttpsOrftp.com"
        ]
    },
    {
        "id": 2459,
        "expression": "^<(?:@[a-z0-9][a-z0-9-]*[a-z0-9](?:\\.[a-z0-9][a-z0-9-]*[a-z0-9])+(?:,@[a-z0-9][a-z0-9-]*[a-z0-9](?:\\.[a-z0-9][a-z0-9-]*[a-z0-9])+)*:)?([a-zA-Z0-9!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]+(?:\\.[a-zA-Z0-9!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]+)*@[a-z0-9][a-z0-9-]*[a-z0-9](?:\\.[a-z0-9][a-z0-9-]*[a-z0-9])+)>$",
        "description": "forward-path and reverse-path as defined in RFC 2821",
        "matches": [
            "<@arsec.sk,@beton.cz,@polo-domena.com:gkusnir@example.org>"
        ],
        "non_matches": [
            "<@arsec.sk,@beton.cz, @polo-domena.com:gkusnir@example.org>"
        ]
    },
    {
        "id": 2461,
        "expression": "^[-\\w\\s\"'=/!@#%&,;:`~\\.\\$\\^\\{\\[\\(\\|\\)\\]\\}\\*\\+\\?\\\\]*$",
        "description": "Anti-HTML pattern for english sentences. any < or > will make it not match.",
        "matches": [
            "Test *1 - 2% + $3=#7 ... ?! &lt;"
        ],
        "non_matches": [
            "<a href=\"http:/acleditor.com\">CraigsListMultiplier</a>"
        ]
    },
    {
        "id": 2463,
        "expression": "^[a-zA-Z0-9\\-]+\\.cn$",
        "description": "select .cn from domain where nic.deleted",
        "matches": [
            "dotnetblog.cn"
        ],
        "non_matches": [
            "dotnetblog.com.cn,dotnetblog.com.cn"
        ]
    },
    {
        "id": 2466,
        "expression": "\\A(.*?)\\s+(\\d+[a-zA-Z]{0,1}\\s{0,1}[-]{1}\\s{0,1}\\d*[a-zA-Z]{0,1}|\\d+[a-zA-Z-]{0,1}\\d*[a-zA-Z]{0,1})",
        "description": "This pattern splits the streetname and housenumber of Dutch Postal Addresses.",
        "matches": [
            "Sophia van Teylingenstraat 19",
            "Abrikozenstraat 116A",
            "Laan van Meerdervoort 1218-1220",
            "Laan van Meerdervoort 1218 - 1220"
        ],
        "non_matches": [
            "none"
        ]
    },
    {
        "id": 2467,
        "expression": "^([a-zA-Z0-9]{1,15})$",
        "description": "Simple validation reg ex that requires 1-15 alphanumeric characters",
        "matches": [
            "kazoosoft",
            "tw33tfan",
            "MediaOwls"
        ],
        "non_matches": [
            "@lpha",
            "bad\\username",
            "badname1234567890"
        ]
    },
    {
        "id": 2470,
        "expression": "^([1-9]{0,1})([0-9]{1})((\\.[0-9]{0,1})([0-9]{1})|(\\,[0-9]{0,1})([0-9]{1}))?$",
        "description": "Vat percentage format for Indian and Germany.Maximum two digit before decimal and after decimal",
        "matches": [
            "89.56",
            "14.69",
            "56,23"
        ],
        "non_matches": [
            "100.56",
            "25.365",
            "125,56"
        ]
    },
    {
        "id": 2476,
        "expression": "(?!^[0-9 ]*$)(?!^[a-zA-Z ]*$)^([a-zA-Z0-9 ]{6,15})$",
        "description": "This expression validates alphanumeric with one alphabet compulsory and one numeric compulsory and accepts minimum 6 characters and max 15 characters irrespective of the order and case.It doesnt accept special characters",
        "matches": [
            "1DAV100"
        ],
        "non_matches": [
            "asdfgh,asd.123 etc.,"
        ]
    },
    {
        "id": 2480,
        "expression": "^[a-zA-Z]\\w{0,30}$",
        "description": "A simple expression to verify a FORTRAN variable name to within 31 chars.",
        "matches": [
            "ABC1_1",
            "ABcdef",
            "abc_def_123"
        ],
        "non_matches": [
            "1A",
            "_ABC",
            "a1234567890123456789012345678901"
        ]
    },
    {
        "id": 2482,
        "expression": "^[A-Za-z0-9_]+$",
        "description": "This expression checks whether the string contains lower or uppercase characters and numbers from zero to nine and an underscore",
        "matches": [
            "ab_12"
        ],
        "non_matches": [
            "%$"
        ]
    },
    {
        "id": 2485,
        "expression": "^\\d{1,6}\\040([A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,})$|^\\d{1,6}\\040([A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,})$|^\\d{1,6}\\040([A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,})$",
        "description": "This will accept any 6 digit street address only, with min of two and up to four street names.",
        "matches": [
            "123456 My Street",
            "123 West Main St",
            "12345 Via De La Rosa"
        ],
        "non_matches": [
            "123 Street",
            "1234 W Side Street"
        ]
    },
    {
        "id": 2486,
        "expression": "\\(\\d{3}\\)\\040\\d{3}-\\d{4}",
        "description": "Phone Number in (###) ###-#### Format Only",
        "matches": [
            "(717) 899-9998"
        ],
        "non_matches": [
            "(717)999-9999",
            "999-999-9999"
        ]
    },
    {
        "id": 2487,
        "expression": "\\(714|760|949|619|909|951|818|310|323|213|323|562|626\\)\\040\\d{3}-\\d{4}",
        "description": "Phone Numbers Format (###) ###-#### with only SoCal Area Codes. Use or replace with Area Codes You need.",
        "matches": [
            "(714) 123-4567",
            "(949) 555-5555",
            "(323) 467-1070"
        ],
        "non_matches": [
            "(808) 666-6666",
            "(111)123-4567",
            "Any Non SoCal Area Code"
        ]
    },
    {
        "id": 2488,
        "expression": "714|760|949|619|909|951|818|310|323|213|323|562|626-\\d{3}-\\d{4}",
        "description": "Phone Number in ###-###-#### Format Only with Southern California Area Codes. Use or Replace Area Codes",
        "matches": [
            "714-333-3333",
            "818-222-2222",
            "323-333-3333"
        ],
        "non_matches": [
            "808-123-4567",
            "(808) 123-4567",
            "Any Non So Cal Area Code"
        ]
    },
    {
        "id": 2492,
        "expression": "^\\D{0,2}[0]{0,3}[1]{0,1}\\D{0,2}([2-9])(\\d{2})\\D{0,2}(\\d{3})\\D{0,2}(\\d{3})\\D{0,2}(\\d{1})\\D{0,2}$",
        "description": "Very useful if you want to use ANY-NON-DIGIT as delimiter and return proper US-Phone-Number. Use \"($1) $2-$3$4\" to get Number in form: \"(234) 567-8901\".\nWill ignore starting 1, 01, 001, +1 etc.\nValidates and also captures AreaCode, Prefix and Suffix for reformatting.\nIn all matching examples, it will return the same result. I have not found any exception yet.",
        "matches": [
            "(234) 567-8901",
            "+1-234-567-890-1",
            "+001 2345678901",
            "+1/234/567/890-1",
            "0012345678901",
            "X234X567X890X1X",
            "(+001)(234)(5678901)",
            "+1(234)5678901",
            "+1 234 567 890-1",
            "[234][567][890(1)]",
            "234/567/890/1",
            "12345678901"
        ],
        "non_matches": [
            "12X345678901",
            "23456789X01",
            "5678901"
        ]
    },
    {
        "id": 2494,
        "expression": "((&#[0-9]+|&[a-zA-Z]+[0-9]*?);)",
        "description": "Matches HTML 'amp' codes",
        "matches": [
            "&reg;",
            "&nbsp;",
            "&#32;"
        ],
        "non_matches": [
            "&32;"
        ]
    },
    {
        "id": 2497,
        "expression": "^(?:mailto:)?(?:[a-z][\\w~%!&amp;',;=\\-\\.$\\(\\)\\*\\+]*)@(?:[a-z0-9][\\w\\-]*[a-z0-9]*\\.)*(?:(?:(?:[a-z0-9][\\w\\-]*[a-z0-9]*)(?:\\.[a-z0-9]+)?)|(?:(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)))$",
        "description": "I think this is a very good e-mail validation match expression\nPS: you have got to try RegexBuddy it's a very cool tool that helps realy http://www.regexbuddy.com",
        "matches": [
            "mailto:support@regexbuddy.com",
            "user@172.168.0.1",
            "user%20name@domain.com",
            "admin@localhost"
        ],
        "non_matches": [
            "@172.168.0.1",
            "domain.com",
            "user%20name@domain.com/test"
        ]
    },
    {
        "id": 2500,
        "expression": "^(?:(?:\\.\\./)|/)?(?:\\w(?:[\\w`~!$=;\\-\\+\\.\\^\\(\\)\\|\\{\\}\\[\\]]|(?:%\\d\\d))*\\w?)?(?:/\\w(?:[\\w`~!$=;\\-\\+\\.\\^\\(\\)\\|\\{\\}\\[\\]]|(?:%\\d\\d))*\\w?)*(?:\\?[^#]+)?(?:#[a-z0-9]\\w*)?$",
        "description": "parse/match url path with:\n1. optional relative path\n2. optional query string\n3. optional fragments",
        "matches": [
            "..//test/tesf",
            "/cgi-bin/version.pl?r=fhjkjh%20ds&djj=fffsd#kit",
            "index.html",
            "/?q=test"
        ],
        "non_matches": [
            ".path./index.html",
            "about:blank",
            "..///test/tesf"
        ]
    },
    {
        "id": 2502,
        "expression": "^#[\\dA-Fa-f]{3}(?:[\\dA-Fa-f]{3}[\\dA-Fa-f]{0,2})?$",
        "description": "matches # + 3 hex numbers + optional 3 more hex numbers and 2 more hex numbers for alpha\nPS: you have got to try RegexBuddy it's a very cool tool that helps realy http://www.regexbuddy.com",
        "matches": [
            "#fff",
            "#123456",
            "#12345678",
            "#1f35cc"
        ],
        "non_matches": [
            "#1234",
            "#0",
            "#123456789"
        ]
    },
    {
        "id": 2507,
        "expression": "^[0-9#\\*abcdABCD]+$",
        "description": "Tests expression for DTMF combinations (numbers 0-9, asterisk, octothorpe and A,B,C,D or a,b,c,d). Does not limit number of occurrences or their order.",
        "matches": [
            "*AB132#",
            "12#AB*3",
            "*c3d42a##"
        ],
        "non_matches": [
            "r13",
            "#bCz31*",
            "*%#"
        ]
    },
    {
        "id": 2512,
        "expression": "^[0-9]+(,[0-9]+)*$",
        "description": "Parses comma-separated numbers. Doesn't allow spaces inbetween numbers and/or between numbers and commas. Allows single number to be added. Doesn't allow sequence to end with a comma.",
        "matches": [
            "1321",
            "1321,0,42412",
            "0,1,2,3,4"
        ],
        "non_matches": [
            "1321,,42412",
            "12c,13d,23",
            "445,",
            "412 , 421, 4122",
            "42 4,41"
        ]
    },
    {
        "id": 2519,
        "expression": "^((\\+){1}91){1}[1-9]{1}[0-9]{9}$",
        "description": "In this Pattern +91 will be the prefix in the Mobile number(of 10 digits).",
        "matches": [
            "+919123456789"
        ],
        "non_matches": [
            "+91 9123456789",
            "+91-9123456789"
        ]
    },
    {
        "id": 2531,
        "expression": "^\\d{8,8}$|^[SC]{2,2}\\d{6,6}$",
        "description": "Matches against a valid UK Limited company numer, either Scotland, Wales England or Northern Ireland. Either 8 numerical digits or SC followed by 6 numerical digits are allowed",
        "matches": [
            "12345678",
            "SC123456"
        ],
        "non_matches": [
            "123456789",
            "AB123456",
            "a2345678"
        ]
    },
    {
        "id": 2532,
        "expression": "megaupload\\.com.*(?:\\?|&)(?:(?:folderi)?d|f)=([A-Z-a-z0-9]{8})",
        "description": "Detects megaupload files and folders links.",
        "matches": [
            "http://www.megaupload.com/?d=QDNFF02H",
            "http://www.megaupload.com/?f=TSNFLU2K",
            "http://www.megaupload.com/xml/folderfiles.php?folderid=1DGR6C4H"
        ],
        "non_matches": [
            "http://www.megaupload.com/?k=TSNFLU2K",
            "http://www.megaupload.com/?f=TSNFLU#@",
            "http://www.megaupload.com/xml/folderfiles.php?folderod=1DGR6C4H"
        ]
    },
    {
        "id": 2536,
        "expression": "\\$(\\d*)??,??(\\d*)??,??(\\d*)\\.(\\d*)",
        "description": "This captures (for filters out non digits) numbers with or without commas (eg currency as above) in the correct order - the other examples I see here don't capture in right order for all combinations. It doesn't check lengths or leading digits or number of digits between commas- that is left as an exercise for the student.\nFirst example gives:[4],[234],[567],[89]\nSecond gives:\n[],[1],[234],[80]\nrather than the incorrect:\n[1],[],[234],[80]",
        "matches": [
            "$1,234,567.89",
            "$1,234.80",
            "$34.45",
            "$1234.5"
        ],
        "non_matches": [
            "$1,234",
            "$123-45",
            "$-123.00"
        ]
    },
    {
        "id": 2539,
        "expression": "^[89][0-9]{9}",
        "description": "This will accept all the Mobile nos starting with 8 or 9 and having exactly 10 digits (total) or it must be blank",
        "matches": [
            "9323444432",
            "8022234456",
            "8812345678"
        ],
        "non_matches": [
            "72",
            "54353454",
            "01212",
            "7644321108",
            "79055",
            "asdfg",
            "12ase"
        ]
    },
    {
        "id": 2542,
        "expression": "^[\\d]{3}[\\s\\-]*[\\d]{3}[\\s\\-]*[\\d]{4}\\s*$",
        "description": "Used to check US phone pattern",
        "matches": [
            "222-222-2222",
            "333 333 3333"
        ],
        "non_matches": [
            "3333333",
            "3333-333-33"
        ]
    },
    {
        "id": 2543,
        "expression": "background-image.[^<]*?;",
        "description": "returns the background-image property with its value. It will not return the uppercase property value like Background-image.",
        "matches": [
            "<div style=\"overflow: hidden; background-image:url(https://d2img01/z/Badge/N8_5x2_75/Tall_buildings_lores.gif);"
        ],
        "non_matches": [
            "<div style=\"overflow: hidden; Background-image:url(https://d2img01/z/Badge/N8_5x2_75/Tall_buildings_lores.gif);"
        ]
    },
    {
        "id": 2547,
        "expression": "^(([01]?[0-9]{1,2}|2[0-4][0-9]|25[0-5])\\.){3}([01]?[0-9]{1,2}|2[0-4][0-9]|25[0-5])$",
        "description": "This is a standard perl-compatible regexp for ip4 address validation",
        "matches": [
            "192.168.0.1"
        ],
        "non_matches": [
            "192.259.800.1"
        ]
    },
    {
        "id": 2548,
        "expression": "^(000000[1-9])$|^(00000[1-9][0-9])$|^(0000[1-9][0-9][0-9])$|^(000[1-9][0-9][0-9][0-9])$|^(00[1-9][0-9][0-9][0-9][0-9])$|^(0[1-9][0-9][0-9][0-9][0-9][0-9])$|^([1-9][0-9][0-9][0-9][0-9][0-9][0-9])$",
        "description": "This will check to see if the string entered is all digits and is seven digits long. It will allow for leading zeros and also not allow for all zeros to be entered.",
        "matches": [
            "0000001",
            "1234567",
            "0003344"
        ],
        "non_matches": [
            "000012",
            "12345678",
            "123456A"
        ]
    },
    {
        "id": 2549,
        "expression": "^((((0?[13578]|1[02])\\/([0-2]?[1-9]|20|3[0-1]))|((0?[469]|11)\\/([0-2]?[1-9]|20|30))|(0?2\\/([0-1]?[1-9]|2[0-8])))\\/((19|20)?\\d{2}))|(0?2\\/29\\/((19|20)?(04|08|12|16|20|24|28|32|36|40|44|48|52|56|60|64|68|72|76|80|84|88|92|96)|2000))$",
        "description": "Check that a valid date has been entered. Uses mm/dd/yyyy or m/d/yy format or various combinations. Checks for valid leap years.",
        "matches": [
            "2/28/1990",
            "2/29/1992",
            "03/1/10"
        ],
        "non_matches": [
            "2/29/90",
            "11/31/2010"
        ]
    },
    {
        "id": 2550,
        "expression": "^[0-9][0-9,]*[0-9]$",
        "description": "It is for Comma separated integer values only.it won't allow comma before and end string.\nValid Expression :\n123,345,4444444,56,6\nInvalid Expressions :\n12,@@34,fsff,333,\n,12,234,456\n34,567,3456,\n111,11fff,&*,fff,567\nthe above all invalid.",
        "matches": [
            "123,345,4444444,56,6"
        ],
        "non_matches": [
            "12,@@34,fsff,333,"
        ]
    },
    {
        "id": 2553,
        "expression": "^((0*[0-1]?[0-9]{1,2}\\.)|(0*((2[0-4][0-9])|(25[0-5]))\\.)){3}((0*[0-1]?[0-9]{1,2})|(0*((2[0-4][0-9])|(25[0-5]))))$",
        "description": "Matches ip addresses. Takes into account trailing left zeros.",
        "matches": [
            "172.18.200.101",
            "00172.18.200.001",
            "172.255.255.255"
        ],
        "non_matches": [
            "172.256.255.255",
            "1072.255.255.255",
            "172.255.255.1.1"
        ]
    },
    {
        "id": 2555,
        "expression": "\\b([A-CEGHJ-PR-TW-Z]{1}[A-CEGHJ-NPR-TW-Z]{1}(?<!BG|GB|NK|KN|TN|NT|ZZ))[0-9]{6}[A-DFM]{1}\\b",
        "description": "First letter cannot be: D, F, I, Q, U, or V\nSecond letter cannot be: D, F, I, O, Q, U, or V\nThe first two character combinations BG, GB, NK, KN, TN, NT, and ZZ are not used.\nFollowed by 6 digits (0-9)\nFinished by a suffix: A, B, C, D, F, or M",
        "matches": [
            "JG103759A",
            "AP019283D",
            "AB103455B",
            "SS345603D"
        ],
        "non_matches": [
            "CK945723N",
            "BG103442A",
            "NT834238A",
            "ZZ834758A"
        ]
    },
    {
        "id": 2566,
        "expression": "(<meta [.\\w\\W]*?\\>)|(<style [.\\w\\W]*?</style>)|(<link [.\\w\\W]*?\\>)|(<script [.\\w\\W]*?</script>)",
        "description": "Parses the objects out from an html header. These objects are: meta, style, link, and script. Use with the multiline option to pull from multine scripts and styles.",
        "matches": [
            "<head runat=\"server\"> <title></title> <script type=\"text/javascript\"> // // function foo() { } // </script> <style type=\"text/css\"> /* ** ** */ .foo { font-size : large;} </style> <script src=\"includes/JScript1.js\" type=\"text/javascript\"></script> <link href=\"includes/Stylesheet1.css\" rel=\"stylesheet\" type=\"text/css\" /> <script type=\"text/javascript\"> // // function foo2() { } // </script> <style type=\"text/css\"> /* **"
        ],
        "non_matches": [
            "Um...."
        ]
    },
    {
        "id": 2567,
        "expression": "[NS] \\d{1,}(\\:[0-5]\\d){2}.{0,1}\\d{0,},[EW] \\d{1,}(\\:[0-5]\\d){2}.{0,1}\\d{0,}",
        "description": "Latitude and longitude coordinates separated by a comma in the form:\nN 0:59:59.99,E 0:59:59.99 No restriction on degrees. Use split on comma to separate Latitude and Longitude then on colon and space for parts to convert into a decimal value.",
        "matches": [
            "N 50:54:44.99,W 4:59:11.0",
            "N 38:55:02.90,W 76:59:31.19",
            "N 22:16:42,E 114:09:32"
        ],
        "non_matches": [
            "N 22:66:61,E 85:00:33",
            "E 00:00:00.00,N 00:00:00.00",
            "N00:00:00.00, E00:00:00.00"
        ]
    },
    {
        "id": 2568,
        "expression": "(?<=[[]tex[]]).*?(?=[[]/tex[]])",
        "description": "This expression helps in finding any text inside [tex] \u2013 [/tex] tags. For example returns x+y=z for the following input [tex]x+y=z[/tex] Was written for parsing LaTex equations written by users in Html editor. Despite its\u2019 original purpose it can be used for matching of any arbitrary tags in squared brackets.",
        "matches": [
            "[tex]x+y=10[/tex]",
            "[tex] i \\hbar {\\partial \\over \\partial t} \\Psi(x,\\,t)= -{\\hbar^2 \\over 2m} {\\partial^2 \\over \\partial x^2} \\Psi(x,\\,t)+ V(x)\\Psi(x,\\,t)\\, [/tex]",
            "[tex] [/tex]"
        ],
        "non_matches": [
            "No match [tex] [/tx]",
            "[tex] NO match [tex]",
            "[tx] No match [/tex]"
        ]
    },
    {
        "id": 2570,
        "expression": "(^[1-9]$)|(^10$)",
        "description": "Matches the numbers 1-10 and only the numbers 1-10.",
        "matches": [
            "1",
            "8",
            "10"
        ],
        "non_matches": [
            "0",
            "11",
            "99"
        ]
    },
    {
        "id": 2572,
        "expression": "^[A-Za-z]$",
        "description": "Matches a string that contains exactly one letter in the range A-Z or a-z.",
        "matches": [
            "B",
            "L",
            "a",
            "k",
            "z"
        ],
        "non_matches": [
            "BL",
            "akz",
            "Az"
        ]
    },
    {
        "id": 2573,
        "expression": "http://(www\\.)?([^\\.]+)\\.com",
        "description": "This regex matches 'http://' optionally followed by 'www.' then starts a group and matches one or more of any character that is not a full stop/period (.) closes the group then matches '.com'.",
        "matches": [
            "http://www.yahoo.com",
            "http://yahoo.com"
        ],
        "non_matches": [
            "yahoo.com"
        ]
    },
    {
        "id": 2574,
        "expression": "[^\\u0009\\u000A\\u000D\\u0020-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]",
        "description": "RegEx to match Invalid XML character",
        "matches": [
            "\u0019",
            "\b",
            "\u0010"
        ],
        "non_matches": [
            "abc",
            "0x007F",
            "xyz"
        ]
    },
    {
        "id": 2577,
        "expression": "^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[^a-zA-Z0-9])(?!.*\\s).{8,20}$",
        "description": "Password between 8 and 20 characters; must contain at least one lowercase letter, one uppercase letter, one numeric digit, and one special character, but cannot contain whitespace.",
        "matches": [
            "Abc1234#",
            "abcD$123",
            "A1b2&C3!"
        ],
        "non_matches": [
            "abcd1234",
            "AbCd!@#$",
            "Abc 123#"
        ]
    },
    {
        "id": 2580,
        "expression": "(<(!--|script)(.|\\n[^<])*(--|script)>)|(<|&lt;)(/?[\\w!?]+)\\s?[^<]*(>|&gt;)|(\\&[\\w]+\\;)",
        "description": "Matches any text inside greater than less than characters. Can be used to remove HTML Markup including attributes and comments.",
        "matches": [
            "<p><font face=\"Trebuchet MS\" size=\"2\" >summary of </font></p>",
            "<body><font face=\"Trebuchet MS\" size=\"2\" >Example 2</font></body>",
            "<!-- Comment-->"
        ],
        "non_matches": [
            "Regular Text",
            "Regular Text2",
            "Regular Text3"
        ]
    },
    {
        "id": 2581,
        "expression": "(\"(?:(?:(?:\\\\.)|[^\"\\\\\\r\\n])*)\"|'(?:(?:(?:\\\\.)|[^'\\\\\\r\\n])*)'|`(?:(?:(?:\\\\.)|[^`\\\\\\r\\n])*)`)|((?:-- .*)|(?:#.*)|(?:/\\*(?:(?:[^*]|\\*(?!/))*)\\*/))",
        "description": "Isolates MySQL Query strings and comments. Lines that look like comments inside strings are not falsely recognised as comments. To strip comments from a MySQL Query, simply replace all matches with group 1",
        "matches": [
            "-- insurance",
            "# renaming some primary keys",
            "/**/",
            "\"hello -- this is not a comment\""
        ],
        "non_matches": [
            "ALTER TABLE table_insurance_covered"
        ]
    },
    {
        "id": 2586,
        "expression": "^(?=.*[!@#$%^&*()\\-_=+`~\\[\\]{}?|])(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9]).{8,20}$",
        "description": "This should require all of the following: An uppercase letter, a lowercase letter, a number and a special character from the provided list. Lastly, it needs to be between 8 and 20 characters long.\nA lot of expressions I've found here don't require all four, this should. I'm pretty new at regex though, so I hope that other people will help strengthen this expression.\nWhen testing on this site, make sure you have the Case Insensitive checkbox turned off.",
        "matches": [
            "p2sSw@rd",
            "p2sSw@rd#l0ngEr",
            "abc#$%GH1"
        ],
        "non_matches": [
            "p2ssw@rd",
            "p2sSw@rd#l0ngErThisIs2l0ng",
            "abc123DEF"
        ]
    },
    {
        "id": 2588,
        "expression": "^#(\\d{6})|^#([A-F]{6})|^#([A-F]|[0-9]){6}",
        "description": "Hexadecimal color values to validate the system must begin with a # symbol, which can be combination of numbers and letters AF, but the letters must be uppercase.",
        "matches": [
            "#000000",
            "#FFFFFF",
            "#000FFF",
            "#FFF000",
            "#A1B2C3"
        ],
        "non_matches": [
            "#ffffff",
            "#ABC",
            "#123",
            "#AJKSDD",
            "#a1b2c3",
            "abcdef",
            "123456"
        ]
    },
    {
        "id": 2591,
        "expression": "^([+]39)?\\s?((313)|(32[03789])|(33[013456789])|(34[0256789])|(36[0368])|(37[037])|(38[0389])|(39[0123]))[\\s-]?([\\d]{7})$",
        "description": "This pattern matches italian mobile phone numbers:\n- Tim (330, 331, 333, 334, 335, 336, 337, 338, 339, 360, 363, 366, 368)\n- Vodafone Italia (340, 342, 345, 346, 347, 348, 349)\n- Wind (320, 323, 327, 328, 329, 380, 383, 388, 389)\n- 3 Italia (390, 391, 392, 393)\n- RFI (313)\n- virtual operators (370, 373, 377)",
        "matches": [
            "+393381234567",
            "+39 3381234567",
            "+39 338 1234567",
            "+39 338-1234567",
            "3381234567",
            "3381234567",
            "338 1234567",
            "338-1234567"
        ],
        "non_matches": [
            "0039 338 1234567",
            "(338)1234567",
            "338/1234567"
        ]
    },
    {
        "id": 2593,
        "expression": "^(?!0{1})\\d{6}",
        "description": "Indian Postal has siz digit of length and does not start with zero",
        "matches": [
            "362265",
            "1254215",
            "256201"
        ],
        "non_matches": [
            "021545"
        ]
    },
    {
        "id": 2596,
        "expression": "^([a-zA-Z][a-zA-Z0-9+-.]*):((\\/\\/(((([a-zA-Z0-9\\-._~!$&'()*+,;=':]|(%[0-9a-fA-F]{2}))*)@)?((\\[((((([0-9a-fA-F]{1,4}:){6}|(::([0-9a-fA-F]{1,4}:){5})|(([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:){4})|((([0-9a-fA-F]{1,4}:)?[0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:){3})|((([0-9a-fA-F]{1,4}:){0,2}[0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:){2})|((([0-9a-fA-F]{1,4}:){0,3}[0-9a-fA-F]{1,4})?::[0-9a-fA-F]{1,4}:)|((([0-9a-fA-F]{1,4}:){0,4}[0-9a-fA-F]{1,4})?::))((([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4}))|(([0-9]|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5]))\\.([0-9]|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5]))\\.([0-9]|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5]))\\.([0-9]|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5])))))|((([0-9a-fA-F]{1,4}:){0,5}[0-9a-fA-F]{1,4})?::[0-9a-fA-F]{1,4})|((([0-9a-fA-F]{1,4}:){0,5}[0-9a-fA-F]{1,4})?::))|(v[0-9a-fA-F]+\\.[a-zA-Z0-9\\-._~!$&'()*+,;=':]+))\\])|(([0-9]|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5]))\\.([0-9]|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5]))\\.([0-9]|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5]))\\.([0-9]|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5])))|(([a-zA-Z0-9\\-._~!$&'()*+,;=']|(%[0-9a-fA-F]{2}))*))(:[0-9]*)?)((\\/([a-zA-Z0-9\\-._~!$&'()*+,;=':@]|(%[0-9a-fA-F]{2}))*)*))|(\\/?(([a-zA-Z0-9\\-._~!$&'()*+,;=':@]|(%[0-9a-fA-F]{2}))+(\\/([a-zA-Z0-9\\-._~!$&'()*+,;=':@]|(%[0-9a-fA-F]{2}))*)*)?))(\\?(([a-zA-Z0-9\\-._~!$&'()*+,;=':@\\/?]|(%[0-9a-fA-F]{2}))*))?((#(([a-zA-Z0-9\\-._~!$&'()*+,;=':@\\/?]|(%[0-9a-fA-F]{2}))*)))?$",
        "description": "Manually derived this from the grammar in Appendix A of RFC3986 (Uniform Resource Identifier (URI): Generic Syntax).\nMatches anything that fits the generic syntax of a URI. Supports IPv6 hosts.",
        "matches": [
            "http://user:pwd@domain.com:123/dir/subdir/?qp1=v%d3&qp2=98#frag",
            "http://192.168.0.0:123/dir/subdir/?qp1=v%d3&qp2=98#frag",
            "svn+ssh://[D456::1234:4321]:123/dir/subdir/?qp1=v%d3&qp2=98#frag"
        ],
        "non_matches": [
            "http://user:pwddomain.com:123/dir/subdir/?qp1=v%d3&qp2=98#frag",
            "http://192.168.0.0:123/dir/subdir/?qp1=v%d&qp2=98#frag",
            "svn+ssh://[D456::12344321]:123/dir/subdir/?qp1=v%d3&qp2=98#frag"
        ]
    },
    {
        "id": 2598,
        "expression": "^(\\+[1-9]\\d+) ([1-9]\\d+) ([1-9]\\d+)(\\-\\d+){0,1}$|^(0\\d+) ([1-9]\\d+)(\\-\\d+){0,1}$|^([1-9]\\d+)(\\-\\d+){0,1}$",
        "description": "Matches a Din 5008 formatted phone number, except of \"special numbers\" like \"0180 5 12345\"",
        "matches": [
            "+49 12 3456789",
            "+49 12 34567-89",
            "012 3456789",
            "1234567-89"
        ],
        "non_matches": [
            "+49 012 3456789",
            "+49 (0)12 3456789",
            "0180 5 12345"
        ]
    },
    {
        "id": 2602,
        "expression": "^\\w+\\.((?:\\w+\\.)+\\w+)$",
        "description": "Drops the first subdomain from a domain name with at least one subdomain. Fails if the domain does not contain a subdomain.",
        "matches": [
            "www.google.com",
            "www.wave.google.com",
            "as.vcu.acadia.memco.edu"
        ],
        "non_matches": [
            "google.com",
            "microsoft.com",
            "memco.edu"
        ]
    },
    {
        "id": 2603,
        "expression": "^[0-9]{4} {0,1}[A-Z]{2}$",
        "description": "Check the Dutch postal code offical format of \"9999 AA\". Since it is often stored in a database without the space, this pattern allows 0 or 1 space.",
        "matches": [
            "9999 AA",
            "9999AA"
        ],
        "non_matches": [
            "9999 aa",
            "9999?AA"
        ]
    },
    {
        "id": 2606,
        "expression": "(?![A-Z](\\d)\\1{5,})(^[A-Z]{1,3}(\\d{6}|\\d{9})$)|(^\\d{9}[A-Z][0-9|A-Z]?$)",
        "description": "Matches valid Medicare HIC number according to CMS specifications",
        "matches": [
            "H123456",
            "XYZ123456789",
            "123456789B"
        ],
        "non_matches": [
            "H123",
            "H999999",
            "H1234XB"
        ]
    },
    {
        "id": 2618,
        "expression": "^[^iIoOqQ'-]{10,17}$",
        "description": "Validates US VIN. It could be between 10 and 17 character in length and should never contain i, l, o, O, q, Q, ' or -.",
        "matches": [
            "12345awertasfggr"
        ],
        "non_matches": [
            "12345qwertasfggr"
        ]
    },
    {
        "id": 2620,
        "expression": "^((.){1,}(\\d){1,}(.){0,})$",
        "description": "Does a very basic validation on Danish street addresses.\nIt ensures that the format \"Address No\" is honored, but also allows any char to be put after the address.\nThis is to ensure additions like floor, and which door it is. Ex. \"Addrees No Floor LeftDoor.\"\nEnjoy!",
        "matches": [
            "Teststreet 32",
            "T\u00f8rststr\u00e6de 4",
            "T\u00f8rststr\u00e6de 24 1. tv"
        ],
        "non_matches": [
            "T\u00f8rststr\u00e6de",
            "2 T\u00f8rststr\u00e6de"
        ]
    },
    {
        "id": 2626,
        "expression": "/\"(\\\\[\"\\\\]|[^\"])*(\"|$)|'(\\\\['\\\\]|[^'])*('|$)|(\\\\[\"'\\\\]|[^\\s\"'])+/g",
        "description": "Intended for single line. JavaScript match() method (or equivalent) creates an array of values each of which is either an unquoted string of non-whitespace chars, or a quoted string which can contain whitespace, escaped quotes (\\' or \\\"), escaped escaped chars (\\\\), or be empty ('' or \"\"). Splits on whitespace AND splits on opening and closing quotes. An unclosed quote matches all until end of input. The Matching Example is ready for enclosure in single quotes. Output of Matching Example: [0]=a\n[1]=' b\"\\'b '\n[2]='b2'\n[3]=\"c\\\"'c\"\n[4]=\"d",
        "matches": [
            "a \\' b\"\\\\\\'b \\'\\'b2\\' \"c\\\\\"\\'c\" \"d"
        ],
        "non_matches": [
            "only strings with <1 non-whitespace char"
        ]
    },
    {
        "id": 2631,
        "expression": "^(([0-1][0-9]|2[0-3])[0-5][0-9]\\-([0-1][0-9]|2[0-3])[0-5][0-9]|[C|c]losed)$",
        "description": "This allows for a single line input of open and close times (for a store/office).",
        "matches": [
            "0700-1530",
            "1130-2310",
            "Closed",
            "closed",
            "0000-2359"
        ],
        "non_matches": [
            "0700",
            "Not open",
            "0700-2400",
            "3159-0761"
        ]
    },
    {
        "id": 2634,
        "expression": "\\d{1,2}(/|-)\\d{1,2}(/|-)\\d{2,4}",
        "description": "This is regular expression for date.\neg.:02/06/2010\n2/6/10\n02-06-2010\n2-6-10",
        "matches": [
            "02/06/2010"
        ],
        "non_matches": [
            "02 June 2010"
        ]
    },
    {
        "id": 2635,
        "expression": "^\\.{0,2}[\\/\\\\]",
        "description": "Will match any web path that's supposed to start in the root (e.g. with \"/\" in front of it.",
        "matches": [
            "./some/file.html \\this\\is\\a.file ../blah/blah"
        ],
        "non_matches": [
            "path\\in\\current.folder"
        ]
    },
    {
        "id": 2643,
        "expression": "^([_a-zA-Z0-9-]+(\\.[_a-zA-Z0-9-]+)*@[a-zA-Z0-9-]+(\\.[a-zA-Z0-9-]+)*\\.(([0-9]{1,3})|([a-zA-Z]{2,})))(;[ ]?[_a-zA-Z0-9-]+(\\.[_a-zA-Z0-9-]+)*@[a-zA-Z0-9-]+(\\.[a-zA-Z0-9-]+)*\\.(([0-9]{1,3})|([a-zA-Z]{2,})))*$",
        "description": "Matches a semi-colon-delimited string of email addresses. Delimiter can include a space after the semi-colon. Based on/thanks to David Huyck's pattern, with the domain extension opened up and specific extensions removed.",
        "matches": [
            "jdude@yahoo.com",
            "jdude@yahoo.com; janedoe@hotmail.com",
            "jdude@yahoo.com; janedoe@hotmail.com; billybob@127.0.0.1"
        ],
        "non_matches": [
            "jdudeyahoo.com",
            "jdude@yahoo.com or janedoe@hotmail.com",
            "jdude@yahoo.com, janedoe@hotmail.com, billybob@127.0.0.1"
        ]
    },
    {
        "id": 2648,
        "expression": "^(3[0-1]|2[0-9]|1[0-9]|0[1-9])(0[0-9]|1[0-9]|2[0-3])([0-5][0-9])\\sUTC\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s[0-9]{2}$",
        "description": "In military messages and communications (e.g. on naval charts, or maps showing troop movements) the format is DDHHMMZ Mon YY, so for instance, \"271545Z FEB 08\" represents 15:45 Zulu time (which is to say UTC) on the 27th of February, 2008.\nFor Radio Navigational Warnings (RNWs), the international format is slightly different, using the explicit UTC text instead of the Zulu character, becoming \"DDhhmm UTC Jun YY\". E.g. \"240923 UTC Jun 10\" is \"9:23am on 24th June 2010\".",
        "matches": [
            "312359 UTC Jun 99"
        ],
        "non_matches": [
            "322567 UTC June 1999"
        ]
    },
    {
        "id": 2649,
        "expression": "^[\\w]+[-\\.\\w]*@[-\\w]+\\.[a-z]{2,6}(\\.[a-z]{2,6})?$",
        "description": "@ Before you can have underlined, connection, point character, @there are three points after the characters are not allowed",
        "matches": [
            "abc@cde.com",
            "abd@def.com.cn",
            "a2b_cd3-2fg.ss@a2bd5_sd-mbv.com.cn"
        ],
        "non_matches": [
            "abc@ccddme.my.com.cn"
        ]
    },
    {
        "id": 2654,
        "expression": "^(\\d+\\.\\d+)$",
        "description": "This will validate atleast minimum of one digit in either side of Decimal point",
        "matches": [
            "1.22",
            "12.23",
            "123.123"
        ],
        "non_matches": [
            "1..",
            ".",
            "123.",
            ".213"
        ]
    },
    {
        "id": 2655,
        "expression": "^\\s*[+-]?\\s*(?:\\d{1,3}(?:(,?)\\d{3})?(?:\\1\\d{3})*(\\.\\d*)?|\\.\\d+)\\s*$",
        "description": "Matches numbers. May include decimals, thousands separators, and sign.",
        "matches": [
            "5,000",
            "- 10",
            ".1"
        ],
        "non_matches": [
            "7.000.000",
            "5,0000",
            "1.000,000"
        ]
    },
    {
        "id": 2662,
        "expression": "^([9]{1})([234789]{1})([0-9]{8})$",
        "description": "Its 10 digits Indian Mobile Number validation.",
        "matches": [
            "9829373514"
        ],
        "non_matches": [
            "919829373514",
            "09829373514"
        ]
    },
    {
        "id": 2663,
        "expression": "^([Aa][LKSZRAEPlkszraep]|[Cc][AOTaot]|[Dd][ECec]|[Ff][LMlm]|[Gg][AUau]|[Hh][Ii]|[Ii][ADLNadln]|[Kk][SYsy]|[Ll][Aa]|[Mm][ADEHINOPSTadehinopst]|[Nn][CDEHJMVYcdehjmvy]|[Oo][HKRhkr]|[Pp][ARWarw]|[Rr][Ii]|[Ss][CDcd]|[Tt][NXnx]|[Uu][Tt]|[Vv][AITait]|[Ww][AIVYaivy])$",
        "description": "This is just a simple US states and territories in 2 character regex. Requires valid 2 letter abbreviations. It accepts the Lower and Upper Case Entries.",
        "matches": [
            "MN",
            "tx",
            "Tx"
        ],
        "non_matches": [
            "M",
            "23",
            "Alaska",
            "zz"
        ]
    },
    {
        "id": 2664,
        "expression": "([0-9][0-9])((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))\\-([0-9][0-9])\\-([0-9][0-9][0-9][0-9])",
        "description": "Simple Malaysian New IC Number Validation.\nLength: 8 characters.\nFormat: YYMMDD-99-9999",
        "matches": [
            "900120-01-5567"
        ],
        "non_matches": [
            "909020-01-5567",
            "900120-0A-5567",
            "900120-01-55"
        ]
    },
    {
        "id": 2665,
        "expression": "^([EV])?\\d{3,3}(\\.\\d{1,2})?$",
        "description": "validates an ICD9 medical code which MAY start with an E or V, 3 digits, and MAY be followed by a period and a 1-2 digit sub-code",
        "matches": [
            "123.45",
            "E123.45",
            "V123.45",
            "456.7",
            "E456.7",
            "V456.7",
            "987",
            "E987",
            "V987"
        ],
        "non_matches": [
            "e123",
            "X123",
            "e123.4",
            "e123.45",
            "E12345"
        ]
    },
    {
        "id": 2666,
        "expression": "^([EV])?\\d{3,3}(\\.\\d{1,2})?(, *([EV])?\\d{3,3}(\\.\\d{1,2})?)*$",
        "description": "See my sigle ICD9 validator for ICD9 rules. This does the same, and validates for comma delitter (with optiona space after comma)",
        "matches": [
            "E123",
            "E123.45, V456.6",
            "V456,E987.2, 123.45"
        ],
        "non_matches": [
            "E123V456",
            "E123, x",
            "12;467.789"
        ]
    },
    {
        "id": 2667,
        "expression": "^\\d{4,4}[A-Z0-9]$",
        "description": "a CPT code is a 4 digits + a captial letter or number (forming 5 character code). The CPT code describes a medical procedure",
        "matches": [
            "0001F",
            "21082"
        ],
        "non_matches": [
            "F0123",
            "0001f",
            "100F"
        ]
    },
    {
        "id": 2671,
        "expression": "^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,8}[a-zA-Z0-9]$",
        "description": "This expression will validate user name with the following rules\n1- It must start and end with a digit or character\n2- It must be exactly 4 to 10 character long\n3- Allowed Special Characters are _.-",
        "matches": [
            "1.ma",
            "user",
            "ma_mo-on.r"
        ],
        "non_matches": [
            "_user",
            "asfd@12",
            "user."
        ]
    },
    {
        "id": 2674,
        "expression": "^([0-1]?[0-9]|[2][0-3]):([0-5][0-9]):([0-5][0-9])$",
        "description": "match time for : H:nn:ss or HH:nn:ss",
        "matches": [
            "01:00:59",
            "1:59:00",
            "23:59:59"
        ],
        "non_matches": [
            "24:00:00"
        ]
    },
    {
        "id": 2677,
        "expression": "^(([0-2]\\d|[3][0-1])\\/([0]\\d|[1][0-2])\\/[2][0]\\d{2})$|^(([0-2]\\d|[3][0-1])\\/([0]\\d|[1][0-2])\\/[2][0]\\d{2}\\s00\\:00\\:00)$",
        "description": "This expression will parse the date with zero time span only (e.g. 26/07/2010 00:00:00)",
        "matches": [
            "26/07/2010 00:00:00"
        ],
        "non_matches": [
            "26/07/2010 10:00:00",
            "26/07/2010 10:34:14"
        ]
    },
    {
        "id": 2679,
        "expression": "[-+]?((\\.[0-9]+|[0-9]+\\.[0-9]+)([eE][-+][0-9]+)?|[0-9]+)",
        "description": "Used in my SVG parser.\nExplanation:\nMay start with + or -. This is followed by either an integer, or a float (\"dot numbers\", \"numbers dot numbers\" or \"numbers dot\" followed by an optional scientific postfix (+ or - followed by numbers) )\nI'm using it to parse lists of floats, add ^$ boundaries if you want it to match whole lines.",
        "matches": [
            "10.2",
            ".0",
            "3.9265e+2",
            "5"
        ],
        "non_matches": [
            "-one",
            ".",
            "whatever"
        ]
    },
    {
        "id": 2682,
        "expression": "(?<=(,|;|:))\\s(?=((?:(?!<).)*>))",
        "description": "Needing a way to shrink HTML based email to the smallest amount of characters, we wanted to remove any extra unnecessary white space characters in attributes such as style. This finds any space with a proceeding comma, semi-colon, or colon, and then checks with a lookahead for the closing > with a negative lookbehind to make sure that a < opening does not exist. The secondary trailing look behind is done to make sure that it does not change any content contained in the element.",
        "matches": [
            "<table width=\"750px\" cellpadding=\"0\" cellspacing=\"0\" style=\"font-family: Arial , Helvetica , Sans-Serif ; font-size: 10pt;\">"
        ],
        "non_matches": [
            "<td>1, 2, 3</td>"
        ]
    },
    {
        "id": 2683,
        "expression": "(\\d{2}\\.\\d{3}\\.\\d{3}\\/\\d{4}\\-\\d{2})|(\\d{3}\\.\\d{3}\\.\\d{3}\\-\\d{2})",
        "description": "Valida e mascara CNPJ ou CPF dependendo do valor informado. Se informado dois digitos mais o ponto, ser\u00e1 mascarado CNPJ se nao , CPF",
        "matches": [
            "12.123.123/1234-11",
            "123.123.123-12"
        ],
        "non_matches": [
            "qualquer letra"
        ]
    },
    {
        "id": 2684,
        "expression": "^([1-9]+\\d{0,2},(\\d{3},)*\\d{3}(\\.\\d{1,2})?|[1-9]+\\d*(\\.\\d{1,2})?)$",
        "description": "Accepts non-negative numbers with max two decimals. Commas can be added after every thousand.",
        "matches": [
            "1200",
            "1,200",
            "1,200.0",
            "12,324,532.23"
        ],
        "non_matches": [
            "-43",
            "0",
            "01,423,534.23",
            "24.4223",
            "32,42,123"
        ]
    },
    {
        "id": 2687,
        "expression": "jquery\\-(\\d|\\.)*\\.min\\.js",
        "description": "Checks for filename of any version of minified jquery in string.",
        "matches": [
            "jquery-1.4.2.min.js"
        ],
        "non_matches": [
            "jquery.js, jquery-1.3.2.js"
        ]
    },
    {
        "id": 2694,
        "expression": "(http|ftp|https):\\/\\/(\\w[\\w\\-_\\.]*\\.)?([_\\-\\w]+)(:[0-9]+)?([\\/[\\w_\\.-]+]*)\\/(\\.?\\w[\\w._-]*[\\w_-])?(#\\w+)?([\\w\\-\\.,@?^=%&amp;:\\~\\+#]*[\\w\\-\\@?^=%&amp;\\/\\~\\+#])?",
        "description": "divides an url into the different parts: protocol, subdomain, tld, port, folder, file, anchor, parameter",
        "matches": [
            "http://www.example.com/folder/file.php#anchor?parameter=value"
        ],
        "non_matches": [
            "www.example.com"
        ]
    },
    {
        "id": 2696,
        "expression": "^\\s*((31([-/ ])((0?[13578])|(1[02]))\\3(\\d\\d)?\\d\\d)|((([012]?[1-9])|([123]0))([-/ ])((0?[13-9])|(1[0-2]))\\12(\\d\\d)?\\d\\d)|(((2[0-8])|(1[0-9])|(0?[1-9]))([-/ ])0?2\\22(\\d\\d)?\\d\\d)|(29([-/ ])0?2\\25(((\\d\\d)?(([2468][048])|([13579][26])|(0[48])))|((([02468][048])|([13579][26]))00))))\\s*$",
        "description": "This .NET regular expression matches all valid dates in dd/MM/yyyy , dd-MM-yyyy or dd MM yyyy formats between 1/1/0000 and 31/12/9999 with the leading zero for the day and month portions being optional. The century for the year is optional for all dates except for the 29th of February of century years divisible by 400. This expression also validates the 29th of February for leap years, defined as (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0).",
        "matches": [
            "29-2-2000",
            "31/12/9999",
            "1 1 0000",
            "29/02/0000",
            "8/3/9841"
        ],
        "non_matches": [
            "29/2/1900",
            "29/02/2001",
            "31/04/2000",
            "28/02-1934",
            "1/13/1978"
        ]
    },
    {
        "id": 2699,
        "expression": "^[0-9]*[1-9]+[0-9]*$",
        "description": "Allows only positive integers that are greater than 0. Also allows for infinite zeros leading the integer\nBased on William Powell's Pattern Title, but modified to allow for leading zeros.",
        "matches": [
            "1",
            "12",
            "124",
            "01",
            "0012",
            "000124"
        ],
        "non_matches": [
            "-1",
            "a",
            "1.0",
            "0000"
        ]
    },
    {
        "id": 2700,
        "expression": "^([A-Za-z]{6}[0-9lmnpqrstuvLMNPQRSTUV]{2}[abcdehlmprstABCDEHLMPRST]{1}[0-9lmnpqrstuvLMNPQRSTUV]{2}[A-Za-z]{1}[0-9lmnpqrstuvLMNPQRSTUV]{3}[A-Za-z]{1})|([0-9]{11})$",
        "description": "Pattern to verify Codice Fiscale Italiano (TIN, Tax Identification Number).\nInclude verification of Codice Fiscale to natural, artificial, legal and juristic person, with and without OMOCODIA (verifica del codice fiscale per persone fisiche e persone giuridiche, anche in caso di omocodia).\nCodice Fiscale, CF, omocodia, persone fisiche, persone giuridiche, italian fiscal code, TIN, Tax Identification Number.",
        "matches": [
            "VRDGPP13R10B293P",
            "VRDGPP13R10B29PP",
            "12345678901"
        ],
        "non_matches": [
            "VRDGPP13R10B293",
            "VRDGPP13R10B29BP",
            "1234567890"
        ]
    },
    {
        "id": 2701,
        "expression": "^[0-9a-zA-Z]+([0-9a-zA-Z]*[-._+])*[0-9a-zA-Z]+@[0-9a-zA-Z]+([-.][0-9a-zA-Z]+)*([0-9a-zA-Z]*[.])[a-zA-Z]{2,6}$",
        "description": "Pattern to verify email addresses. Take a look at match / not match. It works very well. E-mail, email, mail, e-mail address, email address, mail address.",
        "matches": [
            "john-smith@example.com",
            "john.smith@example.com",
            "john_smith@x-ample.com"
        ],
        "non_matches": [
            ".john-smith@example.com",
            "@example.com",
            "johnsmith@example."
        ]
    },
    {
        "id": 2703,
        "expression": "[0](\\d{9})|([0](\\d{2})( |-|)((\\d{3}))( |-|)(\\d{4}))|[0](\\d{2})( |-|)(\\d{7})|(\\+|00|09)(\\d{2}|\\d{3})( |-|)(\\d{2})( |-|)((\\d{3}))( |-|)(\\d{4})",
        "description": "allows validation of phone numbers in different formats, including local dialing code (eg 033 or 076) or international dialing code in the formats +12 or 0012 or 0912.",
        "matches": [
            "073-386-2612",
            "0443862612",
            "076 858 7777",
            "+27 76 858 7777",
            "0027 765877777",
            "0956 33 8881234"
        ],
        "non_matches": [
            "qdsq11123"
        ]
    },
    {
        "id": 2707,
        "expression": "<img\\s((width|height|alt|align|style)=\"[^\"]*\"\\s)*src=\"(\\/?[a-z0-9_-]\\/?)+\\.(png|jpg|jpeg|gif)\"(\\s(width|height|alt|align|style)=\"[^\"]*\")*\\s*\\/>",
        "description": "Will match an image with the most common attributes.",
        "matches": [
            "<img width=\"80\" height=\"80\" style=\"border: none\" src=\"img/fluffy.jpg\" alt=\"cat\"/>"
        ],
        "non_matches": [
            "<img src=\"img/fluffy\" >"
        ]
    },
    {
        "id": 2708,
        "expression": "(([+]?34) ?)?(6(([0-9]{8})|([0-9]{2} [0-9]{6})|([0-9]{2} [0-9]{3} [0-9]{3}))|9(([0-9]{8})|([0-9]{2} [0-9]{6})|([1-9] [0-9]{7})|([0-9]{2} [0-9]{3} [0-9]{3})|([0-9]{2} [0-9]{2} [0-9]{2} [0-9]{2})))",
        "description": "This regular expression allows to verify mobile phone numbers (600) and telephone numbers (900). Not provide premium charging phones (line 800). The number may be separated by spaces in groups of three digits, or one group of three number plus two groups of three numbers for fixed phones.",
        "matches": [
            "952 566 009",
            "+34 615 977 911",
            "967 90 23 44"
        ],
        "non_matches": [
            "802 59 23 09",
            "677 90 23 44",
            "67 7 809 235"
        ]
    },
    {
        "id": 2710,
        "expression": "^([1-9][0-9]?|100)%$",
        "description": "Matches a percentage between 1 and 100. Accepts up to 2 decimal places. No decimal places accepted.",
        "matches": [
            "1%",
            "52%",
            "100%"
        ],
        "non_matches": [
            "0%",
            "100",
            "101%",
            "52",
            "52.4%"
        ]
    },
    {
        "id": 2714,
        "expression": "(\\<!--\\s*.*?((--\\>)|$))",
        "description": "matches comments <!-- --> in string. Singleline option must be enabled. It works well also with multiple comment start tags such as: <!--this is comment <!--and this as well and end-- of comment\nis!-- >right now-->. It also matches comments in between script or style tags <script> <!-- --> </script>",
        "matches": [
            "<!-- comment <!-- continuing -- >and ends now-->"
        ],
        "non_matches": [
            "< !-- not comment -->, <a href=\"--\">, all other html code"
        ]
    },
    {
        "id": 2715,
        "expression": "(\\<\\?php\\s+.*?((\\?\\>)|$))",
        "description": "Get code in between php tag <?php and ?> or until end of string if end of tag not found. Singleline option must be enabled!",
        "matches": [
            "<?php this is code in php ?>"
        ],
        "non_matches": [
            "text outside php tag"
        ]
    },
    {
        "id": 2725,
        "expression": "(?!000)(?!666)^([0-8]\\d{2})(\\d{2})(\\d{4})$",
        "description": "Validates SSN for INTEGERS ONLY. This does not allow spaces or dashes.\nFollowing this info:\nhttp://www.socialsecurity.gov/employer/randomization.html\nStarting in June 2011, the SSA will begin randomizing SSN creation. The only exclusions are SSNs beginning with 000, 666, or 900-999. That rather simplifies things.",
        "matches": [
            "001191873",
            "667191873",
            "899191873"
        ],
        "non_matches": [
            "000191873",
            "666191873",
            "901191873"
        ]
    },
    {
        "id": 2727,
        "expression": "^[^'<>?%!\\s]{1,20}$",
        "description": "Disallow ' or < or > or ? or % or ! or space in a string. Minimum character is 1 and maximum is 20 in a string.",
        "matches": [
            "abcd123",
            "--+abc"
        ],
        "non_matches": [
            "abc'123",
            "abc?",
            "abc abc",
            "<script>"
        ]
    },
    {
        "id": 2735,
        "expression": "^([0-9][0-9])[.]([0-9][0-9])[.]([0-9][0-9])$",
        "description": "Versioning in XX.YY.ZZ format",
        "matches": [
            "01.02.23"
        ],
        "non_matches": [
            "1.2.3"
        ]
    },
    {
        "id": 2740,
        "expression": "[\\\\\"\"=/>](25[0-4]|2[0-4][0-9]|1\\d{2}|\\d{2})\\.((25[0-4]|2[0-4][0-9]|1\\d{2}|\\d{1,2})\\.){2}(25[0-4]|2[0-4][0-9]|1\\d{2}|\\d{2}|[1-9])\\b[\\\\\"\"=:;,/<]",
        "description": "This expression is ideal used for \"identifying some plain application configuration files that contain any form of ip addresses, with or without port number followed and with protocol at the beginning\".\n[\\\\\"\"=/] can be removed on both ends to seach IPs in text files, but with it, it has better accuracy - there are version numbers in the application configuration files.\nIt also does not match IPs that have one digit at the first number.",
        "matches": [
            "/172.21.134.89: /127.0.0.1: \"14.14.14.14\""
        ],
        "non_matches": [
            "\"255.255.255.255\" \"243.243.2.0\" \"2.222.222.222\" /2224.2224.2224.2224:"
        ]
    },
    {
        "id": 2742,
        "expression": "\\b(1(?!27\\.0\\.0\\.1)\\d{1,2}|2[0-4][0-9]|25[0-4]|\\d{1,2})\\.(?:\\d{1,3}\\.){2}(25[0-5]|2[0-4][0-9]|1\\d{2}|\\d{2}|[1-9])\\b",
        "description": "Match all IP addresses other than 127.0.0.1. It dose not match an IP has 0 at the last number",
        "matches": [
            "172.21.134.89 127.1.1.1 7.0.0.1 214.214.214.214"
        ],
        "non_matches": [
            "127.0.0.1 192.168.1.0 255.255.255.255"
        ]
    },
    {
        "id": 2743,
        "expression": "[\\\\\"\"=:;,](([\\w][\\w\\-\\.]*)\\.)?([\\w][\\w\\-]+)(\\.([\\w][\\w\\.]*))?\\\\sql\\d{1,3}[\\\\\"\"=:;,]",
        "description": "This expression is ideal used for \"identifying some plain application configuration files that contain any form of MSSQL database/instance reference in connection string\". Dose not match .\\sql. [\\\\\"\"=/] can be removed on both ends to seach server/instance in text files, but with it, it has better accuracy",
        "matches": [
            "=abc\\sql022, =abc.e.f.g\\sql078, =192.168.1.1\\sql001, =234\\sql003,"
        ],
        "non_matches": [
            "sql .\\sql003"
        ]
    },
    {
        "id": 2750,
        "expression": "(^\\d{1,9})+(,\\d{1,9})*$",
        "description": "Positive Whole number matched from 0 to 9999999. Only 9 digits length is allowed in every comma separated value.Can be easily changed to modify the length of the comma separated values.",
        "matches": [
            "123,158,19",
            "123456789,9568523,1",
            "1,2,3"
        ],
        "non_matches": [
            "0,0,",
            ",3444,0999",
            "1234567890,25689,1425"
        ]
    },
    {
        "id": 2753,
        "expression": "^(((19|2\\d)\\d{2}\\/(((0?[13578]|1[02])\\/31)|((0?[1,3-9]|1[0-2])\\/(29|30))))|((((19|2\\d)(0[48]|[2468][048]|[13579][26])|(2[048]00)))\\/0?2\\/29)|((19|2\\d)\\d{2})\\/((0?[1-9])|(1[0-2]))\\/(0?[1-9]|1\\d|2[0-8]))$",
        "description": "this expression validates a date-time field in yyyy/m/d format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1900-2999, and all 2 digits years except 00",
        "matches": [
            "2008/2/29",
            "2010/12/31",
            "2400/02/29"
        ],
        "non_matches": [
            "2009/2/29",
            "2010/11/31",
            "2100/02/29"
        ]
    },
    {
        "id": 2754,
        "expression": "^(((1[6-9]|[2-9]\\d)\\d{2}\\/(((0?[13578]|1[02])\\/31)|((0?[1,3-9]|1[0-2])\\/(29|30))))|((((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))\\/0?2\\/29)|((1[6-9]|[2-9]\\d)\\d{2})\\/((0?[1-9])|(1[0-2]))\\/(0?[1-9]|1\\d|2[0-8]))$",
        "description": "this expression validates a date-time field in yyyy/m/d format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00",
        "matches": [
            "2008/2/29",
            "2010/12/31",
            "2400/02/29"
        ],
        "non_matches": [
            "2009/2/29",
            "2010/11/31",
            "2100/02/29"
        ]
    },
    {
        "id": 2755,
        "expression": "^(((1[6-9]|[2-9]\\d)\\d{2}([-|\\/])(((0?[13578]|1[02])([-|\\/])31)|((0?[1,3-9]|1[0-2])([-|\\/])(29|30))))|((((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))([-|\\/])0?2([-|\\/])29)|((1[6-9]|[2-9]\\d)\\d{2})([-|\\/])((0?[1-9])|(1[0-2]))([-|\\/])(0?[1-9]|1\\d|2[0-8]))$",
        "description": "this expression validates a date-time field in yyyy/m/d or yyyy-m-d format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00",
        "matches": [
            "2008/2/29",
            "2010/12/31",
            "2400-02-29"
        ],
        "non_matches": [
            "2009/2/29",
            "2010/11/31",
            "2100-02-29"
        ]
    },
    {
        "id": 2756,
        "expression": "^(((1[6-9]|[2-9]\\d)\\d{2}([-|\\/])(((0?[13578]|1[02])([-|\\/])31)|((0?[1,3-9]|1[0-2])([-|\\/])(29|30))))|((((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))([-|\\/])0?2([-|\\/])29)|((1[6-9]|[2-9]\\d)\\d{2})([-|\\/])((0?[1-9])|(1[0-2]))([-|\\/])(0?[1-9]|1\\d|2[0-8]))(\\s)((([0]?[1-9]|1[0-2])(:|\\.)[0-5][0-9]((:|\\.)[0-5][0-9])?(\\s)?([aApP][mM]))|(([0]?[0-9]|1[0-9]|2[0-3])(:|\\.)[0-5][0-9]((:|\\.)[0-5][0-9])?))$",
        "description": "this expression validates a date-time field in yyyy/m/d h:m:s or yyyy-m-d h:m:s format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00.\nMatches times seperated by either : or . will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.",
        "matches": [
            "2008/2/29 8:25:59",
            "2010/12/31 11:25AM",
            "2400-02-29 09:30"
        ],
        "non_matches": [
            "2009/2/29 8:25:59",
            "2010/11/31 11:25AM",
            "2100-02-29 09:30"
        ]
    },
    {
        "id": 2757,
        "expression": "^(0?[1-9]|[12][0-9]|3[01])[- /.](0?[1-9]|1[012])[- /.](19|20)?[0-9]{2}? ?((([0-1]?\\d)|(2[0-3])):[0-5]\\d)?(:[0-5]\\d)? ?([a,p,A,P][m,M])?$",
        "description": "Regex to match date and or time either in 12 or 24 hour format.\nIt will also allow for am/pm with mixed cases.",
        "matches": [
            "31-12-2010 14:15:22",
            "1.1.2010 00:00:00",
            "2/1/2010",
            "31/1/2011 05:22 pm"
        ],
        "non_matches": [
            "1.31.2011",
            "31.1.2011 1455",
            "31.1.2011 14 pm"
        ]
    },
    {
        "id": 2761,
        "expression": "^([1-9]\\d*|0)(([.,]\\d*[1-9])?)$",
        "description": "Positive real multi-digit number: don't allow preciding zero, last decimal digit zero not allowed.",
        "matches": [
            "1500",
            "0,331",
            "12.005"
        ],
        "non_matches": [
            "01500",
            "0,330",
            "012.0050"
        ]
    },
    {
        "id": 2762,
        "expression": "^[^<>`~!/@\\#},.?\"-$%:;)(_ ^{&*=|'+]+$",
        "description": "This regular expression will remove all invalid chars from a string",
        "matches": [
            "AdnanSattar"
        ],
        "non_matches": [
            "Adnan=Sattar"
        ]
    },
    {
        "id": 2763,
        "expression": "^[a-zA-Z]{1}[\\w\\sa-zA-Z\\d_]*[^\\s]$",
        "description": "Username start only with alphabet, and then can combine with any digit, space, and underscore. Reject other special character and space in the begin and the end of characters.",
        "matches": [
            "Dodol 123",
            "Dodol_garut",
            "dodol li pret 5 kali"
        ],
        "non_matches": [
            "23dodol",
            "_dodol garut",
            "dodol . / d"
        ]
    },
    {
        "id": 2764,
        "expression": "^(\\d+(,\\d+)*)+$",
        "description": "Evaluates an 'n' series of non decimal numbers separated by a coma",
        "matches": [
            "1",
            "1,2,3,4,5",
            "1234,54321,0987654321"
        ],
        "non_matches": [
            ",1",
            "1,2,3,",
            "1.2,2.3,3"
        ]
    },
    {
        "id": 2768,
        "expression": "^(?-i:A[DEFGILMNOQRSTUWZ]|B[ABDEFGHIJMNORSTVWYZ]|C[ACDFGHIKLMNORSUVXYZ]|D[EJKMOZ]|E[CEGHRST]|F[IJKMOR]|G[ABDEFHILMNPQRSTUWY]|H[KMNRTU]|I[DELNOQRST]|J[MOP]|K[EGHIMNPRWYZ]|L[ABCIKRSTUVY]|M[ACDGHKLMNOPQRSTUVWXYZ]|N[ACEFGILOPRUZ]|O[M]|P[AEFGHKLMNRSTWY]|QA|R[EOUW]|S[ABCDEGHIJKLMNORTVYZ]|T[CDFGHJKLMNORTVWZ]|U[AGMSYZ]|V[ACEGINU]|W[FS]|Y[ET]|Z[AMW])$",
        "description": "Matches against the two character country abbreviations (as of 2010).\n\"AD\",\"AE\",\"AF\",\"AG\",\"AI\",\"AL\",\"AM\",\"AN\",\"AO\",\"AQ\",\"AR\",\"AS\",\"AT\",\"AU\",\"AW\",\"AZ\",\"BA\",\"BB\",\"BD\",\"BE\",\"BF\",\"BG\",\"BH\",\"BI\",\"BJ\",\"BM\",\"BN\",\"BO\",\"BR\",\"BS\",\"BT\",\"BV\",\"BW\",\"BY\",\"BZ\",\"CA\",\"CC\",\"CD\",\"CF\",\"CG\",\"CH\",\"CI\",\"CK\",\"CL\",\"CM\",\"CN\",\"CO\",\"CR\",\"CS\",\"CU\",\"CV\",\"CX\",\"CY\",\"CZ\",\"DE\",\"DJ\",\"DK\",\"DM\",\"DO\",\"DZ\",\"EC\",\"EE\",\"EG\",\"EH\",\"ER\",\"ES\",\"ET\",\"FI\",\"FJ\",\"FK\",\"FM\",\"FO\",\"FR\",\"GA\",\"GB\",\"GD\",\"GE\",\"GF\",\"GH\",\"GI\",\"GL\",\"GM\",\"GN\",\"GP\",\"GQ\",\"GR\",\"GS\",\"GT\",\"GU\",\"GW\",\"GY\",\"HK\",\"HM\",\"HN\",\"HR\",\"HT\",\"HU\",\"ID\",\"IE\",\"IL\",\"IN\",\"IO\",\"IQ\",\"IR\",\"IS\",\"IT\",\"JM\",\"JO\",\"JP\",\"KE\",\"KG\",\"KH\",\"KI\",\"KM\",\"KN\",\"KP\",\"KR\",\"KW\",\"KY\",\"KZ\",\"LA\",\"LB\",\"LC\",\"LI\",\"LK\",\"LR\",\"LS\",\"LT\",\"LU\",\"LV\",\"LY\",\"MA\",\"MC\",\"MD\",\"MG\",\"MH\",\"MK\",\"ML\",\"MM\",\"MN\",\"MO\",\"MP\",\"MQ\",\"MR\",\"MS\",\"MT\",\"MU\",\"MV\",\"MW\",\"MX\",\"MY\",\"MZ\",\"NA\",\"NC\",\"NE\",\"NF\",\"NG\",\"NI\",\"NL\",\"NO\",\"NP\",\"NR\",\"NU\",\"NZ\",\"OM\",\"PA\",\"PE\",\"PF\",\"PG\",\"PH\",\"PK\",\"PL\",\"PM\",\"PN\",\"PR\",\"PS\",\"PT\",\"PW\",\"PY\",\"QA\",\"RE\",\"RO\",\"RU\",\"RW\",\"SA\",\"SB\",\"SC\",\"SD\",\"SE\",\"SG\",\"SH\",\"SI\",\"SJ\",\"SK\",\"SL\",\"SM\",\"SN\",\"SO\",\"SR\",\"ST\",\"SV\",\"SY\",\"SZ\",\"TC\",\"TD\",\"TF\",\"TG\",\"TH\",\"TJ\",\"TK\",\"TL\",\"TM\",\"TN\",\"TO\",\"TR\",\"TT\",\"TV\",\"TW\",\"TZ\",\"UA\",\"UG\",\"UM\",\"US\",\"UY\",\"UZ\",\"VA\",\"VC\",\"VE\",\"VG\",\"VI\",\"VN\",\"VU\",\"WF\",\"WS\",\"YE\",\"YT\",\"ZA\",\"ZM\",\"ZW\"",
        "matches": [
            "US",
            "CA",
            "MX"
        ],
        "non_matches": [
            "NX",
            "12",
            "USA"
        ]
    },
    {
        "id": 2780,
        "expression": "^(\\+48\\s*)?\\d{2}\\s*\\d{3}(\\s*|\\-)\\d{2}(\\s*|\\-)\\d{2}$",
        "description": "Polish stationary phone number. Mask +48 XX XXXXXXX\nor +48 XX-XXX-XX-XX or +48 XXXXXXXXX",
        "matches": [
            "+48222222222",
            "+48 22 3333333",
            "+48 22 842 33 33"
        ],
        "non_matches": [
            "+48-22-2222222",
            "+49 22 222222"
        ]
    },
    {
        "id": 2781,
        "expression": "^((\\d{3}[- ]\\d{3}[- ]\\d{2}[- ]\\d{2})|(\\d{3}[- ]\\d{2}[- ]\\d{2}[- ]\\d{3}))$",
        "description": "allow to insert input for polish tax identyfication number (NIP). Mask accepted:\nXXX-XX-XX-XXX ; XXX-XXX-XX-XX ; XXX XX XX XXX ; XXX XXX XX XX",
        "matches": [
            "222-22-22-222",
            "222-222-22-22",
            "222 22 22 222",
            "222 222 22 22"
        ],
        "non_matches": [
            "2222222222",
            "XXXXXXXXXX"
        ]
    },
    {
        "id": 2788,
        "expression": "^[1]?[-\\.\\s]?(\\(\\d{3}\\)|\\d{3}){1}[-\\.\\s]?\\d{3}[-\\.\\s]?\\d{4}(\\s+|\\s*[-\\.x]{1}\\d{1,6})?$",
        "description": "This expression will match a 10 or 11 digit US phone number with optional area code parenthesis, non-standard seperators such as spaces or dot's (.), and an extension up to 6 digits long",
        "matches": [
            "(800) 555-1212",
            "999.555.1212 x1234",
            "19995551212x123456"
        ],
        "non_matches": [
            "555-1212",
            "(800 555-1212",
            "888...555-1212"
        ]
    },
    {
        "id": 2790,
        "expression": "[0-9]{1,2}[:|\u00b0|\u00ba][0-9]{1,2}[:|'](?:\\b[0-9]+(?:\\.[0-9]*)?|\\.[0-9]+\\b)\"?[N|S|E|W]",
        "description": "This is a slightly modified version of Kurt's DMS Coordinate regex so all the credit should go to Kurt - I just modified it to match a second character that may commonly be used to represent degrees",
        "matches": [
            "37\u00ba41'26\"N,97\u00ba20'0\"W (comma delimited, commas do not match...obviously :)"
        ],
        "non_matches": [
            "\u221e , \u03c6, \u03c0 ....etc.... see Kurt's documentation"
        ]
    },
    {
        "id": 2797,
        "expression": "^([0-9A-F]{2}[:-]){5}([0-9A-F]{2})$",
        "description": "This regular expression will validate against a valid MAC address. The 6 bytes are hexadecimal and separated by semi colon or dash caracters.",
        "matches": [
            "01:23:45:67:89:AB"
        ],
        "non_matches": [
            "01:23:45:67:89:X9"
        ]
    },
    {
        "id": 2799,
        "expression": "^[+]?((\\d*[1-9]+\\d*\\.?\\d*)|(\\d*\\.\\d*[1-9]+\\d*))$",
        "description": "Matches any positive decimal number > 0 with optional leading '+' symbol and optional leading or trailing zeros on both sides of the decimal point. Decimal point is also optional and either side of the decimal is optional.",
        "matches": [
            "010",
            "010.",
            ".010",
            "010.010"
        ],
        "non_matches": [
            ".",
            "0",
            "0.",
            ".0",
            "0.0",
            "0.00",
            "00.0",
            "00.00",
            "-0",
            "-1",
            "a"
        ]
    },
    {
        "id": 2803,
        "expression": "\\b[A-Z0-9]{5}\\d{1}[01567]\\d{1}([0][1-9]|[12][0-9]|[3][0-1])\\d{1}[A-Z0-9]{3}[A-Z]{2}\\b",
        "description": "Matches the UK Drivers License format:\ni. Must be 16 characters\nii. First 5 characters are alphanumeric.\niii. Next 6 characters must be numeric\niv. Next 3 characters are alphanumeric\nv. Last 2 characters are alpha\nvi. Second character of numeric section can only be 0, 1, 5 or 6. 7.\nFourth and fifth characters of numeric section must be in the range 01 to 31.",
        "matches": [
            "SASAS701062AB8DD ASD12405315AA4AA ABCDE101010XY9AA"
        ],
        "non_matches": [
            "SASAS701062AB8D ASD12405315AA4A ABCDE101010XY9A ABD2A121010AM9FA ABCDE101010XY9A9 AbCdE711215GG9aa AFG98101010AM9Fa SSSSS841215SS9SS AFG98101000AM9FA AF\u00ac98101010AM9FA ABC99808275m99sc ABC99808275m99sca ABC99808275m99scsd ABCDE654321A98"
        ]
    },
    {
        "id": 2809,
        "expression": "^[a-zA-Z][a-zA-Z\\-' ]*[a-zA-Z ]$",
        "description": "Check for person name in database for example.\nA person name is a string compound of letters in upper or lower case and three more typographical characters, the hyphen (-), the simple quote or apostrophe (') and the space. For these three characters, not at the beginning or the end of the string.",
        "matches": [
            "Pierre-Francis d'Astier de Weyergans-Migery",
            "Jeanne d'Arc",
            "Nicolas Sarkozy",
            "Charles de Gaulle",
            "Dominique Strauss-Kahn"
        ],
        "non_matches": [
            "-tutu",
            "tutu-",
            "'tutu",
            "tutu'",
            "tu1tu",
            "tu*tu",
            "1tutu",
            "tutu*"
        ]
    },
    {
        "id": 2812,
        "expression": "^([1-9]|1[0-2]|0[1-9]){1}(:[0-5][0-9][ ][aApP][mM]){1}$",
        "description": "This will validate 12 hours time format with AM/am PM/pm",
        "matches": [
            "11:11 AM",
            "01:11 PM",
            "12:59 AM"
        ],
        "non_matches": [
            "21:11 AM",
            "00:00 PM",
            "10:70 AM",
            "10:50PM"
        ]
    },
    {
        "id": 2814,
        "expression": "^((61|\\+61)?\\s?)04[0-9]{2}\\s?([0-9]{3}\\s?[0-9]{3}|[0-9]{2}\\s?[0-9]{2}\\s?[0-9]{2})$",
        "description": "Validates an Australian mobile telephone number that can include an international prefix and four plus (two or three-digit) grouping.\nI use it in ASP.NET MVC DataAnnotations [RegularExpression()] attributes where I don't get to easily strip out spaces beforehand.",
        "matches": [
            "0418123456",
            "0411 123 456",
            "0414 12 34 56",
            "61 0401 123 456",
            "+61 0418 12 34 56"
        ],
        "non_matches": [
            "0418 1 23 45 6",
            "04 01 123456",
            "+62 0418 12 34 56"
        ]
    },
    {
        "id": 2816,
        "expression": "(((^[>]?1.0)(\\d)?(\\d)?)|(^[<]?1.0(([1-9])|(\\d[1-9])|([1-9]\\d)))|(^[<]?1.4(0)?(0)?)|(^[<>]?1.(([123])(\\d)?(\\d)?)))$",
        "description": "Range validator for urine lab panel specific gravity. The valid range is 1.000 to 1.400 inclusive. Sometimes < and > are used but not in the context of <1.000 nor >1.400. To 1, 2 or 3 decimals. Normal range is 1.003 to 1.03 but is left to the viewer.",
        "matches": [
            ">1.0",
            "<1.001",
            ">1.399"
        ],
        "non_matches": [
            ">1.400",
            "1.",
            "1.0011"
        ]
    },
    {
        "id": 2818,
        "expression": "(\\'([^\\'\\\\]*\\\\.)*[^\\'\\\\]*\\')+",
        "description": "Matches mysql single-quoted string literals. double quotes and backslashed quotes are recognised.",
        "matches": [
            "'this is ''a'' string\\n with \\'embedded\\' quotes'"
        ],
        "non_matches": [
            "'a string \\'without\\' terminator"
        ]
    },
    {
        "id": 2822,
        "expression": "[1-9][0-9]{3}[ ]?(([a-rt-zA-RT-Z][a-zA-Z])|([sS][bce-rt-xBCE-RT-X]))",
        "description": "Most RegExpr for dutch zip codes are too simple. For historic reasons, the two-letter combinations SS, SA and SD are not allowed.\nThere should be one space between the numbers and letters, but I allow any number of spaces. Also I allow lowercase. In the early days of dutch zip codes, some letters were not allowed to avoid confusion (F,I,Q, O etc). Nowadays, they are not excluded anymore, because we ran out of letter combinations.\nIt should be easy to make the RegExpr more strict, by prescribing ONE mandatory space and allowing only uppercase.",
        "matches": [
            "1234HG",
            "3454 FG",
            "1000 AA",
            "3456 sg"
        ],
        "non_matches": [
            "0987 SE",
            "8767 SD",
            "6756 ss"
        ]
    },
    {
        "id": 2827,
        "expression": "^(((0?[1-9]|1\\d|2[0-8])|(0?[13456789]|1[012])/(29|30)|(0?[13578]|1[02])/31)/(0?[1-9]|1[012])/(19|[2-9]\\d)\\d{2}|0?29/0?2/((19|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|(([2468][048]|[3579][26])00)))$",
        "description": "DD/MM/YYYY with leap year detection as most of the date regex are in MM/DD/YYYY format. Allows MM and DD to be 1 or 2 digits, eg. D/M/YYYY, D/MM/YYYY or DD/M/YYYY",
        "matches": [
            "21/01/1972",
            "21/1/1972",
            "1/1/1972",
            "29/2/2012",
            "29/02/2012"
        ],
        "non_matches": [
            "21-01-1972",
            "21-01-1972",
            "29/02/2011"
        ]
    },
    {
        "id": 2832,
        "expression": "^http[s]?://twitter\\.com/(#!/)?[a-zA-Z0-9]{1,15}[/]?$",
        "description": "Allows http and https, bans www prefix, username portion is clamped to the rules it gives you at signup and also allows an optional trailing slash. [UPDATED] allows the #! notation that twitter used.",
        "matches": [
            "http://twitter.com/rtpharry/",
            "http://twitter.com/rtpharry",
            "https://twitter.com/rtpharry/",
            "https://twitter.com/rtpharry",
            "http://twitter.com/#!/rtpharry/"
        ],
        "non_matches": [
            "http://www.twitter.com/wwwprefix/",
            "http://twitter.com/longerthan15characters/",
            "http://twitter.com/illegal$chars/"
        ]
    },
    {
        "id": 2833,
        "expression": "(?=^.{1,}$)(?!.*\\s)[0-9a-zA-Z!@#$%*()_+^&\\[\\]]*$",
        "description": "Regular Expression which does not allow SPACE but allows every possible alpha-numeric and special characters.",
        "matches": [
            "abc*()A123",
            "12xyz[_]"
        ],
        "non_matches": [
            "no space",
            "abc *0123[]"
        ]
    },
    {
        "id": 2835,
        "expression": "^(([0-9]{2,4})([-\\s\\/]{0,1})([0-9]{4,8}))?$",
        "description": "validate mobile and land phone numbers.\nAllow space - / or nothing number and area codes",
        "matches": [
            "02/583725",
            "3471231231",
            "02 12345678"
        ],
        "non_matches": [
            "+3902/583725",
            "0 2998765",
            "02 996 876"
        ]
    },
    {
        "id": 2836,
        "expression": "\\b(?!000)(?!666)(?!9)[0-9]{3}[ -]?(?!00)[0-9]{2}[ -]?(?!0000)[0-9]{4}\\b",
        "description": "Finds 9 digit numbers within word boundaries, not separated or separated by - or space, not starting with 000, 666, or 900-999, not containing 00 or 0000 in the middle or at the end of SSN (in compliance with current SSN rules).",
        "matches": [
            "123-45-6789, 123 45 6789, 123456789, 123-45 6789, 123-456789, 123 456789, etc."
        ],
        "non_matches": [
            "000-45-6789, 666-45-6789, 123-00-6789, 123-45-0000, 900-45-6789 through 999-45-6789"
        ]
    },
    {
        "id": 2841,
        "expression": "&amp;#([0-9]{1,5}|x[0-9a-fA-F]{1,4});",
        "description": "Find all html encoded characters as dec &amp;#[0-9]{1,5}; or hex &amp;#x[0-9a-fA-F]{1,4}; values. Remember to remove \"amp;\" which is used for making this post possible.",
        "matches": [
            "&amp;#160;",
            "&amp;#xa0;"
        ],
        "non_matches": [
            "&amp;nbsp;"
        ]
    },
    {
        "id": 2844,
        "expression": "(Mo(n(day)?)?|Tu(e(sday)?)?|We(d(nesday)?)?|Th(u(rsday)?)?|Fr(i(day)?)?|Sa(t(urday)?)?|Su(n(day)?)?)",
        "description": "The expression matches any weekday name (english) in short (2 or 3 characters) or full style. Use it with case insensitive mode in your date matching expressions.",
        "matches": [
            "Mo",
            "Sun"
        ],
        "non_matches": [
            "Any"
        ]
    },
    {
        "id": 2850,
        "expression": "^[_a-z0-9-]+(\\.[_a-z0-9-]+)*@[a-z0-9]+(-?[a-z0-9]+)?(\\.[a-z0-9]+(-?[a-z0-9]+)?)*\\.([a-z]{2}|xn\\-{2}[a-z0-9]{4,18}|arpa|aero|asia|biz|cat|com|coop|edu|gov|info|int|jobs|mil|mobi|museum|name|net|org|pro|tel|travel|xxx)$",
        "description": "Validates email addresses (except those using IP) according to list of TLD's http://data.iana.org/TLD/tlds-alpha-by-domain.txt .",
        "matches": [
            "name@domain.com",
            "first.last@abc.d-e.fg",
            "first.middle.last@a-b.c-d.xxx",
            "name-surname@foreign.xn--h2brj9c"
        ],
        "non_matches": [
            "name@abc-.de",
            "first.last@-abc.defg.hij",
            "first.last@123.123.123.123"
        ]
    },
    {
        "id": 2852,
        "expression": "(CREATE|ALTER) +(PROCEDURE|PROC|FUNCTION|VIEW) *(\\[(.*)\\]|(.*))",
        "description": "Expression to detect the name of the stored procedure / function / view, useful to detect automatically the name of the sproc the produced text in SQL",
        "matches": [
            "CREATE PROC[spTest], CREATE FUNCTION fnTest, ALTER PROCEDURE spTestOther"
        ],
        "non_matches": [
            "DROP PROC xxx, CREATE CURSOR xxx"
        ]
    },
    {
        "id": 2853,
        "expression": "^(?!^(5|15|18|30)$)\\d+$",
        "description": "Because a regular expression only deals with a single character at a time it can be a challenge to work with numbers as they often contain multiple digits. This regex allows any number except the numbers in the list. It does this by using a negative look ahead to fail the regex if it finds an excluded number.",
        "matches": [
            "1",
            "325",
            "515",
            "300"
        ],
        "non_matches": [
            "5",
            "15",
            "18",
            "30"
        ]
    },
    {
        "id": 2854,
        "expression": "\\.(?i:)(?:jpg|gif)$",
        "description": "This expression will only allow the .jpg and .gif file to get uploaded.\nThis handles the case of the file type i.e. it will accept .gif and .GIF both and so on .JPG and .jpg.",
        "matches": [
            "mypicture.jpg, MYPICTURE.JPG, MYPICTURE.GIF, mypicture.gif"
        ],
        "non_matches": [
            "mypicture.png, mypicture.bmp"
        ]
    },
    {
        "id": 2861,
        "expression": "^(net.tcp\\://|(ht|f)tp(s?)\\://)\\S+",
        "description": "For validate uri directions that must occur at the beginning of the string net.tcp|http|https|ftp|ftps://",
        "matches": [
            "http://ww.nancy.net/Servicios/ProxyWSService.svc",
            "net.tcp://testwcf02.com:808/Tasacion",
            "ftps://nancy.inet:/ProxyFTP"
        ],
        "non_matches": [
            "C:",
            "C:\\inetpub\\wwwroot\\file.asmx",
            "file.svc"
        ]
    },
    {
        "id": 2868,
        "expression": "(\\(0\\d\\d\\)\\s\\d{3}[\\s-]+\\d{4})|(0\\d\\d[\\s-]+\\d{3}[\\s-]+\\d{4})|(0\\d{9})|(\\+\\d\\d\\s?[\\(\\s]\\d\\d[\\)\\s]\\s?\\d{3}[\\s-]?\\d{4})",
        "description": "Tries to match the format of phone numbers within South Africa. Does not try to validate phone numbers based on actual numbers (e.g. cell networks or other landline prefixes)",
        "matches": [
            "(011) 123 4543,(011) 123-4543,(011) 212 8765,011 876 8789,0118768789,011-876-8789,082 821 9090,+27 11 123 1231,+27 (11) 123-1231,+27 (11) 123 1231,+27(11)123-1231,+27 11 1238765"
        ],
        "non_matches": [
            "011 1234 242"
        ]
    },
    {
        "id": 2869,
        "expression": "^(?:[\\w]\\:|\\\\)(\\\\[a-z_\\-\\s0-9\\.]+)+\\.(txt|gif|pdf|doc|docx|xls|xlsx)$",
        "description": "Regular Expression to validate file path and extension.Compatible with JavaScript and ASP.NET",
        "matches": [
            "\\\\192.168.0.1\\folder\\file.pdf",
            "\\\\192.168.0.1\\my folder\\folder.2\\file.gif",
            "c:\\my folder\\abc abc.docx",
            "c:\\my-folder\\another_folder\\abc.v2.docx"
        ],
        "non_matches": [
            "\\\\192.168.0.1\\folder\\fi/le.pdf",
            "\\\\192.168.0.1\\folder\\\\file.pdf",
            "\\\\192.168.0.1\\my folder\\folder.2\\.gif",
            "c:\\my folder\\another_folder\\.docx",
            "c:\\my folder\\\\another_folder\\abc.docx",
            "c:\\my folder\\another_folder\\ab*c.v2.docx",
            "c:\\my?folder\\another_folder\\abc.v2.docx",
            "file.xls"
        ]
    },
    {
        "id": 2877,
        "expression": "^(?:-([0-9]{1,2})|([0-9]{4}))?(?:-?(?:([0-9]{2})?(?:-?([0-9]{2}))?|W([0-9]{2})(?:-?([1-7]))?|([0-9]{3})))?(?:T([0-9]{2})(?::?([0-9]{2})(?::?([0-9]{2}))?)?(?:[,\\.]([0-9]+))?(?:(Z)|([+-])([0-9]{2})(?::?([0-9]{2}))?)?)?$",
        "description": "Validate and parse date/time string in ISO8601 format. Works with complete representation in both with basic and extended formats. Some of turncated representations and most of representations with reduced precision are also supported. It does not validate range of date/time fields in any way.\nCaptured fields may be empty depending on what kind of representation is used.\nYear: $1 two-digit year with implicit century or $2 full 4-digit year.\nCalendar date: $3 month, $4 day of the month.\nWeek date: $5 week of the year, $6 day of the week.\nOrdinal date: $7 day of the year.\nTime: $8 hours, $9 minutes, $10 seconds, $11 fractional part of last non-empty time field.\nTime zone: if $12 is Z then it's UTC zone, otherwise offset may be given as $13 direction (+/-), $14 hours and $15 minutes.",
        "matches": [
            "19850412T232050Z",
            "1985-04-12T10:15:30+0400",
            "1985102",
            "1985-102",
            "1985W155",
            "1985-W15-5",
            "T23:20:50",
            "T23,347"
        ],
        "non_matches": [
            "11111",
            "23,5",
            "23:20"
        ]
    },
    {
        "id": 2879,
        "expression": "^(?i:([a-z])\\1?(?!\\1)){2,}$",
        "description": "This was designed to match a single name field which required a minimum length of 2 characters and no triplicate characters.",
        "matches": [
            "John",
            "Bob",
            "Smith",
            "Jones"
        ],
        "non_matches": [
            "aa",
            "aaa",
            "Smiiith"
        ]
    },
    {
        "id": 2882,
        "expression": "^(((0|((\\+)?91(\\-)?))|((\\((\\+)?91\\)(\\-)?)))?[7-9]\\d{9})?$",
        "description": "First digit can be 7 or 8 or 9.\nNo. can have any of the following prefixes\n0\n91\n91-\n(91)-\n+91\n(+91)\n(+91)-",
        "matches": [
            "9876543210",
            "09876543210",
            "919876543210",
            "+919876543210",
            "91-9876543210",
            "+91-9876543210",
            "(91)9876543210",
            "(+91)9876543210",
            "(91)-9876543210",
            "(+91)-9876543210"
        ],
        "non_matches": [
            "9198279",
            "6789123456",
            "0-9876543210",
            "+(91)-9876543210"
        ]
    },
    {
        "id": 2883,
        "expression": "(?:[Yy][Oo][Uu][Tt][Uu][Bb][Ee]\\.[Cc][Oo][Mm]/watch\\?v=)([\\w-]{11})",
        "description": ".NET 3.5 Tested. Used to extract the YouTubeID from a fully qualified YouTube URL.\nDim _Regex As New Regex(\"(?:[Yy][Oo][Uu][Tt][Uu][Bb][Ee]\\.[Cc][Oo][Mm]/watch\\?v=)([\\w-]{11})\", RegexOptions.IgnoreCase Or RegexOptions.Compiled)\nDim _RegexMatch As Match = _Regex.Match(\"http://www.youtube.com/watch?v=pW2GSdxxwDg\")\nDim _YouTubeVideoID As System.String = _RegexMatch.Groups(1).Value",
        "matches": [
            "http://www.youtube.com/watch?v=pW2GSdxxwDg",
            "http://www.youtube.com/watch?v=-7P7_kxZQ5I",
            "http://www.youtube.com/watch?v=7sPKHwsupmQ&playnext=1&list=PL40CB7986D1A9A285",
            "http://www.youtube.com/watch?v=r-di4gJvq4Q&feature=channel_video_title"
        ],
        "non_matches": [
            "http://www.youtu.be/watch?v=pW2GSdxxwDg"
        ]
    },
    {
        "id": 2884,
        "expression": "^[^-]{1}?[^\\\"\\']*$",
        "description": "to accept only alphanumeric with all special characters except (double/single Quotes). and if numbers then only positive numbers",
        "matches": [
            "65 ghf, 65% - consumed, hello, 64 - 56"
        ],
        "non_matches": [
            "-65 ghf, -164, 65% - \"consumed\""
        ]
    },
    {
        "id": 2890,
        "expression": "^(?:(?=[02468][048]00|[13579][26]00|[0-9][0-9]0[48]|[0-9][0-9][2468][048]|[0-9][0-9][13579][26])\\d{4}(?:(-|)(?:(?:00[1-9]|0[1-9][0-9]|[1-2][0-9][0-9]|3[0-5][0-9]|36[0-6])|(?:01|03|05|07|08|10|12)(?:\\1(?:0[1-9]|[12][0-9]|3[01]))?|(?:04|06|09|11)(?:\\1(?:0[1-9]|[12][0-9]|30))?|02(?:\\1(?:0[1-9]|[12][0-9]))?|W(?:0[1-9]|[1-4][0-9]|5[0-3])(?:\\1[1-7])?))?)$|^(?:(?![02468][048]00|[13579][26]00|[0-9][0-9]0[48]|[0-9][0-9][2468][048]|[0-9][0-9][13579][26])\\d{4}(?:(-|)(?:(?:00[1-9]|0[1-9][0-9]|[1-2][0-9][0-9]|3[0-5][0-9]|36[0-5])|(?:01|03|05|07|08|10|12)(?:\\2(?:0[1-9]|[12][0-9]|3[01]))?|(?:04|06|09|11)(?:\\2(?:0[1-9]|[12][0-9]|30))?|(?:02)(?:\\2(?:0[1-9]|1[0-9]|2[0-8]))?|W(?:0[1-9]|[1-4][0-9]|5[0-3])(?:\\2[1-7])?))?)$",
        "description": "Validate a date according to the ISO 8601 standard (no time part) considering long-short months to allow 31st day of month and leap years to allow 29th February. I took Ted Cambron's implementation, simplified and added support for leap years and long-short months.",
        "matches": [
            "1600-02-29"
        ],
        "non_matches": [
            "2011-02-29"
        ]
    },
    {
        "id": 2896,
        "expression": "\\b(((20)((0[0-9])|(1[0-1])))|(([1][^0-8])?\\d{2}))((0[1-9])|1[0-2])((0[1-9])|(2[0-9])|(3[01]))[-+]?\\d{4}[,.]?\\b",
        "description": "Matches a Swedish social security number in format xxYYMMDD-NNNN, xxYYMMDD+NNNN, YYMMDD-NNNN, YYMMDD-NNNN and YYMMDDNNN. Does not allow birth years before 1900 and after 2011.\nTo raise the birth year to higher level of birth just change the 1[0-1] part to i.e. 1[0-4] to allow birth years up to 2014 etc.\nThis will find the SSN within a string. Also allow for a comma(,) or period(.) behind the SSN.",
        "matches": [
            "7712314582",
            "810325+0782",
            "19771231-4582"
        ],
        "non_matches": [
            "137712314582",
            "201211224567",
            "10880215-0987"
        ]
    },
    {
        "id": 2898,
        "expression": "^(((20)((0[0-9])|(1[0-1])))|(([1][^0-8])?\\d{2}))((0[1-9])|1[0-2])((0[1-9])|(2[0-9])|(3[01]))[-]?\\d{4}$",
        "description": "Matches a Swedish social security number in format CCYYMMDD-NNNN, CCYYMMDDNNNN, YYMMDD-NNNN and YYMMDDNNNN on a single line. More useful version of my earlier expression. Will only match 1900 - 2011 years.",
        "matches": [
            "7712314582",
            "810325-0782",
            "19771231-4582",
            "197712314582"
        ],
        "non_matches": [
            "137712314582",
            "201211224567",
            "10880215-0987"
        ]
    },
    {
        "id": 2903,
        "expression": "(?:youtu\\.be\\/|youtube.com\\/(?:watch\\?.*\\bv=|embed\\/|v\\/)|ytimg\\.com\\/vi\\/)(.+?)(?:[^-a-zA-Z0-9]|$)",
        "description": "This regex should recognize a Youtube video ID from any Youtube URL, embed snippet, or preview image.",
        "matches": [
            "http://www.youtube.com/watch?v=QH2-TGUlwu4",
            "http://youtu.be/QH2-TGUlwu4",
            "http://www.youtube.com/embed/QH2-TGUlwu4",
            "http://www.youtube.com/v/QH2-TGUlwu4?version=3&amp;hl=en_US",
            "http://i4.ytimg.com/vi/QH2-TGUlwu4/default.jpg"
        ],
        "non_matches": [
            "asdf"
        ]
    },
    {
        "id": 2906,
        "expression": "(http|ftp|https)://[a-zA-Z0-9\\-\\.]+\\.[a-zA-Z]{2,4}(/\\S*)?$",
        "description": "This Regex check protocol (ftp, http, https), extension should be between 2 and 4 chars example (.co.uk, .com, .us and .info), domain or subdomain name between protocol and extension should contain the following chars\na-z, A-Z, 0-9, \"-\", and \".\"\nThe rest of URL after \"/\" contain unicode char",
        "matches": [
            "http://domain-1.us",
            "ftp://www.domain.co.uk",
            "https://domain.info",
            "https://subdomain.domain.info",
            "http://subdomain.domain.info/\u0627\u0644\u062c\u0632\u0627\u0626\u0631.html"
        ],
        "non_matches": [
            "http://domain.infor",
            "http://domain_1.com"
        ]
    },
    {
        "id": 2913,
        "expression": "^((\\d{1,3}(,\\d{3})*)|(\\d{1,3}))$",
        "description": "Matches all properly formatted integers of 1 or more integer with commas separating each group of 3 integers",
        "matches": [
            "10",
            "100",
            "1,000",
            "1,000,000,000,000"
        ],
        "non_matches": [
            "1000",
            "1,0000",
            "1000,000"
        ]
    },
    {
        "id": 2919,
        "expression": "(\\d{5}-\\d{4}|\\d{5})",
        "description": "Matches:\nfive digits hypen four digits\nor just five digits\nanywhere within string.\nC#\nstring reg_usa_postcode = @\"(\\d{5}-\\d{4}|\\d{5})\";",
        "matches": [
            "Ohio 43050-2495 USA, Houston 77053 USA Texax"
        ],
        "non_matches": [
            "USA 4512, Texas 1234-1234 US"
        ]
    },
    {
        "id": 2931,
        "expression": "start\\s*([^$]*)\\s*(.*?)",
        "description": "Matches a string and grabs all data till the end of the string/text/sentence.\nEg.\nI wonder why all programming languages start with a hello world program !!",
        "matches": [
            "start with a hello world program !!"
        ],
        "non_matches": [
            "."
        ]
    },
    {
        "id": 2932,
        "expression": "wonder\\s*([^$]*)\\s*with",
        "description": "Matches and returns the text provided the match string and the end string. Eg. I wonder why all programming languages start with a hello world program !!",
        "matches": [
            "wonder why all programming languages start with"
        ],
        "non_matches": [
            "."
        ]
    },
    {
        "id": 2933,
        "expression": "^((\\D*[a-z]\\D*[A-Z]\\D*)|(\\D*[A-Z]\\D*[a-z]\\D*)|(\\D*\\W\\D*[a-z])|(\\D*\\W\\D*[A-Z])|(\\D*[a-z]\\D*\\W)|(\\D*[A-Z]\\D*\\W))$",
        "description": "Password validation with any two of combinations: [A-Z],[a-z],Punctuation Symbols with minimum user requirement without digits.If digit is added , it wont validate.As per requirement add '.{n,m}' without quotes before the $ sign in the expression.",
        "matches": [
            "Sara,sA,%g,&HHJ,G(*,hgh%"
        ],
        "non_matches": [
            "Sa2,hjH7,7&h"
        ]
    },
    {
        "id": 2937,
        "expression": "((?:Microsoft)?.?(?:(?:Windows.NT.(?:[1-4].[0-9]))|(?:Win(?:dows)?.?NT).?[1-4](?:.?[0-9])?|NT[1-4]))",
        "description": "Matches the \"Official\" and several other popular expressions of the \"Windows NT\" line of operating systems. Used to discern one OS version from another. Must include at least one digit of the version number (1 to 4 or 1.0 to 4.9 will match).\nOnly one capture group will return the full, matching string.",
        "matches": [
            "Windows NT 4.0",
            "Microsoft Windows NT 4.0",
            "Microsoft Windows NT 3.5",
            "Win NT4",
            "NT4",
            "Windows_NT_4.0",
            "MicrosoftWindowsNT3.1",
            "WindowsNT4",
            "Windows_NT.4"
        ],
        "non_matches": [
            "WinNT",
            "Win NT",
            "Windows 2000",
            "Windows NT"
        ]
    },
    {
        "id": 2944,
        "expression": "^([A-Z]+\\s*[A-Z]+)$",
        "description": "1 or 2 words with 1 or no space. Words are in all capital letters. Nothing in front or end of word(s).",
        "matches": [
            "JOHN DOE",
            "BOB",
            "MELTON HILL"
        ],
        "non_matches": [
            "John 3",
            "THE CHEROKEE LAKE",
            "Bill"
        ]
    },
    {
        "id": 2950,
        "expression": "^[\\u0600-\\u06ff\\s]+$|[\\u0750-\\u077f\\s]+$|[\\ufb50-\\ufc3f\\s]+$|[\\ufe70-\\ufefc\\s]+$|^$",
        "description": "Arabic Word only or Null String",
        "matches": [
            "\u0645\u062d\u0645\u062f \u0627\u062d\u0645\u062f"
        ],
        "non_matches": [
            "\u0645\u062d\u0645\u062f \u0627\u062d\u0645\u062f gjghj"
        ]
    },
    {
        "id": 2951,
        "expression": "^[5,6]\\d{7}|^$",
        "description": "Number Begin Specfic Number 5 or 6 and Lenght 8 or Null string",
        "matches": [
            "64564654"
        ],
        "non_matches": [
            "24564654"
        ]
    },
    {
        "id": 2952,
        "expression": "([+(]?\\d{0,2}[)]?)([-/.\\s]?\\d+)+",
        "description": "it will validate phone number formats like -\n1. (91)123-456-7890\n2. +91-123-456-7890\n3. 911234567890\n4. 1234567890\n5. (91)123/456/7890\n6. +91/123/456/7890\n7. (91)123.456.7890\n8. +91.123.456.7890\nThere is no limitation on the repeating pattern",
        "matches": [
            "+91.123.456.7890"
        ],
        "non_matches": [
            "symbols other than '/' '.' '(' ')' '-' will not be allowed"
        ]
    },
    {
        "id": 2970,
        "expression": "^((((0[1-9]|[1-2][0-9]|3[0-1])[./-](0[13578]|10|12))|((0[1-9]|[1-2][0-9])[./-](02))|(((0[1-9])|([1-2][0-9])|(30))[./-](0[469]|11)))[./-]((19\\d{2})|(2[012]\\d{2})))$",
        "description": "Date pattern for date format\nDD-MM-YYYY or\nDD/MM/YYYY or\nDD.MM.YYYY.\nYear value limited from 1900-2299",
        "matches": [
            "01/01/1900",
            "29/02/2012",
            "31/12/2101"
        ],
        "non_matches": [
            "30/02/2012",
            "31/04/2010",
            "31.05.2300"
        ]
    },
    {
        "id": 2972,
        "expression": "^\\S{1}(?:.){4,}\\S$",
        "description": "Check if a string contains at least 6 characters. Can not end or start with whitespace but can contain any other. PCRE optimized with none-capturing parentheses.",
        "matches": [
            "4 good p@ssW0rd?",
            "password"
        ],
        "non_matches": [
            "pass",
            "word",
            "12345"
        ]
    },
    {
        "id": 2973,
        "expression": "^(0|1)+$",
        "description": "A REGEXP that validate a binary number on more rows.",
        "matches": [
            "01001010101001"
        ],
        "non_matches": [
            "010102002010010"
        ]
    },
    {
        "id": 2980,
        "expression": "(\\w+),[^(]+\\((\\w+)\\)\\s+(\\w+)\\s+(\\d+)/(\\d+)\\s+(\\d+)?",
        "description": "7750 Birthday & Anniversayr Report",
        "matches": [
            "Alexander, Doug (DOUG) Sharon 02/12 Hilscher, Susan M. (SUSAN) Woody 02/22 44"
        ],
        "non_matches": [
            "asdf"
        ]
    },
    {
        "id": 2984,
        "expression": "(?i)((sun(day)?|mon(day)?|tue(sday)?|wed(nesday)?|thu(rsday)?|fri(day)?|sat(urday)?),?\\s)?((jan(uary)?|feb(ruary)?|mar(ch)?|apr(il)?|may|jun(e)?|jul(y)?|aug(ust)?|sep(tember)?|oct(ober)?|nov(ember)?|dec(ember)?)\\s)+((0?[1-9]|[1-2][0-9]|3[0-1]),?\\s)+([1-2][0-9][0-9][0-9])",
        "description": "Matches full textual date formats. Case insensitive, optional commas, short and long weekdays and months, optional weekdays, optional leading zeros in date.",
        "matches": [
            "Sun, Mar 7, 2012",
            "Sunday, March 7, 2012",
            "March 07, 2012",
            "SUN MARCH 7 2012"
        ],
        "non_matches": [
            "07MAR2012",
            "03/07/2012",
            "Mar-07-2012"
        ]
    },
    {
        "id": 2988,
        "expression": "^\\d+((\\.|\\,)\\d+)?$",
        "description": "Decimal with comma or dot",
        "matches": [
            "11,11",
            "33.33",
            "22"
        ],
        "non_matches": [
            ".11",
            ".33",
            "11,111.1"
        ]
    },
    {
        "id": 2989,
        "expression": "^[1-9]+[0-9]*$",
        "description": "Matches all Positive Numbers not including zero (0). Does not allow decimals.",
        "matches": [
            "1",
            "12",
            "1000"
        ],
        "non_matches": [
            "0",
            "-2",
            "1.00"
        ]
    },
    {
        "id": 2992,
        "expression": "^(?=^.{1,254}$)(^(?:(?!\\.|-)([a-z0-9\\-\\*]{1,63}|([a-z0-9\\-]{1,62}[a-z0-9]))\\.)+(?:[a-z]{2,})$)$",
        "description": "This regex matches FQDNs plus domains starting with an or containing asterisk. This is usefull for DNS configuration tools where you might have domains like *.domain.de or 12.152.80.in-addr.arpa.",
        "matches": [
            "12.152.80.in-addr.arpa",
            "*.domain.de",
            "test.de"
        ],
        "non_matches": [
            "test",
            "test.",
            "-.de"
        ]
    },
    {
        "id": 2994,
        "expression": "ISBN(-1(?:(0)|3))?:?\\x20(\\s)*[0-9]+[- ][0-9]+[- ][0-9]+[- ][0-9]*[- ]*[xX0-9]",
        "description": "To find ISBN-10 or ISBN-13 text",
        "matches": [
            "ISBN-13 978-3-642-11746-6 SomeText",
            "ISBN 978-3-642-11746-6",
            "ISBN-10 3-642-11746-5 SomeText",
            "ISBN 3-642-11746-5",
            "ISBN: 978-3-642-11746-6"
        ],
        "non_matches": [
            "ISBN : 978-3-642-11746-6",
            "ISBN-10 : 3-642-11746-5",
            "ISBN-13 : 978-3-642-11746-6"
        ]
    },
    {
        "id": 3001,
        "expression": "^[\\d]{1,}?\\.[\\d]{2}$",
        "description": "This will check that the string is made of up numbers in a D.XX with at least on number for D",
        "matches": [
            "1234.56",
            "1.50",
            "0.50"
        ],
        "non_matches": [
            "X23.50",
            "23.5",
            ".50"
        ]
    },
    {
        "id": 3003,
        "expression": "^(0[1-9]|[12][0-9]|3[01])[\\s\\.\\-/](J(anuary|uly|an|AN)|M(arch|ar|AR|ay|AY)|A(ugust|ug|UG)|(O(ctober|ct|CT)|(D(ecember|ec|EC))))[\\s\\.\\-/][1-9][0-9]{3}|(0[1-9]|[12][0-9]|30)[\\s\\.\\-/](A(pril|pr|PR)|J(une|un|UN)|S(eptember|ep|EP)|N(ovember|ov|OV))[\\s\\.\\-/][1-9][0-9]{3}|(0[1-9]|1[0-9]|2[0-8])[\\s\\.\\-/]F(ebruary|eb|EB)[\\s\\.\\-/][1-9][0-9]{3}|29[\\s\\.\\-/]F(ebruary|eb|EB)[\\s\\.\\-/]((0[48]|[2468][048]|[13579][26])00|[0-9]{2}(0[48]|[2468][048]|[13579][26]))$",
        "description": "Verifies all valid Gregorian dates of the form DD MONTH YYYY, and short month names, taking days/month and leap years into account. Accepts space, -, . and / between paramters.",
        "matches": [
            "05 March 2012",
            "29-Feb-2012",
            "31.DEC.2011"
        ],
        "non_matches": [
            "32 March 2012",
            "29-Feb-2011",
            "2011.DEC.31"
        ]
    },
    {
        "id": 3004,
        "expression": "(([1-9])|(0[1-9])|(1[0-2]))\\/(([0-9])|([0-2][0-9])|(3[0-1]))\\/(([0-9][0-9])|([1-2][0,9][0-9][0-9]))\\s+(20|21|22|23|[01]\\d|\\d)(([:.][0-5]\\d){1,2})$",
        "description": "Validates Date and time in the format mm/dd/yyyy hh:mi:ss",
        "matches": [
            "10/12/2012 14:58:32"
        ],
        "non_matches": [
            "14/65/20 25:25:25"
        ]
    },
    {
        "id": 3005,
        "expression": "\\b([0-1]?\\d{1,2}|2[0-4]\\d|25[0-5])(\\.([0-1]?\\d{1,2}|2[0-4]\\d|25[0-5])){3}\\b",
        "description": "Matches any IPv4.",
        "matches": [
            "192.168.11.12",
            "123.123.123.012",
            "0.0.0.1"
        ],
        "non_matches": [
            "192.168.11",
            "256.10.11.12",
            "10.101.1.900",
            "192.168.1. 2",
            "192.168.10.0001"
        ]
    },
    {
        "id": 3011,
        "expression": "(http://)?(www\\.)?(youtube|yimg|youtu)\\.([A-Za-z]{2,4}|[A-Za-z]{2}\\.[A-Za-z]{2})/(watch\\?v=)?[A-Za-z0-9\\-_]{6,12}(&[A-Za-z0-9\\-_]{1,}=[A-Za-z0-9\\-_]{1,})*",
        "description": "Matches only valid YouTube links. This includes directly linked videos (yimg) and using YouTube's shortening service (youtu.be). Also supports local domains, like youtube.nl, youtube.de, youtube.co.uk, etc.",
        "matches": [
            "www.youtube.co.uk/watch?v=KUlv7qraZaM",
            "http://www.yimg.com/watch?v=KUlv7qraZaM",
            "http://www.youtube.com/watch?v=apxKFXJ8jSg&feature=relmfu",
            "youtu.be/apxKFXJ8jSg"
        ],
        "non_matches": [
            "youtube.com/watch/v=apxKFXJ8jSg"
        ]
    },
    {
        "id": 3012,
        "expression": "^(([1][0-2])|([0]?[1-9]{1}))\\/(([0-2]?\\d{1})|([3][0,1]{1}))\\/(([1]{1}[9]{1}[9]{1}\\d{1})|([2-9]{1}\\d{3}))$",
        "description": "MM/DD/YYYY\nYear from 1990-9999\nThx to: http://regexlib.com/%28X%281%29%29/REDetails.aspx?regexp_id=60",
        "matches": [
            "12/31/2012",
            "12/0/2012",
            "2/31/2012"
        ],
        "non_matches": [
            "19/28/2012",
            "0/12/1999",
            "5/25/1980"
        ]
    },
    {
        "id": 3014,
        "expression": "^\\s*[a-zA-Z0-9,\\s]+\\s*$",
        "description": "This regular expression allows user to add string spaces and numbers.",
        "matches": [
            "Valid Text, 1",
            "2nd Text is valid",
            "Comma , is valid"
        ],
        "non_matches": [
            "asd#!#@",
            "asdfasd_asdf",
            "2323_SDF_sdf"
        ]
    },
    {
        "id": 3018,
        "expression": "^[1-9]+\\d*\\.\\d{2}$",
        "description": "Useful for matching monetary values formatted without commas, leading zeros, currency symbols.",
        "matches": [
            "25.97",
            "5.39",
            "1000.24",
            "10340.23"
        ],
        "non_matches": [
            "0.23",
            "01.45",
            "10,000.23",
            "1000.2"
        ]
    },
    {
        "id": 3019,
        "expression": "^(?!0?2/3)(?!0?2/29/.{3}[13579])(?!0?2/29/.{2}[02468][26])(?!0?2/29/.{2}[13579][048])(?!(0?[469]|11)/31)(?!0?2/29/[13579][01345789]0{2})(?!0?2/29/[02468][1235679]0{2})(0?[1-9]|1[012])/(0?[1-9]|[12][0-9]|3[01])/([0-9]{4})$",
        "description": "Validates dates in the format MM/DD/YYYY, M/D/YYYY, or any permutation in between. Takes into account leap year as well as the rule that century marks are leap years only if they are divisible by 400.",
        "matches": [
            "1/30/2012",
            "2/29/2012",
            "02/29/2400"
        ],
        "non_matches": [
            "04/31/2000",
            "02/29/2100",
            "2/30/2012"
        ]
    },
    {
        "id": 3021,
        "expression": "^0$|^0\\.{1}(\\d{1,2})$|^[1-9]{1}[0-9]*\\.?(\\d{1,2})$|^[1-9]+[0-9]*$",
        "description": "Matches any non-negative, non-signed real number with maximum of 2 decimal spaces. The decimal is denoted by a . symbol.",
        "matches": [
            "0.4",
            "50.76",
            "100",
            "120.00",
            "0",
            "0.00"
        ],
        "non_matches": [
            "+5",
            ".32",
            "00",
            "15.123",
            "-5",
            "4."
        ]
    },
    {
        "id": 3022,
        "expression": "(^(?!0{5})(\\d{5})(?!-?0{4})(|-\\d{4})?$)",
        "description": "This expression matches two different formats of zip codes: 5 digit US ZIP code and 5 digit US ZIP code + 4.The first one must be 5 numeric digits. The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits.",
        "matches": [
            "12345",
            "12345-1234"
        ],
        "non_matches": [
            "00000",
            "123451234",
            "12345-0000",
            "00000-0000",
            "00000-1234",
            "000001234"
        ]
    },
    {
        "id": 3023,
        "expression": "^([987]{1})(\\d{1})(\\d{8})",
        "description": "indian mobile number perfect validation for three number series's that start with 9,8,7. if you want you can easily add one more series that you want in feature. it validates 10 digit number starting with 9,8,7 and followed by 9 digits 0-9 in any order.",
        "matches": [
            "9848012345,804812345,7000000000"
        ],
        "non_matches": [
            "6897895648,+919848012345"
        ]
    },
    {
        "id": 3030,
        "expression": "^(((?:(?:f|ht)tps?(?!\\:\\/\\/[-\\.\\w]+@)|mailto(?=\\:\\/\\/[-\\.\\w]+@))\\:\\/\\/)?(?:((?:(?:(?:2(?:[0-4]\\d|5[0-5])|[01]?\\d?\\d))(?:\\.(?:2(?:[0-4]\\d|5[0-5])|[01]?\\d?\\d)){3})|(?:(?:[a-zA-Z0-9](?:[-\\w]*[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,6}(?:(?:\\/[-\\w]+(?=\\/))*)?)|(?:[0-9a-zA-Z](?:[-.\\w]*[0-9a-zA-Z])?@(?:[0-9a-zA-Z](?:[-\\w]*[0-9a-zA-Z])?\\.)+[a-zA-Z]{2,6}(?![\\/\\?])))(\\/[-\\w]+)?(?:(?<=\\w)\\.([a-zA-Z0-9]{2,4}))?(?:(?<=\\w)\\?([a-zA-Z][-\\w]*=[-\\w]+(?:&[a-zA-Z][-\\w]*=[-\\w]+)*))?))$",
        "description": "Designed for full url matching in common hyperlink text including: 1. ftp(s),http(s), and mailto protocols. 2. ip, domain names and sub-domains, and standard email addresses. 3. files with extensions and parameters. Match provides whole match and protocol, address, page, file extension, and parameter sub-matches for use in parsing. If you see anything that can be improved, by all means provide me some feedback. Thanks!",
        "matches": [
            "ftp://255.255.255.255",
            "http://www.domain.com",
            "mailto://user@domain.com",
            "domain.com/dir/page.ext?param=value&param=value"
        ],
        "non_matches": [
            "https://user@domain.com",
            "user@domain.com/dir?param=value",
            "256.256.256.256",
            "ftps://sub.domain.com/.ext",
            "domain.com/?param=value"
        ]
    },
    {
        "id": 3033,
        "expression": "^\\d+(\\,\\d{1,2})?$",
        "description": "Matches a currency value (without currency symbol) using , for decimal digits separator",
        "matches": [
            "0,12",
            "100",
            "100,1"
        ],
        "non_matches": [
            "0,123",
            "10.1",
            ",23"
        ]
    },
    {
        "id": 3037,
        "expression": "^(([1-9][0-9]{0,3}|[1-4][0-9]{4}|5([0-8][0-9]{3}|9([0-2][0-9]{2}|3([0-8][0-9]|9[01]))))|(6(4(5(1[2-9]|[2-9][0-9])|[6-9][0-9]{2})|5([0-4][0-9]{2}|5([0-2][0-9]|3[0-4]))))|(1(3(1(0(7[2-9]|[89][0-9])|[1-9][0-9]{2})|[2-9][0-9]{3})|[4-9][0-9]{4})|[2-9][0-9]{5}|[1-9][0-9]{6,8}|[1-3][0-9]{9}|4([01][0-9]{8}|2([0-8][0-9]{7}|9([0-3][0-9]{6}|4([0-8][0-9]{5}|9([0-5][0-9]{4}|6([0-6][0-9]{3}|7([01][0-9]{2}|2([0-8][0-9]|9[0-4]))))))))))$",
        "description": "will match muliple numeric ranges, from range (1 to 59391) , (64512 to 65534) and (131072 to 4294967294)",
        "matches": [
            "1",
            "59391",
            "65000",
            "4294967294"
        ],
        "non_matches": [
            "0",
            "59392",
            "66000",
            "4294967295"
        ]
    },
    {
        "id": 3038,
        "expression": "(?!^0*\\.0*$)^\\d{1,10}(\\.\\d{1,2})?$",
        "description": "1 to 10 digits are allowed before the decimal. 1 to 2 digits are allowed after decimal. Zero is allowed. Whole numbers allowed.",
        "matches": [
            "0",
            "2.50",
            "9999999999.99",
            "1.1"
        ],
        "non_matches": [
            ".50",
            "999999999999",
            "1000000.369"
        ]
    },
    {
        "id": 3040,
        "expression": "((X|x):-?(180(\\.0+)?|[0-1]?[0-7]?[0-9](\\.\\d+)?))([ ]|,)*((Y|y):-?(90(\\.0+)?|[0-8]?[0-9](\\.\\d+)?))",
        "description": "Latitude and Longitude in Decimal Degrees useful for X (longitude), Y (latitude) coordinate systems such as WGS84.\nPrefix x: and y: must be used in order.\nX range: -180.00 to 180.00\nY range: -90.00 to 90.00",
        "matches": [
            "x:180.00, , ,,, Y:-90.000",
            "x:180y:-90",
            "X:179.99999, Y:-89.99",
            "X:50 y:5.540",
            "x:050y:05.123",
            "x:0, y:0",
            "X:-179.99999, Y:-89.99",
            "X:-180, y:-90",
            "x:-180.00, Y:-90.000"
        ],
        "non_matches": [
            "x:-180.01, y:-90.001",
            "x:-180., y:-90.",
            "x:180.01, y:90.001",
            "x:180., y:90.",
            "x:180-y:90"
        ]
    },
    {
        "id": 3041,
        "expression": "[A-Z][a-zA-Z]+ [A-Z][a-zA-Z]+",
        "description": "Find proper names in the form John Doe",
        "matches": [
            "John Doe",
            "Jeff Tart",
            "Sally Tong"
        ],
        "non_matches": [
            "rebecca Hart",
            "Joe",
            "Jeff bridges"
        ]
    },
    {
        "id": 3043,
        "expression": "<(\\s*/?\\s*)\\w+?(\\s*(([\\w-]+=\"[^\"]*?\")|([\\w-]+='[^']*?')|([\\w-]+=[^'\"<>\\s]+)))*(\\s*/?\\s*)>",
        "description": "This RE strips HTML open and close tags from text with any attributes provided, including not properly formatted tags.",
        "matches": [
            "<html>, <meta http-equiv=Content-Type content=\"text/html; charset=windows-1250\">, < / html body=\"<'something'>\" body='\"any thing\"' b=jj123-qqj / >"
        ],
        "non_matches": [
            "<html / d>, <html body='something\">, <d /html>"
        ]
    },
    {
        "id": 3047,
        "expression": "^((\\+92)|(0092))-{0,1}\\d{3}-{0,1}\\d{7}$|^\\d{11}$|^\\d{4}-\\d{7}$",
        "description": "The expression is used to validate all the number which follows the format of pakistani mobile companies cell phone number format.\ni.e. Ufone, Warid, Mobilink, Zong, telenor etc",
        "matches": [
            "03231234567",
            "0345-1234567",
            "+923211234567",
            "+92324-1234567",
            "+92-3331234567",
            "+92-333-1234567",
            "00923331234567",
            "0092333-1234567",
            "0092-3331234567",
            "0092-333-1234567"
        ],
        "non_matches": [
            "3331234567",
            "0333-123-4567",
            "92513331234567"
        ]
    },
    {
        "id": 3049,
        "expression": "(?:\\b\\w*(\\w\\w?)\\1{2,}\\w*\\b)",
        "description": "Word deformed by repeating a character, or a pair of characters. Common in internet communication, can be useful for detecting emotions.",
        "matches": [
            "wooot",
            "yeeeeah",
            "lalalala",
            "hahahaha"
        ],
        "non_matches": [
            "teepee",
            "mississippi"
        ]
    },
    {
        "id": 3058,
        "expression": "^\\s*[a-zA-Z0-9,&\\s]+\\s*$",
        "description": "only accept chara, & ,\\ , not allowed- @@ ## $$",
        "matches": [
            "AAAA333"
        ],
        "non_matches": [
            "@@@$$"
        ]
    },
    {
        "id": 3059,
        "expression": "^([0])([1])([1,2,3,4,6,7,8,9])([0-9][0-9][0-9][0-9][0-9][0-9][0-9])",
        "description": "accepts malaysian mobile number example (011,012,013...) plus 7 additional numbers",
        "matches": [
            "0171234567",
            "0141234567",
            "0167791990"
        ],
        "non_matches": [
            "0151234567",
            "0211234567",
            "1011234567"
        ]
    },
    {
        "id": 3064,
        "expression": "[?&]([^&#=]+)(?:=([^&#]*))?",
        "description": "Matches parameters in an URL's query part. The parameters' name and value will be available as subsrting $1 and $2. $2 will be empty if the value is empty (e.g. \"\u2026&param=&\u2026\") or undefined if there's no equals to sign (e.g. \"\u2026&param&\u2026\").",
        "matches": [
            "http://example.com/?param=value&emptyParam=&undefinedParam#anchor",
            "https://www.google.com/imghp?hl=en&tab=wi",
            "http://www.youtube.com/results?search_type=videos&search_query=Regular+Expressions&uni=3"
        ],
        "non_matches": [
            "http://example.com/#anchor",
            "http://www.google.com/",
            "URL's with no GET parameters"
        ]
    },
    {
        "id": 3065,
        "expression": "^((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5]))$",
        "description": "Matches valids TCP/IP-Adresses",
        "matches": [
            "0.0.0.0",
            "100.10.0.1",
            "255.255.255.255"
        ],
        "non_matches": [
            "..12.23",
            "a.23.345",
            "400.500.300.300"
        ]
    },
    {
        "id": 3066,
        "expression": "^01[1,2,3,4,6,7,8,9]\\d{7,8}$",
        "description": "allows the new 8 digit numbers aswell as 7 digit numbers without the 015",
        "matches": [
            "01712345677",
            "0141234567",
            "0167791990",
            "01277784921"
        ],
        "non_matches": [
            "0151234567",
            "021567",
            "101123456734"
        ]
    },
    {
        "id": 3071,
        "expression": "^(~?/|[a-zA-Z]:[\\\\/]).+",
        "description": "Written to tell absolute and relative paths apart (by matching only absolute paths) on *nix or Windows systems, for a cross-platform PHP project. Admittedly there are a few weird edges cases that will outwit the pattern, like the %FOO% anchor things that can be used in windows paths.",
        "matches": [
            "/usr/local/lib",
            "~/temp",
            "C:\\windows\\path"
        ],
        "non_matches": [
            "file.ext",
            "./path/file",
            "~file"
        ]
    },
    {
        "id": 3074,
        "expression": "^[^\\\\/:*?\"\"<>|.][^\\\\/:*?\"\"<>|]*(?<!\\.)(^[^\\\\/:*?\"\"<>|]|$)|^$",
        "description": "Regex for valid folder name.\n1. Do not allow \\ / : * ? \" < > | any where in the language (folder) name.\n2. Do not allow . at beginning or end of text. '.' can present in middle of text.",
        "matches": [
            "ValidFolder.Name",
            "Folder!@#$%^&()",
            "New Folder"
        ],
        "non_matches": [
            "InvalidFolderName>",
            "InvalidFolder.",
            "Invalid<>Folder"
        ]
    },
    {
        "id": 3075,
        "expression": "(?:@[A-Z]\\w*\\s+)*(?:(?:public|private|protected)\\s+)?(?:(?:(?:abstract|final|native|transient|static|synchronized)\\s+)*(?:<(?:\\?|[A-Z]\\w*)(?:\\s+(?:extends|super)\\s+[A-Z]\\w*)?(?:(?:,\\s*(?:\\?|[A-Z]\\w*))(?:\\s+(?:extends|super)\\s+[A-Z]\\w*)?)*>\\s+)?(?:(?:(?:[A-Z]\\w*(?:<[A-Z]\\w*>)?|int|float|double|char|byte|long|short|boolean)(?:(?:\\[\\]))*)|void)+)\\s+(([a-zA-Z]\\w*)\\s*\\(\\s*(((?:[A-Z]\\w*(?:<(?:\\?|[A-Z]\\w*)(?:\\s+(?:extends|super)\\s+[A-Z]\\w*)?(?:(?:,\\s*(?:\\?|[A-Z]\\w*))(?:\\s+(?:extends|super)\\s+[A-Z]\\w*)?)*>)?|int|float|double|char|boolean|byte|long|short)(?:(?:\\[\\])|\\.\\.\\.)?\\s+[a-z]\\w*)(?:,\\s*((?:[A-Z]\\w*(?:<[A-Z]\\w*>)?|int|float|double|char|byte|long|short|boolean)(?:(?:\\[\\])|\\.\\.\\.)?\\s+[a-z]\\w*))*)?\\s*\\))",
        "description": "\\1 references the method signature (eg main(String[] args)), \\2 references the method name (eg main), \\3 references the args (eg String[] args), and \\4 and up reference each arg in turn (including type names). Supports @interfaces, java keywords/primitives, generic classes (including bounded and unbounded parameters), varargs, and array classes, but due to recursion limitations, generic types can only go one level deep (List<String> is ok, but List<List<String>> isn't).\nDoes not match Constructors.",
        "matches": [
            "public static void main(String... args)"
        ],
        "non_matches": [
            "public static void Main(string... args)"
        ]
    },
    {
        "id": 3083,
        "expression": "^(0{0,1}[1-9][0-9]){1}(\\s){0,1}(\\-){0,1}(\\s){0,1}[1-9]{1}([0-9]{3}|[0-9]{4})(\\-){0,1}(\\s){0,1}[0-9]{4}$",
        "description": "Validation to Brazilian telephone number (mobile or not), including DDD and allowing \"9o D\u00edgito\" (on all DDDs). It also accept 2 or 3 digit DDD (11 or 011).\n----- Valid to: ----- 11 98989-9090, 11 977777777, 83-8855-8981, 1199999888, 011 42511992, 01142511992, 011-42511992, 011 4251-1992, 011-4251-1992, 011 98989-9090, 011 977777777, 083-8855-8981, 011999998888, 083 4251-1010, 01192222-3333\n----- Invalid to: ----- 011 9898-90909, 08 98989-9090, 083 4251.1010",
        "matches": [
            "1142511992",
            "11 42511992",
            "11-42511992",
            "11 4251-1992",
            "11-4251-1992",
            "011 98989-9090"
        ],
        "non_matches": [
            "08 98989-9090",
            "083 4251.1010",
            "011 9898-90909"
        ]
    },
    {
        "id": 3097,
        "expression": "<a[\\s]+[^>]*?.*?>([^<]+|.*?)?<\\/a>",
        "description": "for cut links on PHP\n$text = preg_replace(\"/<a[\\s]+[^>]*?.*?>([^<]+|.*?)?<\\/a>/s\",\"\",$text);",
        "matches": [
            "<a href=\"http://www.tss-s.ru/index.php?option=com_content&amp;task=view&amp;id=170&amp;Itemid=75\">\u041a\u0410\u0417\u0410\u0425\u0421\u0422\u0410\u041d</a>"
        ],
        "non_matches": [
            "<a href=\"http://www.tss-s.ru/index.php?option=com_content&amp;task=view&amp;id=170&amp;Itemid=75\">\u041a\u0410\u0417\u0410\u0425\u0421\u0422\u0410\u041d< /a>"
        ]
    },
    {
        "id": 3100,
        "expression": "^([A-Z]{0,3}?[0-9]{9}($[0-9]{0}|[A-Z]{1}))",
        "description": "Medicare number validation:XXXYYYYYYYYYZBBXXX- can be up to 3 letters. Not requiredYYY- 9 digits \u2013 requiredZ- must be letter. No number. Not requiredBB- can be letter or numbers. Not required. Can only exist if Z is exists.",
        "matches": [
            "ABC123456789A12"
        ],
        "non_matches": [
            "CA1234567885"
        ]
    },
    {
        "id": 3105,
        "expression": "(\\w+([-+.']\\w+)*@(gmail.com))",
        "description": "This expression will fail if the host/domain does not end with @gmail.com",
        "matches": [
            "tester@gmail.com"
        ],
        "non_matches": [
            "tester@gmail.net",
            "tester@bob.com"
        ]
    },
    {
        "id": 3110,
        "expression": "^((\\([2-9]\\d{2}\\)[ ]?)|([2-9]\\d{2})[- ]?)\\d{3}[- ]?\\d{4}$",
        "description": "Requires area code, optional parentheses but requires both. Allows '-' or ' '.",
        "matches": [
            "(555) 555-5555",
            "555-555-5555",
            "555 555-5555"
        ],
        "non_matches": [
            "(555 555-5555, (555)-555-5555",
            "555) 555-5555"
        ]
    },
    {
        "id": 3111,
        "expression": "(?!^0*$)(?!^0*\\.0*$)^\\d{1,16}(\\.\\d{1,2})?$",
        "description": "Decimal 18,2 valid 16 digits before decimal place\ni.e. upto 16 digit without decimal place is valid. With decimal place 16digit and 2 digits after decimal place is valid",
        "matches": [
            "1234567890123456.12"
        ],
        "non_matches": [
            "12345678901234567.12"
        ]
    },
    {
        "id": 3112,
        "expression": "^((?!string).)*$",
        "description": "This expression will NOT match any string that contains the word \"string\". You can replace \"string\" with any list of characters you would like to prevent matching on.",
        "matches": [
            "strin",
            "tring",
            "123tring",
            "strin123"
        ],
        "non_matches": [
            "string",
            "123string",
            "string123",
            "anythingwithstringinit"
        ]
    },
    {
        "id": 3115,
        "expression": "(([0-2]{1}[0-9]{1})|([3-3]{1}[0-1]))/[1-12]{2}/[1900-2999]{4}\\s(([0-0]{1}[0-9]{1})|([1-1]{1}[0-9]{1})|([2-2]{1}[0-3]{1})):[0-5]{1}[0-9]{1}:[0-5]{1}[0-9]{1}",
        "description": "UK Data and Time\nUse an 'onupdated' method to correct '31/02/2012' to 28/02/2012, for example.\nMS Visual Studio 2010",
        "matches": [
            "18/12/2012 09:52:07 31/02/2012 09:52:07"
        ],
        "non_matches": [
            "32/12/3000 09:52:07"
        ]
    },
    {
        "id": 3123,
        "expression": "^((((19|20)(([02468][048])|([13579][26])).02.29))|((20[0-9][0-9])|(19[0-9][0-9])).((((0[1-9])|(1[0-2])).((0[1-9])|(1[0-9])|(2[0-8])))|((((0[13578])|(1[02])).31)|(((0[1,3-9])|(1[0-2])).(29|30)))))$",
        "description": "Validates yyyy.MM.dd and yyyy-MM-dd format date,and also verifying leap years.",
        "matches": [
            "2000.02.29",
            "1976.11.10",
            "1988-02-29"
        ],
        "non_matches": [
            "2001.02.29",
            "1980.04.31",
            "1977-05-32"
        ]
    },
    {
        "id": 3125,
        "expression": "(^[1-9]{1,3}(,\\d{3})*$)|(^0$)",
        "description": "Unsigned integer with ',' (comma) as thousands separator, for example: 1,234,500",
        "matches": [
            "1,234,500",
            "45",
            "45,111",
            "0",
            "1,000",
            "25,123"
        ],
        "non_matches": [
            "1,23",
            "0,450",
            "1000",
            "1000,000",
            "300,1234"
        ]
    },
    {
        "id": 3127,
        "expression": "^P(([0-9]+([.,][0-9]*)?Y)?([0-9]+([.,][0-9]*)?M)?([0-9]+([.,][0-9]*)?D)?T?([0-9]+([.,][0-9]*)?H)?([0-9]+([.,][0-9]*)?M)?([0-9]+([.,][0-9]*)?S)?)|\\d{4}-?(0[1-9]|11|12)-?(?:[0-2]\\d|30|31)T((?:[0-1][0-9]|[2][0-3]):?(?:[0-5][0-9]):?(?:[0-5][0-9]|60)|2400|24:00)$",
        "description": "Test for valid ISO 8601 duration value",
        "matches": [
            "P3Y6M4DT12H30M5S P23DT23H P4Y P1M PT1M P0.5Y P0,5Y PT36H P1DT12H P0003-06-04T12:30:05"
        ],
        "non_matches": [
            "1234567"
        ]
    },
    {
        "id": 3144,
        "expression": "((\\d{1,5})*\\.*(\\d{0,3})\"[W|D|H|DIA][X|\\s]).*",
        "description": "It matches product dimensions in inches",
        "matches": [
            "24.5\"WX25\"DX24.125\"H",
            "24.5\"WX25\"H \\ 24.5\"W X 25\"H"
        ],
        "non_matches": [
            "24.5WX25DX24.125H",
            "24.5\"",
            "24.5\"X25\""
        ]
    },
    {
        "id": 3145,
        "expression": "^((0|(\\(0\\)))?|(00|(\\(00\\)))?(\\s?|-?)(27|\\(27\\))|((\\+27))|(\\(\\+27\\))|\\(00(\\s?|-?)27\\))( |-)?(\\(?0?\\)?)( |-)?\\(?(1[0-9]|2[1-4,7-9]|3[1-6,9]|4[0-9]|5[1,3,6-9]|7[1-4,6,8,9]|8[0-9])\\)?(\\s?|-?)((\\d{3}(\\s?|-?)\\d{4}$)|((\\d{4})(\\s?|-?)(\\d{3})$)|([0-2](\\s?|-?)(\\d{3}(\\s?|-?)\\d{3}$)))",
        "description": "Matches all valid mobile numbers, landline numbers, share call etc in all common phone number notations",
        "matches": [
            "+27-11-399-7206"
        ],
        "non_matches": [
            "075-356-6364"
        ]
    },
    {
        "id": 3148,
        "expression": "^((http(s){0,1}\\:\\/\\/){0,1}([a-z|A-Z|0-9|\\.|\\-|_]){4,255}(\\:\\d{1,5}){0,1}){0,1}((\\/([a-z|A-Z|0-9|\\.|\\-|_]|\\%[A-F|a-f|0-9]{2}){1,255}){1,255}\\/{0,1}){0,1}(|\\/{0,1}\\?[a-z|A-Z|0-9|\\.|\\-|_]{1,255}\\=([a-z|A-Z|0-9|\\.|\\-|_|\\+|\\:]|\\%[A-F|a-f|0-9]{2}|\\&[a-z|A-Z]{2,12}\\;){0,255}){0,1}((\\&[a-z|A-Z|0-9|\\.|\\-|_]{1,255}\\=([a-z|A-Z|0-9|\\.|\\-|_|\\+|\\:]|\\%[A-F|a-f|0-9]{2}|\\&[a-z|A-Z]{2,12}\\;){0,255}){0,255})(\\/{0,1}|\\#([a-z|A-Z|0-9|\\.|\\-|_|\\+|\\:]|\\%[A-F|a-f|0-9]{2}|\\&[a-z|A-Z]{2,12}\\;){0,255})$",
        "description": "Validates completely for relative and absolute paths, and allows port definitions. Also contains parameter validation, and allows for anchors and URL escape characters.",
        "matches": [
            "http://www.google.com",
            "https://sub.domain.com:8080/ok",
            "mobi.yoursite.org/%e3498549843",
            "/relative_path/ok/home.aspx?id=4985&x=5"
        ],
        "non_matches": [
            "http://site.com/?id=4095?x=485",
            "http://site.com:3098594",
            "www.site.org?p=this is wrong"
        ]
    },
    {
        "id": 3149,
        "expression": "((?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[\\W_]).{6,50})",
        "description": "Password requires at least 1 lower case character, 1 upper case character, 1 number, 1 special character and must be at least 6 characters and at most 50",
        "matches": [
            "Abcde1!",
            "Abcde1$",
            "ABCDe1!"
        ],
        "non_matches": [
            "abcde1!",
            "ABCDE1!",
            "abcdef"
        ]
    },
    {
        "id": 3156,
        "expression": "-?[0-9]{4}-(((0(1|3|5|7|8)|1(0|2))-(0[1-9]|(1|2)[0-9]|3[0-1]))|((0(4|6|9)|11)-(0[1-9]|(1|2)[0-9]|30))|(02-(0[1-9]|(1|2)[0-9])))T([0-1][0-9]|2[0-4]):(0[0-9]|[1-5][0-9]):(0[0-9]|[1-5][0-9])(\\.[0-999])?((\\+|-)([0-1][0-9]|2[0-4]):(0[0-9]|[1-5][0-9])|Z)?",
        "description": "Matches xs:dateTime values described in XML Schema 1.0. Handles correct days in each month.\nhttp://www.w3.org/TR/xmlschema-2/#dateTime",
        "matches": [
            "2012-01-31T10:00:00Z",
            "2012-02-28T10:00:00Z",
            "2012-02-29T10:00:00Z"
        ],
        "non_matches": [
            "2012-02-30T10:00:00Z",
            "2012-01-32T10:00:00Z",
            "2012-04-31T10:00:00Z"
        ]
    },
    {
        "id": 3159,
        "expression": "(((0[1-9]|(1|2)[0-9]|3[0-1])\\/(0(1|3|5|7|8)|1(0|2)))|((0[1-9]|(1|2)[0-9]|30)\\/(0(4|6|9)|11))|((0[1-9]|(1|2)[0-9])\\/02))\\/[0-9]{4}",
        "description": "UK Date Format, using '/' as the separator character.\nHandles correct days in each month.",
        "matches": [
            "01/01/2013",
            "30/04/2013",
            "29/01/2013"
        ],
        "non_matches": [
            "32/01/2013",
            "31/04/2013",
            "30/02/2013"
        ]
    },
    {
        "id": 3160,
        "expression": "[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}",
        "description": "Matches a Version 4 UUID as described here http://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_.28random.29",
        "matches": [
            "e9257dd5-d221-4293-88c3-93f7d3fada4f",
            "dd536276-4483-4c83-9901-2463f78c81cc",
            "b0a59123-bf86-4047-9760-8c968c6b52d7"
        ],
        "non_matches": [
            "e9257dd5-d221-1293-88c3-93f7d3fada4f",
            "dd536276-4483-4c83-7901-2463f78c81cc",
            "b0a59123-bf86-2047-9760-5c968c6b52d7"
        ]
    },
    {
        "id": 3161,
        "expression": "[a-f0-9]{8}-[a-f0-9]{4}-3[a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}",
        "description": "Matches a Version 3 UUID as described here http://en.wikipedia.org/wiki/Uuid#Version_3_.28MD5_hash.29",
        "matches": [
            "e9257dd5-d221-3293-88c3-93f7d3fada4f",
            "dd536276-4483-3c83-9901-2463f78c81cc",
            "b0a59123-bf86-3047-9760-8c968c6b52d7"
        ],
        "non_matches": [
            "e9257dd5-d221-4293-88c3-93f7d3fada4f",
            "dd536276-4483-4c83-9901-2463f78c81cc",
            "b0a59123-bf86-4047-9760-8c968c6b52d7"
        ]
    },
    {
        "id": 3162,
        "expression": "^((?!.*//.*)(?!.*/ .*)/{1}([^\\\\(){}:\\*\\?<>\\|\\\"\\'])+\\.(csv|jpg|txt|pdf|dat|xls|doc))$",
        "description": "This will match with all absolute file paths in Unix/Linux. The extensions added are csv|jpg|txt|pdf|dat|xls|doc. Can be customized for specific extensions.",
        "matches": [
            "/usr/local/data/userdata.xls, /home/userdata.doc, /accounts.txt"
        ],
        "non_matches": [
            "//usr/local/data/userdata.xls, //usr/local/,/usr/local/ data/users.txt"
        ]
    },
    {
        "id": 3163,
        "expression": "(?<=[[]).*?(?=[]])",
        "description": "Match Text in square braces",
        "matches": [
            "I love [INDIA]"
        ],
        "non_matches": [
            "i love india"
        ]
    },
    {
        "id": 3166,
        "expression": "[A-Z|a-z]{4}[0][\\d]{6}$",
        "description": "IFSC Code normally contains 11 characters.In that first 4 characters are alphabets,5th character is 0 and next 6 characters are numerics",
        "matches": [
            "CITI0344444"
        ],
        "non_matches": [
            "CITI3444444"
        ]
    },
    {
        "id": 3169,
        "expression": "^([7-9]{1})([0-9]{9})$",
        "description": "Mobile Number starts with 7,8,9 and total 10 digits",
        "matches": [
            "9848457682"
        ],
        "non_matches": [
            "123456789"
        ]
    },
    {
        "id": 3170,
        "expression": "^[A-Za-z0-9. ]+(?:[_&%$*#@!-][A-Za-z0-9. ]+)*$",
        "description": "Rules: Username can consist of lowercase and capitals Username can consist of alphanumeric characters Username can consist of underscore and hyphens and spaces Cannot be two underscores or any other specified special characters, two hypens or two spaces in a row Cannot have a underscore, hypen or space at the start or end",
        "matches": [
            "My Name is $Test$ and your name is #testuser# and his name is %testeds% they are *s on this planet."
        ],
        "non_matches": [
            "My Name is $Test$ and your name is #testuser# and his name is %testeds% they are *s on this planet.$"
        ]
    },
    {
        "id": 3171,
        "expression": "(23:59:59)|([01]{1}[0-9]|2[0-3]):((00)|(15)|(30)|(45))+:(00)",
        "description": "match only if 23:59:59 OR increments of 15 minutes from 00:00:00 to 23:45:00\nhh:mm:ss format",
        "matches": [
            "00:00:00, 01:15:00, 22:45:00, 23:59:00"
        ],
        "non_matches": [
            "00:00:01, 12:04:00, 23:55:00, 05:22:36"
        ]
    },
    {
        "id": 3175,
        "expression": "((((19|20)([2468][048]|[13579][26]|0[48])|2000)-02-29|((19|20)[0-9]{2}-(0[469]|11)-(0[1-9]|[12][0-9]|30)|(19|20)[0-9]{2}-(0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01])|(19|20)[0-9]{2}-02-(0[1-9]|1[0-9]|2[0-8])))\\s([01][0-9]|2[0-3]):([012345][0-9]):([012345][0-9]))",
        "description": "Very secure MySQL datetime RegEx pattern control.\nStrictly allow the following format only :\n\"YYYY-MM-DD HH:MM:SS\"\nVerify if date is correct (28,29,30,31 days accoring to the month. Leap years with 29/02 also controled.",
        "matches": [
            "2013-04-05 17:59:59",
            "2013-07-30 01:22:42",
            "2099-12-30 23:59:59",
            "2016-02-28 00:00:00"
        ],
        "non_matches": [
            "2016-02-29 -01:01:02",
            "3000-04-24 17:42:21",
            "2012-03-03 24:24:02",
            "2012-03-03 21:60:45"
        ]
    },
    {
        "id": 3177,
        "expression": "((\\+351|00351|351)?)(2\\d{1}|(9(3|6|2|1)))\\d{7}",
        "description": "Validates mobile and land-line numbers. Also validates international Portuguese code +351.",
        "matches": [
            "217896545",
            "+351214563214",
            "917894125",
            "00351917896352"
        ],
        "non_matches": [
            "dfsdfdf9122222",
            "528521445",
            "+6542544545"
        ]
    },
    {
        "id": 3179,
        "expression": "[A-Za-z]{1,2}[\\d]{1,2}[A-Za-z]{0,1}\\s*[\\d]",
        "description": "The postcode sector is the first block (the postcode district) of a UK postcode plus the first number of the second block. For example with DN55 1PT it would match DN55 1. Its a loose match as it only ensures that the format is correct, it doesn't validate the letters and numbers. It doesn't let in the non-geographic codes postcodes SAN TA1 and GIR 0AA. It will pull out the first block & the sector code of any of the matching examples below. Examples of the names of the different parts of a UK postcode can be found here: http://en.wikipedia.org/wiki/Postcodes_in_the_United_Kingdom#Life-cycle_of_post_codes",
        "matches": [
            "AA9A 9AA",
            "A9A 9AA",
            "A9 9AA",
            "A99 9AA",
            "AA9 9AA",
            "AA99 9AA",
            "EC1A 1BB",
            "W1A 1HQ",
            "M1 1AA",
            "B33 8TH",
            "CR2 6XH",
            "DN55 1PT",
            "AA9A9AA",
            "A9A9AA",
            "A99AA",
            "A999AA",
            "AA99AA",
            "AA999AA"
        ],
        "non_matches": [
            "SAN TA1",
            "GIR 0AA"
        ]
    },
    {
        "id": 3180,
        "expression": "^([(]?[+]{1}[0-9]{1,3}[)]?[ .\\-]?)?[(]?[0-9]{3}[)]?[ .\\-]?([0-9]{3}[ .\\-]?[0-9]{4}|[a-zA-Z0-9]{7})([ .\\-]?[/]{1}[ .\\-]?[0-9]{2,4})?$",
        "description": "An inefficient number validator. PHP and JavaScript compatible.\nDashes [-] can be replaced by \" \" or \".\"\nSupport for extention /000",
        "matches": [
            "+000-000-000-0000",
            "(+000) 000 000 0000",
            "(+000) (000) 000-0000",
            "(000) 000-0000",
            "+1-800-0000000",
            "+1-800-RLYCOOL"
        ],
        "non_matches": [
            "1-800-0000000",
            "1-800-RLYCOOL"
        ]
    },
    {
        "id": 3197,
        "expression": "^-?(\\d+(,\\d{3})*(\\.\\d+)?|\\d?(\\.\\d+))$",
        "description": "Matches any floating point numeric string with or without commas.",
        "matches": [
            "123",
            "9,001",
            "-123,456,789.123",
            "3.14159",
            ".25"
        ],
        "non_matches": [
            "abc",
            "-",
            "123,456,78",
            "0.123.456",
            "234.567,890",
            ",123,456"
        ]
    },
    {
        "id": 3199,
        "expression": "(\\d{1,3}[\\.]\\d*)[, ]+-?(\\d{1,3}[\\.]\\d*)",
        "description": "Matches Google Maps style GPS Decimal format, but not Northing, Easting style or DMS",
        "matches": [
            "38.048889, 122.157778",
            "46.3881 -116.8204"
        ],
        "non_matches": [
            "46\u00b023'17.1600, -116\u00b049'13.4400",
            "38\u00b02'56'N, 122\u00b09'28'W",
            "38\u00b02'56''N, 122\u00b09'28''W",
            "38\u00b02'56\"N, 122\u00b09'28\"W",
            "40:26:46N,079:56:55W",
            "40\u00b026\u203247\u2033N 079\u00b058\u203236\u2033W",
            "40d 26m 47s N 079d 58\u2032 36\u2033 W",
            "90 00 00.0, 180 00 00.0",
            "89 59 50.4141 S 090 29 20.4 E",
            "00 00 00.0, 000 00 00.0"
        ]
    },
    {
        "id": 3200,
        "expression": "^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*\\W)(?!.*\\s).{8,}$",
        "description": "Password expresion that requires one lower case letter, one upper case letter, one digit, one non-word character, 8>= length and no spaces.",
        "matches": [
            "aA@1aaaa",
            "aA@1aaaaasfljs;lkfe"
        ],
        "non_matches": [
            "aA@1a aaa",
            "aA1aaaaaaaa",
            "12345678"
        ]
    },
    {
        "id": 3201,
        "expression": "^[a-zA-Z]{3}[0-9]{6}$",
        "description": "Simple Pac code regex, first 3 should be letters and last 6 should be digits.",
        "matches": [
            "abc123456",
            "ptx654321"
        ],
        "non_matches": [
            "abc 123456",
            "ab12345x",
            "abc12345"
        ]
    },
    {
        "id": 3207,
        "expression": "^((\\+|00)[1-9]{1,3})?(\\-| {0,1})?(([\\d]{0,3})(\\-| {0,1})?([\\d]{5,11})){1}$",
        "description": "International phone number with 6 capturing groups:\ninternational prefix (00 xor '+');\n1 to 3 international code number, no zero allowed;\noptional space or hyphen;\n0 to 3 local prefix number;\noptional space or hyphen;\n5 to 11 local number without spaces or hyphens;",
        "matches": [
            "0034 91 12345678",
            "+39-2-1234567",
            "9112345678"
        ],
        "non_matches": [
            "0034 91 123-456-789",
            "(91)12345678",
            "0034 (91)12345678"
        ]
    },
    {
        "id": 3209,
        "expression": "^([a-z0-9]+[.+-])*([a-z0-9]+)+@(([a-z0-9]+[.-])+([a-z]{2,})$|(([0-9]|[1-9][0-9]|1[0-9]{1,2}|2[0-4][0-9]|25[0-5])(\\.|$)){4})",
        "description": "Validates most common varieties of email addresses.\nWill accept domain with character-valid TLD, and also will accept an IPv4 address.\nIt doesn't support validation of IPv6 address.\nWill also accept a valid username with tags.",
        "matches": [
            "j-ohn.smith@example.com",
            "j.smith+account@sub-domain.domain.tld",
            "1@4.144.0.255",
            "a+a@0.0.0.0"
        ],
        "non_matches": [
            ".s@example.com",
            "name.+tag@domain.tld",
            "aaa+@domain.tld",
            "john@125.122.1",
            "a@a",
            "a@a.255",
            "a@a.com1"
        ]
    },
    {
        "id": 3211,
        "expression": "(?!^[0-9]*$)(?!^[a-zA-Z]*$)^([a-zA-Z0-9]{6,8})$",
        "description": "It Required Input of a combination of Numbers & Strings also length must be greater than 6...",
        "matches": [
            "123456s",
            "abc123",
            "123abc"
        ],
        "non_matches": [
            "1234567",
            "+_()'675",
            "abcdefgh"
        ]
    },
    {
        "id": 3214,
        "expression": "^\\d{5}[- .]?\\d{7}[- .]?\\d{1}$",
        "description": "It Required Input of National ID Card Number with or without dash(-), Please Rate!",
        "matches": [
            "45506-6532448-5",
            "4551658624457"
        ],
        "non_matches": [
            "AAA45-65AAA7-2",
            "AAAAA765A66AA",
            "AAAAAAAAAAAAA"
        ]
    },
    {
        "id": 3215,
        "expression": "^\\{[A-Fa-f\\d]{8}-[A-Fa-f\\d]{4}-[A-Fa-f0\\d]{4}-[A-Fa-f\\d]{4}-[A-Fa-f\\d]{12}\\}$",
        "description": "This validates GUID strings. It is not case sensitive and requires the beginning and ending curly brackets - '{' and '}' - to be present.",
        "matches": [
            "{CA373C30-293E-4DB8-A5E4-07AEA8D3F16E}",
            "{01234567-8998-7654-3210-012345678998}",
            "{ABCDEFFE-DCBA-ABCD-EFFE-DCBAABCDEFFE}"
        ],
        "non_matches": [
            "{ABCDEFGH-IJKL-MNOP-QRST-UVWXYZ123456}",
            "{0123-456789AB-CDEF-FEDC-BA9876543210}\"",
            "{0123456789ABCDEFFEDCBA9876543210}"
        ]
    },
    {
        "id": 3216,
        "expression": "^(?=.*\\d)\\w+$",
        "description": "Any alphabets are allowed.Passsword must contain atleast 1 digit and none of the characters are allowed.",
        "matches": [
            "password1"
        ],
        "non_matches": [
            "password1@"
        ]
    },
    {
        "id": 3219,
        "expression": "((0[1-9])|(1[0-9])|(2[0-9])|(3[0]))/((0[1-9])|(1[0-2]))/14[3-9]{2}",
        "description": "Matches DD/MM/YYYY for Arabic Hijri Dates. It starts range from 1434 ( current year ) to 1499",
        "matches": [
            "29/12/1434",
            "01/02/1435",
            "30/11/1434"
        ],
        "non_matches": [
            "31/12/144",
            "01/2/1435",
            "5/5/1435"
        ]
    },
    {
        "id": 3228,
        "expression": "^(0|\\+33)[1-9]([-. ]?[0-9]{2}){4}$",
        "description": "Match french phone number with or without french international dialling code",
        "matches": [
            "+33622313131",
            "02 02 02 02 02",
            "0303030303"
        ],
        "non_matches": [
            "+34622313131",
            "1702020202"
        ]
    },
    {
        "id": 3232,
        "expression": "(?<!\\.)(?<!e[+-])(\\b\\d+\\b)(?!\\.)",
        "description": "Locates standalone integers, like the 1 and 4 in 1/4, but doesn't match the 5 in 6e-5 (nor the 6, in fact). I use this to convert 1/4 to 1.0/4.0 so that it can be evaluated as a floating number, since 1/4 by itself will normally eval to 0 (integer division). However, 6e-5.0 would not be valid.",
        "matches": [
            "1/4",
            "1e-2+1/4",
            "1.2+4/7"
        ],
        "non_matches": [
            "1.9e-2",
            "1e+3",
            "1e4"
        ]
    },
    {
        "id": 3234,
        "expression": "^(\\d?)*\\.?(\\d{1}|\\d{2})?$",
        "description": "Expression to validate currency formatted numbers without the currency symbol. This is an updated version of my previous expression and now works in ASP.NET regular expression validators.",
        "matches": [
            "153",
            "33.48",
            "786.1",
            "1567863483.33"
        ],
        "non_matches": [
            "-123",
            "8524.258",
            "eo45"
        ]
    },
    {
        "id": 3237,
        "expression": "^((?:[A-HJ-PR-Y][A-HJ-PR-Y]\\s?(?:0[2-9]|[1-9][0-9])\\s?[A-HJ-PR-Z]{3})|(?:[A-Z](?:[IZ][A-Z]|[A-Z][IZ])\\s?\\d{1,4})|(?:[A-HJ-NP-TV-Y]\\s?\\d{1,3}\\s?[A-Z]{3})|(?:[A-Z]{3}\\s?\\d{1,3}\\s?[A-HJ-NPR-TV-Y])|(?:\\d{1,3}\\s?[A-HJ-Y]{1,3}|[A-HJ-Y]{1,3}\\s?\\d{1,3})|(?:\\d{1,4}\\s?(?:[IZ][A-Z]|[A-Z][IZ]))|(?:[A-Z]{1,2}\\s?\\d{1,4}))$",
        "description": "Matches all UK number plates used in England, Scotland, Wales and Northern Ireland, including the dateless formats pre-1932 and 1932-1963 formats, the year prefix and suffix formats, and the current style format brought into use from 2001 onwards.",
        "matches": [
            "AAA111",
            "A123BCD",
            "ACB123D",
            "AB12CDE"
        ],
        "non_matches": [
            "A12345",
            "I123JKL",
            "IQ12RST",
            "ABC123O"
        ]
    },
    {
        "id": 3239,
        "expression": "(t|T)(o|O)\\s\\d{4}($|\\D)",
        "description": "Catch text containing \"to \" followed by 4 digit number. Not more than 4 digits, ie 5 or 8 digits.",
        "matches": [
            "to 9373H",
            "tO 0934",
            "TO 6266",
            "To 0937",
            "to 9347.",
            "to 9837",
            "to 8933",
            "to 8937"
        ],
        "non_matches": [
            "to 82799"
        ]
    },
    {
        "id": 3248,
        "expression": "^[13][a-zA-Z0-9]{26,33}$",
        "description": "Matches bitcoin payment (public-key) address.\nAddress must begin with a 1 or 3 and have 27-34 total alphanumeric characters.\nWill exclude Litecoin addresses.\nDoes NOT do a checksum.",
        "matches": [
            "1EEVBLgg4h4TTLv76QiQ1Thcvvk3Be7VPV"
        ],
        "non_matches": [
            "31uEbMgunupShBVTewXjtqbBv5MndwfXhbzz, L12332liteoinaddress"
        ]
    },
    {
        "id": 3249,
        "expression": "^L[a-zA-Z0-9]{26,33}$",
        "description": "Matches litecoin payment (public-key) address. Address must begin with a L and have 27-34 total alphanumeric characters. Will exclude bitcoin address since they begin with 1 or 3. Does NOT do a checksum.",
        "matches": [
            "Lg6GPVfPsmPAbTWYuKBQXtdGnBuCWcxHcr"
        ],
        "non_matches": [
            "19RsSjVgob3JgU9cP9PPEiySftNpbU49Xm",
            "qwerty",
            "__**"
        ]
    },
    {
        "id": 3253,
        "expression": "(^|([:]|\\n|\\s))(4[0-9]{3}[ -]*[0-9]{4}[ -]*[0-9]{4}[ -]*[0-9]{4}|5[12345][0-9]{2}[ -]*[0-9]{4}[ -]*[0-9]{4}[ -]*[0-9]{4}|3[47][0-9]{2}[ -]*[0-9]{6}[ -]*[0-9]{5}|3(?:0[012345]|[68][0-9])[0-9][ -]*[0-9]{6}[ -]*[0-9]{4}|6(?:011|5[0-9]{2})[ -]*[0-9]{4}[ -]*[0-9]{4}[ -]*[0-9]{4}|35[0-9]{2}[ -]*[0-9]{4}[ -]*[0-9]{4}[ -]*[0-9]{4}|(?:2131|1800)[ -]*[0-9]{6}[ -]*[0-9]{5})",
        "description": "Singular Expression standalone or starting with new line, any whitespace or a colon",
        "matches": [
            "4916 3337 5336 2425"
        ],
        "non_matches": [
            "8024007142161982"
        ]
    },
    {
        "id": 3254,
        "expression": "http[s]?://(www.facebook|[a-zA-Z]{2}-[a-zA-Z]{2}.facebook|facebook)\\.com/(pages/[a-zA-Z0-9\\.-]+/[0-9]+|[a-zA-Z0-9\\.-]+)[/]?$",
        "description": "Validating facebook pages url with rules such as with \"www\" or without \"www\", include localization domain such as \"en-gb\"",
        "matches": [
            "https://www.facebook.com/PETRONASMOTORSPORTS",
            "http://www.facebook.com/PETRONASMOTORSPORTS",
            "https://facebook.com/PETRONASMOTORSPORTS",
            "http://facebook.com/PETRONASMOTORSPORTS",
            "https://www.facebook.com/pages/MotherKidzcommy/233933596702267",
            "http://www.facebook.com/pages/MotherKidzcommy/233933596702267",
            "http://www.facebook.com/233933596702267",
            "https://www.facebook.com/233933596702267"
        ],
        "non_matches": [
            "https://facebook.com/pages/MotherKidzcommy/",
            "http://facebook.com/pages/MotherKidzcommy/"
        ]
    },
    {
        "id": 3259,
        "expression": ".*[a-zA-Z]$",
        "description": "This expression will accept only for characters both case(upper and lower)",
        "matches": [
            "lalu",
            "LALU",
            "LAlu"
        ],
        "non_matches": [
            "lalu123",
            "LALU #$#$",
            "Lalu$%"
        ]
    },
    {
        "id": 3264,
        "expression": "^(([0][1-9]|[1|2][0-9]|[3][0|1])[./-]([0][1-9]|[1][0-2])[./-]([0-9]{4})|(([0][1-9]|[1|2][0-9]|[3][0|1])[./-]([0][1-9]|[1][0-2])[./-]([0-9]{4}))[ ]([0|1][0-2])[:](([0-5][0-9]))([:](([0-5][0-9])))?)$",
        "description": "this regular expression accepts date and optinal time with format\n(dd)[.-/](MM)[.-/](yyyy)[ ]\n(hh)[:](mm)[:](ss)",
        "matches": [
            "01-01-2014 10:50",
            "01/01/2014 10:50:59",
            "11-10-2012"
        ],
        "non_matches": [
            "01-01-2014 10:60",
            "32-01-2014 10:50",
            "01-13-2014 10:50"
        ]
    },
    {
        "id": 3266,
        "expression": "^(0{1})([1-9]{2})(\\s|-|.{0,1})(\\d{3})(\\s|-|.{0,1})(\\d{2})(\\s|-|.{0,1})(\\d{2})$",
        "description": "useful regex when we only need phone number from and for people inside the country",
        "matches": [
            "025 546 58 78",
            "025-546-58-78",
            "025.546.58.78",
            "0255465878"
        ],
        "non_matches": [
            "0041 025 546 58 78",
            "+41 025 546 58 78",
            "+41 (0) 25 546 58 78"
        ]
    },
    {
        "id": 3270,
        "expression": "^[{|\\(]?[0-9a-fA-F]{8}[-]([0-9a-fA-F]{4}[-]){3}[0-9a-fA-F]{12}[\\)|}]?|[{|\\(]?[0-9a-fA-F]{8}([0-9a-fA-F]{4}){3}[0-9a-fA-F]{12}[\\)|}]?$",
        "description": "Matches 32 hex string, with optional hypens and optional closing braces",
        "matches": [
            "{0C885DD3-7DD9-484B-9B20-3E6552BCA144}",
            "0C885DD3-7DD9-484B-9B20-3E6552BCA144",
            "0C885DD37DD9484B9B203E6552BCA144"
        ],
        "non_matches": [
            "0C885DD3-7DD9-484B-9B20-1E6552BCA",
            "0C885DD3-7DD9484B9B203E6552BCA144",
            "0C885DD37DD9484B9B203E6552BCA1TT"
        ]
    },
    {
        "id": 3275,
        "expression": "^((\\b[A-Z0-9](\\w)*\\b)|\\s)*$",
        "description": "Validate first letter of each word must capital.",
        "matches": [
            "Amit Chandrakantbhai Rami"
        ],
        "non_matches": [
            "Amit chandrakantbhai Rami"
        ]
    },
    {
        "id": 3277,
        "expression": "^([0-9]{4})([0-9]{5})([0-9]{1})$",
        "description": "The INN code is formed by:\nthe code of the tax department where INN was given (4 numbers), the record number of a registered company in the territorial section of the Unified State Register of Legal Entities in the tax department where INN was given (5 numbers), check digit (1 numbers)",
        "matches": [
            "1234567891"
        ],
        "non_matches": [
            "-"
        ]
    },
    {
        "id": 3278,
        "expression": "^([0-9]{1})([0-9]{2})([0-9]{2})([0-9]{7})([0-9]{1})$",
        "description": "The OGRN code is formed by: the state registration number has the status of the main one (1 number), two last numbers of the year when the record was made (2 numbers), the sequence number of a constituent entity of Russia according to the list of constituent entities of Russia (2 numbers), record number entered in the state register within a year (7 numbers), check digit (1 number)",
        "matches": [
            "1234567891234"
        ],
        "non_matches": [
            "-"
        ]
    },
    {
        "id": 3280,
        "expression": "^((0[1-9]|[12][0-9]|3[01])([/])(0[13578]|[1][02])([/])(19[0-9][0-9]|20[0-9][0-9]))|((0[1-9]|[12][0-9]|30)([/])(0[469]|11)([/])(19[0-9][0-9]|20[0-9][0-9]))|((0[1-9]|[1][0-9]|[2][0-8])([/])(02)([/])(19[0-9][0-9]|20[0-9][0-9]))|((29)([/])(02)([/])(190[48]|19[13579][26]|19[2468][048]|20[02468][048]|20[13579][26]))$",
        "description": "This pattern validates dates with slash (/) separator and with years between 1900 and 2099.",
        "matches": [
            "01/01/1900",
            "05/12/2014",
            "31/12/2099"
        ],
        "non_matches": [
            "41/01/1900",
            "21/31/2014",
            "21/12/1899",
            "21/12/2100"
        ]
    },
    {
        "id": 3283,
        "expression": "^[A-Z]{1}[AEIOUX]{1}[A-Z]{2}((\\d{2}((0[13578]|1[02])(0[1-9]|[12][0-9]|3[01])|(0[13-9]|1[0-2])(0[1-9]|[12][0-9]|30)|02(0[1-9]|1[0-9]|2[0-8])))|([02468][048]|[13579][26])0229)[HM]{1}(AS|BC|BS|CC|CS|CH|CL|CM|DF|DG|GT|GR|HG|JC|MC|MN|MS|NT|NL|OC|PL|QT|QR|SP|SL|SR|TC|TS|TL|VZ|YN|ZS|NE)[B-DF-HJ-NP-TV-Z]{3}[0-9A-Z]{1}[0-9]$",
        "description": "This regular expression is used to check the correct input of Mexican CURP, this regex has been modified over the years to correct some bugs.\nEsta expresi\u00f3n regular la uso para checar la captura de curp en un sistema donde es utilizada como llave universal y se ha actualizado para arreglar peque\u00f1os errores como X en el segundo caracter y que la fecha de nacimiento sea valida.",
        "matches": [
            "CUJM540331MZSNRX09",
            "SASD760229HDFNRV04",
            "PXTA920430HSLNRN02"
        ],
        "non_matches": [
            "FRJU450324HBSKJD09",
            "POLO530229MJCJWSD04",
            "LOOR540932MOCKLD00"
        ]
    },
    {
        "id": 3293,
        "expression": "myInstance\\.myMethod(.*)\\(.*myParam.*\\)",
        "description": "Searchs through code for the myParam value passed as parameter of the myMethod call of myInstance object",
        "matches": [
            "myInstance.myMethod( 1, myParam, 'test')"
        ],
        "non_matches": [
            "myInstance2.myMethod( 1, myParam, 'test')"
        ]
    },
    {
        "id": 3295,
        "expression": "^(1[0-2]|0?[1-9]):([0-5]?[0-9])( AM| PM)$",
        "description": "You want to validate times in various traditional time formats, such as hh:mm tt 12-hour formats.",
        "matches": [
            "12:45 AM",
            "2:30 PM"
        ],
        "non_matches": [
            "12:45AM",
            "2:30PM"
        ]
    },
    {
        "id": 3296,
        "expression": "^(2[0-3]|[01]?[0-9]):([0-5]?[0-9]):([0-5]?[0-9])$",
        "description": "Validate Traditional Time Formats Hours, minutes and seconds, 24-hour clock:",
        "matches": [
            "09:45:12",
            "19:05:12"
        ],
        "non_matches": [
            "07:35 AM"
        ]
    },
    {
        "id": 3300,
        "expression": "^(([a-zA-Z]:)|((\\\\|/){1,2}\\w+)\\$?)((\\\\|/)(\\w[\\w ]*.*))+\\.([a-zA-Z0-9]+)$",
        "description": "Matches file paths to any valid format. Matches both \"\\\" and \"/\" as valid separators in file path. Extension (\"[a-zA-Z0-9]+\") can be changed to any specific extension like (txt|jpg|png) and so on.Does NOT match relative file paths.\nFeel free to write any comments about bugs or anything, since this is my first contribution to regexlib",
        "matches": [
            "/asdjd/jhsdh.ajsd",
            "E:\\drive.txt",
            "\\\\usr\\home\\docs.jpg",
            "\\users\\assassin\\home/yp.r15"
        ],
        "non_matches": [
            "//home/boo/",
            "foo/bar.bmp"
        ]
    },
    {
        "id": 3302,
        "expression": "^(\\d{4}-((0[1-9]|1[012])-(0[1-9]|1\\d|2[0-8])|(0[13456789]|1[012])-(29|30)|(0[13578]|1[02])-31)|(\\d{2}[02468][048]|[13579][26])-02-29) (0[0-9]|1[0-9]|2[0-4]):(60|[0-5][0-9]):(60|[0-5][0-9])$",
        "description": "This pattern allows for full DateTime entry using yyyy-MM-dd hh:mm:ss format.",
        "matches": [
            "2014-08-07 16:52:14",
            "2004-02-29 00:00:59",
            "1800-01-01 23:31:59"
        ],
        "non_matches": [
            "2014-08-07 25:52:14",
            "2004-02-30 00:00:59",
            "1800-30-01 23:31:59"
        ]
    },
    {
        "id": 3303,
        "expression": "([\\\"']).*?[^\\\\]\\1",
        "description": "Matches strings in source code for languages that allow string to be single- or double-quoted.",
        "matches": [
            "It's called \"Montezuma's revenge\"",
            "\"string with a \\\"string\\\" in it\"",
            "Two 'quotes' on a single \"line\""
        ],
        "non_matches": [
            "Mom's cooking",
            "\"",
            "\"improperly closed string'"
        ]
    },
    {
        "id": 3306,
        "expression": "((^\\d{8})|(^\\d{2}[ ]\\d{2}[ ]\\d{2}[ ]\\d{2})|(^\\d{4}[ ]\\d{4}))$",
        "description": "A Danish phone number can be written in three ways (if you don't include the country code +45). Either\none block of 8 digits or two blocks of four digits or\nfour blocks of two digits.",
        "matches": [
            "12345678",
            "1234 5678",
            "12 34 56 78"
        ],
        "non_matches": [
            "123 456 78",
            "12 3456 78",
            "1 23 45 67 8",
            "55 ab 66 xy"
        ]
    },
    {
        "id": 3307,
        "expression": "^(?!0\\d)([0-9]{1,}(,[0-9]{2}))$",
        "description": "No leading zeroes. Must have 2 digits after the decimal comma ','",
        "matches": [
            "0,00",
            "12,34",
            "2014,08"
        ],
        "non_matches": [
            "00,00",
            "12",
            "12,3",
            "12,345",
            "08,20"
        ]
    },
    {
        "id": 3312,
        "expression": "^((8|\\+7)[\\- ]?)?(\\(?\\d{3}\\)?[\\- ]?)?[\\d\\- ]{7,10}$",
        "description": "Focused on the Russian mobile + city code of 3 digits (eg, Russia).\n+79261234567\n89261234567\n79261234567\n+7 926 123 45 67\n8(926)123-45-67\n123-45-67\n9261234567\n79261234567\n(495)1234567\n(495) 123 45 67\n89261234567\n8-926-123-45-67\n8 927 1234 234\n8 927 12 12 888\n8 927 12 555 12\n8 927 123 8 123",
        "matches": [
            "+79261234567",
            "8(926)123-45-67",
            "+7 926 123 45 67"
        ],
        "non_matches": [
            "+9 000 000 00 00"
        ]
    },
    {
        "id": 3315,
        "expression": "^\\d?\\d([./-])\\d?\\d\\1(?:\\d\\d|\\d{4})$",
        "description": "Here's a super simple one for checking dates written numerically, MM/DD/YYYY. Separators can be \"/\", \"-\", or \".\" and must be the same. Because of it's simplicity it will allow dates that don't exist but that doesn't matter if you're looking for a basic date format checker and like to keep it simple.",
        "matches": [
            "1/2/14",
            "01-02-2014",
            "1.20.14"
        ],
        "non_matches": [
            "1/2/014",
            "1-2.2014",
            "Jan.2, 2014"
        ]
    },
    {
        "id": 3317,
        "expression": "^([a-yA-Y]{3,4}(?:\\.?|[a-yA-Y]{1,6}?)\\s?\\d?\\d(?:[d-tD-T]{2})?\\,?\\s?(?:\\'?\\d\\d|\\d{4}))$",
        "description": "This will match things resembling a written date. It will match dates written incorrectly of course but this cute and funny date matching regex is for the beauty of the simplicity in checking the many ways to write a date.",
        "matches": [
            "Jan. 1, 2014",
            "January 1, '14",
            "JAN 1ST 2014"
        ],
        "non_matches": [
            "this is not a date",
            "123 isn't either",
            "neither is this!"
        ]
    },
    {
        "id": 3322,
        "expression": "^100$|^0$|^[1-9]{0,1}[0-9]{0,1}$|^[1-9]{0,1}[0-9]{0,1}\\.[0-9]{1,3}$",
        "description": "Or depending on the decimal convention:\n^100$|^0$|^[1-9]{0,1}[0-9]{0,1}$|^[1-9]{0,1}[0-9]{0,1}\\,[0-9]{1,3}$\nCredit to Samir Azza's expression which I used to expand and arrive at the above expression.",
        "matches": [
            "100",
            "0",
            "99.99",
            "10",
            "5",
            "1.28"
        ],
        "non_matches": [
            "00",
            "09.9",
            "05.9"
        ]
    },
    {
        "id": 3323,
        "expression": "^((\\(([1-9]{2})\\))(\\s)?(\\.)?(\\-)?([0-9]{0,1})?([0-9]{4})(\\s)?(\\.)?(\\-)?([0-9]{4})|(([1-9]{2}))(\\s)?(\\.)?(\\-)?([0-9]{0,1})?([0-9]{4})(\\s)?(\\.)?(\\-)?([0-9]{4}))$",
        "description": "This expression allows Brazilian phone numbers as they have 4 or 5 prefix digits and with/without regional code. Not perfect but simplifies. Also allows space or dot or hyphen as optional separator in the number as parenthesis in regional code.",
        "matches": [
            "(13)98145-5566",
            "(11)8854-3236",
            "(11) 8854-3236",
            "(11).8854.3236",
            "(11)-8854-3236",
            "1177854425",
            "11.5642-3115"
        ],
        "non_matches": [
            "(13654854",
            "01 9854-4253",
            "11.456758-525"
        ]
    },
    {
        "id": 3324,
        "expression": "((20)[0-9]{2})-((0[1-9])|(1[0-2]))-((3[0-1])|([0-2][1-9]|([1-2][0-9])))\\s((2[0-3])|[0-1][0-9]):[0-5][0-9]",
        "description": "Date and hour with fixed format, only accepting year >= 2000. If you want more flexibility on the year, you could replace the first expression (20)[0-9]{2} with only [0-9]{4}, that would allow years from 0000 to 9999.",
        "matches": [
            "2000-12-29 10:00 2014-10-20 23:59 2001-01-01 00:00"
        ],
        "non_matches": [
            "1999-12-29 09:00 2014-01-02 9:00 2000-1-1 23:10"
        ]
    },
    {
        "id": 3325,
        "expression": "[0-9.\\-/+() ]{4,}",
        "description": "This regex supports international praefix, the national (0) and extension numbers.",
        "matches": [
            "+49 (0)40/529 567-31",
            "529 567-31"
        ],
        "non_matches": [
            "529"
        ]
    },
    {
        "id": 3326,
        "expression": "[D]?[-D]?[0-9]{5}",
        "description": "German postal code with or without national praefix.",
        "matches": [
            "D-25335; 25335"
        ],
        "non_matches": [
            "5335"
        ]
    },
    {
        "id": 3328,
        "expression": "\\bhttp(s?)\\:\\/\\/[a-zA-Z0-9\\/\\?\\-\\.\\&amp;\\(\\)_=#]*",
        "description": "Detects URLs in texts. http or https must precede the URL.",
        "matches": [
            "https://icd.slr.xxp.corp/xxp(bD1lbiZjPTAwMSZkPW1pbg==)/bc/bsp/xxp/crm_ui_start/default.htm?sxxrole=ZSU_DEF",
            "http://de.selfhtml.org/perl/sprache/regexpr.htm#zeichen",
            "http://dict.leo.org/#/search=precede&searchLoc=0&resultOrder=basic&multiwordShowSingle=on"
        ],
        "non_matches": [
            "www.mgvo.de",
            "www.facebook.com",
            "google.de"
        ]
    },
    {
        "id": 3336,
        "expression": "(?i)\\w.*\\@\\w*\\.\\w*",
        "description": "Extract Email Address - Autoit",
        "matches": [
            "test@server.com",
            "test2_@server.net"
        ],
        "non_matches": [
            "test3@server"
        ]
    },
    {
        "id": 3346,
        "expression": "[A-Za-z_.0-9-]+@{1}[a-z]+([.]{1}[a-z]{2,4})+",
        "description": "Useful and easy to use RegEx for email validation. Allowed alphabets (capital and small), 0 to 9, \".\", \"_\" and \"-\" before \"@\". Then exactly one \"@\" is allowed in whole email then small letters (1 or more) then multiple set of \".\" and alphabets (2 to 4)",
        "matches": [
            "hamza@demo.net",
            "hamza@demo.co.uk",
            "s.hamza.hasan@googlemail.com",
            "a@b.cc"
        ],
        "non_matches": [
            "a@b.c",
            "@co.uk",
            "hamza@tk.",
            "demo@.com",
            "demo.dem@hero.c"
        ]
    },
    {
        "id": 3347,
        "expression": "^[1-9][0-9][0-9][0-9][0-9][0-9]$",
        "description": "picode test",
        "matches": [
            "221001"
        ],
        "non_matches": [
            "abcdd"
        ]
    },
    {
        "id": 3348,
        "expression": "^([1-9]\\d{0,3}|[1-5]\\d{4}|6[0-4]\\d{3}|65[0-4]\\d{2}|655[0-2]\\d|6553[0-5])$",
        "description": "Match TCP/UDP port number between 1 and 65535",
        "matches": [
            "1",
            "23",
            "1024",
            "65535"
        ],
        "non_matches": [
            "0",
            "65536"
        ]
    },
    {
        "id": 3349,
        "expression": "^((19[0-9][0-9])|(20[0-1][0-5]))\\-((0?[1-9])|(1[0-2]))\\-((0?[1-9])|([1-2][0-9])|(3[0-1]))$",
        "description": "Year, month and day with dashes.Year starts from 1900 to 2015 and must be 4 digits.",
        "matches": [
            "2012-05-21",
            "1960-12-14",
            "1910-5-3"
        ],
        "non_matches": [
            "2011/5/21",
            "60-12-14",
            "2021-5-3"
        ]
    },
    {
        "id": 3351,
        "expression": "^\\w+\\W+[a-z]\\W+(\\w+)([a-z])(\\w+)\\s\\&\\s\\w+\\W+[a-z]\\W+\\1(?!\\2)[a-z]\\3$",
        "description": "Spelling mistakes found in last name 2nd letter to before a end letter",
        "matches": [
            "william a parker & john l perker"
        ],
        "non_matches": [
            "John a smith & William b smith"
        ]
    },
    {
        "id": 3352,
        "expression": "(=)|(<)|(>)|(')|(--)|(/)|(\\+)|(;)|(\\*)|(!)|({)|(})|(drop table)|(drop stored)|(alter table)|(alter stored)|(sp_)|(xp_)|(exec )|(execute )|(fetch)|(select)|(kill)|(selectsys)|(sysobjects)|(syscolumns)|(isnull)|(coalesce)|(dbo)|(tbl)|(usp)",
        "description": "Prevent to use any text that can be executed on the database, it limits many options on the text but is safer than let all on the framework",
        "matches": [
            "example' OR 1=1, drop all the walls and drop table"
        ],
        "non_matches": [
            "this is an example regex"
        ]
    },
    {
        "id": 3355,
        "expression": "^(\\+{1,2}?([0-9]{2,4}|\\([0-9]{2,4}\\))?(-|\\s)?)?[0-9]{2,3}(-|\\s)?[0-9\\-]{5,10}$",
        "description": "Detect most pattern of universal phone numbers",
        "matches": [
            "+(934)-50-1234567"
        ],
        "non_matches": [
            "-94-567834"
        ]
    },
    {
        "id": 3356,
        "expression": "http[s]?://(www.facebook|[a-zA-Z]{2}-[a-zA-Z]{2}.facebook|facebook)\\.com/(events/[0-9]+|[a-zA-Z0-9\\.-]+)[/]?$",
        "description": "Validating facebook events url with rules such as with \"www\" or without \"www\", include localization domain such as \"en-gb\"",
        "matches": [
            "http://www.facebook.com/events/233933596702267 https://www.facebook.com/events/233933596702267"
        ],
        "non_matches": [
            "http://facebook.com/pages/Andy-Worthington/196377860390800",
            "www.facebook.com/pages/Andy-Worthington/196377860390800",
            "http://www.facebook.com/people/Andy-Worthington/738143803"
        ]
    },
    {
        "id": 3357,
        "expression": "^(http(?:s)?\\:\\/\\/[a-zA-Z0-9]+(?:(?:\\.|\\-)[a-zA-Z0-9]+)+(?:\\:\\d+)?(?:\\/[\\w\\-]+)*(?:\\/?|\\/\\w+\\.[a-zA-Z]{2,7}(?:\\?[\\w]+\\=[\\w\\-]+)?)?(?:\\&[\\w]+\\=[\\w\\-]+)*)$",
        "description": "A simple but powerful URL validating regex. Accepts multiple sub-domains and sub-directories. Even accepts query strings ande ports! Accepts HTTP or HTTPS. Also accepts optional \"/\" on end of address. This may be the mother of all URL regexes. It's much more stricter than most others that do far less.",
        "matches": [
            "http://website.com",
            "http://subdomain.web-site.com/cgi-bin/perl.cgi?key1=value1&key2=value2"
        ],
        "non_matches": [
            "http://website.com/perl.cgi?key=",
            "http://web-site.com/cgi-bin/perl.cgi?key1=value1&key2"
        ]
    },
    {
        "id": 3358,
        "expression": "^([a-zA-Z0-9]+(?:[.-]?[a-zA-Z0-9]+)*@[a-zA-Z0-9]+(?:[.-]?[a-zA-Z0-9]+)*\\.[a-zA-Z]{2,7})$",
        "description": "Yet another regex to help validate email addresses. This will work for 99% of all email addresses entered into the average website form. Stricter than RFC2822.",
        "matches": [
            "name@email.com"
        ],
        "non_matches": [
            "_name@.email.com"
        ]
    },
    {
        "id": 3359,
        "expression": "^(http\\:\\/\\/[a-zA-Z0-9\\-\\.]+\\.[a-zA-Z]{2,7}(?:\\/[\\w\\-]+)*\\.(?:jpg|jpeg|gif|png))$",
        "description": "An overly simple regex to verify a URL pointing towards an image. It's usually all you need for this purpose.",
        "matches": [
            "http://website.com/directory/image.gif"
        ],
        "non_matches": [
            "www.website.com/image.php"
        ]
    },
    {
        "id": 3360,
        "expression": "^((?:\\?[a-zA-Z0-9_]+\\=[a-zA-Z0-9_]+)?(?:\\&[a-zA-Z0-9_]+\\=[a-zA-Z0-9_]+)*)$",
        "description": "This is a very simple regex that check the query part of a string. That is to say anything after the \"?\" at the end of an URL.",
        "matches": [
            "?key=value",
            "?key1=value1&key2=value2"
        ],
        "non_matches": [
            "key=value",
            "?key=value&"
        ]
    },
    {
        "id": 3361,
        "expression": "^((?:\\/[a-zA-Z0-9]+(?:_[a-zA-Z0-9]+)*(?:\\-[a-zA-Z0-9]+)*)+)$",
        "description": "An overly simple UNIX based path regex. The path must begin with a forward slash. The path segments may not lead or end with an underscore or dash which is a good thing. They also can not be doubled (__ or --). Another good thing. I've omitted all the punctuation that RFC allows until further notice.",
        "matches": [
            "/users/web/mysite/web/cgi-bin"
        ],
        "non_matches": [
            "/users/web/my site/web/cgi-bin",
            "users/web/mysite/web/cgi-bin/"
        ]
    },
    {
        "id": 3365,
        "expression": "^.{2,}$",
        "description": "^.{2,}$\n^ = start of line\n. = any character\n{2,} = 2 or more characters\n$ = end of line",
        "matches": [
            "LA"
        ],
        "non_matches": [
            "I"
        ]
    },
    {
        "id": 3367,
        "expression": "\\[([\\w \\.]+)\\]\\(([\\w\\.:\\/ ]*)\\)",
        "description": "Easy way to match a markdown link\n[link title](www.sometinng.com)",
        "matches": [
            "[link title](www.sometinng.com)"
        ],
        "non_matches": [
            "[link title]woow(www.sometinng.com)"
        ]
    },
    {
        "id": 3368,
        "expression": "^([A-Z]{1}\\w{1,3}) (\\d{1}[A-Z]{2})$",
        "description": "simple validation of a UK postcode.\nExamples of valid:\nAA9A 9AA\nA9A 9AA\nA9 9AA\nA99 9AA\nAA9 9AA\nAA99 9AA",
        "matches": [
            "EC1A 2BB"
        ],
        "non_matches": [
            "111A 1BB"
        ]
    },
    {
        "id": 3376,
        "expression": "^(?:(((Jan(uary)?|Ma(r(ch)?|y)|Jul(y)?|Aug(ust)?|Oct(ober)?|Dec(ember)?)\\ 31)|((Jan(uary)?|Ma(r(ch)?|y)|Apr(il)?|Ju((ly?)|(ne?))|Aug(ust)?|Oct(ober)?|(Sept|Nov|Dec)(ember)?)\\ (0?[1-9]|([12]\\d)|30))|(Feb(ruary)?\\ (0?[1-9]|1\\d|2[0-8]|(29(?=,\\ ((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))))\\,((1[6-9]|[2-9]\\d)\\d{2})) (?:[0-1]?[0-9]|[2][1-4]):[0-5]?[0-9]:[0-5]?[0-9]\\s?([apAP][Mm])?$",
        "description": "Tested with all date times:\nExamples Like:\n[Jul 30,2015 10:40:43 AM]\nif you want to use space then please add before ((1[6-9]|[2-9]\\d)\\d{2}))\nthen it will works fine.",
        "matches": [
            "Jul 30,2015 10:40:43 AM"
        ],
        "non_matches": [
            "Jul 30, 2015 10:40:43 AM"
        ]
    },
    {
        "id": 3377,
        "expression": "(\\+)?(\\()?(\\d+){1,4}(\\))?(\\s)?(-)?(\\d+){1,3}(\\s)?(-)?(\\d+){1,4}(\\s)?(-)?(\\d+){1,4}(\\s)?(-)?(\\d+){1,4}",
        "description": "This regex make you extract all numbers format i develope it now and i want to share with you guys i know you will see it and thanks me later",
        "matches": [
            "800-555-5555",
            "+212642477919",
            "(800)-555-5555"
        ],
        "non_matches": [
            "0000"
        ]
    },
    {
        "id": 3380,
        "expression": "[0-9]{2}-?[DF][A-Z]{2}-?[0-9]{1}|[DF][A-Z]{1}-?[0-9]{3}-?[A-Z]{1}|[DF]-?[0-9]{3}-?[A-Z]{2}|[DF][A-Z]{2}-?[0-9]{2}-?[A-Z]{1}$",
        "description": "Check for dutch moped licenseplate number validity",
        "matches": [
            "D-123-AS",
            "D123AS",
            "F-123-SA",
            "F123SA"
        ],
        "non_matches": [
            "Others"
        ]
    },
    {
        "id": 3381,
        "expression": "\\(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\)",
        "description": "This regex finds the IPs in its route. This uses the UNIX Bash 'traceroute' command's IP format",
        "matches": [
            "(8.8.8.8)",
            "(127.0.0.1)"
        ],
        "non_matches": [
            "(a.sg.af.)",
            "8.8.8.8"
        ]
    },
    {
        "id": 3383,
        "expression": "^([A-z]{2}\\d{7})|([A-z]{4}\\d{10})$",
        "description": "UK Parcelforce delivery tracking code for internal UK posts. Comes in two formats 2 letters and 7 numbers (e.g. AA1234567) and 4 letters and 10 numbers (e.g. AAAA1234567890). Case insensitive.",
        "matches": [
            "AA1234567",
            "AAAA1234567890"
        ],
        "non_matches": [
            "non",
            "matching",
            "examples"
        ]
    },
    {
        "id": 3384,
        "expression": "^([A-z]{2}\\d{9}[Gg][Bb])|(\\d{12})$",
        "description": "UK Parcelforce delivery tracking code for international tracking of exports. Comes in two formats: 2 letters and 9 numbers and GB (e.g. AA123456789GB) and 12 numbers (e.g. 123456789012). Case insensitive.",
        "matches": [
            "AA123456789GB",
            "123456789012"
        ],
        "non_matches": [
            "non",
            "matching",
            "examples"
        ]
    },
    {
        "id": 3385,
        "expression": "^[A-z]{2}\\d{9}(?![Gg][Bb])[A-z]{2}$",
        "description": "UK Parcelforce delivery tracking code for international tracking of imports. Uses a negative look ahead to prevent it ending in GB which would be an international export code.",
        "matches": [
            "AA123456789AA"
        ],
        "non_matches": [
            "AA123456789GB",
            "AA123456789gb",
            "AA123456789Gb",
            "AA123456789gB"
        ]
    },
    {
        "id": 3387,
        "expression": "^(?:[A-z]{2})?\\d{9}(?:[A-z]{2})?$",
        "description": "TNT UK delivery company consignment number tracking code for TNT Track and Trace service. The system will use the 9 digit code (e.g. 123456789) or you can use the letters as shown on your consignment note (e.g. GE123456781WW). Case insensitive.",
        "matches": [
            "123456789",
            "GE123456781WW"
        ],
        "non_matches": [
            "non",
            "matching",
            "examples"
        ]
    },
    {
        "id": 3389,
        "expression": "^((1[Zz]\\d{16})|(\\d{12})|([Tt]\\d{10})|(\\d{9}))$",
        "description": "As listed in on the UK UPS tracking help page (listed in the source)",
        "matches": [
            "1Z9999999999999999",
            "999999999999",
            "T9999999999",
            "999999999"
        ],
        "non_matches": [
            "non",
            "matching",
            "examples"
        ]
    },
    {
        "id": 3394,
        "expression": "^\\d{4}\\/\\d{1,2}\\/\\d{1,2}$",
        "description": "This regular expressions matches jalali dates of the form YYYY/XX/XX where XX can be 1 or 2 digits long and YYYY is always 4 digits long.",
        "matches": [
            "1394/01/3",
            "1365/12/31",
            "1397/02/01"
        ],
        "non_matches": [
            "1394/1/555",
            "139/1/4",
            "1/11/1394"
        ]
    },
    {
        "id": 3398,
        "expression": "^(\\+(1\\-)?\\d{1,3})?(\\s|\\-)?(\\s|\\-)?((\\(\\d{2}\\)|\\d{2})(\\s|\\-)?\\d{4}|(\\(\\d{3}\\)|\\d{3})(\\s|\\-)?\\d{3})(\\s|\\-)?\\d{4}(\\s)?(x|ext|ext.)?(\\d{1,6})?,?(\\d{1,6})?,?(\\d{1,6})?$",
        "description": "Match mexican local or international numbers with optional area code parentheses and optional max 3 extensions with 6 chars length.",
        "matches": [
            "(55) 1234-5678 x123456,123,12",
            "5512345678",
            "+1 (510) 123-5678 x1234"
        ],
        "non_matches": [
            "+1 510 (55 1234-5678",
            "12345678 x123",
            "+1 (510) 1234-5678 x1234567"
        ]
    },
    {
        "id": 3408,
        "expression": "(?:#|0x)?(?:[0-9A-F]{2}){4}",
        "description": "32 bit hex color preceding with 0x or # . From http://tools.twainscanning.com/getmyregex .",
        "matches": [
            "0xF0F73611"
        ],
        "non_matches": [
            "#FF006C"
        ]
    },
    {
        "id": 3417,
        "expression": "[0-9]{4}[/.-](?:1[0-2]|0?[1-9])[/.-](?:3[01]|[12][0-9]|0?[1-9])",
        "description": "Date Year-Month-Day. From http://tools.twainscanning.com/getmyregex",
        "matches": [
            "2015-08-31"
        ],
        "non_matches": [
            "31/08/2015"
        ]
    },
    {
        "id": 3420,
        "expression": "(facebook|twitter|youtube)",
        "description": "Google Analytics Segment by source social media. From http://tools.twainscanning.com/getmyregex .",
        "matches": [
            "facebook",
            "twitter",
            "youtube"
        ],
        "non_matches": [
            "imgur"
        ]
    },
    {
        "id": 3425,
        "expression": "((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])",
        "description": "IP address IPv4 (127.0.0.1) . From http://tools.twainscanning.com/getmyregex .",
        "matches": [
            "127.0.0.1"
        ],
        "non_matches": [
            "127-0-0-1"
        ]
    },
    {
        "id": 3426,
        "expression": "\\d{3}[.-]?\\d{3}[.-]?\\d{4}",
        "description": "Phone number United States (555-555-1234) . From http://tools.twainscanning.com/getmyregex .",
        "matches": [
            "555-555-1234"
        ],
        "non_matches": [
            "555-55-1234"
        ]
    },
    {
        "id": 3427,
        "expression": "(?:2[0-3]|[01]?[0-9])[:.][0-5]?[0-9]",
        "description": "Time HH:MM (23:30). From http://tools.twainscanning.com/getmyregex .",
        "matches": [
            "23:30",
            "23.30"
        ],
        "non_matches": [
            "23-30"
        ]
    },
    {
        "id": 3428,
        "expression": "(?:1[0-2]|0?[1-9])[:.][0-5]?[0-9][\\t ]+(?:AM|PM)",
        "description": "Time HH:MM AM/PM (11:30 PM) . From http://tools.twainscanning.com/getmyregex .",
        "matches": [
            "11:30 PM"
        ],
        "non_matches": [
            "11:61"
        ]
    },
    {
        "id": 3430,
        "expression": "https?://[\\d.A-Za-z-]+\\.[A-Za-z]{2,6}/?",
        "description": "URL http or https (http://twainscanning.com). From http://tools.twainscanning.com/getmyregex .",
        "matches": [
            "http://twainscanning.com"
        ],
        "non_matches": [
            "ftp://twainscanning.com"
        ]
    },
    {
        "id": 3431,
        "expression": "(?:https?://|www\\.)[\\d.A-Za-z-]+\\.[A-Za-z]{2,6}/?",
        "description": "URL http, https or www (www.twainscanning.com). From http://tools.twainscanning.com/getmyregex .",
        "matches": [
            "www.twainscanning.com"
        ],
        "non_matches": [
            "twainscanning.com"
        ]
    },
    {
        "id": 3434,
        "expression": "[A-Za-z]{5}",
        "description": "Word 5-letter word (TWAIN forum) . From http://tools.twainscanning.com/getmyregex .",
        "matches": [
            "TWAIN",
            "forum"
        ],
        "non_matches": [
            "test"
        ]
    },
    {
        "id": 3440,
        "expression": "\\[(.+)\\].+\\[n?varchar\\].+NULL,",
        "description": "Notepad Plus Plus Replace\npublic string \\1 { get; set; }",
        "matches": [
            "[FirstName] [nvarchar](255) NULL,",
            "[LastName] [nvarchar](255) NULL,",
            "[City] [varchar](255) NULL,"
        ],
        "non_matches": [
            "[Grade] [decimal](18, 0) NULL,",
            "[Price] [decimal](19, 5) NULL,",
            "[IsEnabled] [bit] NULL,"
        ]
    },
    {
        "id": 3444,
        "expression": "[^\\\\]+(?=(\\.dwg)|(\\.pdf)|(\\.doc[^x]))",
        "description": "Extract the file name from a full path string.\nFor example, given a full path:\nD:\\Drawing1\\Drawing2\\draw#1.pdf D:\\Drawing1\\Drawing2\\draw#2.doc D:\\Drawing1\\Drawing2\\draw#3.dwg\nresult: draw#1, draw#2, draw#3",
        "matches": [
            "D:\\Drawing1\\Drawing2\\draw#1.pdf D:\\Drawing1\\Drawing2\\draw#1.doc D:\\Drawing1\\Drawing2\\draw#1.dwg"
        ],
        "non_matches": [
            "D:\\Drawing1\\Drawing2\\draw#1.docx, D:\\Calculations\\Preview\\calcsheet1.xls"
        ]
    },
    {
        "id": 3445,
        "expression": "(([\\n, ])*((<+)([^<>]+)(>*))+([\\n, ])*)+",
        "description": "finds all HTML tags (<___>) in text and leaves normal text alone. Also matches all extra spaces and empty lines next to html tag, if any.Ragex has extra parentheses for orientation.\nUsefull to delete all unwanted html from, lets say, wikipedia souce code.",
        "matches": [
            "<a id = al>",
            "<blahblah>",
            "<<div>something>"
        ],
        "non_matches": [
            "9>3",
            "normaltext",
            "<<<<<<<<"
        ]
    },
    {
        "id": 3446,
        "expression": "^(([\\u0600-\\u065F\\u066A-\\u06EF\\u06FA-\\u06FF]+)\\s){3}([\\u0600-\\u065F\\u066A-\\u06EF\\u06FA-\\u06FF]+)$",
        "description": "you can type the name consist of 4 parts .",
        "matches": [
            "\u062d\u0633\u0627\u0645 \u062d\u0633\u0646 \u0639\u0644\u0649 \u062d\u0633\u0646"
        ],
        "non_matches": [
            "\u062d\u0633\u0627\u0645 \u062d\u0633\u0646 \u0639\u0644\u0649"
        ]
    },
    {
        "id": 3448,
        "expression": "[0-9]{5}\\s?[0-9]{5}",
        "description": "Basic UTR and CRT formats, 10 digits however are often written with an optional space after 1st 5",
        "matches": [
            "1234567890",
            "12345 67890"
        ],
        "non_matches": [
            "123 4567890",
            "A123456789"
        ]
    },
    {
        "id": 3449,
        "expression": "[0-9]{3}P[A-Z][0-9]{7}[0-9X]",
        "description": "HMRC Accounts Office Reference (AORef) in format\n3digits, the letter P and another letter followed by 7 digits and either an 8th digit or letter X",
        "matches": [
            "123PA12345678",
            "451PW1234523X"
        ],
        "non_matches": [
            "A01PA12345678",
            "123RA1234567X"
        ]
    },
    {
        "id": 3454,
        "expression": "^([1-9]|1[0-2])$",
        "description": "Simple check for a value between 1 and 12",
        "matches": [
            "1",
            "2",
            "12"
        ],
        "non_matches": [
            "-1",
            "13",
            "A1"
        ]
    },
    {
        "id": 3457,
        "expression": "^(?=.*[1-9].*)[0-9]{3}$",
        "description": "3 digit number representing an HMRC Tax Office. Office 000 is not valid",
        "matches": [
            "001",
            "123",
            "940"
        ],
        "non_matches": [
            "-01",
            "000",
            "90.1"
        ]
    },
    {
        "id": 3459,
        "expression": "^(GB)?([0-9]{9})$",
        "description": "If you dont need to validate anything other than UK Numbers then this is for you, with optional GB at the start. If you need other countries then the EU Pattern is better suited",
        "matches": [
            "GB123456789",
            "123456789"
        ],
        "non_matches": [
            "GB12345678",
            "AA123456789",
            "1234567"
        ]
    },
    {
        "id": 3460,
        "expression": "^[0-9]{8}R[A-HJ-NP-TV-Z]$",
        "description": "Pension Schemes have their own references, 8 digits followed by R and then another letter.",
        "matches": [
            "12345678RA",
            "43213245RT"
        ],
        "non_matches": [
            "1234567RA",
            "432132456RR"
        ]
    },
    {
        "id": 3467,
        "expression": "^(A[A-HJ-M]|[BR][A-Y]|C[A-HJ-PR-V]|[EMOV][A-Y]|G[A-HJ-O]|[DFHKLPSWY][A-HJ-PR-Y]|MAN|N[A-EGHJ-PR-Y]|X[A-F]|)(0[02-9]|[1-9][0-9])[A-HJ-P-R-Z]{3}$",
        "description": "Current standard UK Registration plates running from Sept 2001 to Feb 2051, basic form AA99AAA but contains prefix combinations, the only number not used is 01",
        "matches": [
            "NE02ABC",
            "AA58DEF"
        ],
        "non_matches": [
            "NF02ABC",
            "AA01WUX"
        ]
    },
    {
        "id": 3473,
        "expression": "^A([0-9]|10)$",
        "description": "Sizes of paper from A0-A10",
        "matches": [
            "A0",
            "A6",
            "A10"
        ],
        "non_matches": [
            "A-1",
            "B1",
            "A11"
        ]
    },
    {
        "id": 3475,
        "expression": "^([1-9]+)?[02468]$",
        "description": "Any number possible as long as its even.",
        "matches": [
            "2",
            "64",
            "4343253298"
        ],
        "non_matches": [
            "3",
            "65",
            "5345643531"
        ]
    },
    {
        "id": 3478,
        "expression": "^((((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)))\\s*([,;]|$)+\\s*)*$",
        "description": "Accept multiple IPs separated by comma or semicolumn",
        "matches": [
            "192.168.0.1,192.168.0.2; 192.168.0.3"
        ],
        "non_matches": [
            "256.0.0.1",
            "192.168.0.1-192.168.0.2",
            "10.0.0.0/172.16.0.1"
        ]
    },
    {
        "id": 3481,
        "expression": "^(-?)((\\d{1,3})(,\\d{3})*|\\d+)((\\.\\d+)?)$",
        "description": "Matches negative and positive numbers with or without commas and with or without decimals",
        "matches": [
            "-9.999",
            "99,999,999.99",
            "9999.99",
            "999"
        ],
        "non_matches": [
            "-.9",
            ".9",
            "9,99.99"
        ]
    },
    {
        "id": 3483,
        "expression": "^([\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[0-9]+[a-z]+[A-Z]+|[0-9]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[a-z]+[A-Z]+|[0-9]+[a-z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[A-Z]+|[0-9]+[a-z]+[A-Z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+|[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[0-9]+[A-Z]+[a-z]+|[0-9]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[A-Z]+[a-z]+|[0-9]+[A-Z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[a-z]+|[0-9]+[A-Z]+[a-z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+|[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[a-z]+[0-9]+[A-Z]+|[a-z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[0-9]+[A-Z]+|[a-z]+[0-9]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[A-Z]+|[a-z]+[0-9]+[A-Z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+|[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[a-z]+[A-Z]+[0-9]+|[a-z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[A-Z]+[0-9]+|[a-z]+[A-Z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[0-9]+|[a-z]+[A-Z]+[0-9]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+|[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[A-Z]+[0-9]+[a-z]+|[A-Z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[0-9]+[a-z]+|[A-Z]+[0-9]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[a-z]+|[A-Z]+[0-9]+[a-z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+|[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[A-Z]+[a-z]+[0-9]+|[A-Z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[a-z]+[0-9]+|[A-Z]+[a-z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[0-9]+|[A-Z]+[a-z]+[0-9]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+)+$",
        "description": "Password with lower, upper case letters, digits and special characters in any order",
        "matches": [
            "#3aZ",
            "3#aZ",
            "3a#Z",
            "3aZ#",
            "#3Za",
            "3#Za",
            "3Z#a",
            "3Za#",
            "#a3Z",
            "a#3Z",
            "a3#Z",
            "a3Z#",
            "#aZ3",
            "a#Z3",
            "aZ#3",
            "aZ3#",
            "#Z3a",
            "Z#3a",
            "Z3#a",
            "Z3a#",
            "#Za3",
            "Z#a3",
            "Za#3",
            "Za3#"
        ],
        "non_matches": [
            "#$@!",
            "aB3a",
            "zzzz",
            "BBBB",
            "1234"
        ]
    },
    {
        "id": 3488,
        "expression": "<!--(?!\\s*\\[if[^]]+]>[^<]*<!\\[endif\\]).*?-->",
        "description": "Matches html comments but excludes comments that contain if statements",
        "matches": [
            "<!-- this is a comment -->"
        ],
        "non_matches": [
            "<!-- [if lt IE 9]>blah<![endif]-->"
        ]
    },
    {
        "id": 3491,
        "expression": "^(?:[2-9]\\d\\d\\d)-(?:1[012]|0?[1-9])?-(?:31(?!.(?:0?[2469]|11))|(?:30|29)(?!.0?2)|29(?=.0?2.(?:(?:(?:1[6-9]|[2-9]\\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00)))(?:T))|(?:2[0-8]|1\\d|0?[1-9]))T(2[01234]|[01]\\d):[0-5]\\d:[0-5]\\d[+-][01]\\d:[0-5]\\d$",
        "description": "Matches the strict datetime format for Common Alerting Protocol v1.2 (might be same as earlier versions too). Inspiration and some code came from Michael Ash's http://regexlib.com/REDetails.aspx?regexp_id=610 with tweaks of my own",
        "matches": [
            "2016-04-07T12:29:00-04:00",
            "2016-04-07T11:13:00-05:00",
            "2016-04-05T00:53:35-04:00"
        ],
        "non_matches": [
            "31/12/2003 11:59:59 PM",
            "2016-04-07 22:00:01+00:00",
            "2016-04-07T22:00:01Z"
        ]
    },
    {
        "id": 3492,
        "expression": "[a-z]{2}[0-9]{5}[a-z]",
        "description": "Very usefull on pirni: when connected with school's wifi this regex will find evry password of electronic register (es spaggiari classe viva portaleargo) divertitevi!",
        "matches": [
            "ab12345c"
        ],
        "non_matches": [
            "aCF34568&"
        ]
    },
    {
        "id": 3494,
        "expression": "^\\s*([\\w*]+)\\s*(?:(-?[\\d]+)?\\s*[(]?\\s*(%[\\w]+)?\\s*,?\\s*(%[\\w]+)\\s*,?\\s*([\\d]+)?[)]?|([$\\d]+))\\s*(?:,\\s*(-?[\\d]+)?\\s*[(]?\\s*(%[\\w]+)?\\s*,?\\s*(%[\\w]+)\\s*,?\\s*([\\d]+)?[)]?)?\\s*$",
        "description": "Get Assembly param's instructions from instruction like: pop %eax to movl -12(%ebp, %eax, 4),-12(, %eax,4) or other like movl $0x324, (%ebx)",
        "matches": [
            "movl -12(%ebp, %eax, 4),-12(, %eax,4)"
        ],
        "non_matches": [
            ".global, .section, ecc"
        ]
    },
    {
        "id": 3498,
        "expression": "(?<!\\[)\\[(?!\\[).*(?<!\\])\\](?!\\])",
        "description": "This will match the an External wiki link ONLY allowing you to separate the href and the title for use in other link types",
        "matches": [
            "[https://sub.domain.com/wiki/index.php?title=test Sample Wiki Link]",
            "[https://regexlib.com/page.aspx Example External Wiki Link]",
            "===[https://sub.domain.com/wiki/index.php Does Match a link surrounded by a header]==="
        ],
        "non_matches": [
            "[[file://\\\\servername\\subfolder\\sample.txt Sample Text Link]]",
            "[[Example Wiki Link Double Square Brackets]]",
            "[https://sub.domain.com/wiki/index.php Will Not Match a link which is missing its matching bracket"
        ]
    },
    {
        "id": 3503,
        "expression": "((8|\\+7)-?)\\W((\\d{3,5})|\\(?\\d{3,5}\\))\\W\\d{3}\\W((\\d{2}\\W\\d{2})|(\\d{4}))|(((8|\\+7)-?)?\\(?\\d{3,5}\\)?-?\\d{1}-?\\d{1}-?\\d{1}-?\\d{1}-?\\d{1}((-?\\d{1})?-?\\d{1})?)",
        "description": "It is looking for a phone number in the Russian format",
        "matches": [
            "+7 (495) 111-1111,+7 905-222-3333,+7 (342) 333 22 22, +7(916)9985670, 8-912-268-5440, 8905148-3339, 8(913)448-51-90, 903-345-34-34, 903-34-334-34, 903-34-33434, 8(34543)54-4-56"
        ],
        "non_matches": [
            "x"
        ]
    },
    {
        "id": 3504,
        "expression": "^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[!@#$%^&*()_\\~\\-\\`\\\\/\\\"\\'+|\\[\\]}{:;'?/>.<,])(?!.*\\s)(?!.*\\s).{8,55}$",
        "description": "Password that allows for 1 special char, 1 numeric, 1 upper case, 1 lower case. Its been tested against the Javascript engine.",
        "matches": [
            "Passw0rd1!@#"
        ],
        "non_matches": [
            "GeneralTso"
        ]
    },
    {
        "id": 3505,
        "expression": "(\\$\\d)|(\\\u20ac\\d)|(\\\u00a3\\d)",
        "description": "Means that any \u00a3, \u20ac or $ symbol with a digit following it will be picked up.",
        "matches": [
            "\u00a31, \u00a31234, $131, \u20ac1231.1241"
        ],
        "non_matches": [
            "\u00a3 1, $ 1231, \u20ac.12321"
        ]
    },
    {
        "id": 3506,
        "expression": "^(?=.*[a-zA-Z])(?=.*[0-9!@#$%^&*\\?\\+])(?!.*[()_\\-\\`\\\\/\\\"\\'|\\[\\]}{:;'/>.<,])(?!.*\\s)(?!.*\\s).{8,20}$",
        "description": "Case sensitive:\n-8-20 characters\n-at least 1 letter\n-at least 1 numeric or special\n-these special chars only ~ ! @ # $ % ^ & ? * +",
        "matches": [
            "P@SSw0rd~!@#$%^&?*+"
        ],
        "non_matches": [
            "Password"
        ]
    },
    {
        "id": 3507,
        "expression": "^(?=.*[a-zA-Z])(?=.*[a-zA-Z0-9]).{6,20}$",
        "description": "Only letters and numbers and at least 1 letter. 6-20 chars",
        "matches": [
            "myusername"
        ],
        "non_matches": [
            "12345"
        ]
    },
    {
        "id": 3508,
        "expression": "ng-[^\\s]+?=\".*?\"",
        "description": "Find all angular properties in HTML markup. Handy for removing them.",
        "matches": [
            "ng-class=\"foo\"",
            "ng-if=\"foo\"",
            "ng-show=\"foo\""
        ],
        "non_matches": [
            "class=\"foo\"",
            "ngClass=\"foo\"",
            "class=\"ng-scope\""
        ]
    },
    {
        "id": 3512,
        "expression": "(?<!\\/|\\\\|\\.)[a-zA-Z]+\\.\\.(?!\\.|\\\\|\\/)",
        "description": "a regex for finding usages of a \"partial ellipsis..\" in a sentence",
        "matches": [
            "Please Wait..",
            "Error..",
            "a.."
        ],
        "non_matches": [
            "1..",
            "\\..\\",
            "/../"
        ]
    },
    {
        "id": 3527,
        "expression": "^NL\\d{2}[A-Z]{4}0\\d{9}$",
        "description": "Validate an International Bank Account Number (IBAN) without formatting. The first two characters represent the country code, coded according ISO 3166-1.\nISO 3166-1",
        "matches": [
            "NL91ABNA0417164300"
        ],
        "non_matches": [
            "91ABNA0417164300",
            "NL91 ABNA 0417164300"
        ]
    },
    {
        "id": 3543,
        "expression": "^(~/|/|(((ht|f)tp(s?))\\://))[^/](\\S*)[^/]+$",
        "description": "Allows selection of a root relative path or absolute path; or it allows off-site http://, https://, or ftp:// specific url.",
        "matches": [
            "http://www.google.com",
            "ftp://crazy.com",
            "https://securecon",
            "~/rootrelative",
            "/absolute/path"
        ],
        "non_matches": [
            "www.google.com",
            "http:cozystuff",
            "go/here",
            "/not/valid/"
        ]
    },
    {
        "id": 3545,
        "expression": "^[a-z]+([\\d_-]*[a-z]+)*@[a-z]{2,}(\\.)[a-z]{2,}(\\.[a-z]{2})?$",
        "description": "Starting to learn, so:\n1.(one or more)letters\n2.(optional) \"-\", \"_\", numbers + (one or more)letters\n3.\"@\"\n4.(two or more)letters\n5.\".\"\n6.(two or more)letters\n7.(optional) \".\" + (two)letters",
        "matches": [
            "t@alright.com",
            "test1ok@alright.com.ha",
            "t-e-s-t1_ok@alright.com.ha"
        ],
        "non_matches": [
            "test1@alright.com",
            "test-@alright.com",
            "_test@alright.com",
            "test@alright.com.ha.ha"
        ]
    },
    {
        "id": 3546,
        "expression": "^\\d{1,2}\\/\\d{1,2}\\/\\d{4}$",
        "description": "This regular expressions matches dates of the form XX/XX/YYYY where XX can be 1 or 2 digits long and YYYY is always 4 digits long",
        "matches": [
            "4/1/2001",
            "12/12/2001",
            "55/5/3434"
        ],
        "non_matches": [
            "1/1/01",
            "12 Jan 01",
            "1-1-2001"
        ]
    },
    {
        "id": 3549,
        "expression": "((a|p|A|P)(m|M)\\s{0,1}(0[0-9]|1[0-2]|[0-9]):[0-5][0-9]:[0-5][0-9])|((a|p|A|P)(m|M)\\s{0,1}(0[0-9]|1[0-2]|[0-9]):[0-5][0-9])|((0[0-9]|1[0-2]|[0-9]):[0-5][0-9]\\s{0,1}(a|p|A|P)(m|M))|((0[0-9]|1[0-2]|[0-9]):[0-5][0-9]:[0-5][0-9]\\s{0,1}(a|p|A|P)(m|M))|((0[0-9]|1[0-9]|2[0-3]|[0-9]):[0-5][0-9]:[0-5][0-9])|((0[0-9]|1[0-9]|2[0-3]|[0-9]):[0-5][0-9])",
        "description": "Matches all types of time declaration with ':' separator.",
        "matches": [
            "0:26:12 aM",
            "00:26:12 Pm",
            "0:26:12aM",
            "00:26:12Pm",
            "Am 0:26:12",
            "pM 00:26:12",
            "Am0:26:12",
            "pM00:26:12",
            "0:26 PM",
            "01:26 am",
            "0:26PM",
            "01:26am",
            "Am 0:26",
            "pM 00:26",
            "Am0:26",
            "pM00:26",
            "23:26:12",
            "00:26:12",
            "0:26:12",
            "23:26",
            "0:26"
        ],
        "non_matches": [
            "n/a"
        ]
    },
    {
        "id": 3556,
        "expression": "(0\\d|1\\d|2[0-4]) ?: ?([0-5]\\d)( ?: ?[0-5]\\d)?",
        "description": "Validate hh:minmin:ss",
        "matches": [
            "09:03:05",
            "08 : 03 : 57",
            "24:00: 05",
            "00: 00 :00",
            "17:54"
        ],
        "non_matches": [
            "17:2",
            "3:52"
        ]
    },
    {
        "id": 3560,
        "expression": ".+(?=((\\\\|\\/).+){2})",
        "description": "Get file\\folder path and rise in hierarchy by n folders.\nFor example: c:\\fold1\\fold2\\fold3\\fold4\\fold5 will match c:\\fold1\\fold2\\fold3",
        "matches": [
            "c:\\fold1\\fold2\\fold3\\fold4\\fold5"
        ],
        "non_matches": [
            "abcd"
        ]
    },
    {
        "id": 3561,
        "expression": "^-?[1-9]\\d*\\.?(\\d+([eE][-+]\\d+)?)?$",
        "description": "Matches numbers including scintific format",
        "matches": [
            "-23333.1e+24",
            "123",
            "34.2"
        ],
        "non_matches": [
            "23333.01+24",
            "+123",
            "34.-20"
        ]
    },
    {
        "id": 3563,
        "expression": "^\\d{4}\\s\\d{4}\\s\\d{4}$",
        "description": "This regular expression will match a Aadhar Number in the format 1111 1111 1111.",
        "matches": [
            "1234 5678 9123"
        ],
        "non_matches": [
            "123456789123"
        ]
    },
    {
        "id": 3569,
        "expression": "\\B(\\s)(?!(?:[^\"]*\"[^\"]*\")*[^\"]*$)",
        "description": "This expression finds a string of nothing but spaces between double quotes.",
        "matches": [
            "\" \""
        ],
        "non_matches": [
            "\"abc 123\""
        ]
    },
    {
        "id": 3571,
        "expression": "[0-9]*[-| ][0-9]*[-| ][0-9]*[-| ][0-9]*[-| ][0-9]*",
        "description": "Pattern for ISBN 13",
        "matches": [
            "978-1-86197-876-9",
            "978 1 86197 876 9"
        ],
        "non_matches": [
            "no isbn number"
        ]
    },
    {
        "id": 3573,
        "expression": "^(0[1-9]|[12]\\d|3[01])(0[1-9]|1[0-2])([5-9]\\d\\+|\\d\\d-|[01]\\dA)\\d{3}[\\dABCDEFHJKLMNPRSTUVWXY]$",
        "description": "Description\nThis is for the Finnish social security numbers (henkil\u00f6tunnus / hetu). It consists of eleven characters of the form DDMMYYCZZZQ, where DDMMYY is the date of birth, C the century sign (-,+, or A), ZZZ the individual number (even for men and odd for female), and Q the control character or the checksum. It is calculated DDMMYYZZZ mod 31, where the remainder 0,1,2,..,31 is converted from the list 0,1,...A,B,C..Y . The G,I, O and Q are not in the list, they are too similar to numbers 1, 8 and 0 (zero). Note: This regex does not calculate the checksum (mod 31).",
        "matches": [
            "010593-123A",
            "010503A123A",
            "210566-022Y"
        ],
        "non_matches": [
            "010593123A",
            "011403A123A",
            "011203-123O"
        ]
    },
    {
        "id": 3601,
        "expression": "^(0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])[- /.](19|20)\\d\\d$",
        "description": "Date in MM/DD/YYYY (USA Format). Allows for 1 or 2 digit month and day. Requires 4 digit year between 1900-2999. Allows for dash, slash, period or space for separators.",
        "matches": [
            "01/02/2015",
            "5-7-1915",
            "12.8.2035",
            "7 15 1963"
        ],
        "non_matches": [
            "11-11-1845",
            "31/12/2000",
            "10-17-85"
        ]
    },
    {
        "id": 3612,
        "expression": "^(?=.{16,})(?=.*[1-9])(?=.*[a-z])(?=.*[A-Z])(?=.*[(!@#$%^&*()_+|~\\- =\\`{}[\\]:\u201d;'<>?,.\\/, )])(?!.*(.)\\1{2,}).+$",
        "description": "Password validator for a high complexity secure passwords.\nLength minimum 16 characters\nAt least one number\nAt least one lowercase character\nAt least one uppercase character\nAt least one special character from the following set \u201c(!@#$%^&*()_+|~\\- =\\`{}[\\]:\u201d;'<>?,.\\/, )]\u201d\nNo sequential repeating characters",
        "matches": [
            "Pas$words0123456"
        ],
        "non_matches": [
            "Password"
        ]
    },
    {
        "id": 3657,
        "expression": "\\w+\\S?\\w+\\s?(@|\\W(at)\\W)\\s?\\w+\\s?(\\.|\\W(dot)\\W)\\s?\\w+\\.?\\w+",
        "description": "This should be able to match all emails including ones which try to avoid scrapers.",
        "matches": [
            "example@demo.net",
            "example @ demo.net",
            "example at demo.net",
            "example at demo dot net",
            "example [at] demo.net",
            "example [at] demo [dot] net",
            "example.example@test.co.uk",
            "example-example@test.co.uk",
            "example_example@test.co.uk"
        ],
        "non_matches": [
            "Not Sure Yet"
        ]
    },
    {
        "id": 3712,
        "expression": "^(1[0-2]|0[1-9]|[1-9])\\/(1[0-9]|2[0-9]|3[0-1]|0[1-9]|[1-9])\\/\\d{4}$",
        "description": "is very accurate when catching\nand matching dates within the correct ranges in US standard date formats MM/DD/YYYY",
        "matches": [
            "1/3/2017",
            "01/03/2017",
            "12/12/2017",
            "12/31/2017"
        ],
        "non_matches": [
            "31/12/2017",
            "99/99/9999",
            "12-31-2017",
            "December 30th, 2017"
        ]
    },
    {
        "id": 3731,
        "expression": "((((0[1-9]|[12][0-9]|3[01])(0[13578]|10|12)(\\d{2}))|(([0][1-9]|[12][0-9]|30)(0[469]|11)(\\d{2}))|((0[1-9]|1[0-9]|2[0-8])(02)(\\d{2}))|((29)(02)(0(0|4|8)))|((29)(02)([2468][048]))|((29)(02)([13579][26])))[- ]?\\d{4})",
        "description": "Matches the format from www.cpr.dk and fixed to match 29th February for leap years",
        "matches": [
            "020955-2012",
            "020955-2012",
            "241283-1234",
            "290204-1234",
            "010111-1111"
        ],
        "non_matches": [
            "459434-1234",
            "123456-1234"
        ]
    },
    {
        "id": 3734,
        "expression": "^([A-Za-z]+)([0-9]+)?([A-Za-z0-9\\.\\_]+)?\\@(([A-Za-z]+)([0-9]+)?([A-Za-z0-9\\.\\_]+)?)((\\.)([a-zA-Z]+))$",
        "description": "Need Multiline option to validate email string for better result",
        "matches": [
            "ankur.ranpariya@test.com",
            "ankur.ran.pariya@test.com",
            "ankur@test.com",
            "ankur01@test.com",
            "ankur.01abc@abc.com",
            "ankur@abc01.com",
            "ankur@ank01xt.com",
            "ankur@gaming.indianic.com"
        ],
        "non_matches": [
            "ankur ankur@test.com",
            "ankur-ranpariya@test.com",
            "ankur@@test.com",
            "ankur@ankur@test.com",
            "ankur@01ABC.com",
            "01ankur@test.com",
            "ankur@ankur",
            "@ankur.com",
            "ankur.ra@123.com",
            "ankur.ra@inda.123",
            "ankur.ra@test.a1",
            "1@inidnia.com",
            "ank%20@gmail.com"
        ]
    },
    {
        "id": 3736,
        "expression": "^(http(s?)\\:\\/\\/)?(www.)?(([A-Za-z]+)([0-9]+)?([A-Za-z0-9\\.\\_\\-]+)?)(\\.)(([a-zA-Z]{2,})([0-9a-zA-Z]+)?)(\\:\\d{0,5})?(\\/|(\\/[A-Za-z]+([a-zA-Z0-9]+)?)+)?(\\?[a-zA-Z0-9\\\\\\&\\%\\_\\.\\/\\-\\=\\~\\*]+)?$",
        "description": "Web Url validation using regex. need mult-line option",
        "matches": [
            "https://www.test.com",
            "https://www.test.com/",
            "https://test.com",
            "https://test.com/",
            "http://test.com",
            "www.test.com",
            "www.test.com/",
            "test.com",
            "test.com",
            "test069.com",
            "test.test.com",
            "test01.test01.com",
            "test.test.co",
            "test.com:1",
            "test.cm:12345",
            "www.xa.com/abc/a",
            "www.xa.com/abc",
            "test.com/con1/method1",
            "w.google.com",
            "google.com?te-st=xyz",
            "oogle.com?test=xyz",
            "google.com?test=",
            "google.com?test",
            "google.com?test=xyz&text",
            "google.com?test=xyz&text=t&*5"
        ],
        "non_matches": [
            "*.google.com",
            "goole.com/*",
            ".google.com",
            "google.com?",
            "google.com/?",
            "google.co-m",
            "@.google.com",
            "ftp://test.com",
            "test test.com",
            "www.xa.com/ab c/a",
            "test.com:123456",
            "//test.com",
            "test.test.c",
            "01test.test.com",
            "test.c",
            "test.test.",
            "http://www.test.c",
            "01test.com",
            "test.01",
            ""
        ]
    },
    {
        "id": 3737,
        "expression": "^(\\d{5})([\\-\\ ]\\d{4})?$",
        "description": "Support Zip+4 with dash \"-\" or space \" \"\nneed multiline option",
        "matches": [
            "12345-4565",
            "12345",
            "12345 1234"
        ],
        "non_matches": [
            "123456",
            "1234",
            "1234-1234",
            "12345-12345",
            "12345-123",
            "12345 123",
            "12345 12345",
            "1234 1234",
            "1234 12345"
        ]
    },
    {
        "id": 3753,
        "expression": "(\\+989|9|09)(0[1-3]|1[0-9]|2[0-2]|3[0-9]|90|9[8-9])\\d{7}",
        "description": "Regex for current available mobile numbers mention at\nhttps://fa.wikipedia.org/wiki/%D8%B4%D9%85%D8%A7%D8%B1%D9%87%E2%80%8C%D9%87%D8%A7%DB%8C_%D8%AA%D9%84%D9%81%D9%86_%D8%AF%D8%B1_%D8%A7%DB%8C%D8%B1%D8%A7%D9%86",
        "matches": [
            "09221113344"
        ],
        "non_matches": [
            "09057614584"
        ]
    },
    {
        "id": 3772,
        "expression": "^([1-9][0][0]|[1-9][0-9][0][0]|[1-9][0-9][0-9][0][0]|[1-9][0-9][0-9][0-9][0][0]|[1-9][0-9][0-9][0-9][0-9][0][0])$",
        "description": "Permite digitar valores m\u00faltiplos de 100 entre 0 e 9999999.",
        "matches": [
            "100",
            "200",
            "9999900"
        ],
        "non_matches": [
            "101",
            "201",
            "9999901"
        ]
    },
    {
        "id": 3779,
        "expression": "^(\\+?1(-|\\.|\\s)?)?((\\(((8(00|22|33|44|55|66|77|[8[0-9]))|900)\\)|((8(00|22|33|44|55|66|77|[8[0-9]))|900))(-|\\.|\\s)?\\d{3}(-|\\.|\\s)?\\d{4}|(\\([2-9]([02-9]\\d|1[02-9])\\)|[2-9]([02-9]\\d|1[02-9]))(-|\\.|\\s)?[2-9]([02-9]\\d|1[02-9](-|\\.|\\s)?\\d{4}))$",
        "description": "This is a very detailed RegEx that only allows for valid phone number combinations in accordance with \"North American Numbering Plan\" as well as any combinations for toll (9XX) and toll-free (8XX) numbers.\nNumbers can contain parenthesis around the area code, can include 1 or +1, and can be delimited using \"-\", \".\", or space.",
        "matches": [
            "800-211-5555",
            "(800) 211-5555",
            "1-800-211-5555",
            "+1-800-211-5555",
            "555 212 1234",
            "555.212.1234"
        ],
        "non_matches": [
            "555-555-555",
            "555-211-5555",
            "2-555-555-5555",
            "555-123-1234"
        ]
    },
    {
        "id": 3786,
        "expression": "^\\d+?[A-Za-z]*\\s\\w*\\s?\\w+?\\s\\w{2}\\w*\\s*\\w*$",
        "description": "Flexible match for valid US street addresses requiring at least some street number with or without a unit letter followed by a space, then either a modifier like N, W, West, etc, or no modifier, then another space, followed by the street name, then a space folowed by the street type abreviated or spelled out (ave or avenue). Can accept Apt number at the end. Does not match addresses with no number, improperly formatted numbers, or no street type.",
        "matches": [
            "3 Olive Lane",
            "1234 SE Franklin St",
            "34 East Avenue Apt 54",
            "23b Orange Lane Apt 12",
            "55 Martingale St Apt A"
        ],
        "non_matches": [
            "West Avenue",
            "22b2 East St",
            "22 Olive",
            "Apt 5"
        ]
    },
    {
        "id": 3787,
        "expression": "^(([0]\\d)|([1][0-2])|(\\d))[/](([0-2]\\d)|([3][0-1])|(\\d))[/][2][0]\\d{2}[,]\\s(([0]\\d)|([1][0-2])|(\\d))[:][0-5]\\d\\s[AP][M]",
        "description": "This is basic datetime validator that does bother with seconds and enforces slashes, a comma after the date, as well as a year that must start with \"20\". Morning and evening are represented by \"AM\" or \"PM\" only.",
        "matches": [
            "1/31/2086, 9:50 AM",
            "08/04/2082, 09:13 PM",
            "1/2/2000, 1:12 PM"
        ],
        "non_matches": [
            "1/31/2086 9:50 AM",
            "08/04/2082, 09:13",
            "1/2/1900, 1:12 PM"
        ]
    },
    {
        "id": 3791,
        "expression": "((0[1-9]|[12]\\d|3[01])(0[1-9]|1[0-2])\\d{3}\\d{2}\\d{4})",
        "description": "Regex to match the \"Unique Master Citizen Number\" based on the wikipedia description.\nIt doesn't keep in account the checksum, but it matches the example on wikipedia.",
        "matches": [
            "0101006500006"
        ],
        "non_matches": [
            "none"
        ]
    },
    {
        "id": 3800,
        "expression": "([0-8]?\\d(\u00b0|\\s)[0-5]?\\d('|\\s)[0-5]?\\d(\\.\\d{1,6})?\"?|90(\u00b0|\\s)0?0('|\\s)0?0\"?)\\s{0,}[NnSs]\\s{1,}([0-1]?[0-7]?\\d(\u00b0|\\s)[0-5]?\\d('|\\s)[0-5]?\\d(\\.\\d{1,6})?\"?|180(\u00b0|\\s)0?0('|\\s)0?0\"?)\\s{0,}[EeOoWw]",
        "description": "Validate lat/lon coordinates",
        "matches": [
            "45\u00b023'36.0\" N 10\u00b033'48.0\" E or 45\u00b023'36.123456\"N 010\u00b033'48\"E"
        ],
        "non_matches": [
            "45\u00b023'36.\" N 10\u00b033'48.0\" E or 45\u00b023'36.1234567\"N 010\u00b033'48\"E"
        ]
    },
    {
        "id": 3803,
        "expression": "([0-8]?\\d[0-5]?\\d[0-5]?\\d|900000)[NS]([0-1]?[0-7]?\\d[0-5]?\\d[0-5]?\\d|1800000)[EW]\\d{3}",
        "description": "NOTAM coords and radius in \"Q\" field",
        "matches": [
            "440110N0123634E005"
        ],
        "non_matches": [
            "any other format"
        ]
    },
    {
        "id": 3805,
        "expression": "(?!219( |\\.|\\-|)??09( |\\.|\\-|)??9999|078( |\\.|\\-|)??05( |\\.|\\-|)??1120)(?!666|000|9\\d{2})\\d{3}( |\\.|\\-|)??(?!00)\\d{2}( |\\.|\\-|)??(?!0{4})\\d{4}",
        "description": "Advanced SSN regular expression. Matches 9 digits separated by mixed spaces, hyphens, or periods. Excludes:\n- Values containing all 0's in any group\n- Values beginning with 900-999\n- 078-05-1120 (Woolworth's Wallet)\n- Values beginning with 666\nGuidelines can be seen at: https://www.ssa.gov/kc/SSAFactSheet--IssuingSSNs.pdf",
        "matches": [
            "001-23-1123",
            "377.42.1423",
            "389551234",
            "389 55.1234"
        ],
        "non_matches": [
            "078051120",
            "900 20 2211",
            "389.00.4411"
        ]
    },
    {
        "id": 3806,
        "expression": "^((?:\\*)|(?:[0-5]?[0-9])|(?:(?:(?:[0-5]?[0-9])-(?:[0-5]?[0-9]))(?:,(?:(?:[0-5]?[0-9])-(?:[0-5]?[0-9])))*)|(?:(?:[0-5]?[0-9])(?:,(?:[0-5]?[0-9]))*))\\s+((?:\\*)|(?:[0-9]|0[0-9]|1[0-9]|2[0-3])|(?:(?:(?:[0-9]|0[0-9]|1[0-9]|2[0-3])-(?:[0-9]|0[0-9]|1[0-9]|2[0-3]))(?:,(?:(?:[0-9]|0[0-9]|1[0-9]|2[0-3])-(?:[0-9]|0[0-9]|1[0-9]|2[0-3])))*)|(?:(?:[0-9]|0[0-9]|1[0-9]|2[0-3])(?:,(?:[0-9]|0[0-9]|1[0-9]|2[0-3]))*))\\s+((?:\\*)|(?:[1-9]|0[1-9]|1[0-9]|2[0-9]|3[0-1])|(?:(?:(?:[1-9]|0[1-9]|1[0-9]|2[0-9]|3[0-1])-(?:[1-9]|0[1-9]|1[0-9]|2[0-9]|3[0-1]))(?:,(?:(?:[1-9]|0[1-9]|1[0-9]|2[0-9]|3[0-1])-(?:[1-9]|0[1-9]|1[0-9]|2[0-9]|3[0-1])))*)|(?:(?:[1-9]|0[1-9]|1[0-9]|2[0-9]|3[0-1])(?:,(?:[1-9]|0[1-9]|1[0-9]|2[0-9]|3[0-1]))*))\\s+((?:\\*)|(?:[1-9]|0[1-9]|1[0-2])|(?:(?:(?:[1-9]|0[1-9]|1[0-2])-(?:[1-9]|0[1-9]|1[0-2]))(?:,(?:(?:[1-9]|0[1-9]|1[0-2])-(?:[1-9]|0[1-9]|1[0-2])))*)|(?:(?:[1-9]|0[1-9]|1[0-2])(?:,(?:[1-9]|0[1-9]|1[0-2]))*)|(?:\\*)|(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)|(?:(?:(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)-(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec))(?:,(?:(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)-(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)))*)|(?:(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)(?:,(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec))*))\\s+((?:\\*)|(?:[0-6]|0[0-6])|(?:(?:(?:[0-6]|0[0-6])-(?:[0-6]|0[0-6]))(?:,(?:(?:[0-6]|0[0-6])-(?:[0-6]|0[0-6])))*)|(?:(?:[0-6]|0[0-6])(?:,(?:[0-6]|0[0-6]))*)|(?:\\*)|(?:sun|mon|tue|wed|thu|fri|sat)|(?:(?:(?:sun|mon|tue|wed|thu|fri|sat)-(?:sun|mon|tue|wed|thu|fri|sat))(?:,(?:(?:sun|mon|tue|wed|thu|fri|sat)-(?:sun|mon|tue|wed|thu|fri|sat)))*)|(?:(?:sun|mon|tue|wed|thu|fri|sat)(?:,(?:sun|mon|tue|wed|thu|fri|sat))*))$",
        "description": "Validates a cron schedule.\nSupports:\n- single values (zero-padded or not)\n- comma-separated lists of values (e.g. '2,14,17')\n- value ranges (e.g. '4-10')\n- list of ranges (e.g. '1-3,5-7')\n- days of the week and months specified as digits or strings (e.g. 'mon-tues', 'feb', '07', '3')\nDoes not support non-standard formats:\n- step values (e.g. '5/2')\n- @yearly, @annually, @monthly etc\n- Sunday specified as '7' (instead of '0')\n- 6th field (year)\nCapturing groups:\n1: minute\n2: hour\n3: day of the month\n4: month\n5: day of the week",
        "matches": [
            "15,45 4-5 2 feb *",
            "00 06,08 * * mon,wed",
            "00 * * 4 02",
            "00 * * 4 mon-tue,thu-fri"
        ],
        "non_matches": [
            "*****",
            "0 1 3 * * *",
            "0 1 * * 7",
            "60 * * * *",
            "* 24 * * *",
            "* * 32 * *",
            "* * 0 * *",
            "* * * 13 *",
            "* * * 0 *",
            "* * * * mon-tue-wed",
            "* * * jan-feb-mar *",
            "* * * jan-fed *"
        ]
    },
    {
        "id": 3811,
        "expression": "(((\\d{2}((0[13578]|1[02])(0[1-9]|[12]\\d|3[01])|(0[13456789]|1[012])(0[1-9]|[12]\\d|30)|02(0[1-9]|1\\d|2[0-8])))|([02468][048]|[13579][26])0229))(( |-)(\\d{4})( |-)([01]8((( |-)\\d{1})|\\d{1}))|(\\d{4}[01]8\\d{1}))",
        "description": "Matches valid South African ID numbers based on all criteria (except of course the checksum digit at the end).\nMatches the format defined as:\nYYMMDDSSSSCAZ.\nYY - Year,\nMM - Month,\nDD - Day,\nSSSS - Gender,\nC - Denotes citizenship (0 or a 1),\nA - Always an 8,\nZ - Checksum digit (doesn't validate if the checksum itself is valid).\nAlso supports the following ways of entering it:\nYYMMDDSSSSCAZ |\nYYMMDD SSSS CAZ |\nYYMMDD SSSS CA Z .\nSee this for a reference:\nhttps://www.westerncape.gov.za/general-publication/decoding-your-south-african-id-number-0",
        "matches": [
            "9202204720082",
            "920220 4720 082",
            "920220 4720 08 2",
            "920220-4720-082",
            "920220-4720-08-2 9202204720183",
            "920220 4720 183",
            "920220 4720 18 3",
            "920220-4720-183",
            "920220-4720-18-3"
        ],
        "non_matches": [
            "9202204720282",
            "920220 4720 052",
            "920220 4720 05 2",
            "920220-4720-252"
        ]
    },
    {
        "id": 3813,
        "expression": "^[a-zA-Z0-9_.-@$]*$",
        "description": "User name which will allow _ . @$And -",
        "matches": [
            "gcccbb@ghg$"
        ],
        "non_matches": [
            "bb#Dntn^b,m"
        ]
    },
    {
        "id": 3814,
        "expression": "((\\/\\*(\\r|\\n|(.(?!\\*/)))*)\\s\\*\\/|\\/\\/.*$)([\\r\\n\\s]+)?",
        "description": "Matches block comments or line comments, and all whitespace until the next uncommented character.",
        "matches": [
            "/* this matches */",
            "/** so does this */",
            "// this too"
        ],
        "non_matches": [
            "this does not match"
        ]
    },
    {
        "id": 3825,
        "expression": "^(([\\da-fA-F]{2}[-:]){5}[\\da-fA-F]{2})$",
        "description": "Easiest way to describe a MAC Address.",
        "matches": [
            "00-25-86-DC-FD-3B",
            "00:25:86:DC:FD:3B",
            "00-25-86-dc-fd-3b",
            "00:25:86:dc:fd:3b"
        ],
        "non_matches": [
            "00 25 86 dc fd 3b",
            "002586dcfd3b",
            "00.25.86.dc.fd.3b"
        ]
    },
    {
        "id": 3860,
        "expression": "^((750|7[0-4]\\d|[1-6]\\d\\d|[1-9]\\d|[3-9])|((7[0-4]\\d|[1-6]\\d\\d|[1-9]\\d|[3-9])\\.{1}[0,5]{1}){1}|750.0)$",
        "description": "Validate a number between 3 and 750 with one decimal that only is 0 or 5. Decimal separator is '.'",
        "matches": [
            "3.0",
            "10.5",
            "750.0",
            "750"
        ],
        "non_matches": [
            "2.0",
            "750.5",
            "2.5",
            "23,5"
        ]
    },
    {
        "id": 3879,
        "expression": "^[a-zA-Z0-9,./-]*$",
        "description": "check special character exists or not",
        "matches": [
            "a-zA-Z0-9,./-"
        ],
        "non_matches": [
            "~`!@#$%^&*()_=+-\\",
            "[]{}"
        ]
    },
    {
        "id": 3882,
        "expression": "([0-1][0-9]|[1-2][0-9]|[1-3][0-1])\\/([0][0-9]|[1][0-2])\\/(\\d{4})",
        "description": "Simple regex that matches european date format with slashes.\nIt doesn\u00b4t validate the different number of days of each month.",
        "matches": [
            "31/12/1987",
            "10/10/2010",
            "21/02/2019"
        ],
        "non_matches": [
            "2/5/1981",
            "21/6/213",
            "01/13/1900"
        ]
    },
    {
        "id": 3889,
        "expression": "^\\([2-9]\\d{2}\\) \\d{3}[- .]?\\d{4}\\D*(\\d*)$",
        "description": "Forces parethesis and space before 7 digit number",
        "matches": [
            "(555) 555-5555"
        ],
        "non_matches": [
            "555-555-5555"
        ]
    },
    {
        "id": 3893,
        "expression": "<a[\\s](?!.*\\b(title)\\b)[^>]+>",
        "description": "Finding all the anchor tags that do not contain the title attribute",
        "matches": [
            "<a href=\"mailto:abc2.jagadale@gmail.com\">abc2.jagadale@gmail.com</a>"
        ],
        "non_matches": [
            "This working well with all my files"
        ]
    },
    {
        "id": 3902,
        "expression": "(ns=[0-9])?;?((i=[0-9]+)|s=[a-zA-Z.]+)",
        "description": "Regex to check if a string is a OPC UA NodeId XML schema. Only works for Numeric and String NodeIds",
        "matches": [
            "ns=1;i=3015",
            "i=884",
            "ns=2;s=Demo.Static.Scalar.String"
        ],
        "non_matches": [
            "",
            "10001",
            "\"Hallo\""
        ]
    },
    {
        "id": 3906,
        "expression": "[a-zA-Z]+[0-9]*@[a-zA-Z]+[\\.](edu|org|com)",
        "description": "matches email syntax with com,edu,org only. You can add more the way you like it",
        "matches": [
            "aaa@dd.com, aa2332@bb.edu"
        ],
        "non_matches": [
            "aa@dd.ee"
        ]
    },
    {
        "id": 3909,
        "expression": "^\\d{1,2}-\\d{1,2}-\\d{4}$",
        "description": "This takes an American date using mm-dd-yyyy format. It does not validate month or day values.",
        "matches": [
            "12-9-1969",
            "2-8-1998",
            "8-17-2002"
        ],
        "non_matches": [
            "12-9-69",
            "12/2/1948"
        ]
    },
    {
        "id": 3910,
        "expression": "[\\+-]?(([0-9]*\\.[0-9]+|[0-9]+\\.[0-9]*)([Ee][\\+-]?[0-9]+)?[Ff]?|[0-9]+[Ff])",
        "description": "match a float number with Exponent sign and f sign",
        "matches": [
            "2.0",
            "0.3",
            "-.4",
            "3.f",
            "2.4E-2f",
            "0.4E4f"
        ],
        "non_matches": [
            "2",
            "234",
            ".f"
        ]
    },
    {
        "id": 3912,
        "expression": "(<<=|>>=|&&=|(\\|\\|=)|<<|>>(\\+=)|-=|(\\*=)|(\\/=)|%=|&=|(\\^=)|(\\|=)|<=|>=|==|!=|&&|(\\|\\|)|(\\+\\+)|--|>|<|\\^|&|(\\|)|\\*|\\/|%|\\+|-|~|=)",
        "description": "matches almost all programming language operator",
        "matches": [
            "++",
            "<=",
            ">>="
        ],
        "non_matches": [
            "identifier",
            "2000",
            "0xFFF"
        ]
    },
    {
        "id": 3915,
        "expression": "^(?:[a-zA-Z]\\.?){1,4}$",
        "description": "This expression will allow someone to place 1-4 Lower case or Upper case letters with optional periods after each letter for a total of up to 8 possible characters.",
        "matches": [
            "J.W.R.",
            "JwR",
            "j.r.",
            "jwre",
            "JWWR",
            "J.er.e"
        ],
        "non_matches": [
            "j..r.",
            "jwers",
            "jw2",
            ".j.w.r"
        ]
    },
    {
        "id": 3923,
        "expression": "^(?![-_.0-9])(?!.*[-_.][-_.])(?!.*[-_.]$)[A-Za-z0-9-_.]+$",
        "description": "Provide username constraint that allow character and numeric and also perion hyphen and underscore, but it only allows alphabet at the begin, and alphanumeric at the end. also user may not user more than one sign side by side",
        "matches": [
            "my.username",
            "u-s-e-r.n_a_m_e",
            "xyz724",
            "c1"
        ],
        "non_matches": [
            "9abc",
            "x..z",
            "a._-c",
            "-a",
            "c54_"
        ]
    },
    {
        "id": 3934,
        "expression": "^([\\da-fA-f]{2}[:-]){5}[\\da-fA-f]{2}$",
        "description": "Matches mixed case, colon or hypen hexadecimal notation. Discards string too short or long, or with invalid characters. Needs extended grep.",
        "matches": [
            "98-CE-d0-a2-0a-68",
            "98:cE:d0:a2:0a:68"
        ],
        "non_matches": [
            "98-cE-d0-a2-0a",
            "98-cE-d0-a2-0a-68-f0"
        ]
    },
    {
        "id": 3936,
        "expression": "^9792\\d{12}$",
        "description": "Matches troy credit cards (length 16, prefix 9792)",
        "matches": [
            "9792131111111111",
            "9792461111111111",
            "9792111111111111"
        ],
        "non_matches": [
            "9792 1311 1111 1111",
            "1234561234561234"
        ]
    },
    {
        "id": 3945,
        "expression": "(<log4j:Event logger=\")(.*?)(\" timestamp=\")(.*?)(\" level=\")(.*?)(\" thread=\")(.*?)(\">)(.*?)(<log4j:Message><!\\[CDATA\\[)(.*?)(\\]\\]>)",
        "description": "This is a regex to split a message by log4j into:\nLogger (Group 2)\nTimestamp (Group 4)\nLoggin Level (Group 6)\nThread (Group 8)\nMessage (Group 12)\nImportant: You have to enable single line",
        "matches": [
            "<log4j:Event logger=\"dxa\" timestamp=\"1564402596208\" level=\"INFO\" thread=\"Client thread\"> <log4j:Message><![CDATA[Message from log4j]]></log4j:Message> </log4j:Event>"
        ],
        "non_matches": [
            "asdf"
        ]
    },
    {
        "id": 3951,
        "expression": "^(?:Yes\\b|No\\b|yes\\b|YES\\b|YEs\\b|yeS\\b|yEs\\b|NO\\b|nO\\b|no\\b)",
        "description": "This regex will match below values only\nYES\nyes\nYes\nYEs\nyEs\nyeS\nNO\nno\nNo\nnO",
        "matches": [
            "YES yes Yes YEs yEs yeS NO no No nO"
        ],
        "non_matches": [
            "Except YES yes Yes YEs yEs yeS NO no No nO"
        ]
    },
    {
        "id": 3981,
        "expression": "^01[0125]{1}[0-9]{8}",
        "description": "- first 2 digits are 01\n- second 1 digit is 0 for (Vodafone) or 1 for (Etisalat) or 2 for (orange) or 5 for (We)\n- third 8 digits are between 0 and 9",
        "matches": [
            "01022685544",
            "01122685544",
            "01222685544",
            "01522685544"
        ],
        "non_matches": [
            "+0201622685544",
            "01322685544",
            "01422685544",
            "01622685544",
            "01722685544",
            "01822685544",
            "01922685544"
        ]
    },
    {
        "id": 3983,
        "expression": "^(\\d|\\d{1,9}|1\\d{1,9}|20\\d{8}|21[0-3]\\d{7}|214[0-6]\\d{6}|2147[0-3]\\d{5}|21474[0-7]\\d{4}|214748[0-2]\\d{3}|2147483[0-5]\\d{2}|21474836[0-3][0-9]|214748364[0-7])$",
        "description": "regular expression for positive integer",
        "matches": [
            "2147483647",
            "0",
            "2147483639"
        ],
        "non_matches": [
            "2147483648",
            "0.0",
            "-54645"
        ]
    },
    {
        "id": 4006,
        "expression": "^[0][5-7]\\d{2}(?:(\\s|-|\\/))?\\d{2}(?:(\\s|-|\\/))?\\d{2}(?:(\\s|-|\\/))?\\d{2}$",
        "description": "Algerian Mobile :\n1-Starts With 0\n2-Between 5 & 7\nThe rest can be filled with 8 digits with or without\nspaces or dashes, I even added slashes, grouped 2 by 2\nTotal of digits (without spaces/dashes/slashes) must be 10.",
        "matches": [
            "0696 22 13 23"
        ],
        "non_matches": [
            "02252525225"
        ]
    },
    {
        "id": 4010,
        "expression": "^(0)((3[0-6][0-9]))(\\d{7})$",
        "description": "All phone numbers starting with 03*********. total 11 digit numbers.",
        "matches": [
            "03355011998"
        ],
        "non_matches": [
            "+923355011998"
        ]
    },
    {
        "id": 4013,
        "expression": "(?:\\s|^)(?P<day>(?P<threeone>31)|(?P<thirty>30)|(?P<twonine>29)|(?P<twoeight>2[0-8]|1[0-9]|0?[1-9]))(?P<sep>[/\\-\\.:])(?P<month>(?(threeone)(?:1[02]|0?[13578]))(?(thirty)(?:1[012]|0?[13456789]))(?(twonine)(?:1[012]|0?[13-9]|(?P<leap>0?2)))(?(twoeight)(?:1[012]|0?[1-9])))(?P=sep)(?P<year>(?:\\d\\d)?(?(leap)(?:(?:[02468][048])|(?:[13579][26]))|(?:\\d\\d)))(?:$|\\s)",
        "description": "This matches valid dates (including leap year dates of the following formats :\ndd/mm/yy\ndd/mm/yyyy\nd/m/yy\nd/m/yyyy\ndd-mm-yy\ndd-mm-yyyy\nd-m-yy\nd-m-yyyy\ndd.mm.yy\ndd.mm.yyyy\nd.m.yy\nd.m.yyyy\nuse the named groups day, month, year",
        "matches": [
            "29/02/2096"
        ],
        "non_matches": [
            "29/02/2097",
            "31/04/2020"
        ]
    },
    {
        "id": 4014,
        "expression": "(?:\\s|^)(?P<day>(?P<threeone>31)|(?P<thirty>30)|(?P<twonine>29)|(?P<twoeight>2[0-8]|1[0-9]|0?[1-9]))(?P<sep>[/\\-\\.:])(?P<month>(?(threeone)(?:jan|mar|may|jul|aug|oct|dec))(?(thirty)(?:jan|mar|apr|may|jun|jul|aug|sep|oct|nov|dec))(?(twonine)(?:jan|(?P<feb>feb)|mar|apr|may|jun|jul|aug|sep|oct|nov|dec|))(?(twoeight)(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)))(?P=sep)(?P<year>(?:\\d\\d)?(?(twonine)(?(feb)(?:(?:[02468][048])|(?:[13579][26]))|(?:\\d\\d))))(?:$|\\s)",
        "description": "Validates dates in the (d)d-MMM-(yy)yy format",
        "matches": [
            "29-feb-2020, 1-jan-01"
        ],
        "non_matches": [
            "29-feb-19, 31-sep-2010"
        ]
    },
    {
        "id": 4015,
        "expression": "(?:\\s|^)(?P<day>(?P<threeone>31)|(?P<thirty>30)|(?P<twonine>29)|(?P<twoeight>2[0-8]|1[0-9]|0?[1-9]))(?P<sep>[/\\-\\.:])(?P<month>(?(threeone)(?:jan|mar|may|jul|aug|oct|dec))(?(thirty)(?:jan|mar|apr|may|jun|jul|aug|sep|oct|nov|dec))(?(twonine)(?:jan|(?P<feb>feb)|mar|apr|may|jun|jul|aug|sep|oct|nov|dec|))(?(twoeight)(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)))(?P=sep)(?P<year>(?:\\d\\d)?(?(twonine)(?(feb)(?:(?:[02468][048])|(?:[13579][26]))|(?:\\d\\d))|(?:\\d\\d)))(?:$|\\s)",
        "description": "Validates dates in the (d)d-MMM-(yy)yy format",
        "matches": [
            "29-feb-2020",
            "1-jan-01"
        ],
        "non_matches": [
            "29-feb-19",
            "31-sep-2010"
        ]
    },
    {
        "id": 4029,
        "expression": "^[0-9]{4}(0[1-9]|1[0-2])(0[1-9]|[1-2][0-9]|3[0-1])($|(([01][0-9]|2[0-3])[0-5][0-9][0-5][0-9])$)",
        "description": "This expression validate the YYYYMMDDHHMMSS datetime format but also only the date YYYYMMDD. It does not control month length or leap years. Made for a SAP retail sales tickets interface.\nFor XML pattern facet this would do:\n([0-9]{4}(0[1-9]|1[0-2])(0[1-9]|[1-2][0-9]|3[0-1])(([01][0-9]|2[0-3])[0-5][0-9][0-5][0-9]))|([0-9]{4}(0[1-9]|1[0-2])(0[1-9]|[1-2][0-9]|3[0-1]))",
        "matches": [
            "20200707181818",
            "20200707",
            "20200231010000",
            "20200931",
            "00011231235959",
            "00000101"
        ],
        "non_matches": [
            "20201232",
            "20201301",
            "20200028",
            "20200500",
            "20200707235978",
            "20201231128533",
            "20200327453030"
        ]
    },
    {
        "id": 4034,
        "expression": "^((25[0-5]|2[0-4]\\d|1\\d{2}|[1-9]?\\d)(\\.|$)){4}\\b",
        "description": "Match valid IPv4 address. Constraints: matches only IP. All numbers must be between 0-255 for each block, delimited by dots, and cannot be zero padded or be suffixed by a dot on the last class.",
        "matches": [
            "0.0.0.0",
            "192.168.1.35",
            "169.254.0.0"
        ],
        "non_matches": [
            "127.0.0.01",
            "255.255.255.256",
            "7.7.7.7."
        ]
    },
    {
        "id": 4041,
        "expression": "(^[3|4|5|6|7|8|9]\\d{2}(\\ |-){0,1}\\d{4}$)|(^[4|5|7|8]\\d{3}(\\ |-){0,1}\\d{4}$)|(^8\\d{2,3}(\\ |-){0,1}\\d{3,4}(\\ |-){0,1}\\d{3,4}$)",
        "description": "Supports 7 digits (starting with 3,4,5,6,7,8,9) 8 digits (starting with 4,5,7,8), machine-to-machine (M2M) numbers 9-12 digits (starting with 8).",
        "matches": [
            "300 3000",
            "300-3000",
            "3003000"
        ],
        "non_matches": [
            "3000 3000",
            "9000 9000 9000"
        ]
    },
    {
        "id": 4042,
        "expression": "^(\\d)(\\s)(\\d)*(-)(\\d)*(-)(\\d)*",
        "description": "Matches any number following the 1 800 phone method. It's not 100% foolproof so please be wary - just wanted to present my legitimate, raw regex without having to look up anything on Stack Overflow. Thank you.\nLink to my GitHub: https://github.com/StoddardSpencer96",
        "matches": [
            "1 902-444-444 1 904-565-5555 1 419-444-4444 1 902-44-3333 (this one shouldnt match)"
        ],
        "non_matches": [
            "23 904-5555-5555 1 902-44-3333 (this is where the number should be)"
        ]
    },
    {
        "id": 4043,
        "expression": "([s]){10,}",
        "description": "Matches the hissing noise of a snake. Link to my GitHub: https://github.com/StoddardSpencer96",
        "matches": [
            "ssssssssss wwwwwwwwwwwsssssssssssssssssss"
        ],
        "non_matches": [
            "effsgrgrsfefsv54543534544 FKR$>%>??W?EK#$Krkdk3oror"
        ]
    },
    {
        "id": 4044,
        "expression": "([ing]){3}$",
        "description": "Matching any word that ends with \"ing\"\nLink to my GitHub: https://github.com/StoddardSpencer96",
        "matches": [
            "Reading Playing Comforting Crying"
        ],
        "non_matches": [
            "Readings Listenings Playful Comfort"
        ]
    },
    {
        "id": 4047,
        "expression": "^([\\d])([\\s])([\\d]){3}([-])([\\d]){3}([-])([\\d])*",
        "description": "Matches the 1 800-8000 format.\nLink to Github: https://github.com/StoddardSpencer96",
        "matches": [
            "1 902-444-4444 1 405-543-3000 1 910-243-321"
        ],
        "non_matches": [
            "1902-44-4-5-3-2-2 1 9023333333 1-902-3332222"
        ]
    },
    {
        "id": 4051,
        "expression": "((=)[A-F0-9]{2}){3}",
        "description": "Using this Regex for finding spam in RAW email\nthis is Case sensitive\nHEX only CAPITAL A-F and numbers 0-9",
        "matches": [
            "=EF=BB=BF",
            "=E2=9C=80",
            "=E2=9D=A4"
        ],
        "non_matches": [
            "e2 9d a4",
            "ABCXYZ",
            "f0=9f=aa=81"
        ]
    },
    {
        "id": 4067,
        "expression": "\\b[0-9]{2}([0][1-9]{1}|[1][0-2]{1})([0][1-9]{1}|[1][0-9]{1}|[2][0-9]{1}|[3][0-1]{1})\\d{5}",
        "description": "The PESEL number is an identification number given to every Polish citizen when they are born and registered in Poland.",
        "matches": [
            "11083197485",
            "36110878229",
            "00063172200",
            "12110383138"
        ],
        "non_matches": [
            "1F083297485",
            "36204578229",
            "AA06317220B",
            "12203383138"
        ]
    },
    {
        "id": 4072,
        "expression": "^((0[1-9])|(1[0-2]))[\\/\\.\\-]*((2[0-9])|(3[0-9]))$",
        "description": "valid years 2020 to 2039",
        "matches": [
            "12/20",
            "12/39",
            "05-25"
        ],
        "non_matches": [
            "12/40",
            "23/02",
            "15-25"
        ]
    },
    {
        "id": 4086,
        "expression": "^((?!.*(00000|11111|22222|33333|44444|55555|66666|77777|88888|99999))[0-9]{5,10})",
        "description": "In example for some input number in case random digits not repeat number 5 number in 5-10 digits in pattern.",
        "matches": [
            "0000110000",
            "000010010"
        ],
        "non_matches": [
            "00000",
            "1122000009"
        ]
    },
    {
        "id": 4087,
        "expression": "^((?!.*(01234|12345|23456|34567|45678|56789))[0-9]{5,10})",
        "description": "In example for some input number in case random digits not sort number 5 number in 5-10 digits in pattern.",
        "matches": [
            "000111222",
            "111222333"
        ],
        "non_matches": [
            "0000123400",
            "1112345"
        ]
    },
    {
        "id": 4107,
        "expression": "(?!BG|GB|KN|NK|NT|TN|ZZ)[A-CEGHJ-PR-TW-Z][A-CEGHJ-NPR-TW-Z][0-9]{6}[A-D]",
        "description": "UK NI number. ensured that the suffix is always a single character of A-D (as these are the only values currently supported by HMRC). Created 2021",
        "matches": [
            "XY123456D"
        ],
        "non_matches": [
            "XY123456E"
        ]
    },
    {
        "id": 4110,
        "expression": "([A-Za-z]{3})([pchabgjlftPCHABGJLFT])([a-zA-Z])([0-9]{4})([A-Za-z]{1})",
        "description": "1. 3 generic Alphabets\n2. 1 specific alphabet\n3. 1 generic alphabet\n4. 4 digits\n5. 1 generic alphabet\n(alphabets: small or capital)",
        "matches": [
            "AABCL5045N"
        ],
        "non_matches": [
            "AABXL5045N"
        ]
    },
    {
        "id": 4125,
        "expression": "^01[0-2,5]{1}[0-9]{8}$",
        "description": "this regex can validate the Egyptian mobile phone numbers for the 4 Major Service Providers\n(Orange|We|Etisalat|Vodafone)",
        "matches": [
            "01151151111",
            "01208939599",
            "01001111111"
        ],
        "non_matches": [
            "0115115111",
            "0120893959",
            "01611112935"
        ]
    }
]