[{"expression": "^\\d{5}-\\d{4}|\\d{5}|[A-Z]\\d[A-Z] \\d[A-Z]\\d$", "raw_prompt": "This expression matches three different formats of postal codes: 5 digit US ZIP code, 5 digit US ZIP code + 4, and 6 digit alphanumeric Canadian Postal Code. The first one must be 5 numeric digits. The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits. The Canadian postal code must be of the form ANA NAN where A is any uppercase alphabetic character and N is a numeric digit from 0 to 9.", "refined_prompt": "This expression matches three different formats of postal codes: 5 digit US ZIP code, 5 digit US ZIP code + 4, and 6 digit alphanumeric Canadian Postal Code. The first one must be 5 numeric digits. The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits. The Canadian postal code must be of the form ANA NAN where A is any uppercase alphabetic character and N is a numeric digit from 0 to 9.\nMatch examples:\n- \"44240\"\n- \"44240-5555\"\n- \"G3H 6A3\"\nNon-match examples:\n- \"Ohio\"\n- \"abc\"", "matches": ["44240", "44240-5555", "G3H 6A3", "40243", "58940", "32854-1383", "73948-1937", "48527-4827", "49284-3194", "48365", "F7S 9S9", "S7S 7S7", "K9K 4J4"], "non_matches": ["Ohio", "abc", "g3h6a3", "INDIANA", "NOTRE DAME", "02934-23429", "50394-234234", "sdfkgj", "000-000", "092032-234", "s8s 8s8", "SDFFDS"], "stress_tests": [], "serial": 17, "problematic": [{"example": "02934-23429", "is_match": false}, {"example": "50394-234234", "is_match": false}, {"example": "092032-234", "is_match": false}]}, {"expression": "\\(([0-9]{2}|0{1}((x|[0-9]){2}[0-9]{2}))\\)\\s*[0-9]{3,4}[- ]*[0-9]{4}", "raw_prompt": "Match diferent styles for brazilian Phone number code.\nOnly DDD (12), complete DDD (012), complete DDD + Telephony Company (0xx12) plus 3 or 4 digits (city code) plus 4 digits (phone number).", "refined_prompt": "Match different styles for brazilian Phone number code.\r\nOnly DDD (12), complete DDD (012), complete DDD + Telephony Company (0xx12) plus 3 or 4 digits (city code) plus 4 digits (phone number).\nMatch examples:\n- \"(12) 123 1234\"\n- \"(01512) 123 1234\"\n- \"(0xx12) 1234 1234\"\nNon-match examples:\n- \"12 123 1234\"\n- \"(012) 123/1234\"", "matches": ["(12) 123 1234", "(01512) 123 1234", "(0xx12) 1234 1234", "(12) 324 6532", "(12) 624 2534", "(12) 653 2753", "(01512) 678 9678", "(01512) 367 8368", "(01512) 836 6583", "(0xx12) 8635 8563", "(0xx12) 3643 1234", "(0xx12) 7256 2345", "(0xx12) 7282 6253"], "non_matches": ["12 123 1234", "(012) 123/1234", "(012) 123 12345", "(12) 324 653210", "(12) 32494 6532", "(12) 324 645532", "(01512) 836 41236583", "(01512) 84536 646583", "(01512) 836", "(0xx12) 7256 2345154", "(0xx12) 62509", "(0xx12) 093124800"], "stress_tests": [], "serial": 22, "problematic": [{"example": "(12) 324 653210", "is_match": false}, {"example": "(12) 324 645532", "is_match": false}, {"example": "(01512) 836 41236583", "is_match": false}, {"example": "(0xx12) 7256 2345154", "is_match": false}, {"example": "(0xx12) 093124800", "is_match": false}]}, {"expression": "\\b(([01]?\\d?\\d|2[0-4]\\d|25[0-5])\\.){3}([01]?\\d?\\d|2[0-4]\\d|25[0-5])\\b", "raw_prompt": "Most Concise RegExp for matching Decimal IPs. If nothing else, it'll make your code easier to read. (And I know that \\d?\\d is \\d{1,2} but that's 2 extra characters.)\n--Update: darkone noticed 8 characters could be shaved down. I've edited it to reflect this. Thanks, darkone!", "refined_prompt": "Matches a valid decimal IP address with four segments, where each segment ranges from 0 to 255, separated by dots.\nMatch examples:\n- \"217.6.9.89\"\n- \"0.0.0.0\"\n- \"255.255.255.255\"\nNon-match examples:\n- \"256.0.0.0\"\n- \"0978.3.3.3\"", "matches": ["217.6.9.89", "0.0.0.0", "255.255.255.255", "32.31.31.41", "251.23.53.6", "2.4.5.2", "52.54.83.127", "185.27.64.83", "245.75.61.176", "135.163.167.143", "43.6.1.3", "5.8.3.6", "2.5.8.9"], "non_matches": ["256.0.0.0", "0978.3.3.3", "65.4t.54.3", "524.15.134.3", "654.22.72.566", "256.25.345.3", "22.44.66.1111", "44.44.44.44.44", "67.84.25.644", "145.634.462.43", "4512.2436.246.43", "6243.2463.34.34"], "stress_tests": [], "serial": 27, "problematic": [{"example": "44.44.44.44.44", "is_match": false}]}, {"expression": "^((4\\d{3})|(5[1-5]\\d{2})|(6011))-?\\d{4}-?\\d{4}-?\\d{4}|3[4,7]\\d{13}$", "raw_prompt": "Matches major credit cards including:\nVisa (length 16, prefix 4), Mastercard (length 16, prefix 51-55), Discover (length 16, prefix 6011), American Express (length 15, prefix 34 or 37). All 16 digit formats accept optional hyphens (-) between each group of four digits.", "refined_prompt": "Matches major credit cards including:\r\nVisa (length 16, prefix 4), Mastercard (length 16, prefix 51-55), Discover (length 16, prefix 6011), American Express (length 15, prefix 34 or 37). All 16 digit formats accept optional hyphens (-) between each group of four digits.\nMatch examples:\n- \"6011-1111-1111-1111\"\n- \"5423-1111-1111-1111\"\n- \"341111111111111\"\nNon-match examples:\n- \"4111-111-111-111\"\n- \"3411-1111-1111-111\"", "matches": ["6011-1111-1111-1111", "5423-1111-1111-1111", "341111111111111", "4032-2532-3424-6424", "6011-3453-5135-6542", "5423-5134-7541-751411", "341111492857111", "4032-5143-3424-7536", "6011-5437-1111-4265", "5423-3757-7335-7141", "341111521111593", "4032-7134-1643-5354", "6011-4326-1111-7452"], "non_matches": ["4111-111-111-111", "3411-1111-1111-111", "Visa", "Mastercard", "134123409584391084032", "Chase", "512309842312345123", "543-5431-15234-51234", "Discover", "532151324234", "15235", "Match"], "stress_tests": [], "serial": 30, "problematic": [{"example": "512309842312345123", "is_match": false}]}, {"expression": "^[-+]?\\d*\\.?\\d*$", "raw_prompt": "Matches any floating point numer/numeric string, including optional sign character (+ or -). Also matches empty strings.", "refined_prompt": "Matches any floating point number/numeric string, including optional sign character (+ or -). Also matches empty strings.\nMatch examples:\n- \"123\"\n- \"+3.14159\"\n- \"-3.14159\"\nNon-match examples:\n- \"abc\"\n- \"3.4.5\"", "matches": ["123", "+3.14159", "-3.14159", "41325", "5435", "1534", "634", "+2435.2543", "+645.265", "-265.667", "-65.532", "-89.53", "-1.1"], "non_matches": ["abc", "3.4.5", "$99.95", "5.4.352.5431", "5145134.5143", "@R$#@FDS", "*(URW(", "2345.341v1v", "415.11534vvv", "341.431v4f3.fv1", "314v.341v", "ccc.ccc"], "stress_tests": [], "serial": 35, "problematic": [{"example": "5145134.5143", "is_match": false}]}, {"expression": "^(([1-9])|(0[1-9])|(1[0-2]))\\/((0[1-9])|([1-31]))\\/((\\d{2})|(\\d{4}))$", "raw_prompt": "Matches U.S. dates with leading zeros and without and with 2 or four digit years", "refined_prompt": "Match strings representing U.S. dates in the month/day/year or month/day/yy format. It validates the month to be between 1 and 12, the day to be between 1 and 31, and the year to be either two or four digits.\nMatch examples:\n- \"01/01/2001\"\n- \"1/1/2001\"\n- \"01/1/01\"\nNon-match examples:\n- \"13/01/2001\"\n- \"1/2/100\"", "matches": ["01/01/2001", "1/1/2001", "01/1/01", "1/1/1111", "2/2/2222", "3/3/3333", "04/04/2004", "05/04/2345", "10/10/1010", "11/11/1111", "12/12/1212", "12/11/2000", "04/05/06"], "non_matches": ["13/01/2001", "1/2/100", "09/32/2001", "02/67/5205", "25/642/42645", "462/246/75", "7457/245/245", "26/2542/642", "245/524/12", "1/1/1", "534/61/165", "1354/67531/1345"], "stress_tests": [], "serial": 40, "problematic": [{"example": "10/10/1010", "is_match": true}, {"example": "11/11/1111", "is_match": true}, {"example": "12/12/1212", "is_match": true}, {"example": "12/11/2000", "is_match": true}]}, {"expression": "^\\$?([0-9]{1,3},([0-9]{3},)*[0-9]{3}|[0-9]+)(.[0-9][0-9])?$", "raw_prompt": "Matches currency input with or without commas.", "refined_prompt": "Match strings representing monetary values in the format of dollars and cents. It allows for optional dollar signs, handles numbers with or without commas, and allows for an optional decimal portion with exactly two digits.\nMatch examples:\n- \"$3,023,123.34\"\n- \"9,876,453\"\n- \"123456.78\"\nNon-match examples:\n- \"4,33,234.34\"\n- \"$1.234\"", "matches": ["$3,023,123.34", "9,876,453", "123456.78", "345.532", "54235.7542", "6254.7653", "27454.274", "6254", "$423.542", "$5234.52452", "$6452", "6547", "2654"], "non_matches": ["4,33,234.34", "$1.234", "abc", "dafs", "-234", "\u00a5423", "\u00a55243.652", "%jfkdl", "#2432", "%flksfa", "$$skljdf", "$23423$"], "stress_tests": [], "serial": 41, "problematic": [{"example": "345.532", "is_match": true}, {"example": "54235.7542", "is_match": true}, {"example": "6254.7653", "is_match": true}, {"example": "27454.274", "is_match": true}, {"example": "$423.542", "is_match": true}, {"example": "$5234.52452", "is_match": true}]}, {"expression": "^(\\(?\\+?[0-9]*\\)?)?[0-9_\\- \\(\\)]*$", "raw_prompt": "A regular expression to match phone numbers, allowing for an international dialing code at the start and hyphenation and spaces that are sometimes entered.", "refined_prompt": "Match strings representing phone numbers. It allows for an optional country code, which can be enclosed in parentheses and prefixed with a plus sign. The main content of the phone number can consist of digits, underscores, hyphens, spaces, and parentheses.\nMatch examples:\n- \"(+44)(0)20-12341234\"\n- \"02012341234\"\n- \"+44 (0) 1234-1234\"\nNon-match examples:\n- \"(44+)020-12341234\"\n- \"12341234(+020)\"", "matches": ["(+44)(0)20-12341234", "02012341234", "+44 (0) 1234-1234", "(+44)(0)20-58404831", "(+48)(0)20-59420618", "(+69)(0)20-54830618", "02059301759", "02019684729", "02068295839", "+44 (0) 1045-1234", "+89 (0) 1234-5143", "+48 (0) 6316-1234", "+68 (0) 1234-0851"], "non_matches": ["(44+)020-12341234", "12341234(+020)", "90438502+9503", "542090()839045", "25498(543)98453-", "(543908)04395+0954-", "25498-305+", "54398IONF", "3458=+759304", "3495u0()", "432,543,345", "6234,523+5234"], "stress_tests": [], "serial": 43, "problematic": [{"example": "542090()839045", "is_match": false}, {"example": "25498(543)98453-", "is_match": false}]}, {"expression": "\\b(\\w+)\\s+\\1\\b", "raw_prompt": "Uses backreferences and word boundaries to match repeated words seperated by whitespace without matching a word with the same ending as the next words beginning.", "refined_prompt": "Match repeated consecutive words. It looks for a word, followed by one or more whitespace characters, and then the same word again. The word boundaries ensure that the pattern matches complete words and not just partial matches within larger words.\nMatch examples:\n- \"Tell the the preacher\"\n- \"some some\"\n- \"hubba hubba\"\nNon-match examples:\n- \"once an annual report\"\n- \"mandate dated submissions\"", "matches": ["Tell the the preacher", "some some", "hubba hubba", "abc abc", "hello hello afsd", "adf qwer qwer", "abcd abcd efads", "poe poe werf", "fdsi fdsi qrew", "hello hi hi", "ha ha hao", "cool cool great", "apple pen pen"], "non_matches": ["once an annual report", "mandate dated submissions", "Hubba hubba", "once upon", "a time", "there is a boy", "notre dame", "university hello", "literal basic", "asdf asdf ai0qroew ads", "adsfqij hquiwe fads", "fadsijb reiqjwna"], "stress_tests": [], "serial": 46, "problematic": [{"example": "asdf asdf ai0qroew ads", "is_match": false}]}, {"expression": "^(s-|S-){0,1}[0-9]{3}\\s?[0-9]{2}$", "raw_prompt": "Validates swedish zipcodes (postnr) with or without space between groups. With leading s- or not. Can be disconnected by removing ''(s-|S-){0,1}''.", "refined_prompt": "Validate strings that start with an optional \"s-\" or \"S-\" prefix, followed by three digits, an optional space, and then two more digits.\nMatch examples:\n- \"12345\"\n- \"932 68\"\n- \"S-621 46\"\nNon-match examples:\n- \"5367\"\n- \"425611\"", "matches": ["12345", "932 68", "S-621 46", "S-40213", "20088", "s-82126", "s-244\ufeff18", "24283", "63407", "s-770\u200671", "626\u00a013", "S-038\f46", "35244"], "non_matches": ["5367", "425611", "31 545", "25435243", "523452", "54615431", "5243", "s543", "SDF345", "F$FE#DF", "234 234423", "2654265"], "stress_tests": [], "serial": 50, "problematic": [{"example": "s-244\ufeff18", "is_match": true}]}, {"expression": "((0?[13578]|10|12)(-|\\/)((0[0-9])|([12])([0-9]?)|(3[01]?))(-|\\/)((\\d{4})|(\\d{2}))|(0?[2469]|11)(-|\\/)((0[0-9])|([12])([0-9]?)|(3[0]?))(-|\\/)((\\d{4}|\\d{2})))", "raw_prompt": "Regex used in .NET to validate a date. Matches the following formats mm/dd/yy, mm/dd/yyyy, mm-dd-yy, mm-dd-yyyy\nThis covers days with 30 or 31 days but does not handle February, it is allowed 30 days.", "refined_prompt": "Regex used in .NET to validate a date. Matches the following formats mm/dd/yy, mm/dd/yyyy, mm-dd-yy, mm-dd-yyyy. This covers days with 30 or 31 days but does not handle February, it is allowed 30 days.\nMatch examples:\n- \"1/31/2002\"\n- \"04-30-02\"\n- \"12-01/2002\"\nNon-match examples:\n- \"2/31/2002\"\n- \"13/0/02\"", "matches": ["1/31/2002", "04-30-02", "12-01/2002", "08/01-28", "12-02-53", "11-06-4294", "11/01/15", "12/09-4478", "06-3-2360", "6/27/8762", "9/30-62", "10/07/73", "04/19-30"], "non_matches": ["2/31/2002", "13/0/02", "Jan 1, 2001", "1//112/1", "2/2/22222", "33/33/3333", "7/55/2023", "40/70/7960", "432/524/2435", "354/243/542", "9/9/9", "12/132/90"], "stress_tests": [], "serial": 51, "problematic": [{"example": "2/2/22222", "is_match": false}]}, {"expression": "^(?:(?:(?:0?[13578]|1[02])(\\/|-|\\.)31)\\1|(?:(?:0?[13-9]|1[0-2])(\\/|-|\\.)(?:29|30)\\2))(?:(?:1[6-9]|[2-9]\\d)?\\d{2})$|^(?:0?2(\\/|-|\\.)29\\3(?:(?:(?:1[6-9]|[2-9]\\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00))))$|^(?:(?:0?[1-9])|(?:1[0-2]))(\\/|-|\\.)(?:0?[1-9]|1\\d|2[0-8])\\4(?:(?:1[6-9]|[2-9]\\d)?\\d{2})$", "raw_prompt": "This expression validates dates in the US m/d/y format from 1/1/1600 - 12/31/9999.", "refined_prompt": "Validate dates in various date formats (allowing for optional years in two or four digits) while considering leap years and different separators between components (/, -, .). It also ensures that the dates are from 1/1/1600 - 12/31/9999.\nMatch examples:\n- \"01.1.02\"\n- \"11-30-2001\"\n- \"2/29/2000\"\nNon-match examples:\n- \"02/29/01\"\n- \"13/01/2002\"", "matches": ["01.1.02", "11-30-2001", "2/29/2000", "5/31/5417", "12.31.4730", "1/31/1981", "12/31/1889", "10/31/1834", "7/31/73", "7.31.7629", "12-31-20", "12-31-21", "12-10-18"], "non_matches": ["02/29/01", "13/01/2002", "11/00/02", "12/123/4322", "2346-2345-2435", "2/3/5235", "/5/5/5", "/5/5/20022", "432/524/2435", "354/243/542", "9/9/9", "12/132/90"], "stress_tests": [], "serial": 70, "problematic": [{"example": "2/3/5235", "is_match": false}]}, {"expression": "\"((\\\\\")|[^\"(\\\\\")])+\"", "raw_prompt": "Matches quoted string, using \\&quot; as an escape to place quotes in the string", "refined_prompt": "Captures text enclosed in double quotes, allowing for escaped double quotes within the text, while ignoring double quotes outside of the enclosing quotes.\nMatch examples:\n- \"\"test\"\"\n- \"\"escape\\\"quote\"\"\n- \"\"\\\"\"\"\nNon-match examples:\n- \"test\"\n- \"\"test\"", "matches": ["\"test\"", "\"escape\\\"quote\"", "\"\\\"\"", "\"gdfsg\"", "\"fsda\"", "\"fjaoif98\"", "\"fsdiofjsd09\"", "\"jfiosdj09\"", "\"\\\"\\\"\\\"p\"", "\"\\\"o2+\\\"m\\\"S2?^sS\\\"su\\\"a\\\"`FVlV\\\"g\\\"\\\"\\\"\\\"\\\"\\\"7}\\\"2\\\"3\"", "\"4%\\\"I\\\"j1{\\\"\\\"\\\"<Py\\\"\\\"OX\\\":z\\\"\\\"\\\"\\\"\\\"\\\"#v\\\"\\\"\\\"\\\",\\\"16E,\\\"Y\\\"8\\\"\\\"\"", "\"=\\\"\\\"U\\\"\\\">\\\"\\\"o2\\\"^\\\"eo|\\\"\\\" 2cW\\\"\"", "\"-\\\"EX\\\"\\\"\\\"\\\"\\\"0G\\\"\\\"\""], "non_matches": ["test", "\"test", "\"test\\\"", "32fs\"\\dfsfds", "sdffds\"", "\"\"\"fdsDFSDF:\"", "\"DFS\":DSF\":DS\"F:", "\"\"SDFL\"DF\"S", "432/\"524/2435", "(0xx12) 7256\"2345154", "9/9\"/9", "++63453.345\""], "stress_tests": [], "serial": 74, "problematic": [{"example": "\"\"\"fdsDFSDF:\"", "is_match": false}, {"example": "\"DFS\":DSF\":DS\"F:", "is_match": false}, {"example": "\"\"SDFL\"DF\"S", "is_match": false}]}, {"expression": "(\"[^\"]*\")|('[^\\r]*)(\\r\\n)?", "raw_prompt": "Will match a VBScript string and/or comment\nEx:\n' userinfo\nstrUsername = &quot;tomsve&quot;\niAge = 20\n' temp\nstrPassword = &quot;halloj&quot;\n...Would result in the following matches:\n' userinfo\n&quot;tomsve&quot;\n' temp\n&quot;halloj&quot;\nGood luck!\nTom S. info@tomsvensson.com", "refined_prompt": "Will match a VBScript string and/or comment. Capture text enclosed in either double quotes or single quotes, with support for multiline text in single quotes.\nMatch examples:\n- \"\"my string\"\"\n- \"\"a string with ' in it\"\"\n- \"' comment\"\nNon-match examples:\n- \"asd \"\"\n- \"\"fsdlkfjalkfdj\"", "matches": ["\"my string\"", "\"a string with ' in it\"", "' comment", "'afds", "\"[.|)?\"", "\"fgsgfd\"", "'fsda'", "\"fdsahds\"", "'hkjzcvk", "sdafha", "'afds'", "\"fsdafds2\"", "'asdfah'"], "non_matches": ["asd \"", "\"fsdlkfjalkfdj", "afdsads", "fadfs", "hafd23f", "43.v234", "@#dfkjnav", "notre dame", "432/524/2435", "(0xx12) 7256 2345154", "abc111def", "++63453.345"], "stress_tests": [], "serial": 82, "problematic": [{"example": "sdafha", "is_match": true}]}, {"expression": "^[_a-zA-Z0-9-]+(\\.[_a-zA-Z0-9-]+)*@[a-zA-Z0-9-]+(\\.[a-zA-Z0-9-]+)*\\.(([0-9]{1,3})|([a-zA-Z]{2,3})|(aero|coop|info|museum|name))$", "raw_prompt": "Matches e-mail addresses, including some of the newer top-level-domain extensions, such as info, museum, name, etc. Also allows for emails tied directly to IP addresses.", "refined_prompt": "Matches e-mail addresses, including some of the newer top-level-domain extensions, such as info, museum, name, etc. Also allows for emails tied directly to IP addresses.\nMatch examples:\n- \"example@example.com\"\n- \"foo@bar.info\"\n- \"blah@127.0.0.1\"\nNon-match examples:\n- \"broken@@example.com\"\n- \"foo@bar.infp\"", "matches": ["example@example.com", "foo@bar.info", "blah@127.0.0.1", "example@asdf.com", "sd@tqfdg.com", "agads@fasdfa.com", "adsf@bar.info", "gds@afds.info", "afds@gads.info", "adsga@127.0.0.255", "ag@127.0.255.255", "hdgadfs@127.0.200.1", "gadsf@127.255.0.255"], "non_matches": ["broken@@example.com", "foo@bar.infp", "blah@.nospam.biz", "12/123/4322", "sfalijad234", "3nf@", "@#dfkjnav", "2546dgwre@fsdcxzv", "qwerty@123.123", "com.edu.github@fdsa", "(0xx12) 62509", "99999@gmail@"], "stress_tests": [], "serial": 87, "problematic": [{"example": "qwerty@123.123", "is_match": false}]}, {"expression": "^[a-zA-Z]+(([\\'\\,\\.\\- ][a-zA-Z ])?[a-zA-Z]*)*$", "raw_prompt": "Person's name (first, last, or both) in any letter case. Although not perfect, this expression will filter out many incorrect name formats (especially numerics and invalid special characters).", "refined_prompt": "Person's name (first, last, or both) in any letter case. Will filter out many incorrect name formats (especially numerics and invalid special characters).\nMatch examples:\n- \"T.F. Johnson\"\n- \"John O'Neil\"\n- \"Mary-Kate Johnson\"\nNon-match examples:\n- \"sam_johnson\"\n- \"Joe--Bob Jones\"", "matches": ["T.F. Johnson", "John O'Neil", "Mary-Kate Johnson", "Michael afds", "afds afsd", "fasd adsf", "gfda afsd", "Jerry Bob", "Dwayne wade", "Neymar Junior", "Apple Cat", "Tom Yedder", "Kate Jack"], "non_matches": ["sam_johnson", "Joe--Bob Jones", "dfjsd0rd", "huadsf-dsahfjk", "sfalijad234", "there is a boy--", "/5/5/5", "2546dgwre", "qwerty@123.123", "com.edu.github", "abc111def", "99999@gmail"], "stress_tests": [], "serial": 89, "problematic": [{"example": "huadsf-dsahfjk", "is_match": false}, {"example": "com.edu.github", "is_match": false}]}, {"expression": "^(?:(?:31(\\/|-|\\.)(?:0?[13578]|1[02]))\\1|(?:(?:29|30)(\\/|-|\\.)(?:0?[1,3-9]|1[0-2])\\2))(?:(?:1[6-9]|[2-9]\\d)?\\d{2})$|^(?:29(\\/|-|\\.)0?2\\3(?:(?:(?:1[6-9]|[2-9]\\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00))))$|^(?:0?[1-9]|1\\d|2[0-8])(\\/|-|\\.)(?:(?:0?[1-9])|(?:1[0-2]))\\4(?:(?:1[6-9]|[2-9]\\d)?\\d{2})$", "raw_prompt": "This expression validates dates in the ITALIAN d/m/y format from 1/1/1600 - 31/12/9999. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00 since it could be any century (1900, 2000, 2100). Days and months must be 1 or 2 digits and may have leading zeros. Years must be 2 or 4 digit years. 4 digit years must be between 1600 and 9999. Date separator may be a slash (/), dash (-), or period (.)\nThanks to Michael Ash for US Version", "refined_prompt": "This expression validates dates in the ITALIAN d/m/y format from 1/1/1600 - 31/12/9999. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00 since it could be any century (1900, 2000, 2100). Days and months must be 1 or 2 digits and may have leading zeros. Years must be 2 or 4 digit years. 4 digit years must be between 1600 and 9999. Date separator may be a slash (/), dash (-), or period (.)\nMatch examples:\n- \"29/02/1972\"\n- \"5-9-98\"\n- \"10-11-2002\"\nNon-match examples:\n- \"29/02/2003\"\n- \"12/13/2002\"", "matches": ["29/02/1972", "5-9-98", "10-11-2002", "31/12/79", "29/02/1992", "4-9-98", "31/8/79", "10-4-2003", "20/02/1975", "5-9-99", "16/7/79", "9-11-1999", "29/03/1972"], "non_matches": ["29/02/2003", "12/13/2002", "1-1-1500", "12/123/4322", "234/423/5243", "2/3/5235", "/5/5/5", "/5/5/20022", "432/524/2435", "354/243/542", "9/9/9", "12/132/90"], "stress_tests": [], "serial": 94, "problematic": [{"example": "2/3/5235", "is_match": false}]}, {"expression": "^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?!.*\\s).{4,8}$", "raw_prompt": "Password expresion that requires one lower case letter, one upper case letter, one digit, 6-13 length, and no spaces. This is merely an extension of a previously posted expression by Steven Smith (ssmith@aspalliance.com) . The no spaces is new.", "refined_prompt": "Password expresion that requires one lower case letter, one upper case letter, one digit, 6-13 length, and no spaces.\nMatch examples:\n- \"1agdA*$#\"\n- \"1L,o;J4\"\n- \"2fhLP.\"\nNon-match examples:\n- \"wyrn%@*&amp;$# f\"\n- \"mbndkfh782\"", "matches": ["1agdA*$#", "1L,o;J4", "2fhLP.", "m!K8Kf", "+yXe8Xp", "Z\"|:", "\\Q$5C._", "Xz#l5#T", "v`shru", "_XC7O9Z[", "ASG#G%Df", "^NbR<e\".", "xJjvr2+r"], "non_matches": ["wyrn%@*&amp;$# f", "mbndkfh782", "BNfhjdhfjd&amp;*)%#$)", "sdfggsfdg43fe", "sdfgwg3rwffd", "gsdfgw45gsd$@", "GSFDG GDSF34G", "GSFDGSDFHU989J", "gdkfsojoiOIJGFD ADSF89", "IOFDGJ9ADF9", "IJDOIJ9082390)($*@", ")(*$#)W($DFKJ"], "stress_tests": [], "serial": 100, "problematic": [{"example": "Z\"|:", "is_match": true}, {"example": "\\Q$5C._", "is_match": true}, {"example": "v`shru", "is_match": true}, {"example": "_XC7O9Z[", "is_match": true}, {"example": "ASG#G%Df", "is_match": true}, {"example": "^NbR<e\".", "is_match": true}]}, {"expression": "(^([0-9]|[0-1][0-9]|[2][0-3]):([0-5][0-9])(\\s{0,1})(AM|PM|am|pm|aM|Am|pM|Pm{2,2})$)|(^([0-9]|[1][0-9]|[2][0-3])(\\s{0,1})(AM|PM|am|pm|aM|Am|pM|Pm{2,2})$)", "raw_prompt": "Validate \u201cTime\u201d Data to Work with SQL Server\nThis is a fix (I hope) for a problem with the original expression. It originally allowed any combination of am or pm. For example: ma, aa, mm, mp, etc.", "refined_prompt": "Validate \u201cTime\u201d Data to Work with SQL Server. Validate time input that follows either a 12-hour format with AM/PM or a 24-hour format, allowing for various case combinations of AM and PM indicators, along with an optional space between hours and minutes.\nMatch examples:\n- \"8am\"\n- \"8 am\"\n- \"8:00 am\"\nNon-match examples:\n- \"8a\"\n- \"8 a\"", "matches": ["8am", "8 am", "8:00 am", "07:04Am", "21", "23:03\u2028PM", "21:54pM", "3:40AM", "18:50am", "22:59AM", "23:43 pm", "20:09am", "2:27\u2009pM"], "non_matches": ["8a", "8 a", "8:00 a", "54\u2009Pmm", "1:133AM", "6:104\u200apm", "22:57PM", "90pM", "124pm", "27:55\ufeffAm", "5:67am", "114pm"], "stress_tests": [], "serial": 107, "problematic": [{"example": "21", "is_match": true}, {"example": "22:57PM", "is_match": false}]}, {"expression": "([0-1][0-9]|2[0-3]):[0-5][0-9]", "raw_prompt": "Validate an hour entry to be between 00:00 and 23:59", "refined_prompt": "Validate an hour entry to be between 00:00 and 23:59\nMatch examples:\n- \"00:00\"\n- \"13:59\"\n- \"23:59\"\nNon-match examples:\n- \"24:00\"\n- \"23:60\"", "matches": ["00:00", "13:59", "23:59", "20:05", "13:02", "21:01", "22:41", "23:36", "09:48", "00:14", "02:33", "20:45", "17:50"], "non_matches": ["24:00", "23:60", "05:579", "291:14", "04:592", "34:49", "12:593", "2197", "46:27", "84:45", "280:36", "73:41"], "stress_tests": [], "serial": 110, "problematic": [{"example": "05:579", "is_match": false}, {"example": "04:592", "is_match": false}, {"example": "12:593", "is_match": false}]}, {"expression": "^([1-zA-Z0-1@.\\s]{1,255})$", "raw_prompt": "A general string validation to insure no malicious code is being passed through user input. General enough too allow email address, names, address, passwords, so on. Disallows \u2018,\\*&amp;$&lt;&gt; or other characters that could cause issues.", "refined_prompt": "A general string validation to insure no malicious code is being passed through user input. General enough too allow email address, names, address, passwords, so on. Disallows \u2018,\\*&amp;$&lt;&gt; or other characters that could cause issues. This regular expression matches a string consisting of alphanumeric characters (both uppercase and lowercase letters) along with the characters \"@\" and \".\", as well as spaces, with a length between 1 and 255 characters.\nMatch examples:\n- \"email@email.com\"\n- \"My Name\"\n- \"asdf12df\"\nNon-match examples:\n- \"\u2018,\\*&amp;$&lt;&gt;\"\n- \"1001' string\"", "matches": ["email@email.com", "My Name", "asdf12df", "github.com", "L\ufeff>\u00a0Syd", "=e", "DiX", "fasd", "gfsgs", "o8U", "0bY", "Z\u180e3i1Qf", "LM7"], "non_matches": ["\u2018,\\*&amp;$&lt;&gt;", "1001' string", "AbCdEfGhIjKlMnOpQrStUvWxYzAbCdEfGhIjKlMnOpQrStUvWxYzAbCdEfGhIjKlMnOpQrStUvWxYzfuijksndfhgisjkgfndsokfghodisghoirhtwnekvlnxg", "%&*$(&*%HIOJNK", "*U%IJNK", "%IHOJNKHSDF FDSKJIO*)(", "%^($&*UIHJK EJIWOF", "%&TFGUVH", "%^RFTYGHV HFUIDJSK", "hjfsdnib %GYHUBFDS", "&%^*()IOJKN&^*(", "&^%TYUGHVBN fds"], "stress_tests": [], "serial": 113, "problematic": [{"example": "L\ufeff>\u00a0Syd", "is_match": true}, {"example": "Z\u180e3i1Qf", "is_match": true}, {"example": "AbCdEfGhIjKlMnOpQrStUvWxYzAbCdEfGhIjKlMnOpQrStUvWxYzAbCdEfGhIjKlMnOpQrStUvWxYzfuijksndfhgisjkgfndsokfghodisghoirhtwnekvlnxg", "is_match": false}]}, {"expression": "^(?:(?:(?:(?:(?:1[6-9]|[2-9]\\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00)))(\\/|-|\\.)(?:0?2\\1(?:29)))|(?:(?:(?:1[6-9]|[2-9]\\d)?\\d{2})(\\/|-|\\.)(?:(?:(?:0?[13578]|1[02])\\2(?:31))|(?:(?:0?[1,3-9]|1[0-2])\\2(29|30))|(?:(?:0?[1-9])|(?:1[0-2]))\\2(?:0?[1-9]|1\\d|2[0-8]))))$", "raw_prompt": "This expression validates dates in the y/m/d format from 1600/1/1 - 9999/12/31. Follows the same validation rules for dates as my other date validator (m/d/y format) located in this library.", "refined_prompt": "this regular expression matches dates in the formats YYYY/MM/DD, YYYY-MM-DD, or YYYY.MM.DD, from 1600/1/1 - 9999/12/31, considering leap years and the varying number of days in different months.\nMatch examples:\n- \"04/2/29\"\n- \"2002-4-30\"\n- \"02.10.31\"\nNon-match examples:\n- \"2003/2/29\"\n- \"02.4.31\"", "matches": ["04/2/29", "2002-4-30", "02.10.31", "6000/2/29", "3600/2/29", "6400-2-29", "7366/1031", "1600.2.29", "04.02.29", "3200-02-29", "1640-02-29", "2596.02.29", "6789/01/31"], "non_matches": ["2003/2/29", "02.4.31", "00/00/00", "1702.14132231", "25942146.02.29", "541241-1228", "54421/531", "243/5/5/20022", "432/524/2435", "354/243/542", "9/9/924342", "12/132/90"], "stress_tests": [], "serial": 114, "problematic": [{"example": "7366/1031", "is_match": true}]}, {"expression": "^([a-zA-Z0-9@*#]{8,15})$", "raw_prompt": "Password matching expression. Match all alphanumeric character and predefined wild characters. Password must consists of at least 8 characters and not more than 15 characters.", "refined_prompt": "Password matching expression. Match all alphanumeric character and predefined wild characters \"@\" and \"*,\" and \"#\". Password must consists of at least 8 characters and not more than 15 characters.\nMatch examples:\n- \"@12X*567\"\n- \"1#Zv96g@*Yfasd4\"\n- \"#67jhgt@erd\"\nNon-match examples:\n- \"$12X*567\"\n- \"1#Zv_96\"", "matches": ["@12X*567", "1#Zv96g@*Yfasd4", "#67jhgt@erd", "AMdgo#4fcxvUmLP", "VbFI8gEpE*aRJ", "RFkUPtK6*X", "fz1E5@AOEh@c1", "G2WOY2*Qf1bMMld", "cy3q8Puv", "zstBl3wmFk", "Tg5ipn#R", "EJJ@KAP0bBc5KNh", "tU6Or9dzFI"], "non_matches": ["$12X*567", "1#Zv_96", "+678jhgt@erd", "789", "5143f", "34ehrtuifgjkndvf4398ueijrdfkn", "43vwt98toolonga2rfedw", "$#REDF@#", "@#F@E@#F", "f32%$#", "g8fhuy8uhifsd9ijo", "423"], "stress_tests": [], "serial": 126, "problematic": [{"example": "@#F@E@#F", "is_match": false}]}, {"expression": "^(([0]?[1-9]|[1][0-2])[\\/|\\-|\\.]([0-2]\\d|[3][0-1]|[1-9])[\\/|\\-|\\.]([2][0])?\\d{2}\\s+((([0][0-9]|[1][0-2]|[0-9])[\\:|\\-|\\.]([0-5]\\d)\\s*([aApP][mM])?)|(([0-1][0-9]|[2][0-3]|[0-9])[\\:|\\-|\\.]([0-5]\\d))))$", "raw_prompt": "MM-DD-20YY HH:MM AP\nMM-DD-20YY H:MM AP\nMM-DD-20YY HH:MM\nMM-DD-20YY H:MM\nMM-DD-YY HH:MM AP\nMM-DD-YY H:MM AP\nMM-DD-YY HH:MM\nMM-DD-YY H:MM\nM-D-YY HH:MM AP\nM-D-YY H:MM AP\nM-D-YY HH:MM\nM-D-YY H:MM\nwhere - can be / or - or .\nwhere : can be : or - or .\nDefinition:\n^( ;Start of Line\n([0]?[1-9]|[1][0-2]) ;00-09 or 10-12 or 1-9\n[\\/|\\-|\\.] ;/ or - or .\n([0-2]\\d|[3][0-1]|[1-9]) ;00-29 or 30-31 or 1-9\n[\\/|\\-|\\.] ;/ or - or .\n([2][0])?\\d{2} ;2000-2099 or 00-99\n\\s+ ;one or more spaces\n( ;must be either 12H notation w/AM|PM\n(\n([0][0-9]|[1][0-2]|[0-9])\n[\\:|\\-|\\.] ;: or - or .\n([0-5]\\d) ;01 thru 59\n\\s* ;zero or more spaces\n([aApP][mM])? ;nothing or AM or PM (case insensitive)\n)\n| ;or 24H notation w/out AM|PM\n(\n([0-1][0-9]|[2][0-3]|[0-9]) ;00-19 or 20-23\n[\\:|\\-|\\.] ;: or - or .\n([0-5]\\d) ;00-59\n)\n)\n)$ ;End of Line", "refined_prompt": "MM-DD-20YY HH:MM AP\r\nMM-DD-20YY H:MM AP\r\nMM-DD-20YY HH:MM\r\nMM-DD-20YY H:MM\r\nMM-DD-YY HH:MM AP\r\nMM-DD-YY H:MM AP\r\nMM-DD-YY HH:MM\r\nMM-DD-YY H:MM\r\nM-D-YY HH:MM AP\r\nM-D-YY H:MM AP\r\nM-D-YY HH:MM\r\nM-D-YY H:MM\r\nwhere - can be / or - or .\r\nwhere : can be : or - or .\nMatch examples:\n- \"01/01/2002 04:42\"\n- \"5-12-02 04:42 AM\"\n- \"01.01/02 04-42aM\"\nNon-match examples:\n- \"01-12-1999 4:50PM\"\n- \"01-12-2002 15:10PM\"", "matches": ["01/01/2002 04:42", "5-12-02 04:42 AM", "01.01/02 04-42aM", "01/12/2002 04:42", "5-11-02 04:42 AM", "01.01/02 04-45pM", "08/01/2012 04:14", "5-15-02 04:42 PM", "01.01/03 04-28aM", "07/01/2018 04:19", "5-13-02 14:24 AM", "01.05/02 08-42PM", "03/05/2002 05:43"], "non_matches": ["01-12-1999 4:50PM", "01-12-2002 15:10PM", "01-12-002 8:20PM", "12/123/4322 82:23 AM", "234/423/5243 3:39 PM", "2/3/5235 3:492 AM", "/5/5/5 47:94 PM", "/5/5/20022 47:29 AM", "432/524/2435", "354/243/542", "9/9/9", "12/132/90"], "stress_tests": [], "serial": 142, "problematic": [{"example": "5-13-02 14:24 AM", "is_match": true}]}, {"expression": "^[1-9]{1}$|^[1-4]{1}[0-9]{1}$|^50$", "raw_prompt": "Match any number between 1 and 50, no characters, no empty sets, and not zero. Match numbers greater than 1 and less than 51, no spaces, no characters.", "refined_prompt": "Match any number between 1 and 50, no characters, no empty sets, and not zero. Match numbers greater than 1 and less than 51, no spaces, no characters.\nMatch examples:\n- \"1\"\n- \"23\"\n- \"50\"\nNon-match examples:\n- \"0\"\n- \"111\"", "matches": ["1", "23", "50", "13", "45", "43", "25", "42", "35", "37", "25", "32", "11"], "non_matches": ["0", "111", "xyz", "57", "85", "68", "388", "97", "3573", "9", "9/9/9", "12/132/90"], "stress_tests": [], "serial": 143, "problematic": [{"example": "9", "is_match": false}]}, {"expression": "^([1][12]|[0]?[1-9])[\\/-]([3][01]|[12]\\d|[0]?[1-9])[\\/-](\\d{4}|\\d{2})$", "raw_prompt": "Matches dates with the following format\nMonth - either MM (like 01) or M (like 1) - from 1 to 12\nDay - either DD (like 01) or D ( like 1) - from 1 to 31\nYear - either YYYY ( like 1998) or YY (like 98)\nSeparater - either - or /", "refined_prompt": "Matches dates with the following format\r\nMonth - either MM (like 01) or M (like 1) - from 1 to 12\r\nDay - either DD (like 01) or D ( like 1) - from 1 to 31\r\nYear - either YYYY ( like 1998) or YY (like 98)\r\nSeparater - either - or /\nMatch examples:\n- \"11-02-02\"\n- \"1-25-2002\"\n- \"01/25/2002\"\nNon-match examples:\n- \"13-02-02\"\n- \"11.02.02\"", "matches": ["11-02-02", "1-25-2002", "01/25/2002", "01-30/0740", "02/13-0266", "09/19/42", "12/11/82", "12-31/2164", "11-7/18", "12-4-5369", "11/31/2250", "11/23-08", "12-03/24"], "non_matches": ["13-02-02", "11.02.02", "11/32/2002", "12/123/4322", "2346-2345-2435", "2/3/5235", "/5/5/5", "/5/5/20022", "432/524/2435", "354/243/542", "9/9/9", "12/132/90"], "stress_tests": [], "serial": 145, "problematic": [{"example": "2/3/5235", "is_match": false}]}, {"expression": "^([0]?[1-9]|[1|2][0-9]|[3][0|1])[./-]([0]?[1-9]|[1][0-2])[./-]([0-9]{4}|[0-9]{2})$", "raw_prompt": "Validate brazilian date formats: dd/mm/yyyy or d/m/yy or d.m.yyyy\nwith separators: . - /\nValid dates only! d (1-31)/ m (1-12)/ y (0..)\n(rizzipereira.com.br)\nFor American date format: http://www.regexlib.com/REDetails.aspx?regexp_id=932", "refined_prompt": "This regular expression pattern is used to match Brazilian date formats in the form of day, month, and year, separated by \".\", \"/\", or \"-\":\r\n\r\nIt matches days ranging from 01 to 31 (with or without leading zeros).\r\nIt matches months ranging from 01 to 12 (with or without leading zeros).\r\nIt matches years either in 4-digit format (e.g., 2023) or 2-digit format (e.g., 23).\nMatch examples:\n- \"10/03/1979\"\n- \"1-1-02\"\n- \"01.1.2003\"\nNon-match examples:\n- \"10/03/197\"\n- \"09--02--2004\"", "matches": ["10/03/1979", "1-1-02", "01.1.2003", "30/6-7884", "02.3/12", "4.7-06", "06/12-68", "5-08-98", "03-06/84", "3-10/27", "9/9/22", "31/06-32", "23-10-98"], "non_matches": ["10/03/197", "09--02--2004", "01 02 03", "12/123/4322", "234/423/5243", "2/3/5235", "43-5432", "/5/5/20022", "000-000", "341.431v4f3.fv1", "9/9/9/9", "32542"], "stress_tests": [], "serial": 149, "problematic": [{"example": "2/3/5235", "is_match": false}]}, {"expression": "(^\\d*\\.?\\d*[1-9]+\\d*$)|(^[1-9]+\\d*\\.\\d*$)", "raw_prompt": "Accepts only positive decimal values. Zero and negatvie numbers are non-matching. Allows zeros after last non-zero numeric value after decimal place for significant digits.", "refined_prompt": "Accepts only positive decimal values. Zero and negatvie numbers are non-matching. Allows zeros after last non-zero numeric value after decimal place for significant digits.\nMatch examples:\n- \"0.050\"\n- \"5.0000\"\n- \"5000\"\nNon-match examples:\n- \"0\"\n- \"0.0\"", "matches": ["0.050", "5.0000", "5000", "5765", "756", "6876", "786", "5766", "65", "868", "6565635", "656556", "35"], "non_matches": ["0", "0.0", ".0", "-254", "-498", "-49856.156", "-5612", "561236", "0.0000-56", "000.89456104561", "-651", "-4516"], "stress_tests": [], "serial": 150, "problematic": [{"example": "561236", "is_match": false}, {"example": "000.89456104561", "is_match": false}]}, {"expression": "^([2][0]\\d{2}\\/([0]\\d|[1][0-2])\\/([0-2]\\d|[3][0-1]))$|^([2][0]\\d{2}\\/([0]\\d|[1][0-2])\\/([0-2]\\d|[3][0-1])\\s([0-1]\\d|[2][0-3])\\:[0-5]\\d\\:[0-5]\\d)$", "raw_prompt": "this is a regular expression that for chinese programer!\nyyyy/mm/dd hh:mm:ss", "refined_prompt": "It matches date and time formats in the following patterns:\r\n\r\nDate format: YYYY/MM/DD, where:\r\n\r\nYYYY represents a 4-digit year starting with \"20\".\r\nMM represents a 2-digit month from \"01\" to \"12\".\r\nDD represents a 2-digit day from \"01\" to \"31\".\r\n\r\nDate and time format: YYYY/MM/DD HH:MM:SS, where:\r\n\r\nYYYY, MM, and DD follow the same rules as in the date format.\r\nHH represents a 2-digit hour in 24-hour format from \"00\" to \"23\".\r\nMM represents a 2-digit minute from \"00\" to \"59\".\r\nSS represents a 2-digit second from \"00\" to \"59\".\nMatch examples:\n- \"2002/02/03\"\n- \"2002/02/03 12:12:18\"\n- \"2016/12/30\u202921:08:52\"\nNon-match examples:\n- \"2002/02/36\"\n- \"02/03/2002\"", "matches": ["2002/02/03", "2002/02/03 12:12:18", "2016/12/30\u202921:08:52", "2015/11/31\ufeff 08:11:09", "2006/09/31", "2086/04/21", "2048/01/31", "2033/08/30", "2055/01/31 22:06:08", "2013/10/29\u000b23:33:34", "2026/12/09\u200422:40:51", "2095/01/12\u200820:56:26", "2079/12/24"], "non_matches": ["2002/02/36", "02/03/2002", "2534/52435234/2453", "12/123/4322", "234/423/5243", "2/3/5235", "43-5432", "12f3.21f3.213f", "432/524/2435", "1-1-2", "9/9/9", "12/132/90"], "stress_tests": [], "serial": 152, "problematic": [{"example": "2015/11/31\ufeff 08:11:09", "is_match": true}]}, {"expression": "^[0-9A-Za-z_ ]+(.[jJ][pP][gG]|.[gG][iI][fF])$", "raw_prompt": "Matches HTML image leaf filenames.", "refined_prompt": "Matches strings that start with one or more alphanumeric characters, underscores, or spaces, followed by either \".jpg\" or \".gif\" (case insensitive).\nMatch examples:\n- \"good.gif\"\n- \"go d.GIf\"\n- \"goo_d.jPg\"\nNon-match examples:\n- \"junk\"\n- \"bad.bad.gif\"", "matches": ["good.gif", "go d.GIf", "goo_d.jPg", "huisdfaf.jpg", "adsfyu.jpg", "HIUSDF.JPG", "FSAFA.JPG", "DASF.GIF", "fsdfs.gif", "fsafd.gif", "fsafdsa.gif", "rewcx.gif", "rqwesfd.gif"], "non_matches": ["junk", "bad.bad.gif", "slash\\gif.", "fsda.fasdfasd.gifdsaf", "fsda.gifdsaf", "fdsaijgagif", "fdsafaspnf", "fsdaiojpg", "fadsuihfpjfa", "fhuieuf8hR*(#H@", "fdau98h", "0j0jweBBBB"], "stress_tests": [], "serial": 155, "problematic": [{"example": "fdsaijgagif", "is_match": false}, {"example": "fsdaiojpg", "is_match": false}]}, {"expression": "^[-+]?[1-9]\\d*\\.?[0]*$", "raw_prompt": "This will check if a number is an integer. Positive integers are all the whole numbers greater than zero: 1, 2, 3, 4, 5, ... . Negative integers are all the opposites of whole numbers: -1, -2, -3,-4, -5, ... . Zero is not a whole number with either a positive or negative value, and is not an interger. Null or Empty values are not intergers.", "refined_prompt": "The regular expression ^[-+]?[1-9]\\d*\\.?[0]*$ can match numbers with the following characteristics:\r\nOptional sign at the beginning ([-+]?): It may start with an optional plus or minus sign.\r\nAt least one non-zero digit ([1-9]): There must be at least one non-zero digit in the number.\r\nZero or more digits following the first digit (\\d*): After the first non-zero digit, it can have zero or more additional digits.\r\nAn optional decimal point (\\.?): It may have an optional decimal point.\r\nZero or more trailing zeros ([0]*): After the decimal point (if present), it can have zero or more trailing zeros.\r\nHowever, this regular expression will not match the following cases:\r\nThe number 0 because it requires at least one non-zero digit.\r\nNegative numbers like -10.50 because it disallows leading zeros (e.g., -01.50) and requires at least one non-zero digit before the decimal point.\r\nNumbers with only trailing zeros like 10.50 because it requires at least one non-zero digit before the decimal point.\nMatch examples:\n- \"10\"\n- \"-10\"\n- \"+10.00\"\nNon-match examples:\n- \"0\"\n- \"-10.50\"", "matches": ["10", "-10", "+10.00", "8945", "489", "4896", "45", "45", "9456", "4893", "-854", "-489", "-89"], "non_matches": ["0", "-10.50", "10.50", "04856.45", "456.845", "-01.50", "+0", "-0", "000", "00000", "+000.0000", "+10.00"], "stress_tests": [], "serial": 161, "problematic": [{"example": "+10.00", "is_match": false}]}, {"expression": "((^(10|12|0?[13578])([/])(3[01]|[12][0-9]|0?[1-9])([/])((1[8-9]\\d{2})|([2-9]\\d{3}))$)|(^(11|0?[469])([/])(30|[12][0-9]|0?[1-9])([/])((1[8-9]\\d{2})|([2-9]\\d{3}))$)|(^(0?2)([/])(2[0-8]|1[0-9]|0?[1-9])([/])((1[8-9]\\d{2})|([2-9]\\d{3}))$)|(^(0?2)([/])(29)([/])([2468][048]00)$)|(^(0?2)([/])(29)([/])([3579][26]00)$)|(^(0?2)([/])(29)([/])([1][89][0][48])$)|(^(0?2)([/])(29)([/])([2-9][0-9][0][48])$)|(^(0?2)([/])(29)([/])([1][89][2468][048])$)|(^(0?2)([/])(29)([/])([2-9][0-9][2468][048])$)|(^(0?2)([/])(29)([/])([1][89][13579][26])$)|(^(0?2)([/])(29)([/])([2-9][0-9][13579][26])$))", "raw_prompt": "This Validator Validates any date from 1800 - 9999. It takes special care of Leap years and validates any format of type mm/dd/yyyy , m/dd/yyyy , mm/d/yyyy , m/d/yyyy.\nSince SQL Server does not accept any date before 1/1/1753, so i hope it will meet Your Requirements.(Modified Version of Jason West's Date Validator.)", "refined_prompt": "This Validator Validates any date from 1800 - 9999. It takes special care of Leap years and validates any format of type mm/dd/yyyy , m/dd/yyyy , mm/d/yyyy , m/d/yyyy.\nMatch examples:\n- \"2/2/2000\"\n- \"02/02/2000\"\n- \"02/2/2000\"\nNon-match examples:\n- \"2.2.2000\"\n- \"2-2-2000\"", "matches": ["2/2/2000", "02/02/2000", "02/2/2000", "02/29/1808", "2/29/7600", "02/19/5338", "11/06/6241", "02/29/2452", "12/30/1909", "02/4/1824", "10/08/2134", "12/31/8015", "2/03/1914"], "non_matches": ["2.2.2000", "2-2-2000", "2534/52435234/2453", "12/123/4322", "234/423/5243", "2/3/5235", "/5/5/5", "/5/5/20022", "432/524/2435", "354/243/542", "9/9/9", "12/132/90"], "stress_tests": [], "serial": 168, "problematic": [{"example": "2/3/5235", "is_match": false}]}, {"expression": "^\\d* \\d*\\/{1}\\d*$|^\\d*$", "raw_prompt": "This expression is used to validate fractions (entered as strings). It will also accept non-fractional entries. Simple, but effective.", "refined_prompt": "This expression is used to validate fractions (entered as strings). It will also accept non-fractional entries.\nMatch examples:\n- \"100\"\n- \"1 1/2\"\n- \"1232 5/8\"\nNon-match examples:\n- \"a 1/2\"\n- \"abc\"", "matches": ["100", "1 1/2", "1232 5/8", "156 1/5", "915 8/9", "8891", "895", "165", "489", "156", "1894 3/8", "489", "8/7"], "non_matches": ["a 1/2", "abc", "a b/c", "12/123/4322", "2346-2345-2435", "2/3/5235", "/5/5/5", "/5/5/20022", "245/524/12", "354/243/542", "9/9/9", "32542 //"], "stress_tests": [], "serial": 169, "problematic": [{"example": "8/7", "is_match": true}]}, {"expression": "^(\\{|\\[|\\().+(\\}|\\]|\\)).+$", "raw_prompt": "Matches &quot;clan&quot; nicks/names.", "refined_prompt": "In summary, this regular expression is used to match strings that start with an opening brace, bracket, or parenthesis and end with the corresponding closing symbol, with any characters in between. It can be used to extract or identify structured data enclosed within these symbols, such as JSON objects or array representations.\nMatch examples:\n- \"{CLaN}nick\"\n- \"[Clan]Nick\"\n- \"(Clan)Nick\"\nNon-match examples:\n- \"Nick\"\n- \"dsaf\"", "matches": ["{CLaN}nick", "[Clan]Nick", "(Clan)Nick", "{fsdfds}", "[fsdfwe]", "(fsdoifjds)fds", "{fdsfsd}fsdfnjojw", "[sdfsdfjin]fsdn", "(fsdjni)", "[fsddno]dsfjn", "(fsdjoifsd)sfd", "{fsdinjfsd}", "(fdsnijn)nfijsd"], "non_matches": ["Nick", "dsaf", "34f2vf42e", "fasd@fds.fasd@", "sfalijad234", "3nf@", "@#dfkjnav", "(fhudsijfns", "[fsiundjkn fdsji", "{ifdjsfnsido", "09iojkjokl)OL", "}LSDFK"], "stress_tests": [], "serial": 174, "problematic": [{"example": "{fsdfds}", "is_match": true}, {"example": "[fsdfwe]", "is_match": true}, {"example": "(fsdjni)", "is_match": true}, {"example": "{fsdinjfsd}", "is_match": true}]}, {"expression": "^(([\\w][\\w\\-\\.]*)\\.)?([\\w][\\w\\-]+)(\\.([\\w][\\w\\.]*))?$", "raw_prompt": "Is used to evaluating domain names, none of the extras such as paths or protocols.", "refined_prompt": "Is used to evaluating domain names, none of the extras such as paths or protocols.\nMatch examples:\n- \"zigamorph.com\"\n- \"www.zigamorph.com\"\n- \"localhost\"\nNon-match examples:\n- \"http://www.zigamorph.com\"\n- \"ftp://zigamorph.com\"", "matches": ["zigamorph.com", "www.zigamorph.com", "localhost", "www.baidu.com", "www.google.com", "www.apple.com", "msft.com", "abc.com", "adf.com", "fdgsdd.com", "eriwfjd.com", "ms.com", "avpl.com"], "non_matches": ["http://www.zigamorph.com", "ftp://zigamorph.com", "localhost/default.aspx", "fasd@fds.fasd@", "234/423/5243", "3nf@", "@#dfkjnav", "2546dgwre", "u09nKLJG FSL", "com.edu.github", "afsdfa", "99999@gmail"], "stress_tests": [], "serial": 175, "problematic": [{"example": "2546dgwre", "is_match": false}, {"example": "com.edu.github", "is_match": false}, {"example": "afsdfa", "is_match": false}]}, {"expression": "^([a-zA-Z0-9!@#$%^&amp;*()-_=+;:'&quot;|~`&lt;&gt;?/{}]{1,5})$", "raw_prompt": "This Regular expression validates a string that contains all printable characters with a minimum length of 1 and maximum length of 5.\nObviously the min and max can be changed to meet the users needs.\n^([a-zA-Z0-9!@#$%^&amp;*()-_=+;:'&quot;|~`&lt;&gt;?/{}]{1,5})$ This is the string, I keep getting &amp;amp;lt and other characters when I save it.", "refined_prompt": "This Regular expression validates a string that contains all printable characters with a minimum length of 1 and maximum length of 5.\nMatch examples:\n- \"ilove\"\n- \"$%*!_\"\n- \"it\"\nNon-match examples:\n- \"123456\"\n- \"This is great\"", "matches": ["ilove", "$%*!_", "it", "gfa", "afgd", "t45g", "g4", "$GF", "(*HIU", "(*IJ", "(JI", "9IJO", "&*)"], "non_matches": ["123456", "This is great", "1", "fsdgjioknsfdg", "this is long long", "jiofdsaj9dis", "(*HUIJNK8uhi", "(*HUI89hi", "(*IJNK", "9IJNKIFSD", "9ijoknIOFJDS", "IJOKLdsfasdf"], "stress_tests": [], "serial": 177, "problematic": [{"example": "1", "is_match": false}]}, {"expression": "^(?:(?:(?:0?[1-9]|1\\d|2[0-8])\\/(?:0?[1-9]|1[0-2]))\\/(?:(?:1[6-9]|[2-9]\\d)\\d{2}))$|^(?:(?:(?:31\\/0?[13578]|1[02])|(?:(?:29|30)\\/(?:0?[1,3-9]|1[0-2])))\\/(?:(?:1[6-9]|[2-9]\\d)\\d{2}))$|^(?:29\\/0?2\\/(?:(?:(?:1[6-9]|[2-9]\\d)(?:0[48]|[2468][048]|[13579][26]))))$", "raw_prompt": "This expression validates dates in the Brazilian d/m/y format from 1/1/1600 - 12/31/9999. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999. Days and months must be 1 or 2 digits and may have leading zeros. Years must be 4 digit years, between 1600 and 9999. Date separator must be a slash (/)", "refined_prompt": "This expression validates dates in the Brazilian d/m/y format from 1/1/1600 - 12/31/9999. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999. Days and months must be 1 or 2 digits and may have leading zeros. Years must be 4 digit years, between 1600 and 9999. Date separator must be a slash (/)\nMatch examples:\n- \"29/02/2004\"\n- \"15/3/1824\"\n- \"31/01/2001\"\nNon-match examples:\n- \"29/02/2000\"\n- \"21/10/92\"", "matches": ["29/02/2004", "15/3/1824", "31/01/2001", "29/02/3596", "16/12/2648", "29/02/1904", "24/12/5227", "24/12/5227", "29/10/1811", "31/01/8918", "29/02/9704", "11/11/1929", "21/12/9748"], "non_matches": ["29/02/2000", "21/10/92", "31/02/2001", "12/123/4322", "234/423/5243", "2/3/5235", "/5/5/5", "/5/5/20022", "432/524/2435", "354/243/542", "9/9/9", "12/132/90"], "stress_tests": [], "serial": 180, "problematic": [{"example": "2/3/5235", "is_match": false}]}, {"expression": "^((((0?[1-9]|[12]\\d|3[01])[\\.\\-\\/](0?[13578]|1[02])[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}))|((0?[1-9]|[12]\\d|30)[\\.\\-\\/](0?[13456789]|1[012])[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}))|((0?[1-9]|1\\d|2[0-8])[\\.\\-\\/]0?2[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}))|(29[\\.\\-\\/]0?2[\\.\\-\\/]((1[6-9]|[2-9]\\d)?(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)|00)))|(((0[1-9]|[12]\\d|3[01])(0[13578]|1[02])((1[6-9]|[2-9]\\d)?\\d{2}))|((0[1-9]|[12]\\d|30)(0[13456789]|1[012])((1[6-9]|[2-9]\\d)?\\d{2}))|((0[1-9]|1\\d|2[0-8])02((1[6-9]|[2-9]\\d)?\\d{2}))|(2902((1[6-9]|[2-9]\\d)?(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)|00))))$", "raw_prompt": "Date with leap years. Accepts '.' '-' and '/' as separators\nd.m.yy to dd.mm.yyyy (or d.mm.yy, etc)\nEx: dd-mm-yyyy d.mm/yy dd/m.yyyy etc etc\nAccept 00 years also.", "refined_prompt": "Date with leap years. Accepts '.' '-' and '/' as separators\r\nd.m.yy to dd.mm.yyyy (or d.mm.yy, etc)\r\nEx: dd-mm-yyyy d.mm/yy dd/m.yyyy etc etc\r\nAccept 00 years also.\nMatch examples:\n- \"29.2.2004\"\n- \"31121975\"\n- \"29/2-00\"\nNon-match examples:\n- \"29.2.2005\"\n- \"32121975\"", "matches": ["29.2.2004", "31121975", "29/2-00", "14/07/32", "01031630", "170347", "25051851", "300392", "01129891", "30074486", "7/11-78", "30-10/1827", "11018738"], "non_matches": ["29.2.2005", "32121975", "29.2/01", "12/123/4322", "234/423/5243", "2/3/5235", "43-5432", "/5/5/20022", "432/524/2435", "354/243/542", "9/9/9", "12/132/90"], "stress_tests": [], "serial": 183, "problematic": [{"example": "2/3/5235", "is_match": false}]}, {"expression": "^(\\d{5}((|-)-\\d{4})?)|([A-Za-z]\\d[A-Za-z][\\s\\.\\-]?(|-)\\d[A-Za-z]\\d)|[A-Za-z]{1,2}\\d{1,2}[A-Za-z]? \\d[A-Za-z]{2}$", "raw_prompt": "Allows Canadian, American and UK postal/zip codes. Allowing hyphens, periods, or spaces to separate.", "refined_prompt": "Allows Canadian, American and UK postal/zip codes. Allowing hyphens, periods, or spaces to separate.\nMatch examples:\n- \"N9B.1Y8\"\n- \"90210-1234\"\n- \"NE21 6EQ\"\nNon-match examples:\n- \"NN8 Y83\"\n- \"f34fvfv\"", "matches": ["N9B.1Y8", "90210-1234", "NE21 6EQ", "j7U\u20083F7", "S0g\u202f9W2", "RS5W 7tr", "r9 1Dd", "P3D-6U1", "nw22O 0Vy", "Km0 3fg", "N83 2hh", "gZ30D 6xj", "r1i\u20053q5"], "non_matches": ["NN8 Y83", "f34fvfv", "34f2vf42e", "Mastercard", "sfalijad234", "43.v234", "43-5432", "2546dgwre", "000-000", "(0xx12) 7256 2345154", "abc111def", "99999@gmail"], "stress_tests": [], "serial": 197, "problematic": [{"example": "99999@gmail", "is_match": false}]}, {"expression": "(.*\\.([wW][mM][aA])|([mM][pP][3])$)", "raw_prompt": "Matches a file name to be either a .wma or .mp3 file. This can be used to check file uploads to make sure they are of a certain type. Substitute letters where appropriate for specific file types. To include more simply add logical 'or' (|) operator and append.", "refined_prompt": "Matches a file name to be either a .wma or .mp3 file.\nMatch examples:\n- \"thisfile.mp3\"\n- \"tH@tfile.wma\"\n- \"dfsa.mp3\"\nNon-match examples:\n- \"whatever.exe\"\n- \"somethingelse.mpa\"", "matches": ["thisfile.mp3", "tH@tfile.wma", "dfsa.mp3", "d.wma", "dsfa.mp3", "fdjsig.mp3", "fsda.mp3", "duioewr.mp3", "wer.mp3", "fdm.mp3", "fdsf.mp3", "fdsiow.mp3", "fsd.wma"], "non_matches": ["whatever.exe", "somethingelse.mpa", "thisagain.wm3", "fsudhi.fsd", "fdso.fdsi", ".mfdsuijfesmp3", "wmafsadijfmp3", "jfidsj.tewmp3", "fjdos.jaiofdaso", "com.edu.github", "sda sad", "3409fjg43"], "stress_tests": [], "serial": 198, "problematic": [{"example": ".mfdsuijfesmp3", "is_match": false}, {"example": "wmafsadijfmp3", "is_match": false}, {"example": "jfidsj.tewmp3", "is_match": false}]}, {"expression": "(^(\\+?\\-? *[0-9]+)([,0-9 ]*)([0-9 ])*$)|(^ *$)", "raw_prompt": "This is my basic phone number verification. it allows a + - , signs digits, spaces and blank entry", "refined_prompt": "Basic phone number verification. Designed to match numbers with optional positive or negative signs at the beginning, followed by digits, commas, and spaces.\nMatch examples:\n- \"+0335456 545 545\"\n- \"-5465 545\"\n- \"5456465 5454,545\"\nNon-match examples:\n- \"fsd54df 54\"\n- \"f34f43f3\"", "matches": ["+0335456 545 545", "-5465 545", "5456465 5454,545", "+4895", "-845", "+562", "8945612", "84562", "845129865", "89456", "9456", "+4895612", "6123-5612"], "non_matches": ["fsd54df 54", "f34f43f3", "f342f48", "48951d", "4d", "984d897sds984", "48$#@", "s4ds98sd", "4sd849s4d", "fds8", "498", "4895667**--"], "stress_tests": [], "serial": 200, "problematic": [{"example": "6123-5612", "is_match": true}, {"example": "498", "is_match": false}]}, {"expression": "&quot;([^&quot;](?:\\\\.|[^\\\\&quot;]*)*)&quot;", "raw_prompt": "Matches C style strings allowing for escaped string delimiters to be included in the match.\nALTERED 13-Dec-2003\n-------------------\nPrevious pattern was :\n&quot;([^&quot;](?:\\\\.|[^\\\\&quot;]*)*)&quot;\nChanged to:\n&quot;([^&quot;]*(?:\\\\.|[^\\\\&quot;]*)*)&quot;\nMaking the first character after the opening quote optional allows the pattern to match on empty quotes: &quot;&quot;.", "refined_prompt": "Matches C style strings allowing for escaped string delimiters to be included in the match.\nMatch examples:\n- \"&quot;This is a \\&quot;string\\&quot;.&quot;\"\n- \"&quot;asdfhj&quot;\"\n- \"&quot;sdaf dsa f&quot;\"\nNon-match examples:\n- \"&quot;This is a \\&quot;string\\&quot;.\"\n- \"E:\\DyAGT\\SD01A_specV2.jpg\"", "matches": ["&quot;This is a \\&quot;string\\&quot;.&quot;", "&quot;asdfhj&quot;", "&quot;sdaf dsa f&quot;", "&quot;r23fd dffd&quot;", "&quot;f d2 fd2df&quot;", "&quot; fd22fs &quot;", "&quot;sdf sdf2dfdf&quot;", "&quot;f d2dfdf2er67i&quot;", "&quot; i676iu &quot;", "&quot; i67i 6ui6&quot;", "&quot; 76iu iu i&quot;", "&quot; 5u6 56 56u&quot;", "&quot;uijolkijok &quot;"], "non_matches": ["&quot;This is a \\&quot;string\\&quot;.", "E:\\DyAGT\\SD01A_specV2.jpg", "34f2vf42e", "fasd@fds.fasd@", "2346-2345-2435", "2/3/5235", "@#dfkjnav", "12f3.21f3.213f", "432/524/2435", "1-1-2", "(0xx12) 62509", "0j0jweBBBB"], "stress_tests": [], "serial": 202, "problematic": [{"example": "&quot; i676iu &quot;", "is_match": true}, {"example": "&quot; i67i 6ui6&quot;", "is_match": true}, {"example": "&quot; 76iu iu i&quot;", "is_match": true}, {"example": "&quot; 5u6 56 56u&quot;", "is_match": true}, {"example": "&quot;uijolkijok &quot;", "is_match": true}]}, {"expression": "(\\w[-._\\w]*\\w@\\w[-._\\w]*\\w\\.\\w{2,3})", "raw_prompt": "This is my all-time favourite e-mail validator. I've used it for years and it's never failed me :-)", "refined_prompt": "Match an email address pattern consisting of a series of word characters, hyphens, periods, and underscores (before and after the \"@\" symbol) followed by a domain name with a top-level domain extension containing 2 to 3 characters. This regex pattern is commonly used for email address validation.\nMatch examples:\n- \"foo@bar.com\"\n- \"foobar@foobar.com.au\"\n- \"zhang@qq.com\"\nNon-match examples:\n- \"foo@bar\"\n- \"$$$@bar.com\"", "matches": ["foo@bar.com", "foobar@foobar.com.au", "zhang@qq.com", "fsioj@nd.edu", "ijo90@nd.edu", "jiokldsf9@nd.edu", "ijkonlf8@nd.edu", "njksf98@nd.edu", "iujknsdf12@nd.edu", "jiofdksl@nd.edu", "jklfsd01@nd.edu", "ojioqji@qq.com", "ajfdsa@qq.com"], "non_matches": ["foo@bar", "$$$@bar.com", "wfe23@FEDDS", "fasd@fds.fasd@", "FDS@EFDS", "FDSfds@FD", "fwef2", "F@#D", "f@#DSFS", "fdsf2f3", "sdfsd@#FSD.comd", "fsdf@EWEFSD"], "stress_tests": [], "serial": 203, "problematic": [{"example": "fasd@fds.fasd@", "is_match": false}]}, {"expression": "^[^#]([^ ]+ ){6}[^ ]+$", "raw_prompt": "We've come across the situation where we had to extract the IIS-Log entries without the header information. The data is far more complex than the sample given.\nExplanation:\n^[^#] = lines not beginnin with #\n([^ ]+ ){6} = 6 times no space until one space\n[^ ]+ = no spaces allowed...\n$ = ...until end of line\nFor further explanation don't hesitate to write E-Mail.", "refined_prompt": "Match strings that contain exactly 6 words separated by spaces and do not start with a \"#\" character. This regex pattern ensures that the string has a specific structure: it starts with any character other than \"#\" followed by six groups of one or more non-space words separated by spaces, and it ends with a non-space word.\nMatch examples:\n- \"1111 2222 33 44444 55 6 7777\"\n- \"a b c d e f g\"\n- \"jisa asdf af ew yq qrt cv\"\nNon-match examples:\n- \"#IIS Logfile header\"\n- \"#R\"", "matches": ["1111 2222 33 44444 55 6 7777", "a b c d e f g", "jisa asdf af ew yq qrt cv", "we ji afd ads ga af aefa", "jio ijo afo fd wer afd fds", "ois fji jfi qwe af sdaf afd", "q w e r t y u", "1 2 3 4 5 6 7", "qwer 11er 1er 3t re2 r32 23r", "23r r23 t34 y54y u5 t4 r2", "j9 j98 h7 fr fw fwe gre", "ji9 j98 g87 j09 0k few g3e", "j9 j09 fef f3 t43 2r3 t54"], "non_matches": ["#IIS Logfile header", "#R", "fad adsf", "12/123/4322", "sfalijad234", "hiohi", "43-5432", "h hoih iohioh iohiojoi ioj ijo", "90 09jioui 89ji hihio7 9h8", "89jiohioj oigituf ftyf yt huih ijo", "h98ui 9hui #JIOJ", "#jkojfs"], "stress_tests": [], "serial": 205, "problematic": [{"example": "a b c d e f g", "is_match": true}, {"example": "q w e r t y u", "is_match": true}, {"example": "1 2 3 4 5 6 7", "is_match": true}]}, {"expression": "^((((((0?[13578])|(1[02]))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\\-\\/\\s]?((0?[1-9])|([1-2][0-9]))))[\\-\\/\\s]?\\d{2}(([02468][048])|([13579][26])))|(((((0?[13578])|(1[02]))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\\-\\/\\s]?((0?[1-9])|(1[0-9])|(2[0-8]))))[\\-\\/\\s]?\\d{2}(([02468][1235679])|([13579][01345789]))))(\\s(((0?[1-9])|(1[0-2]))\\:([0-5][0-9])((\\s)|(\\:([0-5][0-9])\\s))([AM|PM|am|pm]{2,2})))?$", "raw_prompt": "This regex will match SQL Server datetime values, allowing date only, allowing zero padded digits in month, day and hour, and will match leap years from 1901 up until 2099.", "refined_prompt": "This regex will match SQL Server datetime values, allowing date only, allowing zero padded digits in month, day and hour, and will match leap years from 1901 up until 2099.\nMatch examples:\n- \"2/29/2004\"\n- \"04/01/2003 10:01:23 am\"\n- \"03-20-1999\"\nNon-match examples:\n- \"2/29/2003\"\n- \"13/30/2001 10:05:00 pm\"", "matches": ["2/29/2004", "04/01/2003 10:01:23 am", "03-20-1999", "2/29/2004", "2/14/2004", "4/16/2004", "04/16/2003 10:01:23 am", "04/01/2007 10:01:23 am", "12/01/2003 10:01:23 am", "04/01/2003 10:01:47 am", "03-20-2005", "03-16-1999", "11-20-1999"], "non_matches": ["2/29/2003", "13/30/2001 10:05:00 pm", "12/32/2003", "12/123/4322", "234/423/5243", "2/3/5235", "/5/5/5", "/5/5/20022", "432/524/2435", "354/243/542", "9/9/9", "12/132/90"], "stress_tests": [], "serial": 216, "problematic": [{"example": "2/3/5235", "is_match": false}]}, {"expression": "[0-9A-Fa-f]{2}(\\.?)[0-9A-Fa-f]{2}(\\.?)[0-9A-Fa-f]{2}(\\.?)[0-9A-Fa-f]{2}", "raw_prompt": "matches IP address in hex form in dotted or not dotted notation", "refined_prompt": "matches IP address in hex form in dotted or not dotted notation\nMatch examples:\n- \"c0.a8.01.64\"\n- \"0A0275C4\"\n- \"aC.10.1F.b1\"\nNon-match examples:\n- \"192.168.1.1\"\n- \"10.2.177.4\"", "matches": ["c0.a8.01.64", "0A0275C4", "aC.10.1F.b1", "C1.C7aa.fC", "A989.6fa7", "6fEA.AF.90", "f0.9145a0", "B333754C", "c1.0CEf.32", "91ad.8d2f", "91dFeD.dA", "05A5.bf90", "6f5CFfE6"], "non_matches": ["192.168.1.1", "10.2.177.4", "ah.10.1f.20", "12/123/4322", "2346-2345-2435", "$23.454", "43-5432", "12f3.21f3.213f", "245/524/12", "341.431v4f3.fv1", "423.525.15", "23.425.23432.43"], "stress_tests": [], "serial": 217, "problematic": [{"example": "12f3.21f3.213f", "is_match": false}]}, {"expression": "[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}", "raw_prompt": "Very Simple Match for dotted Decimal IP address. Doesn\u2019t Validate addresses", "refined_prompt": "Very Simple Match for dotted Decimal IP address. Doesn\u2019t Validate addresses\nMatch examples:\n- \"192.168.1.1\"\n- \"10.2.234.1\"\n- \"66.129.71.122\"\nNon-match examples:\n- \"192.168.1\"\n- \"10.2.1234.1\"", "matches": ["192.168.1.1", "10.2.234.1", "66.129.71.122", "481.825.8.0", "7.973.8.62", "22.14.3.79", "709.35.771.888", "87.94.7.253", "6.714.2.767", "34.3.64.9", "580.651.1.1", "75.888.65.21", "9.8.33.77"], "non_matches": ["192.168.1", "10.2.1234.1", "66 129 71 122", "234.423.42.423", ".423.24.234.", "423..52.34.65.4.", "534.7.457.5567.", ".654.756.8.34", "3673.4.63234", "654.2.7.", "645.23.6", "65.464.5364.52"], "stress_tests": [], "serial": 218, "problematic": [{"example": "234.423.42.423", "is_match": false}, {"example": "423..52.34.65.4.", "is_match": false}, {"example": "534.7.457.5567.", "is_match": false}, {"example": ".654.756.8.34", "is_match": false}]}, {"expression": "(.)\\1{2,}", "raw_prompt": "matches any string with characters repeated more than twice, sometimes used as fake input", "refined_prompt": "It matches a sequence of three or more consecutive identical characters (i.e., characters that repeat two or more times in a row) within a string.\nMatch examples:\n- \"aaaeee\"\n- \"????????\"\n- \"gooogle\"\nNon-match examples:\n- \"google\"\n- \"booboo\"", "matches": ["aaaeee", "????????", "gooogle", "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<", "fff", "jjj", "ooosdufoh", "hhhfidsoh", "(((fudsih", ")))hfosdhio", "sfksdjfkdsdsss", "iuhuhuhuhhh", "uuuuuu"], "non_matches": ["google", "booboo", "uufosdiajhio", "jjouaduof", "oofdshuihof", "hiufdghiuhuu", "fjsiojhofisdhhhsfidoh", "uifdshuhuhhuhsiuf", "uu", "ii", "pp", "ttsfohuhoi"], "stress_tests": [], "serial": 260, "problematic": [{"example": "fjsiojhofisdhhhsfidoh", "is_match": false}]}, {"expression": "^p(ost)?[ |\\.]*o(ffice)?[ |\\.]*(box)?[ 0-9]*[^[a-z ]]*", "raw_prompt": "This expression is useful for determining if an address is a PO Box type address. This can be useful in shipping systems as well as other systems that need to make determinations based on the type of address imputed.", "refined_prompt": "It matches strings that may start with \"p\" or \"post,\" followed by optional spaces or periods, then \"o\" or \"office,\" followed by optional spaces or periods, then \"box,\" followed by optional digits, and finally, it matches any characters that are not lowercase letters or spaces.\r\n\r\nThis pattern is designed to match various forms of expressions related to post office boxes while allowing for variations in spacing and abbreviation.\nMatch examples:\n- \"po box 4353\"\n- \"P.O. Box\"\n- \"PO Box\"\nNon-match examples:\n- \"pollo St.\"\n- \"P. O. Box d3f12s\"", "matches": ["po box 4353", "P.O. Box", "PO Box", "P Office Box", "Post Office Box", "P. Office Box", "P. O. Box 12345", "PO Box 567", "P Office Box 7890", "Post Office Box 4567", "P. O. Box 12345", "P.O. Box 7", "PO Box 45678"], "non_matches": ["pollo St.", "P. O. Box d3f12s", "BOX 23", "Parcel Box", "POBox123", "P.O. Box#567", "Post 123 Office Box", "Box12345", "P.O. Box 12345A", "POBox7", "P OfficeBox", "P.O. Box 12345, City"], "stress_tests": [], "serial": 261, "problematic": [{"example": "P.O. Box", "is_match": true}, {"example": "PO Box", "is_match": true}, {"example": "P Office Box", "is_match": true}, {"example": "Post Office Box", "is_match": true}, {"example": "P. Office Box", "is_match": true}, {"example": "P. O. Box 12345", "is_match": true}, {"example": "PO Box 567", "is_match": true}, {"example": "P Office Box 7890", "is_match": true}, {"example": "Post Office Box 4567", "is_match": true}, {"example": "P. O. Box 12345", "is_match": true}, {"example": "P.O. Box 7", "is_match": true}, {"example": "PO Box 45678", "is_match": true}]}, {"expression": "^\\d+\\x20*([pP][xXtT])?$", "raw_prompt": "It can be used to validate Font Sizes.\nThanks to Gideon Engelberth for the shorter version of my original expression.", "refined_prompt": "It can be used to validate Font Sizes.\nMatch examples:\n- \"1px\"\n- \"100 PT\"\n- \"20Px\"\nNon-match examples:\n- \"1abc\"\n- \"px\"", "matches": ["1px", "100 PT", "20Px", "123", "456 PXT", "789pxt", "42 PXT", "100 PXT", "007pxt", "12345PXT", "999", "1 PXT", "555pxT"], "non_matches": ["1abc", "px", "1 sdfs", "ABC", "12.34", "PXT", "pxt123", "1PXT", "PXT456", "1pxt2", "12 pxt 34", "12pxtxyz"], "stress_tests": [], "serial": 262, "problematic": [{"example": "456 PXT", "is_match": true}, {"example": "789pxt", "is_match": true}, {"example": "42 PXT", "is_match": true}, {"example": "100 PXT", "is_match": true}, {"example": "007pxt", "is_match": true}, {"example": "12345PXT", "is_match": true}, {"example": "1 PXT", "is_match": true}, {"example": "555pxT", "is_match": true}]}, {"expression": "ISBN\\x20(?=.{13}$)\\d{1,5}([- ])\\d{1,7}\\1\\d{1,6}\\1(\\d|X)$", "raw_prompt": "This RE validates the format of an ISBN number", "refined_prompt": "match strings that potentially represent ISBN (International Standard Book Number) codes with specific formatting.\nMatch examples:\n- \"ISBN 0 93028 923 4\"\n- \"ISBN 1-56389-668-0\"\n- \"ISBN 1-56389-016-X\"\nNon-match examples:\n- \"123456789X\"\n- \"ISBN 9-87654321-2\"", "matches": ["ISBN 0 93028 923 4", "ISBN 1-56389-668-0", "ISBN 1-56389-016-X", "ISBN 123-456-789-0", "ISBN 1-234567-89-X", "ISBN 1234-56789-0", "ISBN 12-34567-890", "ISBN 12345-6-789-0", "ISBN 12345 6789 0", "ISBN 123456789-X", "ISBN 1234567890", "ISBN 1-23456-789-0", "ISBN 1-234567890"], "non_matches": ["123456789X", "ISBN 9-87654321-2", "ISBN 123 456-789X", "ISBN 1234-56789", "ISBN 12345-67890", "ISBN 12345 67890", "ISBN 123-45-678-90", "ISBN 123-45-678-9X", "ISBN 123-45-678-9x", "ISBN 123-45-678-9", "ISBN 123-45-678-90-", "ISBN 12345678-90"], "stress_tests": [], "serial": 263, "problematic": [{"example": "ISBN 1234-56789-0", "is_match": true}, {"example": "ISBN 12-34567-890", "is_match": true}, {"example": "ISBN 12345 6789 0", "is_match": true}, {"example": "ISBN 123456789-X", "is_match": true}, {"example": "ISBN 1234567890", "is_match": true}, {"example": "ISBN 1-234567890", "is_match": true}]}, {"expression": "<([^\\s>]*)(\\s[^<]*)>", "raw_prompt": "grab all tags attributes...\n&lt;img src=&quot;truc&quot;&gt; returns :\n&lt;\n(1:img)\n(2: src=&quot;truc&quot;)\n&gt;\ni use it to clean html pages to grab infos...\nuse a RegEx Replace with &quot;&lt;$1&gt;&quot; to keep only tags codes...", "refined_prompt": "Match HTML-like tags in a text.\nMatch examples:\n- \"<img src=\"truc\">\"\n- \"<body background='...'>\"\n- \"<p align='left'>\"\nNon-match examples:\n- \"<br>\"\n- \"</body>\"", "matches": ["<img src=\"truc\">", "<body background='...'>", "<p align='left'>", "<div>", "<a href=\"https://example.com\">", "<p class=\"paragraph\">", "<img src=\"image.jpg\" alt=\"Image\">", "<h1 id=\"header\">", "<ul>", "<li>", "<span style=\"color:red;\">", "<table cellpadding=\"5\" cellspacing=\"0\">", "<input type=\"text\" name=\"username\" value=\"John\">"], "non_matches": ["<br>", "</body>", "<p>", "afdsaf.adijs", "This is a text", "23dve22dvf", "Text with <br>", "h8uinjf2ef", "u09nKLJG FSL", "f2ewd", "2efef2d2", "e2f2ef2effds"], "stress_tests": [], "serial": 264, "problematic": [{"example": "<div>", "is_match": true}, {"example": "<ul>", "is_match": true}, {"example": "<li>", "is_match": true}]}, {"expression": "[^!~/&gt;&lt;\\|/#%():;{}`_-]", "raw_prompt": "Trying to remove all these characters in the regular expression: still working on it\n!~/[&gt;&lt;*\\|]/#$%^&amp;():;{},?`_-", "refined_prompt": "Remove all these characters in the regular expression\nMatch examples:\n- \"Soma\"\n- \"Infy\"\n- \"every\"\nNon-match examples:\n- \"&lt;\"\n- \"&gt;\"", "matches": ["Soma", "Infy", "every", "67gyu7gyu", "78gyu", "6fty", "67fty", "09oy8", "87t", "t78", "78t34g", "g43", "g34hy"], "non_matches": ["&lt;", "&gt;", "!", "!y78D", "~UHI", "/fs8uh", "&HGU", "&GUFE", "(GUDFS)", "(GFDS)(FSF", ":FHDSs;d;", "{FDS{ssfudi"], "stress_tests": [], "serial": 267, "problematic": [{"example": "!y78D", "is_match": false}, {"example": "~UHI", "is_match": false}, {"example": "/fs8uh", "is_match": false}, {"example": "&HGU", "is_match": false}, {"example": "&GUFE", "is_match": false}, {"example": "(GUDFS)", "is_match": false}, {"example": "(GFDS)(FSF", "is_match": false}, {"example": ":FHDSs;d;", "is_match": false}, {"example": "{FDS{ssfudi", "is_match": false}]}, {"expression": "^([\\s\\S]){1,20}([\\s\\.])", "raw_prompt": "This pattern returns as much of the first x characters of a string as full words or sentences as a match, where x is currently 20. Change x to adjust the length supported in your database field.\nI'm currently using this within a string shortening utility to shrink large text regions to word/sentance-boundary elements and appending an ellipsis as a text continuator.", "refined_prompt": "This pattern returns as much of the first x characters of a string as full words or sentences as a match, where x is currently 20.\nMatch examples:\n- \"Any text of any length\"\n- \"...but will only 'match' the first 20 characters at a period or space.\"\n- \"8hu\"\nNon-match examples:\n- \"N/A\"", "matches": ["Any text of any length", "...but will only 'match' the first 20 characters at a period or space.", "8hu", "hu9e", "9bio", "fhdiuh", "9dh89", "dhi0hjd09hj0hj0hj", "<ul>", "nd.edu", "fadghui", "<table cellpadding=\"5\" cellspacing=\"0\">", "7225464526"], "non_matches": ["N/A"], "stress_tests": [], "serial": 268, "problematic": [{"example": "8hu", "is_match": true}, {"example": "hu9e", "is_match": true}, {"example": "9bio", "is_match": true}, {"example": "fhdiuh", "is_match": true}, {"example": "9dh89", "is_match": true}, {"example": "dhi0hjd09hj0hj0hj", "is_match": true}, {"example": "<ul>", "is_match": true}, {"example": "fadghui", "is_match": true}, {"example": "7225464526", "is_match": true}]}, {"expression": "(\\w(\\s)?)+", "raw_prompt": "Used to verify that the string consists of only A-z, 0 - 9 and underscore. Several words allowed, only one space between them. No spaces up front. Hey, I know it's easy, but it was not in the library! Plus, the test option here is not working well all the time.", "refined_prompt": "Used to verify that the string consists of only A-z, 0 - 9 and underscore. Several words allowed, only one space between them. No spaces up front.\nMatch examples:\n- \"Test\"\n- \"TesT\"\n- \"tesT9 _test9\"\nNon-match examples:\n- \"\\\\\\\"\n- \"^%&&^\"", "matches": ["Test", "TesT", "tesT9 _test9", "g87g", "8giu", "8g8i7g_", "87g9f89", "g98f", "f", "8ff", "7f", "_8f8f", "8f79fg98"], "non_matches": ["\\\\\\", "^%&&^", "&FTYU", "@#$76fyU", "89';''''g", "iyg'i;i;g", "iug8G*(*(", "(*G*UI", "';79g9", "'';08H*(H", "98GU(*", "$ERTFG@"], "stress_tests": [], "serial": 271, "problematic": [{"example": "&FTYU", "is_match": false}, {"example": "@#$76fyU", "is_match": false}, {"example": "89';''''g", "is_match": false}, {"example": "iyg'i;i;g", "is_match": false}, {"example": "iug8G*(*(", "is_match": false}, {"example": "(*G*UI", "is_match": false}, {"example": "';79g9", "is_match": false}, {"example": "'';08H*(H", "is_match": false}, {"example": "98GU(*", "is_match": false}, {"example": "$ERTFG@", "is_match": false}]}, {"expression": "^ISBN\\s(?=[-0-9xX ]{13}$)(?:[0-9]+[- ]){3}[0-9]*[xX0-9]$", "raw_prompt": "This pattern validates ISBN numbers. I've written a full description about it here: http://regexblogs.com/dneimke/posts/201.aspx", "refined_prompt": "This pattern validates ISBN numbers.\nMatch examples:\n- \"ISBN 90-70002-34-5\"\n- \"ISBN 90-70002-34-x\"\n- \"ISBN 123-456-789-0\"\nNon-match examples:\n- \"ISBN 90-70002-34-5x\"\n- \"ISBN 90-700-02-34-5\"", "matches": ["ISBN 90-70002-34-5", "ISBN 90-70002-34-x", "ISBN 123-456-789-0", "ISBN 1-234567-89-X", "ISBN 1234-56789-0", "ISBN 12-34567-890", "ISBN 12345-6-789-0", "ISBN 12345 6789 0", "ISBN 123456789-X", "ISBN 1234567890", "ISBN 1-23456-789-0", "ISBN 1-234567890", "ISBN 12-34-56-789-0"], "non_matches": ["ISBN 90-70002-34-5x", "ISBN 90-700-02-34-5", "ABCD 123-456-789-0", "ISBN 123-45-678-9-", "ISBN 123-45-678-9-X-", "GUBH 78uibfwe", "@#dfkjnav", "notre dame", "000-000", "(0xx12) 7256 2345154", "9/9/9", "99999@gmail"], "stress_tests": [], "serial": 273, "problematic": [{"example": "ISBN 1234-56789-0", "is_match": true}, {"example": "ISBN 12-34567-890", "is_match": true}, {"example": "ISBN 12345 6789 0", "is_match": true}, {"example": "ISBN 123456789-X", "is_match": true}, {"example": "ISBN 1234567890", "is_match": true}, {"example": "ISBN 1-234567890", "is_match": true}, {"example": "ISBN 12-34-56-789-0", "is_match": true}]}, {"expression": "^((([sS][r-tR-Tx-zX-Z])\\s*([sx-zSX-Z])?\\s*([a-zA-Z]{2,3}))?\\s*(\\d\\d)\\s*-?\\s*(\\d{6,7}))$", "raw_prompt": "California Resale License number validator. Validates Letters and Numbers or Number only. Letters: First 2 letters can be SR, SS, ST , SX, SY, SZ (TAT Code) Next optional letter can be S,X,Y,Z. Next letters must be a minimum of two and a maximum of 3 (District Code). Numbers: Can be 8-9 numbers. Numbers can be delimited with a hypen or spaces after the first 2 numbers. Note: I use () to extract the information I want for use in other scripts.", "refined_prompt": "California Resale License number validator. Validates Letters and Numbers or Number only. Letters: First 2 letters can be SR, SS, ST , SX, SY, SZ (TAT Code) Next optional letter can be S,X,Y,Z. Next letters must be a minimum of two and a maximum of 3 (District Code). Numbers: Can be 8-9 numbers. Numbers can be delimited with a hypen or spaces after the first 2 numbers.\nMatch examples:\n- \"SR BH 97-578613\"\n- \"97578613\"\n- \"SRXBH97578613\"\nNon-match examples:\n- \"RR BH 97-578613\"\n- \"9757861\"", "matches": ["SR BH 97-578613", "97578613", "SRXBH97578613", "srxAB12-3456789", "TxBCD3456789", "SrX Ef1234567", "yzGhi23-4567890", "T uv3456789", "r sxy1234567", "TuV1234567", "Sr z23-4567890", "STUV23-4567890", "SRsYZ12-3456789"], "non_matches": ["RR BH 97-578613", "9757861", "SRAABH 97-578613", "(12) 324 653210", "123.456.789", "there is a boy", "AAAAAAA", "12f3.21f3.213f", "u09nKLJG FSL", "(0xx12) 7256 2345154", "(0xx12) 62509", "99999@gmail"], "stress_tests": [], "serial": 279, "problematic": [{"example": "TxBCD3456789", "is_match": true}, {"example": "SrX Ef1234567", "is_match": true}, {"example": "yzGhi23-4567890", "is_match": true}, {"example": "T uv3456789", "is_match": true}, {"example": "r sxy1234567", "is_match": true}, {"example": "TuV1234567", "is_match": true}, {"example": "Sr z23-4567890", "is_match": true}]}, {"expression": "^DOMAIN\\\\\\w+$", "raw_prompt": "In response to a question on the regex list at www.aspadvice.com, this expression should ensure that a login field's username includes a 'DOMAIN\\' prefix. The latter part of the expression should probably be limited so that it only allows usernames of appropriate lengths, perhaps 3 to 20 characters (by replacing + with {3,20} for instance).", "refined_prompt": "The provided regex pattern is designed to match strings that follow a specific format:\r\n\r\nIt starts with the string \"DOMAIN\\\", which includes the literal text \"DOMAIN\" followed by a double backslash.\r\nIt is then followed by one or more word characters (letters, digits, or underscores).\nMatch examples:\n- \"DOMAIN\\ssmith\"\n- \"DOMAIN\\a\"\n- \"DOMAIN\\username\"\nNon-match examples:\n- \"ssmith\"\n- \"username\"", "matches": ["DOMAIN\\ssmith", "DOMAIN\\a", "DOMAIN\\username", "DOMAIN\\user123", "DOMAIN\\JohnDoe", "DOMAIN\\account_567", "DOMAIN\\Group_42", "DOMAIN\\employee123", "DOMAIN\\User_A", "DOMAIN\\User007", "DOMAIN\\group_xyz", "DOMAIN\\user1234", "DOMAIN\\jdoe_42"], "non_matches": ["ssmith", "username", "DOMAIN\\", "DOMAIN\\user123", "DOMAIN\\", "there is a boy", "@#dfkjnav", "254627g.256", "u09nKLJG FSL", "(0xx12) 7256 2345154", "abc111def", "8h98009hu"], "stress_tests": [], "serial": 281, "problematic": [{"example": "DOMAIN\\user123", "is_match": false}]}, {"expression": "(?i:on(blur|c(hange|lick)|dblclick|focus|keypress|(key|mouse)(down|up)|(un)?load|mouse(move|o(ut|ver))|reset|s(elect|ubmit)))", "raw_prompt": "This regex will match all the valid on event attributes in HTML 4.01/XHTML 1.0", "refined_prompt": "This regex will match all the valid on event attributes in HTML 4.01/XHTML 1.0\nMatch examples:\n- \"onclick\"\n- \"onsubmit\"\n- \"onmouseover\"\nNon-match examples:\n- \"click\"\n- \"onandon\"", "matches": ["onclick", "onsubmit", "onmouseover", "onBlur", "ONFOCUS", "onChange", "ondblclick", "onKeyPress", "onMouseDown", "onMOUSEMOVE", "onUnload", "onmouseout", "ONreset"], "non_matches": ["click", "onandon", "mickeymouse", "onload", "onmouseover", "onmouseup", "onmouseleave", "oncontextmenu", "ondragstart", "ondragend", "onmouseenter", "onscroll"], "stress_tests": [], "serial": 285, "problematic": [{"example": "onload", "is_match": false}, {"example": "onmouseover", "is_match": false}, {"example": "onmouseup", "is_match": false}]}, {"expression": "^(\\d{4}-){3}\\d{4}$|^(\\d{4} ){3}\\d{4}$|^\\d{16}$", "raw_prompt": "Used to validate Credit Card numbers, Checks if it contains 16 numbers in groups of 4 separated by -, ,or nothing", "refined_prompt": "Used to validate Credit Card numbers, Checks if it contains 16 numbers in groups of 4 separated by -, ,or nothing\nMatch examples:\n- \"1111-2323-2312-3434\"\n- \"1234343425262837\"\n- \"1111 2323 2312 3434\"\nNon-match examples:\n- \"1111 2323 2312-3434\"\n- \"34323423\"", "matches": ["1111-2323-2312-3434", "1234343425262837", "1111 2323 2312 3434", "1751335075314489", "2429-9731-1045-3483", "6727-4055-4870-8649", "8661156854987333", "5702 4308 5739 2933", "9060 6176 3574 4245", "7337-6644-0174-6271", "0578-0729-8697-4792", "0309-7166-0763-3951", "8570745681126939"], "non_matches": ["1111 2323 2312-3434", "34323423", "1111-2323-23122-3434", "23456789874632", "8574027385087", "87423560875", "0847325734510875", "87423507v1315v7", "870v587v05876", "807586", "7f68r87f87", "3409fjg43"], "stress_tests": [], "serial": 287, "problematic": [{"example": "0847325734510875", "is_match": false}]}, {"expression": "^([\\+][0-9]{1,3}[\\.][0-9]{1,12})([x]?[0-9]{1,4}?)$", "raw_prompt": "Validates on the following standards:\n+CCC.ZZZZZZZZZZxYYYY, where 'C' is the numeric\ncountry phone code (up to three digits), 'Z' is the phone number (up to\n12 digits) and 'Y' is the extension (up to 4 digits); max length overall is\n20 characters, including the '+', '.', and 'x' (if extension is present).\nUseful for people communicating with the OpenSRS API", "refined_prompt": "Validates on the following standards:\r\n+CCC.ZZZZZZZZZZxYYYY, where 'C' is the numeric\r\ncountry phone code (up to three digits), 'Z' is the phone number (up to\r\n12 digits) and 'Y' is the extension (up to 4 digits); max length overall is\r\n20 characters, including the '+', '.', and 'x' (if extension is present).\r\nUseful for people communicating with the OpenSRS API\nMatch examples:\n- \"+800.4453377x4444\"\n- \"+80.4453377\"\n- \"+8.123456789123x1111\"\nNon-match examples:\n- \"181823884499\"\n- \"+800.4453377x\"", "matches": ["+800.4453377x4444", "+80.4453377", "+8.123456789123x1111", "+476.64971", "+9.41", "+17.88377014", "+29.05x489", "+8.04949200", "+96.61417x", "+5.23317345003", "+522.3403601", "+572.27266779x", "+7.580611257778x"], "non_matches": ["181823884499", "+800.4453377x", "2486994x11", "c12d78gf78f", "79f7", "f79f97f79", "f78df75d57ry808", "2546dgwre", "u09nKLJG FSL", "(0xx12) 7256 2345154", "(0xx12) 62509", "99999@gmail"], "stress_tests": [], "serial": 288, "problematic": [{"example": "+96.61417x", "is_match": true}, {"example": "+572.27266779x", "is_match": true}, {"example": "+7.580611257778x", "is_match": true}]}, {"expression": "^([a-zA-Z]+(.)?[\\s]*)$", "raw_prompt": "This regular expression matches titles. The length of the title has not been restricted. It allows only alphabets in the title and takes zero or one . after the title. Also it allows trailing spaces.", "refined_prompt": "This regular expression matches titles. The length of the title has not been restricted. It allows only alphabets in the title and takes zero or one . after the title. Also it allows trailing spaces.\nMatch examples:\n- \"Mr.\"\n- \"Sr\"\n- \"Mr\"\nNon-match examples:\n- \"Mr..\"\n- \"12M\"", "matches": ["Mr.", "Sr", "Mr", "Hello", "Qodas", "World", "Happy", "Sky", "Moon", "Sun", "Football", "Basket", "Soccer"], "non_matches": ["Mr..", "12M", ".Mr", "8guib", "g98uv7", "f7", "fg89g08g", "89", "g89", "vud98w", ".ouvg/uog", "fds.98(&G"], "stress_tests": [], "serial": 295, "problematic": [{"example": "f7", "is_match": false}]}, {"expression": "(?i:([A-D])(?!\\1)([A-D])(?!\\1|\\2)([A-D])(?!\\1|\\2|\\3)([A-D]))", "raw_prompt": "This regex validates a string of non-repeating characters A, B, C, D.", "refined_prompt": "This regex validates a string of non-repeating characters A, B, C, D.\nMatch examples:\n- \"abcd\"\n- \"dbca\"\n- \"badc\"\nNon-match examples:\n- \"abba\"\n- \"baaa\"", "matches": ["abcd", "dbca", "badc", "dcba", "dbac", "cabd", "cadb", "cbda", "cdba", "cbad", "cdab", "adcb", "acbd"], "non_matches": ["abba", "baaa", "cabb", "abcdc", "abcdcd", "bbb", "bcadd", "bcabd", "cbdab", "dacad", "dcabd", "dddd"], "stress_tests": [], "serial": 297, "problematic": [{"example": "abcdc", "is_match": false}, {"example": "abcdcd", "is_match": false}, {"example": "bcadd", "is_match": false}, {"example": "bcabd", "is_match": false}, {"example": "cbdab", "is_match": false}, {"example": "dcabd", "is_match": false}]}, {"expression": "^(\\d{1,2})(\\s?(H|h)?)(:([0-5]\\d))?$", "raw_prompt": "Validates hours and minutes. Allows for entry in the form of hours:minutes with optional minutes and optional hours indicator (H or h).", "refined_prompt": "Validates hours and minutes. Allows for entry in the form of hours:minutes with optional minutes and optional hours indicator (H or h).\nMatch examples:\n- \"1h\"\n- \"1:45\"\n- \"45\"\nNon-match examples:\n- \"1a\"\n- \"145\"", "matches": ["1h", "1:45", "45", "30", "47", "38", "20", "2:37", "3:18", "1:19", "2:23", "3:39", "4:39"], "non_matches": ["1a", "145", "1:99", "98g89", "86", "f87", "f78", "89064", "0686", "2949", "4764", "76947"], "stress_tests": [], "serial": 303, "problematic": [{"example": "86", "is_match": false}]}, {"expression": "^\\d{1,8}$|^\\d{1,3},\\d{3}$|^\\d{1,2},\\d{3},\\d{3}$", "raw_prompt": "Validates numeric input of 99,999,999 to 0 with or without commas. but no decimal places. Very simple, but not bad for a novice.", "refined_prompt": "Validates numeric input of 99,999,999 to 0 with or without commas. but no decimal places.\nMatch examples:\n- \"1000\"\n- \"12,345\"\n- \"12,345,678\"\nNon-match examples:\n- \"1.1\"\n- \"1,10\"", "matches": ["1000", "12,345", "12,345,678", "6486", "84864", "65486", "876744994", "9474", "4874784", "6754", "47648647", "44877675", "4536289"], "non_matches": ["1.1", "1,10", "123,888,888", "093249023894723489243789423", "42389570278098742390794203", "879524687246395278658327", "423.42.4.23.423", "4.234.23524", "+4234.242.341", "-423.23.4324", "-4234.2432", "982342.423"], "stress_tests": [], "serial": 305, "problematic": [{"example": "876744994", "is_match": true}]}, {"expression": "^(?=[^\\d_].*?\\d)\\w(\\w|[!@#$%]){7,20}", "raw_prompt": "This regex can be used to restrict passwords to a length of 8 to 20 aplhanumeric characters and select special characters. The password also can not start with a digit, underscore or special character and must contain at least one digit.", "refined_prompt": "This regex can be used to restrict passwords to a length of 8 to 20 aplhanumeric characters and select special characters. The password also can not start with a digit, underscore or special character and must contain at least one digit.\nMatch examples:\n- \"password1\"\n- \"pa$$word2\"\n- \"pa!@#$%3\"\nNon-match examples:\n- \"password\"\n- \"1stpassword\"", "matches": ["password1", "pa$$word2", "pa!@#$%3", "234fdsafdgsfd", "hji98uhsgfd", "h89gu98sgfd", "iohfgd98hfdg", "yirew89rwe", "sdiouwer90", "iyo908fyws", "iyohkjoih89", "uigtuiiuue90", "yuiowegui89"], "non_matches": ["password", "1stpassword", "$password#", "cgfkuuh", "vfyfiafdsafsd", "yuccfihiflil", "short1", "89iouij9i", "98hionkhio89hionk", "h90io", "98hionhiosh", "95618giu8iywoer"], "stress_tests": [], "serial": 308, "problematic": [{"example": "234fdsafdgsfd", "is_match": true}]}, {"expression": "^[01]?[- .]?\\(?[2-9]\\d{2}\\)?[- .]?\\d{3}[- .]?\\d{4}$", "raw_prompt": "U. S. or Canadian telephone number regular expression. &lt;BR&gt;\n&lt;BR&gt;\n// # Checks phone numbers for validity &lt;BR&gt;\n// [01]? # optional '0', or '1' &lt;BR&gt;\n// [- .]? # optional separator is either a dash, a space, or a period. &lt;BR&gt;\n// \\(? # optional parentheses &lt;BR&gt;\n// [2-9] # first # of the area code must not be a '0' or '1' &lt;BR&gt;\n// \\d{2} # next 2 digits of area code can be 0-9 &lt;BR&gt;\n// \\)? # optional parentheses &lt;BR&gt;\n// [- .]? # optional separator is either a dash, a space, or a period. &lt;BR&gt;\n// \\d{3} # 3-digit prefix &lt;BR&gt;\n// [- .]? # optional separator is either a dash, a space, or a period. &lt;BR&gt;\n// \\d{4} # 4-digit station number &lt;BR&gt;", "refined_prompt": "U. S. or Canadian telephone number regular expression. &lt;BR&gt;\r\n&lt;BR&gt;\r\n// # Checks phone numbers for validity &lt;BR&gt;\r\n// [01]? # optional '0', or '1' &lt;BR&gt;\r\n// [- .]? # optional separator is either a dash, a space, or a period. &lt;BR&gt;\r\n// \\(? # optional parentheses &lt;BR&gt;\r\n// [2-9] # first # of the area code must not be a '0' or '1' &lt;BR&gt;\r\n// \\d{2} # next 2 digits of area code can be 0-9 &lt;BR&gt;\r\n// \\)? # optional parentheses &lt;BR&gt;\r\n// [- .]? # optional separator is either a dash, a space, or a period. &lt;BR&gt;\r\n// \\d{3} # 3-digit prefix &lt;BR&gt;\r\n// [- .]? # optional separator is either a dash, a space, or a period. &lt;BR&gt;\r\n// \\d{4} # 4-digit station number &lt;BR&gt;\nMatch examples:\n- \"18008793262\"\n- \"800-879-3262\"\n- \"0-800.879.3262\"\nNon-match examples:\n- \"879 3262\"\n- \"077 879 3262\"", "matches": ["18008793262", "800-879-3262", "0-800.879.3262", "555-123-4567", "123.456.7890", "(555) 555-5555", "555 123 4567", "123-4567", "123.4567", "(555)-5555555", "555-555-5555", "123 456 7890", "(123)-456-7890"], "non_matches": ["879 3262", "077 879 3262", "879-3262", "123456", "12-345-67890", "1 (555) 555-5555", "555.55555", "123-456-78901", "5555-5555", "555-555-555", "555-555-5555-5555", "555-555-55555"], "stress_tests": [], "serial": 310, "problematic": [{"example": "123.456.7890", "is_match": true}, {"example": "123-4567", "is_match": true}, {"example": "123.4567", "is_match": true}, {"example": "123 456 7890", "is_match": true}, {"example": "(123)-456-7890", "is_match": true}, {"example": "1 (555) 555-5555", "is_match": false}]}, {"expression": "^((\\(?0\\d{4}\\)?\\s?\\d{3}\\s?\\d{3})|(\\(?0\\d{3}\\)?\\s?\\d{3}\\s?\\d{4})|(\\(?0\\d{2}\\)?\\s?\\d{4}\\s?\\d{4}))(\\s?\\#(\\d{4}|\\d{3}))?$", "raw_prompt": "UK phone number. Allows 3, 4 or 5 digit regional prefix, with 8, 7 or 6 digit phone number respectively, plus optional 3 or 4 digit extension number prefixed with a # symbol. Also allows optional brackets surrounding the regional prefix and optional spaces between appropriate groups of numbers.", "refined_prompt": "UK phone number. Allows 3, 4 or 5 digit regional prefix, with 8, 7 or 6 digit phone number respectively, plus optional 3 or 4 digit extension number prefixed with a # symbol. Also allows optional brackets surrounding the regional prefix and optional spaces between appropriate groups of numbers.\nMatch examples:\n- \"01222 555 555\"\n- \"(010) 55555555 #2222\"\n- \"0122 555 5555#222\"\nNon-match examples:\n- \"01222 555 5555\"\n- \"(010) 55555555 #22\"", "matches": ["01222 555 555", "(010) 55555555 #2222", "0122 555 5555#222", "0822 286 8040", "(0123) 456 7893#239", "01222 456 555", "01222 555 654", "01789 555 555", "0122 123 5555#222", "9876 456 5555#222", "0122 555 7890#111", "0879 555 5555#444", "0122 846 5555#666"], "non_matches": ["01222 555 5555", "(010) 55555555 #22", "0122 5555 5555#222", "12/123/4322", "123.456.789", "$23.454", "AAAAAAA", "/5/5/20022", "qwerty@123.123", "1-1-2", "(0xx12) 62509", "12/132/90"], "stress_tests": [], "serial": 311, "problematic": [{"example": "9876 456 5555#222", "is_match": true}]}, {"expression": "^([A-HK-PRSVWY][A-HJ-PR-Y])\\s?([0][2-9]|[1-9][0-9])\\s?[A-HJ-PR-Z]{3}$", "raw_prompt": "UK vehicle registration system currently in use (as defined by the DVLA and put into effect from September 2001, and therefore does not allow registrations prior to this date).", "refined_prompt": "UK vehicle registration system currently in use (as defined by the DVLA and put into effect from September 2001, and therefore does not allow registrations prior to this date).\nMatch examples:\n- \"AB51DVL\"\n- \"AB 51 DVL\"\n- \"BW51\u205fDWJ\"\nNon-match examples:\n- \"AZ01DLQ\"\n- \"AZ 01 DLQ\"", "matches": ["AB51DVL", "AB 51 DVL", "BW51\u205fDWJ", "HH\u180e06\u00a0EEV", "ES\u200945CMM", "CJ08PMD", "OC\f49\ufeffWZM", "KX\u180e83\u000bAUA", "WO06\u2002UDC", "LV04SRU", "GW42\u2005CEP", "WR07\u2008OFH", "CP\ufeff95\ufeffYPT"], "non_matches": ["AZ01DLQ", "AZ 01 DLQ", "34f2vf42e", "Mastercard", "sfalijad234", "there is a boy", "@#dfkjnav", "98iojk", "324df", "adfa2", "abc111def", "0j0jweBBBB"], "stress_tests": [], "serial": 313, "problematic": [{"example": "HH\u180e06\u00a0EEV", "is_match": true}, {"example": "OC\f49\ufeffWZM", "is_match": true}, {"example": "KX\u180e83\u000bAUA", "is_match": true}, {"example": "CP\ufeff95\ufeffYPT", "is_match": true}]}, {"expression": "^([A-Z]{3}\\s?(\\d{3}|\\d{2}|d{1})\\s?[A-Z])|([A-Z]\\s?(\\d{3}|\\d{2}|\\d{1})\\s?[A-Z]{3})$", "raw_prompt": "UK vehicle registration system prior to September 2001. Allows both older suffix and the later prefix formats in simple form, with optional spaces.", "refined_prompt": "UK vehicle registration system prior to September 2001. Allows both older suffix and the later prefix formats in simple form, with optional spaces.\nMatch examples:\n- \"ABC123A\"\n- \"A 123 ABC\"\n- \"FXE\u2003405\u2000E\"\nNon-match examples:\n- \"AB123A\"\n- \"A 123 AB\"", "matches": ["ABC123A", "A 123 ABC", "FXE\u2003405\u2000E", "C635\u00a0JJK", "G870\u000bQXZ", "E75\u202fNDU", "J2DFM", "YGR\u2005717\u2006P", "OBF\u2005181J", "OVS\ufeff417\u2029Y", "KYN44R", "RSRd\u2009W", "QQD92V"], "non_matches": ["AB123A", "A 123 AB", "34f2vf42e", "Mastercard", "2346-2345-2435", "$23.454", "@#dfkjnav", "98iojk", "qwerty@123.123", "adfa2", "abc111def", "0j0jweBBBB"], "stress_tests": [], "serial": 314, "problematic": [{"example": "OVS\ufeff417\u2029Y", "is_match": true}]}, {"expression": "^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,15}$", "raw_prompt": "Password matching expression. Password must be at least 8 characters, no more than 15 characters, and must include at least one upper case letter, one lower case letter, and one numeric digit.", "refined_prompt": "Password matching expression. Password must be at least 8 characters, no more than 15 characters, and must include at least one upper case letter, one lower case letter, and one numeric digit.\nMatch examples:\n- \"aaaa1234AAAA\"\n- \"12aaAA12\"\n- \"aaaaa12345AAAAA\"\nNon-match examples:\n- \"aaaaa123456AAAAA\"\n- \"12aaAA1\"", "matches": ["aaaa1234AAAA", "12aaAA12", "aaaaa12345AAAAA", "k=\"qFN/ $UX<g", "n~e7S{mT%p,,Dt", "309'X}HYy", "26jj\\:>k1Xr2r", "~:k?+]y^!E?4f@", "1?`hQ+xN_dvdRb", "?mv*AW.Kk2(", "'@=s;w1P[[B3", "Szz330Ee{Lol{", "/^n<y(7=K~|"], "non_matches": ["aaaaa123456AAAAA", "12aaAA1", "12aaaa12", "uiafd", "short", "89aiojfdsfaiodsfladhflasidufhlaisudh98", "jdfskAFIOJSFIO", "4732897rfhdshiuh", "hui2feds", "98hui09uffsd", "UIHFSDIhju", "JFDSKhfdsjk"], "stress_tests": [], "serial": 316, "problematic": [{"example": "k=\"qFN/ $UX<g", "is_match": true}]}, {"expression": "^([2-9])(\\d{2})(-?|\\040?)(\\d{4})( ?|\\040?)(\\d{1,4}?|\\040?)$", "raw_prompt": "A regular expression that validates the any format of fixed telephone numbers inside Lima - Peru, including an optional extension of at least one number up to four numbers.", "refined_prompt": "A regular expression that validates the any format of fixed telephone numbers inside Lima - Peru, including an optional extension of at least one number up to four numbers.\nMatch examples:\n- \"263-8854\"\n- \"5660578 1235\"\n- \"622-4588 21\"\nNon-match examples:\n- \"1227585\"\n- \"4224586 50124\"", "matches": ["263-8854", "5660578 1235", "622-4588 21", "6001003", "613-9027", "3011521", "3608320", "253299040", "378 4925", "373-0877", "454-0494", "5868591", "4857652"], "non_matches": ["1227585", "4224586 50124", "0554499", "456489489", "2346-2345-2435", "43.v234", "@#dfkjnav", "/5/5/20022", "qwerty@123.123", "adfa2", "abc111def", "++63453.345"], "stress_tests": [], "serial": 319, "problematic": [{"example": "456489489", "is_match": false}]}, {"expression": "^(?=\\d)(?:(?:31(?!.(?:0?[2469]|11))|(?:30|29)(?!.0?2)|29(?=.0?2.(?:(?:(?:1[6-9]|[2-9]\\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00)))(?:\\x20|$))|(?:2[0-8]|1\\d|0?[1-9]))([-./])(?:1[012]|0?[1-9])\\1(?:1[6-9]|[2-9]\\d)?\\d\\d(?:(?=\\x20\\d)\\x20|$))?(((0?[1-9]|1[012])(:[0-5]\\d){0,2}(\\x20[AP]M))|([01]\\d|2[0-3])(:[0-5]\\d){1,2})?$", "raw_prompt": "DateTime Validator. This RE validates both dates and/or times patterns. Days in Feb. are also validated for Leap years. Dates: in dd/mm/yyyy or d/m/yy format between 1/1/1600 - 31/12/9999. Leading zeroes are optional. Date separators can be either matching dashes(-), slashes(/) or periods(.) Times: in the hh:MM:ss AM/PM 12 hour format (12:00 AM - 11:59:59 PM) or hh:MM:ss military time format (00:00:00 - 23:59:59). The 12 hour time format: 1) may have a leading zero for the hour. 2) Minutes and seconds are optional for the 12 hour format 3) AM or PM is required and case sensitive. Military time 1) must have a leading zero for all hours less than 10. 2) Minutes are manditory. 3) seconds are optional. Datetimes: combination of the above formats. A date first then a time separated by a space. ex) dd/mm/yyyy hh:MM:ss This RE is an variation of one of my other Datetime (mm/dd/yyyy) validator already in this library http://www.regexlib.com/REDetails.aspx?regexp_id=369, so the same rules for leap year apply. All 4 digit year and all two digit years except 00, which might not be a leap year.", "refined_prompt": "DateTime Validator. This RE validates both dates and/or times patterns. Days in Feb. are also validated for Leap years. Dates: in dd/mm/yyyy or d/m/yy format between 1/1/1600 - 31/12/9999. Leading zeroes are optional. Date separators can be either matching dashes(-), slashes(/) or periods(.) Times: in the hh:MM:ss AM/PM 12 hour format (12:00 AM - 11:59:59 PM) or hh:MM:ss military time format (00:00:00 - 23:59:59). The 12 hour time format: 1) may have a leading zero for the hour. 2) Minutes and seconds are optional for the 12 hour format 3) AM or PM is required and case sensitive. Military time 1) must have a leading zero for all hours less than 10. 2) Minutes are manditory. 3) seconds are optional. Datetimes: combination of the above formats. A date first then a time separated by a space. ex) dd/mm/yyyy hh:MM:ss This RE is an variation of one of my other Datetime (mm/dd/yyyy) validator already in this library http://www.regexlib.com/REDetails.aspx?regexp_id=369, so the same rules for leap year apply. All 4 digit year and all two digit years except 00, which might not be a leap year.\nMatch examples:\n- \"31/12/2003 11:59:59 PM\"\n- \"29-2-2004\"\n- \"01:45:02\"\nNon-match examples:\n- \"12/31/2003\"\n- \"29.02.2005\"", "matches": ["31/12/2003 11:59:59 PM", "29-2-2004", "01:45:02", "05:48", "31-10-2904:34:23", "08:56:12", "12:31:39 PM", "28-12-1785", "29.08.10", "7 AM", "15-12-1660", "31-11-1973", "29.12.42"], "non_matches": ["12/31/2003", "29.02.2005", "13:30 PM", "12/123/4322", "2346-2345-2435", "$23.454", "@#dfkjnav", "/5/5/20022", "qwerty@123.123", "1-1-2", "sda sad", "99999@gmail"], "stress_tests": [], "serial": 326, "problematic": [{"example": "31-10-2904:34:23", "is_match": true}, {"example": "31-11-1973", "is_match": true}]}, {"expression": "^(((\\d{4})(0[13578]|10|12)(0[1-9]|[12][0-9]|3[01]))|((\\d{4})(0[469]|11)([0][1-9]|[12][0-9]|30))|((\\d{4})(02)(0[1-9]|1[0-9]|2[0-8]))|(([02468][048]00)(02)(29))|(([13579][26]00) (02)(29))|(([0-9][0-9][0][48])(02)(29))|(([0-9][0-9][2468][048])(02)(29))|(([0-9][0-9][13579][26])(02)(29))|(00000000)|(88888888)|(99999999))?$", "raw_prompt": "it's for date in the format: &quot;yyyymmdd&quot; and it validates the empty string and some special values (00000000,88888888,99999999) but you can delete these last values. It works with leap years.", "refined_prompt": "it's for date in the format: &quot;yyyymmdd&quot; and it validates the empty string and some special values (00000000,88888888,99999999. It works with leap years.\nMatch examples:\n- \"20041212\"\n- \"20040229\"\n- \"88888888\"\nNon-match examples:\n- \"20040230\"\n- \"20041330\"", "matches": ["20041212", "20040229", "88888888", "71550224", "36000229", "49560229", "99999999", "84291130", "39361209", "19720229", "80000229", "59611129", "43520229", "71550224", "36000229", "49560229", "99999999", "84291130", "39361209", "19720229", "80000229", "59611129", "43520229"], "non_matches": ["20040230", "20041330", "34f2vf42e", "Mastercard", "2346-2345-2435", "$23.454", "48997845", "4886587", "84891876", "48986821", "48965154", "98148913", "34f2vf42e", "Mastercard", "2346-2345-2435", "$23.454", "48997845", "4886587", "84891876", "48986821", "48965154", "98148913"], "stress_tests": [], "serial": 336, "problematic": [{"example": "36000229", "is_match": true}, {"example": "36000229", "is_match": true}]}, {"expression": "^0[234679]{1}[\\s]{0,1}[\\-]{0,1}[\\s]{0,1}[1-9]{1}[0-9]{6}$", "raw_prompt": "The regex matches the UAE land phone numbers. Checks the area codes[04,02,06...etc] strictly. Force user to input phone numbers in strict manner(it take input 04 3452488, but not 04______spaces_______3452488)", "refined_prompt": "The regex matches the UAE land phone numbers. Checks the area codes[04,02,06...etc] strictly. Force user to input phone numbers in strict manner(it take input 04 3452488, but not 04______spaces_______3452488)\nMatch examples:\n- \"04 3452488\"\n- \"04 -3452488\"\n- \"04 - 3452499\"\nNon-match examples:\n- \"01 -3452488\"\n- \"04 34524888\"", "matches": ["04 3452488", "04 -3452488", "04 - 3452499", "04-\f2725219", "03\u202f2326935", "03-\u00a06639339", "03-7125347", "06\ufeff-\u20046757753", "025474576", "02\ufeff7594358", "072156040", "03-7803363", "03-1662120"], "non_matches": ["01 -3452488", "04 34524888", "08 3452488fsd48", "4895619884dfs", "849489sfd748", "4688448489dsf", "4984fsd8949s8f", "684684fsd", "6846fsds", "846afd948", "548945984", "68448949fds"], "stress_tests": [], "serial": 338, "problematic": [{"example": "06\ufeff-\u20046757753", "is_match": true}, {"example": "02\ufeff7594358", "is_match": true}]}, {"expression": "^((\\+){0,1}91(\\s){0,1}(\\-){0,1}(\\s){0,1}){0,1}98(\\s){0,1}(\\-){0,1}(\\s){0,1}[1-9]{1}[0-9]{7}$", "raw_prompt": "The Regex validate the mobile numbers in India.\nGives flexibility to user to enter numbers in different format like\n+919847444225, +91-98-45017381, 9844111116, 98 44111112, 98-44111116\n###Enjoy REGEX###", "refined_prompt": "The Regex validate the mobile numbers in India.\r\nGives flexibility to user to enter numbers in different format like\r\n+919847444225, +91-98-45017381, 9844111116, 98 44111112, 98-44111116\nMatch examples:\n- \"+919847444225\"\n- \"+91-98-44111112\"\n- \"98 44111116\"\nNon-match examples:\n- \"+919800444225\"\n- \"+947444225\"", "matches": ["+919847444225", "+91-98-44111112", "98 44111116", "+91\t-98\f49167552", "98\ufeff-93967047", "+91\u000b98-\u202877276146", "91-98\u200a-16993252", "98\u200699129943", "+91\u20099895229192", "98-\u180e88737379", "9877207378", "78050121", "18535087"], "non_matches": ["+919800444225", "+947444225", "44111116", "984894894849", "2346-2345-2435", "43.v234", "AAAAAAA", "/5/5/20022", "432/524/2435", "adfa2", "abc111def", "12/132/90"], "stress_tests": [], "serial": 340, "problematic": [{"example": "98\ufeff-93967047", "is_match": true}, {"example": "98-\u180e88737379", "is_match": true}, {"example": "78050121", "is_match": true}, {"example": "18535087", "is_match": true}]}, {"expression": "^([0-5]?\\d?\\d?\\d?\\d|6[0-4]\\d\\d\\d|65[0-4]\\d\\d|655[0-2]\\d|6553[0-5])$", "raw_prompt": "match for 0 - 65535", "refined_prompt": "match for 0 - 65535\nMatch examples:\n- \"0\"\n- \"65535\"\n- \"59999\"\nNon-match examples:\n- \"123456\"\n- \"69999\"", "matches": ["0", "65535", "59999", "4981", "4983", "7515", "9194", "9761", "5436", "8621", "8761", "9438", "7145"], "non_matches": ["123456", "69999", "65599", "259481968", "84984894", "489849", "4898889", "49849", "846848", "-5--5-5-", "-516526-1596", "-915"], "stress_tests": [], "serial": 341, "problematic": [{"example": "49849", "is_match": false}]}, {"expression": "((\\(\\d{3,4}\\)|\\d{3,4}-)\\d{4,9}(-\\d{1,5}|\\d{0}))|(\\d{4,12})", "raw_prompt": "telphone number check.", "refined_prompt": "This regex pattern is quite permissive and can match a variety of numeric strings, including phone numbers with different formats, as well as pure numeric strings of varying lengths. It aims to capture numbers with optional parentheses and hyphens.\nMatch examples:\n- \"0833-1234567-8888\"\n- \"(0833)1234567-8888\"\n- \"12345678\"\nNon-match examples:\n- \"ceocio\"\n- \"!@$@#$\"", "matches": ["0833-1234567-8888", "(0833)1234567-8888", "12345678", "493-1853731", "005-7083-73", "1879820073", "(541)966655244", "06472304167", "2535-0093683-1589", "427-0644910", "8333-277445149", "0945072829", "098-188316-32831"], "non_matches": ["ceocio", "!@$@#$", "34f2vf42e", "12/123/4322", "2346-2345-2435afds", "43.v234", "/5/5/5", "/5/5/20022", "432/524/2435", "adfa2", "(0xx12) 62509", "++63453.345"], "stress_tests": [], "serial": 343, "problematic": [{"example": "12/123/4322", "is_match": false}, {"example": "2346-2345-2435afds", "is_match": false}, {"example": "/5/5/20022", "is_match": false}, {"example": "432/524/2435", "is_match": false}, {"example": "(0xx12) 62509", "is_match": false}, {"example": "++63453.345", "is_match": false}]}, {"expression": "^(\\d{2}-\\d{2})*$", "raw_prompt": "This expression is a simplex expression that checks to see if a value is a valid phone system terminal number. It allows a null value or 2 digits, dash, 2 digits. Written by Jason N. Gaylord.", "refined_prompt": "This expression is a simplex expression that checks to see if a value is a valid phone system terminal number. It allows a null value or 2 digits, dash, 2 digits.\nMatch examples:\n- \"00-00\"\n- \"54-68\"\n- \"97-14\"\nNon-match examples:\n- \"1235\"\n- \"0\"", "matches": ["00-00", "54-68", "97-14", "98-65", "97-57", "97-15", "21-64", "98-96", "32-65", "12-45", "87-56", "32-54", "98-12"], "non_matches": ["1235", "0", "5-789", "12/123/4322", "2346-2345-2435", "$23.454", "2-485", "-98451", "-9559", "45-963", "32-87", "98-956"], "stress_tests": [], "serial": 350, "problematic": [{"example": "32-87", "is_match": false}]}, {"expression": "^[a-zA-Z]+((((\\-)|(\\s))[a-zA-Z]+)?(,(\\s)?(((j|J)|(s|S))(r|R)(\\.)?|II|III|IV))?)?$", "raw_prompt": "This regex validates a persons last name. Acceptable names can include compound names seperated by a hyphen or a space.", "refined_prompt": "This regex validates a persons last name. Acceptable names can include compound names seperated by a hyphen or a space.\nMatch examples:\n- \"Jones, Jr\"\n- \"Casey-Jones\"\n- \"Casey-Jones, IV\"\nNon-match examples:\n- \"Jones, IV.\"\n- \"Jones , Jr\"", "matches": ["Jones, Jr", "Casey-Jones", "Casey-Jones, IV", "Apple-Orange", "Pea-Peach", "Kate-Pat", "Tom-Tim", "Abc Cde", "Poe Chat", "Fore Front", "Msft-Apple", "Neymar-Jr", "Bac-Cab"], "non_matches": ["Jones, IV.", "Jones , Jr", "Casey-Jones-Hall", "Mastercard", "2346-2345-2435", "there is a boy", "@#dfkjnav", "12f3.21f3.213f", "qwerty@123.123", "341.431v4f3.fv1", "abc111def", "99999@gmail"], "stress_tests": [], "serial": 358, "problematic": [{"example": "Mastercard", "is_match": false}]}, {"expression": "(^[0]{1}$|^[-]?[1-9]{1}\\d*$)", "raw_prompt": "This is a regular expression I used to validate negative and positive WHOLE numbers, including 0.", "refined_prompt": "This is a regular expression I used to validate negative and positive WHOLE numbers, including 0.\nMatch examples:\n- \"0\"\n- \"123\"\n- \"-123\"\nNon-match examples:\n- \"001\"\n- \"-012\"", "matches": ["0", "123", "-123", "4", "489", "984", "497", "49", "48", "914", "987", "9873", "5612"], "non_matches": ["001", "-012", "-002", "-49856", "-4895", "-956123", "-4684652", "-1457", "-4561", "-563", "-537", "-5312"], "stress_tests": [], "serial": 362, "problematic": [{"example": "-49856", "is_match": false}, {"example": "-4895", "is_match": false}, {"example": "-956123", "is_match": false}, {"example": "-4684652", "is_match": false}, {"example": "-1457", "is_match": false}, {"example": "-4561", "is_match": false}, {"example": "-563", "is_match": false}, {"example": "-537", "is_match": false}, {"example": "-5312", "is_match": false}]}, {"expression": ".+\\.([^.]+)$", "raw_prompt": "Get any file extension...", "refined_prompt": "Get any file extension.\nMatch examples:\n- \"foo.bar\"\n- \"more.foo.bar\"\n- \".txt\"\nNon-match examples:\n- \".\"\n- \"bar\"", "matches": ["foo.bar", "more.foo.bar", ".txt", ".jpg", ".gsa.yug", ".yugi", ".buy", ".yvu", ".gtvv", ".vu", ".yo", ".jihd", ".uifd"], "non_matches": [".", "bar", "34f2vf42e", "12/123/4322", "2346-2345-2435", "there is a boy", "@#dfkjnav", "98iojk", "324df", "adfa2", "abc111def", "12/132/90"], "stress_tests": [], "serial": 367, "problematic": [{"example": ".txt", "is_match": true}, {"example": ".jpg", "is_match": true}, {"example": ".yugi", "is_match": true}, {"example": ".buy", "is_match": true}, {"example": ".yvu", "is_match": true}, {"example": ".gtvv", "is_match": true}, {"example": ".vu", "is_match": true}, {"example": ".yo", "is_match": true}, {"example": ".jihd", "is_match": true}, {"example": ".uifd", "is_match": true}]}, {"expression": "(?=\\d)^(?:(?!(?:10\\D(?:0?[5-9]|1[0-4])\\D(?:1582))|(?:0?9\\D(?:0?[3-9]|1[0-3])\\D(?:1752)))((?:0?[13578]|1[02])|(?:0?[469]|11)(?!\\/31)(?!-31)(?!\\.31)|(?:0?2(?=.?(?:(?:29.(?!000[04]|(?:(?:1[^0-6]|[2468][^048]|[3579][^26])00))(?:(?:(?:\\d\\d)(?:[02468][048]|[13579][26])(?!\\x20BC))|(?:00(?:42|3[0369]|2[147]|1[258]|09)\\x20BC))))))|(?:0?2(?=.(?:(?:\\d\\D)|(?:[01]\\d)|(?:2[0-8])))))([-.\\/])(0?[1-9]|[12]\\d|3[01])\\2(?!0000)((?=(?:00(?:4[0-5]|[0-3]?\\d)\\x20BC)|(?:\\d{4}(?!\\x20BC)))\\d{4}(?:\\x20BC)?)(?:$|(?=\\x20\\d)\\x20))?((?:(?:0?[1-9]|1[012])(?::[0-5]\\d){0,2}(?:\\x20[aApP][mM]))|(?:[01]\\d|2[0-3])(?::[0-5]\\d){1,2})?$", "raw_prompt": "mm/dd/yyyy hh:MM:ss Datetime for all AD years, including leap years.\nJavascript safe version of http://regexlib.com/REDetails.aspx?regexp_id=644. Please see that regex for details of what is being checked", "refined_prompt": "mm/dd/yyyy hh:MM:ss Datetime for all AD years, including leap years.\nMatch examples:\n- \"11/24/0004 11:59 PM\"\n- \"2.29.2008\"\n- \"02:50:10\"\nNon-match examples:\n- \"12/33/1020\"\n- \"2/29/2005\"", "matches": ["11/24/0004 11:59 PM", "2.29.2008", "02:50:10", "02:10", "19:04", "3 Pm", "10:31:46 Pm", "12 aM", "07:00 AM", "11/23/0827 BC", "10/4/6334 BC", "23:46", "11/25/4254 10:54:59"], "non_matches": ["12/33/1020", "2/29/2005", "13:00 AM", "12/123/4322", "2346-2345-2435", "43.v234", "43-5432", "/5/5/20022", "432/524/2435", "adfa2", "9/9/9", "12/132/90"], "stress_tests": [], "serial": 378, "problematic": [{"example": "11/23/0827 BC", "is_match": true}, {"example": "10/4/6334 BC", "is_match": true}]}, {"expression": "^(?=\\d)(?:(?!(?:1582(?:\\.|-|\\/)10(?:\\.|-|\\/)(?:0?[5-9]|1[0-4]))|(?:1752(?:\\.|-|\\/)0?9(?:\\.|-|\\/)(?:0?[3-9]|1[0-3])))(?=(?:(?!000[04]|(?:(?:1[^0-6]|[2468][^048]|[3579][^26])00))(?:(?:\\d\\d)(?:[02468][048]|[13579][26]))\\D0?2\\D29)|(?:\\d{4}\\D(?!(?:0?[2469]|11)\\D31)(?!0?2(?:\\.|-|\\/)(?:29|30))))(\\d{4})([-\\/.])(0?\\d|1[012])\\2((?!00)[012]?\\d|3[01])(?:$|(?=\\x20\\d)\\x20))?((?:(?:0?[1-9]|1[012])(?::[0-5]\\d){0,2}(?:\\x20[aApP][mM]))|(?:[01]\\d|2[0-3])(?::[0-5]\\d){1,2})?$", "raw_prompt": "yyyy/mm/dd hh:MM:ss Datetime for all AD years, including leap years.\nJavascript safe version of http://regexlib.com/REDetails.aspx?regexp_id=760. Please see that regex for details of what is being checked", "refined_prompt": "yyyy/mm/dd hh:MM:ss Datetime for all AD years, including leap years.\nMatch examples:\n- \"0008-02-29\"\n- \"2:34:59 PM\"\n- \"9999/12/31 11:59 PM\"\nNon-match examples:\n- \"04/04/04\"\n- \"1:00\"", "matches": ["0008-02-29", "2:34:59 PM", "9999/12/31 11:59 PM", "9174-11-30", "6450-06-31", "18:34:32", "5987.11.30", "4007/2/10", "7881/12/3110:11", "0158/2/2", "16:58:50", "6938.4.3", "14:19"], "non_matches": ["04/04/04", "1:00", "1999/1/32", "12/123/4322", "2346-2345-2435", "43.v234", "/5/5/5", "/5/5/20022", "9516-9516", "1-1-2", "(0xx12) 62509", "12/132/90"], "stress_tests": [], "serial": 380, "problematic": [{"example": "6450-06-31", "is_match": true}, {"example": "7881/12/3110:11", "is_match": true}]}, {"expression": "^(((ht|f)tp(s?))\\://).*$", "raw_prompt": "Identifies http, https, ftp, and ftps", "refined_prompt": "Identifies http, https, ftp, and ftps\nMatch examples:\n- \"http://3iem.net/\"\n- \"https://foo.org\"\n- \"ftps://jormahma.tk/\"\nNon-match examples:\n- \"yahoo.com\"\n- \"lame://protocol.us\"", "matches": ["http://3iem.net/", "https://foo.org", "ftps://jormahma.tk/", "http://www.example.com", "ftp://ftp.server.net", "ftps://secure.ftp.server", "ftp://my.ftp.server", "ftps://secure.ftp.example", "ftp://ftp.server:21", "ftp://ftp.server:12345", "ftps://secure.ftp.server:990", "https://example.com/resource/file.html", "http://www.example.net?query=param"], "non_matches": ["yahoo.com", "lame://protocol.us", "example.org", "ftp.server.net", "httpss://secure.example.com", "htp://invalid.url", "sftp://secure.server", "file://local/file/path", "htt://typo.url", "ftp:/incomplete.url", "ftp://ftp.server:12345/resource/file.html", "invalid/url"], "stress_tests": [], "serial": 383, "problematic": [{"example": "ftp://ftp.server:12345/resource/file.html", "is_match": false}]}, {"expression": "^(a-z|A-Z|0-9)*[^#$%^&*()']*$", "raw_prompt": "Does not allow these characters in a string #$%^&amp;*()'", "refined_prompt": "Does not allow these characters in a string #$%^&amp;*()'\nMatch examples:\n- \"Test\"\n- \"Whatever Text\"\n- \"D://folder/file.ext\"\nNon-match examples:\n- \"word's\"\n- \"test#\"", "matches": ["Test", "Whatever Text", "D://folder/file.ext", "76YGU", "76FYGU", "FTGIIJH", "E4DRFGYU", "4ERFTGVH", "r5tgyhfgh", "e4r5t6ygv", "u8y7t6fvg", "4567ytfgyf", "h45678yfgy"], "non_matches": ["word's", "test#", "(something)", ";gfiusd", ";igsfdgydfu'", "#ERFGH#$%RTF", "#$RFG", "#$RFG", "FDE#E$RF", "VCFDE$#", "VFRE$#", "GHJKL:#$"], "stress_tests": [], "serial": 392, "problematic": [{"example": ";gfiusd", "is_match": false}]}, {"expression": "^(?:(?:0?[13578]|1[02])|(?:0?[469]|11)(?!\\/31)|(?:0?2)(?:(?!\\/3[01]|\\/29\\/(?:(?:0[^48]|[13579][^26]|[2468][^048])00|(?:\\d{2}(?:0[^48]|[13579][^26]|[2468][^048]))))))\\/(?:0?[1-9]|[12][0-9]|3[01])\\/\\d{4}$", "raw_prompt": "will match all dates in mm/dd/yyyy format. takes into account leap-years and months without 31 days.", "refined_prompt": "will match all dates in mm/dd/yyyy format. takes into account leap-years and months without 31 days.\nMatch examples:\n- \"2/29/2004\"\n- \"07/16/1492\"\n- \"12/31/1999\"\nNon-match examples:\n- \"2/29/2003\"\n- \"2/29/2100\"", "matches": ["2/29/2004", "07/16/1492", "12/31/1999", "02/30/8460", "6/22/5934", "11/30/4139", "10/19/1055", "2/22/1102", "5/08/4565", "11/31/5983", "7/31/6956", "12/31/4190", "10/28/1651"], "non_matches": ["2/29/2003", "2/29/2100", "11/31/2003", "12/123/4322", "2346-2345-2435", "2/3/5235fgsd", "/5/5/5", "/5/5/20022", "432/524/2435", "1-1-2", "(0xx12) 62509", "12/132/90"], "stress_tests": [], "serial": 398, "problematic": [{"example": "02/30/8460", "is_match": true}, {"example": "11/31/5983", "is_match": true}]}, {"expression": "^(((((0[1-9])|(1\\d)|(2[0-8]))[/.-]((0[1-9])|(1[0-2])))|((31[/.-]((0[13578])|(1[02])))|((29|30)[/.-]((0[1,3-9])|(1[0-2])))))[/.-]((000[^0])&amp;([0-9][0-9][0-9][0-9]))|(29[/.-]02[/.-](([0-9][0-9](([02468][48])|([2468][048])|([13579][26])))|((([02468][48])|([2468][048])|([13579][26]))00))))$", "raw_prompt": "Checks 0001-9999\nAlong with leap years\nintermediate symbols can be / or . or -\nthis can be modified easily", "refined_prompt": "Checks 0001-9999\r\nAlong with leap years\r\nintermediate symbols can be / or . or -\nMatch examples:\n- \"29-02/0004\"\n- \"29/02/0004\"\n- \"29.02.9996\"\nNon-match examples:\n- \"29-2-0004\"\n- \"29/02/0005\"", "matches": ["29-02/0004", "29/02/0004", "29.02.9996", "29/02.2868", "29.02.4400", "29-02.2400", "29.02.3796", "29/02/4800", "29-02.8416", "12.31.2023", "10.31.2022", "11.31.2021", "9.31.2020"], "non_matches": ["29-2-0004", "29/02/0005", "29.02.0000", "12/123/4322", "2346-2345-2435", "43.v234", "/5/5/5", "/5/5/20022", "432/524/2435", "1-1-2", "(0xx12) 62509", "12/132/90"], "stress_tests": [], "serial": 410, "problematic": [{"example": "12.31.2023", "is_match": true}, {"example": "10.31.2022", "is_match": true}, {"example": "11.31.2021", "is_match": true}, {"example": "9.31.2020", "is_match": true}]}, {"expression": "^([A-Z]|[a-z]|[0-9])(([A-Z])*(([a-z])*([0-9])*(%)*(&)*(')*(\\+)*(-)*(@)*(_)*(\\.)*)|(\\ )[^ ])+$", "raw_prompt": "will match as long as the only chars exist in the string : A-Z,a-z,0-9,'Space' chr(32),%&amp;'+-@_.\nIt's useful for check vs Account Names where you might want to forbid entering other chars then what is in the pattern. also will not allow repeated space in the string", "refined_prompt": "The provided regex pattern have multiple character groupings and combinations that it can match, including letters (uppercase and lowercase), digits, and special characters like %, &, ', +, -, @, _, and .. It also matches spaces that are not followed by another space.\nMatch examples:\n- \"AccountName_123\"\n- \"Account@email.com\"\n- \"James & Dana Inc.\"\nNon-match examples:\n- \"!MYACCOUNT!\"\n- \"{Superman}\"", "matches": ["AccountName_123", "Account@email.com", "James & Dana Inc.", "sfdtyg", "yhguig", "yg867gik", "guy guygg", "gyugyfu", "yfu", "fuyfi", "uyf", "Ggyu@UIliu", "+fsidhg"], "non_matches": ["!MYACCOUNT!", "{Superman}", "$ Money Man $", "#IJNKJB", "#EDFFGfgh", "$RDFTcfgv", "vgh$RFVcdfvgfvg", "$RDFG#EDFG", "$RTYUI#ERTYUI", "igr4ytre3@#$%^&*", "uytr#$%^&", "4rtyu2345678@#$%^"], "stress_tests": [], "serial": 413, "problematic": [{"example": "+fsidhg", "is_match": true}]}, {"expression": "^([-]?[0-9]?(\\.[0-9]{0,2})?)$|^([-]?([1][0-1])(\\.[0-9]{0,2})?)$|^([-]?([1][0-3](\\.[0]{0,2})))$", "raw_prompt": "This was made for specifying GMT offsets with 2 decimal places. It will validate any number from -12 to 13 with 2 decimal places.", "refined_prompt": "This was made for specifying GMT offsets with 2 decimal places. It will validate any number from -12 to 13 with 2 decimal places.\nMatch examples:\n- \"5\"\n- \"-11.99\"\n- \"12.00\"\nNon-match examples:\n- \"13\"\n- \"-11.999\"", "matches": ["5", "-11.99", "12.00", "1", "2", "3", "4", "9", "8", "-12", "-8", "-9", "-8.54"], "non_matches": ["13", "-11.999", "12.01", "48.8956", "489.489", "-489.78", "894.156", "65.54", "84.978", "89.581", "489.15", "87.544"], "stress_tests": [], "serial": 419, "problematic": [{"example": "-12", "is_match": true}]}, {"expression": "(^[1]$)|(^[1]+\\d*\\.+\\d*[1-5]$)", "raw_prompt": "Simple expression that accepts only values between 1 and 1.5", "refined_prompt": "Simple expression that accepts only values between 1 and 1.5\nMatch examples:\n- \"1\"\n- \"1.4\"\n- \"1.5\"\nNon-match examples:\n- \"2\"\n- \"1.ZZ\"", "matches": ["1", "1.4", "1.5", "1.02", "1.02456", "1.0498563", "1.2489561", "1.4489561", "1.3498563", "1.28456", "1.368543", "1.198765", "1.38451"], "non_matches": ["2", "1.ZZ", "1.6", "1.9456", "1.79856", "894561", "849561", "8453", "687533", ".5fsd", "fsdf8y7uhi", "8guyh"], "stress_tests": [], "serial": 423, "problematic": [{"example": "1.02456", "is_match": true}, {"example": "1.28456", "is_match": true}]}, {"expression": "^(?!0,?\\d)([0-9]{2}[0-9]{0,}(\\.[0-9]{2}))$", "raw_prompt": "Validates currency, must have two leading and two digits following a decimal point. Does not accept leading zero's.", "refined_prompt": "Validates currency, must have two leading and two digits following a decimal point. Does not accept leading zero's.\nMatch examples:\n- \"10.00\"\n- \"32.50\"\n- \"78.85\"\nNon-match examples:\n- \"01.00\"\n- \"12\"", "matches": ["10.00", "32.50", "78.85", "84.95", "95.32", "32.65", "65.97", "97.98", "98.96", "96.32", "31.14", "14.15", "16.17"], "non_matches": ["01.00", "12", "12.0", "156.4856", "516.155", "468.156", "45.789", "987.654", "98563.21", "875.513", "564.389", "983.214"], "stress_tests": [], "serial": 430, "problematic": [{"example": "98563.21", "is_match": false}]}, {"expression": "^[1-9]\\d*\\.?[0]*$", "raw_prompt": "natural numbers 1, 2, 3...\n(no zeros)", "refined_prompt": "natural numbers 1, 2, 3...\r\n(no zeros)\nMatch examples:\n- \"1\"\n- \"2\"\n- \"3\"\nNon-match examples:\n- \"0\"\n- \"1.2\"", "matches": ["1", "2", "3", "465", "4986", "4867", "78961", "465", "15", "97", "65", "32", "455"], "non_matches": ["0", "1.2", "01", ".052.0", "302.02", "02.20.20.2", "20.", "02.02.", "324df", "1-1-2", "(0xx12) 62509", "12/132/90"], "stress_tests": [], "serial": 443, "problematic": [{"example": "20.", "is_match": false}]}, {"expression": "^([Vv]+(erdade(iro)?)?|[Ff]+(als[eo])?|[Tt]+(rue)?|0|[\\+\\-]?1)$", "raw_prompt": "This RegEx will match boolean values, either numeric or literal. It will accept MS Access &quot;-1&quot; values for &quot;true&quot;,\nand recognizes English and Brazilian Portuguese.", "refined_prompt": "This regex pattern is designed to match variations of \"true,\" \"false,\" \"verdadeiro,\" \"falso,\" 0, 1, -1, and +1 in a case-insensitive manner. It will not match strings that don't closely resemble these variations.\nMatch examples:\n- \"False\"\n- \"verdadeiro\"\n- \"0\"\nNon-match examples:\n- \"+0\"\n- \"1-1\"", "matches": ["False", "verdadeiro", "0", "true", "True", "Verdade", "Verdadeiro", "verdadeIRO", "false", "FALSE", "Falso", "FalsEo", "fAlse"], "non_matches": ["+0", "1-1", "Truth", "Falser", "Falsely", "01", "10", "+10", "2", "120", "100", "-100"], "stress_tests": [], "serial": 446, "problematic": [{"example": "verdadeIRO", "is_match": true}, {"example": "FALSE", "is_match": true}, {"example": "FalsEo", "is_match": true}, {"example": "fAlse", "is_match": true}]}, {"expression": "^(\\([2-9]|[2-9])(\\d{2}|\\d{2}\\))(-|.|\\s)?\\d{3}(-|.|\\s)?\\d{4}$", "raw_prompt": "Telephone validator allowing user to enter 10 digit telephone number with segments of number separated by hyphens, periods or spaces. Also braces allowed around area code.", "refined_prompt": "Telephone validator allowing user to enter 10 digit telephone number with segments of number separated by hyphens, periods or spaces. Also braces allowed around area code.\nMatch examples:\n- \"213-123-1234\"\n- \"2131231234\"\n- \"(213) 123-1234\"\nNon-match examples:\n- \"123-123-1234\"\n- \"f34fvfv\"", "matches": ["213-123-1234", "2131231234", "(213) 123-1234", "(874)\u20097326436", "386949-1895", "636 589\u20098765", "(975)3821902", "(453)\ufeff0745764", "(282)989\u20056935", "837867-7509", "4916420842", "827\u2008575\u205f9806", "8968287838"], "non_matches": ["123-123-1234", "f34fvfv", "2534/52435234/2453", "12/123/4322", "2346-2345-2435", "43.v234", "/5/5/5", "12f3.21f3.213f", "432/524/2435", "1-1-2", "abc111def", "++63453.345"], "stress_tests": [], "serial": 455, "problematic": [{"example": "432/524/2435", "is_match": false}]}, {"expression": "^[-+]?[0-9]\\d{0,2}(\\.\\d{1,2})?%?$", "raw_prompt": "Required and regular expression validator. For supporting\n-999.99 to +999.99 . Positive and Negative integer/ decimal validations. Percentage sign is also supported. Will not allow empty strings. Can increase/decrease the range as you need.", "refined_prompt": "Required and regular expression validator. For supporting -999.99 to +999.99 . Positive and Negative integer/ decimal validations. Percentage sign is also supported. Will not allow empty strings.\nMatch examples:\n- \"12.3\"\n- \"123\"\n- \"-123.45\"\nNon-match examples:\n- \"-\"\n- \"10.1234\"", "matches": ["12.3", "123", "-123.45", "4.56", "651", "86", "645", "132", "516.15", "561.54", "453", "987", "516"], "non_matches": ["-", "10.1234", "-1234", "-845.56184", "465.56154", "894561", "456", "849561", "%R^FTY", "5R6TFY", "5R6FTYGUH", "56tfyf156"], "stress_tests": [], "serial": 463, "problematic": [{"example": "456", "is_match": false}]}, {"expression": "^([34|37]{2})([0-9]{13})$", "raw_prompt": "Validate against any american express number. All american express numbers start with either a 34 or 37, followed by 13 other numbers.", "refined_prompt": "Validate against any American express number. All American express numbers start with either a 34 or 37, followed by 13 other numbers.\nMatch examples:\n- \"341256321524212\"\n- \"371524254523125\"\n- \"341234567890123\"\nNon-match examples:\n- \"425152365212542\"\n- \"34256321523621\"", "matches": ["341256321524212", "371524254523125", "341234567890123", "371234567890123", "340000000000000", "370000000000000", "3456789012345", "3743210987654", "3400000000000", "3710000000000", "37432109876543", "34343434343434", "37373737373737"], "non_matches": ["425152365212542", "34256321523621", "3712563212523651", "301234567890123", "561234567890123", "34123456789012A", "3722222222222222", "345678901234567", "330000000000000", "34123456789012", "ABCDEFGHIJKLM", "3412345678901"], "stress_tests": [], "serial": 467, "problematic": [{"example": "3456789012345", "is_match": true}, {"example": "3743210987654", "is_match": true}, {"example": "3400000000000", "is_match": true}, {"example": "3710000000000", "is_match": true}, {"example": "37432109876543", "is_match": true}, {"example": "34343434343434", "is_match": true}, {"example": "37373737373737", "is_match": true}, {"example": "345678901234567", "is_match": false}, {"example": "330000000000000", "is_match": false}]}, {"expression": "^([6011]{4})([0-9]{12})$", "raw_prompt": "Validate against any discover card number. All DC's start with 6011 and are followed by 12 other numbers.", "refined_prompt": "Validate against any discover card number. All DC's start with 6011 and are followed by 12 other numbers.\nMatch examples:\n- \"6011212541254121\"\n- \"6011523654125685\"\n- \"6011123456789012\"\nNon-match examples:\n- \"5021152365212541\"\n- \"601126523652321\"", "matches": ["6011212541254121", "6011523654125685", "6011123456789012", "6011999900001234", "6011999999999999", "6011000000000000", "6011111111111111", "6011888888888888", "6011999900000000", "6011765432109876", "6011222233334444", "6011999900005555", "6011555566667777"], "non_matches": ["5021152365212541", "601126523652321", "60112563212563215", "6111123456789012", "60111234567890123", "60111234567890123", "601199999999999", "60118888888888888", "601100000000000", "601176543210987", "601122223333444", "601199990000A555"], "stress_tests": [], "serial": 468, "problematic": [{"example": "6111123456789012", "is_match": false}]}, {"expression": "^([30|36|38]{2})([0-9]{12})$", "raw_prompt": "Validate against any diner's club card. All diner club cards start with 30,36, or 38, followed by 12 other numbers.", "refined_prompt": "Validate against any diner's club card. All diner club cards start with 30,36, or 38, followed by 12 other numbers.\nMatch examples:\n- \"30125212365212\"\n- \"36125212365212\"\n- \"38125212365212\"\nNon-match examples:\n- \"301252123652121\"\n- \"40256631125452\"", "matches": ["30125212365212", "36125212365212", "38125212365212", "360012345678", "301112345678", "360099990000", "380011112222", "300000000000", "361234567890", "380011112222", "300012345678", "361234567890", "380011112222"], "non_matches": ["301252123652121", "40256631125452", "361251254125212", "6011123456789012", "300012345678901", "3000123456789", "300012345678A", "30001234567", "30001234567890123", "302222222222A", "370012345678", "350012345678"], "stress_tests": [], "serial": 469, "problematic": [{"example": "360012345678", "is_match": true}, {"example": "301112345678", "is_match": true}, {"example": "360099990000", "is_match": true}, {"example": "380011112222", "is_match": true}, {"example": "300000000000", "is_match": true}, {"example": "361234567890", "is_match": true}, {"example": "380011112222", "is_match": true}, {"example": "300012345678", "is_match": true}, {"example": "361234567890", "is_match": true}, {"example": "380011112222", "is_match": true}]}, {"expression": "([^\\.\\?\\!]*)[\\.\\?\\!]", "raw_prompt": "Finds sentences (assuming they end with a full stop, question mark or exclamation mark).", "refined_prompt": "Finds sentences (assuming they end with a full stop, question mark or exclamation mark).\nMatch examples:\n- \"This is a series of sentences.\"\n- \"They end predictably!\"\n- \"Where would we be without punctuation?\"\nNon-match examples:\n- \"This sentence just trails off\"\n- \"fdsa dsfa\"", "matches": ["This is a series of sentences.", "They end predictably!", "Where would we be without punctuation?", "This is a sentence.", "What is your name?", "It's a beautiful day!", "No punctuation here", "I like cats.", "Tell me more about it.", "I don't know.", "A single word!", "Multiple sentences. Separated by punctuation!", "An ellipsis at the end..."], "non_matches": ["This sentence just trails off", "fdsa dsfa", "fasdf 87yguh", "yhub", "8gyubh", "g7yubh uhbj", "j g8uibu8yvu", "67ty", "hubjhuifs dsajfk", "sentence is this", "98yhuijnk g7yufd g7y8hu9fdj", "fewdf"], "stress_tests": [], "serial": 470, "problematic": [{"example": "No punctuation here", "is_match": true}]}, {"expression": "(^[a-zA-Z][a-zA-Z0-9_]*)|(^[_][a-zA-Z0-9_]+)", "raw_prompt": "This pattern can be used for validating a string as a valid element name (e.g. variable or class name) in Microsoft .NET. See also http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vbcn7/html/vbconelementnames.asp", "refined_prompt": "In conclusion, this regex pattern matches strings that start either with an alphabetic character (followed by alphanumeric characters) or with an underscore (followed by alphanumeric characters).\nMatch examples:\n- \"var\"\n- \"_withunder_score99\"\n- \"TeSt\"\nNon-match examples:\n- \"_\"\n- \"123abc\"", "matches": ["var", "_withunder_score99", "TeSt", "sdfyhb", "uyiu", "g8", "uhi7y8", "hui78y", "h87gt", "ytu87t", "_ygug87u", "_hbu9", "gu8h8"], "non_matches": ["_", "123abc", "9", "gyubhj", "67ygv", "6ftyv6rtcf", "65rfty", "4edrt", "09iu%^RFT", "%^RFTYGV", "432Y*UH", "132E$DC"], "stress_tests": [], "serial": 475, "problematic": [{"example": "gyubhj", "is_match": false}]}, {"expression": "^([0-7])*$", "raw_prompt": "Expression validating a octal string of any length.", "refined_prompt": "Expression validating a octal string of any length.\nMatch examples:\n- \"1357\"\n- \"445005\"\n- \"101\"\nNon-match examples:\n- \"900508\"\n- \"7FFF\"", "matches": ["1357", "445005", "101", "764210", "7542", "516", "654654", "546", "45456", "1653216", "56541215156", "4655", "151215"], "non_matches": ["900508", "7FFF", "599D", "7410", "520125", "521041525", "41263144", "415214", "510425414", "415264", "415265241", "54105215214"], "stress_tests": [], "serial": 482, "problematic": [{"example": "7410", "is_match": false}, {"example": "520125", "is_match": false}, {"example": "521041525", "is_match": false}, {"example": "41263144", "is_match": false}, {"example": "415214", "is_match": false}, {"example": "510425414", "is_match": false}, {"example": "415264", "is_match": false}, {"example": "415265241", "is_match": false}, {"example": "54105215214", "is_match": false}]}, {"expression": "([0-9]+\\.[0-9]*)|([0-9]*\\.[0-9]+)|([0-9]+)", "raw_prompt": "This is just a very simple matcher for real numbers.", "refined_prompt": "Simple matcher for real numbers.\nMatch examples:\n- \"123.456\"\n- \".123\"\n- \"123\"\nNon-match examples:\n- \".\"\n- \"apple\"", "matches": ["123.456", ".123", "123", "156.64512", "5612.5612", "7845", "217845", "8956", "84.468", "46.456", "645.46", "456.5468", "7897889"], "non_matches": [".", "apple", "pear", "-123d", "2346-2345-2435", "2/3/5235", "@#dfkjnav", "98iojk", "qwerty@123.123", "1-1-2", "(0xx12) 62509", "++63453.345"], "stress_tests": [], "serial": 494, "problematic": [{"example": "-123d", "is_match": false}, {"example": "2346-2345-2435", "is_match": false}, {"example": "2/3/5235", "is_match": false}, {"example": "98iojk", "is_match": false}, {"example": "qwerty@123.123", "is_match": false}, {"example": "1-1-2", "is_match": false}, {"example": "(0xx12) 62509", "is_match": false}, {"example": "++63453.345", "is_match": false}]}, {"expression": "^(\\$|)([1-9]+\\d{0,2}(\\,\\d{3})*|([1-9]+\\d*))(\\.\\d{2})?$", "raw_prompt": "By combining the contributions from Bri Gipson and Michael Ash in this site. I have come up with this RE to exclude the zero dollar amounts such as $0.00, 0.00, 0, etc.", "refined_prompt": "Matches monetary values with optional dollar signs and supports thousands separators. It enforces that the value must have at least one digit before the decimal point and exactly two digits after the decimal point, if present.\nMatch examples:\n- \"$1,234,567.00\"\n- \"$1234567.00\"\n- \"1234567.00\"\nNon-match examples:\n- \"$1,2345,67.00\"\n- \"$0\"", "matches": ["$1,234,567.00", "$1234567.00", "1234567.00", "$156", "$5464", "54", "54.14", "548.48", "$123.45", "$0.99", "100", "487", "45648"], "non_matches": ["$1,2345,67.00", "$0", "$0.00", "$456.5123", "$65123.0512", "$132.546", "$486.454", "$846.5461586", "4865323.35125123.0512", "com.edu.github", "(0xx12) 62509", "++63453.345"], "stress_tests": [], "serial": 496, "problematic": [{"example": "$0.99", "is_match": true}]}, {"expression": "^[0-9]*(\\.)?[0-9]+$", "raw_prompt": "it will check for the +ve decimal numbers", "refined_prompt": "matches decimal numbers that may or may not have a decimal point. It allows for numbers with leading or trailing digits before and after the decimal point.\nMatch examples:\n- \"1\"\n- \"123\"\n- \"132.132\"\nNon-match examples:\n- \"1.2.2\"\n- \"-123\"", "matches": ["1", "123", "132.132", "56", "657", "456", "35", "24", "78", "56", "35.24", "42.13", "52.13"], "non_matches": ["1.2.2", "-123", "-243", "(12) 324 653210", "234/423/5243", "894561", "-312", "254627g.256", "245/524/12", "354/243/542", "(0xx12) 62509@", "3409fjg43"], "stress_tests": [], "serial": 505, "problematic": [{"example": "894561", "is_match": false}]}, {"expression": "\\w{5,255}", "raw_prompt": "This is User Name &amp; Password validation expression. It does not allow blank spaces as well as special characters like $#%@&amp;*(){}+", "refined_prompt": "This is User Name &amp; Password validation expression. It does not allow blank spaces as well as special characters like $#%@&amp;*(){}+\nMatch examples:\n- \"aa123_ter12\"\n- \"aa4587\"\n- \"784566\"\nNon-match examples:\n- \"123*-/ mksj\"\n- \"c:\\f34fvfv#\"", "matches": ["aa123_ter12", "aa4587", "784566", "56fd67f", "6d65d", "67td", "76f87f", "87yf78", "yf67d", "67d", "67tyd76", "d67y6df", "67y6d76y6dy"], "non_matches": ["123*-/ mksj", "c:\\f34fvfv#", "2534/52435234/2453#", "(12) 324 653210#", "4.23.2423#", "$23.454", "/5/5/5#", "90u09u09##", "u09nKLJG FSL##", "##", "(0xx12) 62509@#", "32542 //#"], "stress_tests": [], "serial": 511, "problematic": [{"example": "67td", "is_match": true}, {"example": "67d", "is_match": true}, {"example": "c:\\f34fvfv#", "is_match": false}, {"example": "2534/52435234/2453#", "is_match": false}, {"example": "(12) 324 653210#", "is_match": false}, {"example": "90u09u09##", "is_match": false}, {"example": "u09nKLJG FSL##", "is_match": false}, {"example": "(0xx12) 62509@#", "is_match": false}, {"example": "32542 //#", "is_match": false}]}, {"expression": "\\b((?:0[1-46-9]\\d{3})|(?:[1-357-9]\\d{4})|(?:[4][0-24-9]\\d{3})|(?:[6][013-9]\\d{3}))\\b", "raw_prompt": "This is my attempt to find out valid german postal codes (PLZ or Postleitzahlen).\nAfter the German Unification the numbers were changed to a five digit system. The postal codes starts with the two digit &quot;Leitzahl&quot;. This is a number between 00 and 99 excluding the not yet used numbers: 00, 05, 43 and 62! After that follows directly a three digit number, 000-999.\nComments welcome. This works for me, however I think it could be written more compact, but could not figure out how ;-)\nFor more information on german postal codes see:\nhttp://de.wikipedia.org/wiki/Liste_der_Postleitbereiche_Deutschland\nhttp://de.wikipedia.org/wiki/Postleitzahl_%28Deutschland%29\nhttp://en.wikipedia.org/wiki/List_of_postal_codes_in_Germany", "refined_prompt": "Find out valid german postal codes (PLZ or Postleitzahlen).\r\nAfter the German Unification the numbers were changed to a five digit system. The postal codes starts with the two digit &quot;Leitzahl&quot;. This is a number between 00 and 99 excluding the not yet used numbers: 00, 05, 43 and 62! After that follows directly a three digit number, 000-999.\nMatch examples:\n- \"12556\"\n- \"01550\"\n- \"80796\"\nNon-match examples:\n- \"05234\"\n- \"8973\"", "matches": ["12556", "01550", "80796", "72495", "41004", "48771", "46277", "45674", "46688", "67500", "63331", "49515", "26134"], "non_matches": ["05234", "8973", "62980", "12/123/4322", "2346-2345-2435", "43.v234", "/5/5/5", "/5/5/20022", "432/524/2435", "adfa2", "(0xx12) 62509", "12/132/90"], "stress_tests": [], "serial": 512, "problematic": [{"example": "/5/5/20022", "is_match": false}]}, {"expression": "^[^\\\\\\/\\?\\*\\&quot;\\'\\&gt;\\&lt;\\:\\|]*$", "raw_prompt": "Validation of a Folder Name. Excludes all forbidden characters", "refined_prompt": "Validation of a Folder Name. Excludes all forbidden characters\nMatch examples:\n- \"321321321 dasds\"\n- \"yugy\"\n- \"f87f7\"\nNon-match examples:\n- \"/\\3fsdfsd\"\n- \"/fsdf\"", "matches": ["321321321 dasds", "yugy", "f87f7", "f76f67", "f78y", "f65", "d6", "f", "g9g", "786f7f8", "g76d545", "u", "7t6"], "non_matches": ["/\\3fsdfsd", "/fsdf", "f/3ef", "f/43/f3", "f3/f", "\\f2\\ewe\\", "\\f23ewsf2\\ef2\\", "\\f3\\ef3w\\", "\\f34et4tg", "\\34grhty", "\\i7f", "dfg4t56\\\\\\///"], "stress_tests": [], "serial": 515, "problematic": [{"example": "yugy", "is_match": true}, {"example": "g9g", "is_match": true}, {"example": "g76d545", "is_match": true}, {"example": "u", "is_match": true}, {"example": "7t6", "is_match": true}]}, {"expression": "^\\$( )*\\d*(.\\d{1,2})?$", "raw_prompt": "Validates US currency but allows for spaces between the dollar sign and dollar amount. If there is cents the period validates to two decimal places", "refined_prompt": "Validates US currency but allows for spaces between the dollar sign and dollar amount. If there is cents the period validates to two decimal places.\nMatch examples:\n- \"$100.00\"\n- \"$100\"\n- \"$10.25\"\nNon-match examples:\n- \"100.\"\n- \"$10.233\"", "matches": ["$100.00", "$100", "$10.25", "$156", "$48956123", "$5353", "$873.45", "$4985", "$834.154", "$87621.12", "$897.98", "$785321.12", "$87.5"], "non_matches": ["100.", "$10.233", "$10.", "$12/123/4322", "$sfalijad234", "$43.v234", "$/5/5/5", "$98iojk", "$526.453.456", "$adfa2", "$(0xx12) 62509", "$12/132/90"], "stress_tests": [], "serial": 525, "problematic": [{"example": "$834.154", "is_match": true}]}, {"expression": "/\\*.+?\\*/", "raw_prompt": "Searches for SQL comments within a T-SQL statement...", "refined_prompt": "Match text enclosed within /* and */ delimiters, including multi-line comments.\nMatch examples:\n- \"/* This is a T-SQL comment! */\"\n- \"/* This is a comment */\"\n- \"/* Another comment */\"\nNon-match examples:\n- \"SELECT * FROM Customers\"\n- \"f34fvfv*/\"", "matches": ["/* This is a T-SQL comment! */", "/* This is a comment */", "/* Another comment */", "/* Comment with * asterisk */", "/* */", "/**/", "/************/", "/**************************/", "/* Comment with escape sequences: \\n \\t \\r */", "/* Comment with no space*/", "/* Comment with some // nested comments */", "/* fadsfsd*/", "/* fasdf156adsf */"], "non_matches": ["SELECT * FROM Customers", "f34fvfv*/", "34f2vf42e*/", "12/123/4322*/", "2346-2345-2435*/", "123*/", "@#dfkjnav*/", "/5/5/20022*/", "432/524/2435*/", "adfa2*/", "(0xx12) 62509*/", "12/132/90*/"], "stress_tests": [], "serial": 526, "problematic": [{"example": "/**/", "is_match": true}]}, {"expression": "^([1-9]{1}(([0-9])?){2})+(,[0-9]{1}[0-9]{2})*$", "raw_prompt": "Matchs comma delimited numbers. Easily changed to allow for other delimiters. (Edit &quot;,&quot;)\nDoes not allow a leading 0\nDoes not allow groups of numbers with less than 3 numbers, exculding the first group.", "refined_prompt": "Matches comma delimited numbers.\r\nDoes not allow a leading 0\r\nDoes not allow groups of numbers with less than 3 numbers, excluding the first group.\nMatch examples:\n- \"123,123,123,123\"\n- \"100,120,000,010,011\"\n- \"1,123,123,123\"\nNon-match examples:\n- \"012,123,123,123\"\n- \"12343,1244,4,12\"", "matches": ["123,123,123,123", "100,120,000,010,011", "1,123,123,123", "56", "156", "453,156", "876", "786,987", "951,564", "987,321", "951,753", "654,321", "786.453"], "non_matches": ["012,123,123,123", "12343,1244,4,12", ",123,123,123", "489,45.632,456", "1895198,4,189,5198", "1951,591,951484,35,43.54", "654,64.,65465", "5,.413,5.1468,4.68,", "35,151.,34.6,4.,5", "3513,5.1,564.1,64.,651561", "519851,.9814.841-458", "9181984181,m86,6"], "stress_tests": [], "serial": 527, "problematic": [{"example": "786.453", "is_match": true}]}, {"expression": "(a(?:[cdefgilmnoqrstuwxz]|ero|(?:rp|si)a)|b(?:[abdefghijmnorstvwyz]iz)|c(?:[acdfghiklmnoruvxyz]|at|o(?:m|op))|d[ejkmoz]|e(?:[ceghrstu]|du)|f[ijkmor]|g(?:[abdefghilmnpqrstuwy]|ov)|h[kmnrtu]|i(?:[delmnoqrst]|n(?:fo|t))|j(?:[emop]|obs)|k[eghimnprwyz]|l[abcikrstuvy]|m(?:[acdeghklmnopqrstuvwxyz]|il|obi|useum)|n(?:[acefgilopruz]|ame|et)|o(?:m|rg)|p(?:[aefghklmnrstwy]|ro)|qa|r[eosuw]|s[abcdeghijklmnortuvyz]|t(?:[cdfghjklmnoprtvwz]|(?:rav)?el)|u[agkmsyz]|v[aceginu]|w[fs]|y[etu]|z[amw])", "raw_prompt": "This regexp matches all existing TLDs (Top-Level Domains) according to IANA specifications as of 14/07/2007.", "refined_prompt": "This regexp matches all existing TLDs (Top-Level Domains) according to IANA specifications as of 14/07/2007.\nMatch examples:\n- \"cat\"\n- \"lb\"\n- \"jobs\"\nNon-match examples:\n- \"huijsdfn\"\n- \"7gyu\"", "matches": ["cat", "lb", "jobs", "sl", "mp", "org", "jo", "fr", "cat", "za", "dm", "tel", "org"], "non_matches": ["huijsdfn", "7gyu", "7g", "67", "f5", "6rt8y", "t67y", "uijo", "ytoi", "GY", "ugY", "GUH"], "stress_tests": [], "serial": 532, "problematic": [{"example": "huijsdfn", "is_match": false}, {"example": "7gyu", "is_match": false}, {"example": "uijo", "is_match": false}, {"example": "ytoi", "is_match": false}, {"example": "ugY", "is_match": false}]}, {"expression": "^(?=.*\\d)(?=.*[a-zA-Z])(?!.*[\\W_\\x7B-\\xFF]).{6,15}$", "raw_prompt": "Password validator\nRequires 6-20 characters including at least 1 upper or lower alpha, and 1 digit.\nIt should disallow just about everything else, inluding extended characters.", "refined_prompt": "Password validator\r\nRequires 6-20 characters including at least 1 upper or lower alpha, and 1 digit.\r\nIt should disallow just about everything else, inluding extended characters.\nMatch examples:\n- \"abc123\"\n- \"BA99342bob\"\n- \"1232z123311\"\nNon-match examples:\n- \"abcdef\"\n- \"123456\"", "matches": ["abc123", "BA99342bob", "1232z123311", "g78uy7f8y", "r6t7", "Dr7t7g", "9ubi89", "gu877fDFSF", "67r", "7g8b9hi0", "g98ADF", "g234t4", "3g42t"], "non_matches": ["abcdef", "123456", "123'ABC", "F^&Y", "GUGYU^%&", "^D%T&^", "6f5&G", "&^FYGU&*", "F&Y", "87gYU&*G", "8&FYU", "&*FUYI"], "stress_tests": [], "serial": 535, "problematic": [{"example": "r6t7", "is_match": true}, {"example": "67r", "is_match": true}, {"example": "3g42t", "is_match": true}]}, {"expression": "^([1-9]{1}[\\d]{0,2}(\\.[\\d]{3})*(\\,[\\d]{0,2})?|[1-9]{1}[\\d]{0,}(\\,[\\d]{0,2})?|0(\\,[\\d]{0,2})?|(\\,[\\d]{1,2})?)$", "raw_prompt": "Numera&#231;&#227;o usar para valores moeda brasileira e de outras regi&#245;es. Dinheiro, money...\nEnjoy! =)", "refined_prompt": "match strings representing numeric values, including integers and decimals, with optional thousands separators (comma) and optional decimal fractions.\nMatch examples:\n- \"123,02\"\n- \"123.456,02\"\n- \"123.456.789,02\"\nNon-match examples:\n- \"123,003\"\n- \"123,123.02\"", "matches": ["123,02", "123.456,02", "123.456.789,02", "1", "12", "123", "1234", "12345", "195", "489", "56", "894156", "45.56"], "non_matches": ["123,003", "123,123.02", "156.156,1651", "156,343.34", "42.424,4343", "4343,43.43414", "2.4344", "3,", "42", ".24242.424", "42,4343.434", "424.4242"], "stress_tests": [], "serial": 542, "problematic": [{"example": "45.56", "is_match": true}, {"example": "3,", "is_match": false}, {"example": "42", "is_match": false}]}, {"expression": "^((0?[1-9]|1[012])(\\s*:\\s*([0-5]\\d))?(\\s*:\\s*([0-5]\\d))?(\\s*([AaPp])[Mm]?)$|(2[0-3]|[1]\\d|0?\\d)(\\s*:\\s*([0-5]\\d))(\\s*:\\s*([0-5]\\d))?)$", "raw_prompt": "Matches a time string. A loose validation for easy user entry. Saves the information needed for a correct time setting.", "refined_prompt": "Match strings representing time in both 12-hour and 24-hour formats. The pattern allows for optional spaces and colons as separators between hours, minutes, and seconds, and it includes an optional \"AM\" or \"PM\" marker for 12-hour time.\nMatch examples:\n- \"3:00:59\"\n- \"12pm\"\n- \"6:30 a\"\nNon-match examples:\n- \"12\"\n- \"25pm\"", "matches": ["3:00:59", "12pm", "6:30 a", "12:34:56", "12:34:56 AM", "12:34:56 PM", "1:23:45 AM", "01:23:45 PM", "01:23:45", "23:59:59", "10:15:30", "01:02:03 PM", "07:45:00 AM"], "non_matches": ["12", "25pm", "6:60 a", "25:61:61", "00:00:61", "00:60:00", "12:34:56 MM", "12:34:56 AMM", "12:34:56 PMM", "01:23:45 AMM", "1:2:3 AMM", "07:45:00 P"], "stress_tests": [], "serial": 558, "problematic": [{"example": "07:45:00 P", "is_match": false}]}, {"expression": "^\\$?([1-9][0-9]{3,}(\\.\\d{2})?|(\\d{1,3}\\,\\d{3}|\\d{1,3}\\,\\d{3}(\\.\\d{2})?)|(\\d{1,3}\\,\\d{3}|\\d{1,3}\\,\\d{3}\\,\\d{3}(\\.\\d{2})?)*)?$", "raw_prompt": "Currency which cannot be less than $1000 and lower than a billion.", "refined_prompt": "Currency which cannot be less than $1000 and lower than a billion.\nMatch examples:\n- \"$1000\"\n- \"$1,000,000.00\"\n- \"9,999\"\nNon-match examples:\n- \"999.00\"\n- \"$1,000,000,000.00\"", "matches": ["$1000", "$1,000,000.00", "9,999", "789456", "798465", "8679", "978426", "8154874", "$48196", "$96149", "$49676", "$491635", "$4196947"], "non_matches": ["999.00", "$1,000,000,000.00", "5.00", "29151891551", "g34rgv", "756", "g34rh6u7", "123", "7kmu8k714", "984", "gfdsg1234r", "159"], "stress_tests": [], "serial": 561, "problematic": [{"example": "29151891551", "is_match": false}]}, {"expression": "(([a-zA-Z]{3}[0-9]{3})|(\\w{2}-\\w{2}-\\w{2})|([0-9]{2}-[a-zA-Z]{3}-[0-9]{1})|([0-9]{1}-[a-zA-Z]{3}-[0-9]{2})|([a-zA-Z]{1}-[0-9]{3}-[a-zA-Z]{2}))", "raw_prompt": "Dutch licenceplate check also including scooters#\nABC123#\n12-AB-AB#\n12-ABC-1#\n1-ABC-12#\nA-123-AB#", "refined_prompt": "Dutch license plate check also including scooters#\r\nABC123#\r\n12-AB-AB#\r\n12-ABC-1#\r\n1-ABC-12#\r\nA-123-AB#\nMatch examples:\n- \"ABC123\"\n- \"12-AB-AB\"\n- \"12-ABC-1\"\nNon-match examples:\n- \"12ABAB\"\n- \"12ABC1\"", "matches": ["ABC123", "12-AB-AB", "12-ABC-1", "o-731-qm", "9-jqy-53", "Ock641", "wnB581", "e6-B3-rR", "6-vqc-10", "7-WSH-38", "jHt284", "HRS486", "08-iBw-4"], "non_matches": ["12ABAB", "12ABC1", "1ABC12", "Mastercard", "sfalijad234", "G6879", "6G789G6879", "878G", "INM0", "9UBIJ", "GY8IJBF", "2EFWDFF"], "stress_tests": [], "serial": 562, "problematic": [{"example": "sfalijad234", "is_match": false}]}, {"expression": "(:[a-z]{1}[a-z1-9\\$#_]*){1,31}", "raw_prompt": "This matches oracle binding variables in SQL. Not sure if it is the same with other RDBMS'", "refined_prompt": "This matches oracle binding variables in SQL. Match strings representing colon-separated tokens. Each token starts with a lowercase letter followed by a combination of lowercase letters, digits, dollar signs ($), hashtags (#), and underscores (_). There can be between 1 and 31 tokens in the string.\nMatch examples:\n- \":x\"\n- \":x1\"\n- \":x#2$\"\nNon-match examples:\n- \":1x\"\n- \":@x\"", "matches": [":x", ":x1", ":x#2$", ":token", ":abc123", ":xyz_123", ":token1:token2", ":token1:token2:token3", ":a:b:c:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z", ":abc:def:ghi:jkl:mno:pqr:stu:vwx:yz", ":token1$token2", ":token#token", ":token_123"], "non_matches": [":1x", ":@x", ":*ac", ":1token", ":1token", ":Token123", ":Token$123", ":TooLongToken1234567890abcdefghij", ":too.many:colons", ":a:b$c#d_e:f_g$h:i_j$k_l$m$n$o$p$q$r$s$t$u$v$w$x$y$z:", "::double::colon:", ":token1 token2"], "stress_tests": [], "serial": 564, "problematic": [{"example": ":too.many:colons", "is_match": false}, {"example": ":a:b$c#d_e:f_g$h:i_j$k_l$m$n$o$p$q$r$s$t$u$v$w$x$y$z:", "is_match": false}, {"example": "::double::colon:", "is_match": false}, {"example": ":token1 token2", "is_match": false}]}, {"expression": "^\\+?\\(?\\d+\\)?(\\s|\\-|\\.)?\\d{1,3}(\\s|\\-|\\.)?\\d{4}$", "raw_prompt": "Simply matches a telephone number. Not meant to be extremly accurate but more for q uick match or extracting from a body of text. Does not support extensions", "refined_prompt": "Match strings representing phone numbers that have a specific format. The phone number can start with an optional plus sign, followed by an optional opening parenthesis, a sequence of digits, an optional closing parenthesis, an optional space, hyphen, or period, a sequence of 1 to 3 digits, and finally, another optional space, hyphen, or period followed by 4 digits.\nMatch examples:\n- \"555 5555\"\n- \"(555) 555-5555\"\n- \"+555 5555555\"\nNon-match examples:\n- \"+ 55 5555\"\n- \"() 555 5555\"", "matches": ["555 5555", "(555) 555-5555", "+555 5555555", "+1234567890", "(123) 456-7890", "123 456 7890", "123.456.7890", "+1(123)456-7890", "12 345-6789", "123.45.6789", "123-4567890", "1(123)-4567890", "+123 45 6789"], "non_matches": ["+ 55 5555", "() 555 5555", "1234567", "12/123/4322", "2346-2345-2435", "43.v234", "@#dfkjnav", "/5/5/20022", "432/524/2435", "341.431v4f3.fv1", "sda sad", "8h98009hu"], "stress_tests": [], "serial": 570, "problematic": [{"example": "+1(123)456-7890", "is_match": true}, {"example": "1(123)-4567890", "is_match": true}, {"example": "1234567", "is_match": false}]}, {"expression": "\\bfor\\b.*[A-Za-z][&lt;&gt; ][\\d]", "raw_prompt": "This regex catches the hard-coded for blocks", "refined_prompt": "Match strings that contain the word \"for\" surrounded by word boundaries, followed by any character, a space, '<', '>', or a space, and then a single digit.\nMatch examples:\n- \"for (i=1;i&lt;7;i++)\"\n- \"for a <5\"\n- \"for b >7\"\nNon-match examples:\n- \"for (i=1;i&lt;MyEnd;i++)\"\n- \"foreach a <5\"", "matches": ["for (i=1;i&lt;7;i++)", "for a <5", "for b >7", "for x <0", "for y >123", "for z 5", "for loop >3", "for <6", "for A <4", "for B >8", "for C <1", "for D >0", "for a >0"], "non_matches": ["for (i=1;i&lt;MyEnd;i++)", "foreach a <5", "while b >7", "forx <0", "for y <", "for <abc>", "no for loop here", "loop for <x>", "for1 <2", "for-loop >3", "for < >", "for 4 <"], "stress_tests": [], "serial": 577, "problematic": [{"example": "for a <5", "is_match": true}, {"example": "for b >7", "is_match": true}, {"example": "for x <0", "is_match": true}, {"example": "for y >123", "is_match": true}, {"example": "for loop >3", "is_match": true}, {"example": "for <6", "is_match": true}, {"example": "for A <4", "is_match": true}, {"example": "for B >8", "is_match": true}, {"example": "for C <1", "is_match": true}, {"example": "for D >0", "is_match": true}, {"example": "for a >0", "is_match": true}]}, {"expression": "\\b(byte|char|short|long|float|int|double|decimal|bool|string)\\b.*\\s[a-zA-Z](?=;)", "raw_prompt": "This regex catches if the variable isn't initialized when it is declared", "refined_prompt": "This regex catches if the variable isn't initialized when it is declared\nMatch examples:\n- \"int a;\"\n- \"int b;\"\n- \"int c;\"\nNon-match examples:\n- \"int a =5;\"\n- \"int x = 5;\"", "matches": ["int a;", "int b;", "int c;", "int d;", "int asadf;", "float fdas;", "string afds;", "double fad;", "byte b;", "short s;", "long l;", "double d;", "decimal dec;"], "non_matches": ["int a =5;", "int x = 5;", "char c = 'A';", "float f = 3.14;", "bool flag = true;", "byte b = 8;", "short s = 42;", "long l = 1234567890;", "double d = 3.14159265359;", "decimal dec = 123.45;", "int count = 0;", "char letter = 'X';"], "stress_tests": [], "serial": 578, "problematic": [{"example": "int asadf;", "is_match": true}, {"example": "float fdas;", "is_match": true}, {"example": "string afds;", "is_match": true}, {"example": "double fad;", "is_match": true}, {"example": "decimal dec;", "is_match": true}]}, {"expression": "(\\bprotected\\b.*(public))|(\\bprivate\\b.*(protected))|(\\bprivate\\b.*(public))", "raw_prompt": "This regex catches illegal precedence order of declerations of a class", "refined_prompt": "match strings that represent an illegal precedence order of declarations within a class, where either the \"protected\" keyword appears before \"public,\" \"private\" appears before \"protected,\" or \"private\" appears before \"public.\"\nMatch examples:\n- \"class SomeClass:private BaseClass1, public BaseClass2, protected BaseClass3\"\n- \"protected void Method() { public int x; }\"\n- \"private string Name; public int Age;\"\nNon-match examples:\n- \"class SomeClass:public BaseClass1, protected BaseClass2, private BaseClass3\"\n- \"public void Method() { protected int x; }\"", "matches": ["class SomeClass:private BaseClass1, public BaseClass2, protected BaseClass3", "protected void Method() { public int x; }", "private string Name; public int Age;", "private double Price; protected internal void Calculate() { public int x; }", "protected string Name; public class MyClass { }", "private void DoSomething() { protected int x; } public string Name;", "private int count; protected string[] items; public void Display() { }", "private int x; public void Method() { protected int y; }", "protected bool IsEnabled; public void Toggle() { }", "public class Test { private int x; protected string y; }", "public void DoWork() { protected int x; private int y; }", "private double[] data; protected internal void Process() { public string name; }", "public class MyClass { protected internal int Value; private string Name; }"], "non_matches": ["class SomeClass:public BaseClass1, protected BaseClass2, private BaseClass3", "public void Method() { protected int x; }", "public int Value; protected internal string Name;", "protected double[] data; public void Process() { }", "protected class MyClass { public int x; private string y; }", "public class Test { protected internal bool IsEnabled; private void Toggle() { } }", "public string[] Names; protected int Count;", "protected void Calculate() { public int x; }", "private int x; public void Method() { protected int y; }", "protected string Name; private class MyClass { }", "protected int count; public void Display() { }", "protected bool IsEnabled; public void Toggle() { }"], "stress_tests": [], "serial": 579, "problematic": [{"example": "public void DoWork() { protected int x; private int y; }", "is_match": true}, {"example": "public class MyClass { protected internal int Value; private string Name; }", "is_match": true}, {"example": "protected double[] data; public void Process() { }", "is_match": false}, {"example": "protected class MyClass { public int x; private string y; }", "is_match": false}, {"example": "protected void Calculate() { public int x; }", "is_match": false}, {"example": "private int x; public void Method() { protected int y; }", "is_match": false}, {"example": "protected int count; public void Display() { }", "is_match": false}, {"example": "protected bool IsEnabled; public void Toggle() { }", "is_match": false}]}, {"expression": "\\b(\\w+).\\1", "raw_prompt": "This regex catches the redundacy of including class names in the name of class properties.", "refined_prompt": "Match strings that represent a redundancy of including class names in the names of class properties.\nMatch examples:\n- \"Book.BookPage\"\n- \"Person.Person\"\n- \"Employee.Employee\"\nNon-match examples:\n- \"Book.Page\"\n- \"Person.Name\"", "matches": ["Book.BookPage", "Person.Person", "Employee.Employee", "Rectangle.Rectangle", "MyClass.MyClass", "Car.Car", "User.User", "Account.Account", "Customer.Customer", "Student.Student", "Product.Product", "Address.Address", "Order.Order"], "non_matches": ["Book.Page", "Person.Name", "Employee.Salary", "Rectangle.Width", "MyClass.Method", "Car.Color", "User.Username", "Account.Balance", "Customer.Email", "Student.Grade", "Product.Price", "Address.City"], "stress_tests": [], "serial": 580, "problematic": [{"example": "User.Username", "is_match": false}]}, {"expression": "\\b(public|private|protected|internal)\\b.*(byte|char|short|long|float|int|double|decimal|bool|string)\\b.*(?=,)", "raw_prompt": "This regex forces the programmer to make only one decleration per line.", "refined_prompt": "The provided regex pattern matches strings containing keywords like \"public,\" \"private,\" \"protected,\" or \"internal\" followed by any text, and then followed by data type keywords such as \"byte,\" \"char,\" \"short,\" \"long,\" \"float,\" \"int,\" \"double,\" \"decimal,\" \"bool,\" or \"string,\" which is then followed by a comma. This regex forces the programmer to make only one decleration per line.\nMatch examples:\n- \"private int height, width;\"\n- \"public byte,\"\n- \"private char,\"\nNon-match examples:\n- \"private int height;\"\n- \"public byte;\"", "matches": ["private int height, width;", "public byte,", "private char,", "protected short,", "internal long,", "public float,", "private int,", "protected double,", "internal decimal,", "public bool,", "private string,", "protected byte,", "internal char,"], "non_matches": ["private int height;", "public byte;", "private char,", "internal int,", "protectedshort,", "public double,", "private string,", "protecteddecimal,", "internal bool,", "public char,", "private short,", "protected long,"], "stress_tests": [], "serial": 581, "problematic": [{"example": "private char,", "is_match": false}, {"example": "internal int,", "is_match": false}, {"example": "public double,", "is_match": false}, {"example": "private string,", "is_match": false}, {"example": "internal bool,", "is_match": false}, {"example": "public char,", "is_match": false}, {"example": "private short,", "is_match": false}, {"example": "protected long,", "is_match": false}]}, {"expression": "((\\bm_[a-zA-Z\\d]*\\b)|(\\bin_[a-zA-Z\\d]*\\b)|(\\bin _[a-zA-Z\\d]*\\b))", "raw_prompt": "This regex limits the use of any special prefix characters to indicate that the variable is scoped to the class.", "refined_prompt": "Matches strings that start with \"m_\" or \"in_\" followed by any combination of letters (both uppercase and lowercase) and digits.\nMatch examples:\n- \"in_name\"\n- \"m_name\"\n- \"m_variable\"\nNon-match examples:\n- \"this.name\"\n- \"gfsdu_*&gyubh\"", "matches": ["in_name", "m_name", "m_variable", "in_value", "in_123", "m_x", "in_test", "m_abc123", "in_abc_xyz", "in_001", "in_7h8ui", "m_h9uib", "in_*&gubh"], "non_matches": ["this.name", "gfsdu_*&gyubh", "34_f2vf42e", "afd_saf.adijs", "sf_alijad234", "2/_3/5235", "_@#dfkjnav", "_98iojk", "_432/524/2435", "34_1.431v4f3.fv1", "(0xv_x12) 62509", "999_99@gmail"], "stress_tests": [], "serial": 582, "problematic": [{"example": "in_abc_xyz", "is_match": true}]}, {"expression": "\\binterface\\b.*(\\bI[_]\\w*\\b)", "raw_prompt": "This regex forbids the use of underscore in the interface decleration.", "refined_prompt": "This regex forbids the use of underscore in the interface decleration.\nMatch examples:\n- \"interface I_Point\"\n- \"interface I_Test\"\n- \"interface I_Something\"\nNon-match examples:\n- \"interface IPoint\"\n- \"interface I\"", "matches": ["interface I_Point", "interface I_Test", "interface I_Something", "interface I_Variable", "interface I_ABC", "interface I_xyz", "interface I_123", "interface I_Test_Interface", "interface I123_Test", "interface I_something_valid", "interface I_valid_name", "interface I_Name_123", "interface I_name_with_underscore"], "non_matches": ["interface IPoint", "interface I", "interface Interface_Name", "interface IName", "interface _Invalid", "interface _No_underscore_here", "interface I_!@#$%^", "interface I_ with_space", "interface NameWithNoSpace", "interface I with space", "interface This Name", "interface Interface_123_"], "stress_tests": [], "serial": 583, "problematic": [{"example": "interface I123_Test", "is_match": true}, {"example": "interface I_!@#$%^", "is_match": false}, {"example": "interface I_ with_space", "is_match": false}]}, {"expression": "^((67\\d{2})|(4\\d{3})|(5[1-5]\\d{2})|(6011))(-?\\s?\\d{4}){3}|(3[4,7])\\d{2}-?\\s?\\d{6}-?\\s?\\d{5}$", "raw_prompt": "Credit Card Validation. Matches Switch/Solo, Visa, MasterCard and Discover in 4-4-4-4/4 4 4 4/4444 format and Amex in 4-6-5/4 6 5/465 format.\nIncludes checks for prefixes, (67 for switch/solo, 4 for visa, 51-55 for MasterCard, 37/34 for Amex and 6011 for Discover.\nMatches all major UK debit and credit cards with spaces dashes or as a continous number", "refined_prompt": "Credit Card Validation. Matches Switch/Solo, Visa, MasterCard and Discover in 4-4-4-4/4 4 4 4/4444 format and Amex in 4-6-5/4 6 5/465 format.\r\nIncludes checks for prefixes, (67 for switch/solo, 4 for visa, 51-55 for MasterCard, 37/34 for Amex and 6011 for Discover.\r\nMatches all major UK debit and credit cards with spaces dashes or as a continous number\nMatch examples:\n- \"4234 1234 1234 1234\"\n- \"5434123412341234\"\n- \"3712 123456 12345\"\nNon-match examples:\n- \"1234123412341234\"\n- \"1111111\"", "matches": ["4234 1234 1234 1234", "5434123412341234", "3712 123456 12345", "3423\u00a0588448 91590", "346579095350813", "455144304631\f7734", "372694292249133", "32490007904801", "3442-62680173169", "4277020086203109", "3468417446\u202f30926", "3756956255-11716", "4821503036505072"], "non_matches": ["1234123412341234", "1111111", "987654321", "784512498561849561", "9485614895614895614865", "7546", "2357", "32", "6845344985613", "48563", "948153", "4895612"], "stress_tests": [], "serial": 591, "problematic": [{"example": "32490007904801", "is_match": true}]}, {"expression": "[^(\\&amp;)](\\w*)+(\\=)[\\w\\d ]*", "raw_prompt": "Query string parser matches and tokenizes each name/value pair for a valid query string.", "refined_prompt": "ntended for parsing and tokenizing name/value pairs in a valid query string. It looks for pairs that start with any character except \"&\" (represented as [^(\\&amp;)]), followed by a series of word characters (represented as (\\w*)+), then an equals sign (=), and finally, a combination of word characters, digits, and spaces ([\\w\\d ]*) for the value part.\nMatch examples:\n- \"name1=value1&amp;name2=value2&amp;...\"\n- \"name=value\"\n- \"username=JohnDoe\"\nNon-match examples:\n- \"anyoldstring\"\n- \"name&value\"", "matches": ["name1=value1&amp;name2=value2&amp;...", "name=value", "username=JohnDoe", "age=25", "city=New York", "product_name=Widget", "category=Electronics", "id=12345", "query=this+is+a+test", "flag=true", "page=1", "multi_word_value=This is a long value", "special_chars=!@#$%^&*()"], "non_matches": ["anyoldstring", "name&value", "gerdf=", "ter=g=df=", "g87yu=9hiubj", "g9ui=", "g78=", "u=", "f67t=", "f67=", "g89ui=", "12/132/90="], "stress_tests": [], "serial": 592, "problematic": [{"example": "gerdf=", "is_match": false}, {"example": "ter=g=df=", "is_match": false}, {"example": "g87yu=9hiubj", "is_match": false}, {"example": "g9ui=", "is_match": false}, {"example": "g78=", "is_match": false}, {"example": "u=", "is_match": false}, {"example": "f67t=", "is_match": false}, {"example": "f67=", "is_match": false}, {"example": "g89ui=", "is_match": false}, {"example": "12/132/90=", "is_match": false}]}, {"expression": "\\\\red([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\\\green([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\\\blue([01]?\\d\\d?|2[0-4]\\d|25[0-5]);", "raw_prompt": "This RegEx will match a RTF color taken from a color tabel in a RTF document (having the form '\\redXXX\\greenXXX\\blueXXX;', where XXX is a number between 0 and 255).", "refined_prompt": "match color values in a specific format. It consists of three parts: red, green, and blue components, each represented by a number between 0 and 255. The regex allows for leading zeros in the numbers.\nMatch examples:\n- \"\\red76\\green157\\blue76;\"\n- \"\\red0\\green0\\blue0;\"\n- \"\\red120\\green120\\blue120;\"\nNon-match examples:\n- \"\\red0\\green\\257\\blue120;\"\n- \"\\red0\\green0\\blue0\"", "matches": ["\\red76\\green157\\blue76;", "\\red0\\green0\\blue0;", "\\red120\\green120\\blue120;", "\\red0\\green128\\blue255;", "\\red255\\green0\\blue0;", "\\red128\\green128\\blue128;", "\\red1\\green1\\blue1;", "\\red25\\green100\\blue200;", "\\red255\\green255\\blue255;", "\\red010\\green020\\blue030;", "\\red002\\green004\\blue006;", "\\red199\\green199\\blue199;", "\\red12\\green34\\blue56;"], "non_matches": ["\\red0\\green\\257\\blue120;", "\\red0\\green0\\blue0", "red120\\green120\\blue120;", "\\red-1\\green128\\blue255;", "\\red256\\green0\\blue0;", "\\red128\\green-128\\blue128;", "\\red1.5\\green1\\blue1;", "\\red255\\green100\\blue256;", "\\red255,255,255;", "\\red10\\green20\\blue30;", "\\red002\\green004\\blue006;", "\\red000\\green000;"], "stress_tests": [], "serial": 593, "problematic": [{"example": "\\red10\\green20\\blue30;", "is_match": false}, {"example": "\\red002\\green004\\blue006;", "is_match": false}]}, {"expression": "(?i:[aeiou]+)\\B", "raw_prompt": "This regular expression matches all interior vowels.\nIf used as a replace, the following strings would result:\nLets meet tomorrow -&gt; Lts mt tmrrw\nPlease come to my party -&gt; Plse cme to my prty\nI like your style -&gt; I lke yr style", "refined_prompt": "This regular expression matches all interior vowels(case-sensitive).\nMatch examples:\n- \"remove all interior vowels\"\n- \"BananA\"\n- \"orangE\"\nNon-match examples:\n- \"A\"\n- \"Cat\"", "matches": ["remove all interior vowels", "BananA", "orangE", "pEar", "COFFEE", "Linguist", "Auto", "Squat", "Zeppelin", "EU", "Robot", "PlaYing", "AeOu"], "non_matches": ["A", "Cat", "Elephant", "Book", "Insect", "Consonant", "U", "Fruit", "Abacus", "Vowel", "Data", "Box"], "stress_tests": [], "serial": 596, "problematic": [{"example": "Cat", "is_match": false}, {"example": "Elephant", "is_match": false}, {"example": "Book", "is_match": false}, {"example": "Insect", "is_match": false}, {"example": "Consonant", "is_match": false}, {"example": "Fruit", "is_match": false}, {"example": "Abacus", "is_match": false}, {"example": "Vowel", "is_match": false}, {"example": "Data", "is_match": false}, {"example": "Box", "is_match": false}]}, {"expression": "^[0-9]*\\/{1}[1-9]{1}[0-9]*$", "raw_prompt": "This regular expression checks if the given string is a fraction. This does not allow 0 either in the numerator or the denominator.", "refined_prompt": "This regular expression checks if the given string is a fraction. This does not allow 0 either in the numerator or the denominator.\nMatch examples:\n- \"1/2\"\n- \"12/325\"\n- \"3/4\"\nNon-match examples:\n- \"-1/2\"\n- \"2se/4rf\"", "matches": ["1/2", "12/325", "3/4", "10/5", "123/456", "9/1", "100/7", "25/8", "33/9", "987/654", "6/11", "777/3", "15/23"], "non_matches": ["-1/2", "2se/4rf", "34f2vf42e", "12/123/4322", "2346-2345-2435", "43.v234", "/5/5/5", "1/0", "0/1", "0/0", "01/2", "0/100"], "stress_tests": [], "serial": 597, "problematic": [{"example": "0/1", "is_match": false}, {"example": "01/2", "is_match": false}, {"example": "0/100", "is_match": false}]}, {"expression": "^((25[0-4]|(2[0-4]|1[0-9]|[1-9]?)[0-9]\\.){3}(25[0-4]|(2[0-4]|1[0-9]|[1-9]?)[0-9]))$", "raw_prompt": "This Regular Expression matches all valid ip-patterns.\n01.02.03.04 is not matched, as leading zeros is not valid a ip-pattern.\n255.255.255.0 is not matched, as 255 is a broadcast identifier, and as such not allowed in ip-patterns.", "refined_prompt": "The provided regex matches valid IP addresses (IPv4) while excluding those with leading zeros and the broadcast identifier \"255.\"\nMatch examples:\n- \"192.168.10.4\"\n- \"130.225.56.40\"\n- \"127.0.0.1\"\nNon-match examples:\n- \"01.02.03.04\"\n- \"255.255.255.0\"", "matches": ["192.168.10.4", "130.225.56.40", "127.0.0.1", "192.168.1.1", "10.0.0.1", "172.16.0.100", "127.0.0.1", "203.45.67.89", "8.8.8.8", "192.0.2.1", "198.51.100.0", "203.0.113.0", "169.254.1.1"], "non_matches": ["01.02.03.04", "255.255.255.0", "abc.def.ghi.jkl", "192.168.01.01", "001.001.001.001", "256.0.0.0", "300.200.100.50", "192.168.1.256", "432/524/2435", "341.431v4f3.fv1", "(0xx12) 62509", "12/132/90"], "stress_tests": [], "serial": 601, "problematic": [{"example": "169.254.1.1", "is_match": true}]}, {"expression": "^((CN=(['\\w\\d\\s\\-\\&amp;\\.]+(\\\\/)*(\\\\,)*)+,\\s*)*(OU=(['\\w\\d\\s\\-\\&amp;\\.]+(\\\\/)*(\\\\,)*)+,\\s*)*(DC=['\\w\\d\\s\\-\\&amp;]+[,]*\\s*){1,}(DC=['\\w\\d\\s\\-\\&amp;]+\\s*){1})$", "raw_prompt": "Matches LDAP path (AdsPath) in Active Directory. Modified version of regex which has been found in library.\nAccepts spaces after , character. Also \\/ and \\, sequences (escapes) in CN or OU name are accepted.", "refined_prompt": "This regex matches LDAP paths (AdsPath) in Active Directory with the following modifications:\r\n\r\nAccepts spaces after the comma character (,).\r\nAccepts \\/ and \\, sequences (escapes) in CN or OU names.\nMatch examples:\n- \"CN=John Smith, OU=Acc, DC=acme, DC=com\"\n- \"CN=John\\, Smith US\\/EXT, OU=Acc, DC=acme ,DC=com\"\n- \"CN=John Doe,OU=Users,DC=mydomain,DC=com\"\nNon-match examples:\n- \"CN=John Smith, OU=Acc, DC=acme\"\n- \"CN=John\\, Smith\\, OU=Acc, DC=acme, DC=com\"", "matches": ["CN=John Smith, OU=Acc, DC=acme, DC=com", "CN=John\\, Smith US\\/EXT, OU=Acc, DC=acme ,DC=com", "CN=John Doe,OU=Users,DC=mydomain,DC=com", "CN=Jane Smith,OU=Sales,DC=example,DC=org", "CN=John/Doe,OU=IT,DC=company,DC=local", "OU=People,OU=Engineers,DC=subdomain,DC=example,DC=org", "CN=Special,User,OU=Development,DC=mydomain,DC=com", "CN=Group,Name,OU=Groups,DC=domain,DC=org", "OU=Admins,OU=Security,DC=mydomain,DC=com", "CN=User1,OU=Test,OU,DC=example,DC=org", "CN=User2,OU=IT,DC=my,domain,DC=local", "CN=John Smith,OU=Users,DC=company,DC=local", "CN=Jane,Doe,OU=Sales,DC=example,DC=org"], "non_matches": ["CN=John Smith, OU=Acc, DC=acme", "CN=John\\, Smith\\, OU=Acc, DC=acme, DC=com", "CN=John Doe, OU=Users, DC=mydomain, DC=com", "CN=Jane Smith, OU=Sales, DC=example, DC=org", "CN=John\\Doe, OU=IT, DC=company, DC=local", "OU=People,OU=Engineers,DC=subdomain,DC=example,DC=org", "CN=Special,User,OU=Development,DC=mydomain,DC=com", "CN=Group;Name,OU=Groups,DC=domain,DC=org", "OU=Admins,OU=Security,DC=mydomain,DC=com", "CN=User1, OU=Test-OU, DC=example, DC=org", "CN=User2, OU=IT, DC=my/domain, DC=local", "CN=John Smith, OU=Users, DC=company, DC=local"], "stress_tests": [], "serial": 602, "problematic": [{"example": "CN=John/Doe,OU=IT,DC=company,DC=local", "is_match": true}, {"example": "CN=Special,User,OU=Development,DC=mydomain,DC=com", "is_match": true}, {"example": "CN=Group,Name,OU=Groups,DC=domain,DC=org", "is_match": true}, {"example": "CN=User1,OU=Test,OU,DC=example,DC=org", "is_match": true}, {"example": "CN=User2,OU=IT,DC=my,domain,DC=local", "is_match": true}, {"example": "CN=Jane,Doe,OU=Sales,DC=example,DC=org", "is_match": true}, {"example": "CN=John Doe, OU=Users, DC=mydomain, DC=com", "is_match": false}, {"example": "CN=Jane Smith, OU=Sales, DC=example, DC=org", "is_match": false}, {"example": "OU=People,OU=Engineers,DC=subdomain,DC=example,DC=org", "is_match": false}, {"example": "CN=Group;Name,OU=Groups,DC=domain,DC=org", "is_match": false}, {"example": "OU=Admins,OU=Security,DC=mydomain,DC=com", "is_match": false}, {"example": "CN=User1, OU=Test-OU, DC=example, DC=org", "is_match": false}, {"example": "CN=John Smith, OU=Users, DC=company, DC=local", "is_match": false}]}, {"expression": "\\s?\\b((?!\\b50\\b|\\b00\\b)\\w*)\\b\\s?", "raw_prompt": "This Expression exclude any word/code from a sentence.\nTo find out all the words except any specific codes/words use this. In this example we will exclude 50 and 00 and find all other words in the sentence.\nExample Text: &quot;Ask me 50 00 times&quot;\nMatches:Ask,me,times\nHere it ignores 50 and 00 and matches the other words. Modify according to your needs. I excluded 50 or 00.", "refined_prompt": "The provided regex can match strings that contain one or more word characters (letters, digits, underscores) but not the exact words \"50\" or \"00\" when they appear as standalone words, with optional leading and trailing whitespace.\nMatch examples:\n- \"ask me 50 times\"\n- \"ask me 00 times\"\n- \"ask me 50 00 times\"\nNon-match examples:\n- \"50\"\n- \"00\"", "matches": ["ask me 50 times", "ask me 00 times", "ask me 50 00 times", "apple", "banana", "12celsius", "dog", "123456", "house", "cat", "text_123", "42degrees", "99redballoons"], "non_matches": ["50", "00", "50degrees", "00_cents", "50", "00", "1001", "50degress", "00afsd", "50fudais", "00fnasdj", "50fads"], "stress_tests": [], "serial": 605, "problematic": [{"example": "50", "is_match": false}, {"example": "00", "is_match": false}, {"example": "50degrees", "is_match": false}, {"example": "00_cents", "is_match": false}, {"example": "50", "is_match": false}, {"example": "00", "is_match": false}, {"example": "1001", "is_match": false}, {"example": "50degress", "is_match": false}, {"example": "00afsd", "is_match": false}, {"example": "50fudais", "is_match": false}, {"example": "00fnasdj", "is_match": false}, {"example": "50fads", "is_match": false}]}, {"expression": "^([12]?[0-9]|3[01])$", "raw_prompt": "This will match numbers in the range 1-31. This is useful for matching the day component of a datetime part.", "refined_prompt": "This will match numbers in the range 1-31. This is useful for matching the day component of a date time part.\nMatch examples:\n- \"1\"\n- \"20\"\n- \"31\"\nNon-match examples:\n- \"1a\"\n- \"32\"", "matches": ["1", "20", "31", "2", "10", "14", "16", "17", "18", "20", "22", "23", "27"], "non_matches": ["1a", "32", "01", "31", "R2", "Y7", "J9", "5D", "V7G", "879", "45", "82"], "stress_tests": [], "serial": 610, "problematic": [{"example": "31", "is_match": false}]}, {"expression": "\\b(((?!\\d\\d\\d)\\d+|1\\d\\d|2[0-4]\\d|25[0-5])(\\b|\\.)){4}", "raw_prompt": "match valid ip", "refined_prompt": "match valid IP addresses in the format of four groups of digits separated by periods. It ensures that each group is within the range 0-255, excluding any groups that start with three consecutive digits.\nMatch examples:\n- \"192.168.0.1\"\n- \"10.0.0.255\"\n- \"211.100.0.0\"\nNon-match examples:\n- \"192.256.0.1\"\n- \"10.0.0.256\"", "matches": ["192.168.0.1", "10.0.0.255", "211.100.0.0", "172.16.31.45", "255.255.255.255", "0.0.0.0", "128.0.0.1", "203.45.67.89", "100.200.150.50", "20.30.40.50", "192.168.1.100", "224.0.0.1", "198.51.100.0"], "non_matches": ["192.256.0.1", "10.0.0.256", "211.100.0.1000", "(12) 324 653210", "234/423/5243", "300.400.500.600", "256.0.0.1", "192.168.300.1", "10.20.30.40.50", "192.168.1.0.1", "999.999.999.999", "123.456.789.0"], "stress_tests": [], "serial": 612, "problematic": [{"example": "10.20.30.40.50", "is_match": false}, {"example": "192.168.1.0.1", "is_match": false}]}, {"expression": "^(0|(-?(((0|[1-9]\\d*)\\.\\d+)|([1-9]\\d*))))$", "raw_prompt": "matches a double number", "refined_prompt": "29/02/1928\nMatch examples:\n- \"-0.5\"\n- \"0.01\"\n- \"15\"\nNon-match examples:\n- \"01\"\n- \"0.2.2\"", "matches": ["-0.5", "0.01", "15", "57", "98", "96", "85", "64", "77", "88", "53", "26", "47"], "non_matches": ["01", "0.2.2", "+5", "r23", "3r43.", "g87", "78g", "6", "65r567", "8e2/2e3", "323e/r23", "23f"], "stress_tests": [], "serial": 615, "problematic": [{"example": "6", "is_match": false}]}, {"expression": "((0[13-7]|1[1235789]|[257][0-9]|3[0-35-9]|4[0124-9]|6[013-79]|8[0124-9]|9[0-5789])[0-9]{3}|10([2-9][0-9]{2}|1([2-9][0-9]|11[5-9]))|14([01][0-9]{2}|715))", "raw_prompt": "Accurate German postal code verification.\nGermany has 5-digit numeric postal codes. The expression evaluates a postal code within state based specific ranges.", "refined_prompt": "Accurate German postal code verification.\r\nGermany has 5-digit numeric postal codes. The expression evaluates a postal code within state based specific ranges.\nMatch examples:\n- \"01125\"\n- \"14177\"\n- \"10591\"\nNon-match examples:\n- \"34125\"\n- \"T34FER\"", "matches": ["01125", "14177", "10591", "10591", "10181", "42212", "14004", "10748", "84046", "14190", "14715", "10179", "10706"], "non_matches": ["34125", "T34FER", "G3QG", "G34ER", "G3RERD", "$23.454", "43-5432", "254627g.256", "245/524/12", "354/243/542", "9/9/9", "3409fjg43"], "stress_tests": [], "serial": 622, "problematic": [{"example": "254627g.256", "is_match": false}]}, {"expression": "^(([a-zA-Z0-9]+([\\-])?[a-zA-Z0-9]+)+(\\.)?)+[a-zA-Z]{2,6}$", "raw_prompt": "Checks domain names. This will match all of the valid domains. It will accept TLD's that are from 2 to 6 characters. You can not have more then one dash or period next to each other. Also it will not let you have dashes at end of the words.", "refined_prompt": "Checks domain names. This will match all of the valid domains. It will accept TLD's that are from 2 to 6 characters. You can not have more then one dash or period next to each other. Also it will not let you have dashes at end of the words.\nMatch examples:\n- \"www.domain.com\"\n- \"your-domain.com\"\n- \"www.sub-domain.your-domain.museum\"\nNon-match examples:\n- \".domain.com\"\n- \"your---domain.com\"", "matches": ["www.domain.com", "your-domain.com", "www.sub-domain.your-domain.museum", "example.com", "my-domain.net", "123abc.info", "sub.domain.co.uk", "a1-b2-c3.xyz", "test-domain.jp", "abc-123.de", "sub.example.mobi", "web-site.org", "123.computer"], "non_matches": [".domain.com", "your---domain.com", "www.-sub-.com", "-invalid.com", "example-.com", "double--dash.net", "domain..", "test--.org", "my_domain.net", ".website.com", "domain.name.", "1234567.com"], "stress_tests": [], "serial": 626, "problematic": [{"example": "1234567.com", "is_match": false}]}, {"expression": "^((0?[1-9])|((1)[0-1]))?((\\.[0-9]{0,2})?|0(\\.[0-9]{0,2}))$", "raw_prompt": "This Regular Expression allows the user to enter a value to represent the imperial measurement of Inches.\nThe expression won't allow and value of 12 or above (otherwise it would be a foot!), and has the option of having a decimal value upto 2 decimal places.\nMy first Regular Expression so go easy on me!! :)", "refined_prompt": "This Regular Expression allows the user to enter a value to represent the imperial measurement of Inches.\r\nThe expression won't allow and value of 12 or above (otherwise it would be a foot!), and has the option of having a decimal value up to 2 decimal places.\nMatch examples:\n- \"11.99\"\n- \"05.5\"\n- \"5\"\nNon-match examples:\n- \"12\"\n- \"12.00\"", "matches": ["11.99", "05.5", "5", "5.25", "11.99", "0.5", "9.75", "10.01", "0.01", "11.5", "10.50", "11.00", "0.99"], "non_matches": ["12", "12.00", "2.587", "10.123", "0.1234", "-5", "13", ".99", "12.00", "12.1", "1.123", "9.009"], "stress_tests": [], "serial": 628, "problematic": [{"example": ".99", "is_match": false}]}, {"expression": "(?=^.{8,30}$)(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[!@#$%^&amp;*()_+}{&quot;&quot;:;'?/&gt;.&lt;,]).*$", "raw_prompt": "Password filter that matches the NSA Password filter DLL ENPASFILT.DLL.\nAt least 1 small-case letter\nAt least 1 Capital letter\nAt least 1 digit\nAt least 1 special character\nLength should be between 8-30 characters.\nSpaces allowed\nThe sequence of the characters is not important.", "refined_prompt": "Password filter that matches the NSA Password filter.\r\nAt least 1 small-case letter\r\nAt least 1 Capital letter\r\nAt least 1 digit\r\nAt least 1 special character\r\nLength should be between 8-30 characters.\r\nSpaces allowed\r\nThe sequence of the characters is not important.\nMatch examples:\n- \"Pa$$w0rd\"\n- \"Passw0rd!\"\n- \"AbcdEfgh1234!\"\nNon-match examples:\n- \"Pa$$word\"\n- \"6f67v7v8yg\"", "matches": ["Pa$$w0rd", "Passw0rd!", "AbcdEfgh1234!", "1Aa@Bb2C!3D", "P@ssw0rd12345", "MyPa55!word", "Secr3t#Code", "123abcDEFG!@#", "P@$$w0rd", "9Inch@Nails", "aB1!cD2@eF3g", "!123AaBbC", "Qwerty@12345"], "non_matches": ["Pa$$word", "6f67v7v8yg", "6v8", "7v87", "v867v", "67vf6yv6YV", "8y7v78v", "78v87gvb8", "7vb7uVYVY", "7VY&BV&", "7v7ug7ug", "7uvy7g6UBUJBNU"], "stress_tests": [], "serial": 629, "problematic": [{"example": "7vb7uVYVY", "is_match": false}, {"example": "7uvy7g6UBUJBNU", "is_match": false}]}, {"expression": "^([\\w]+@([\\w]+\\.)+[a-zA-Z]{2,9}(\\s*;\\s*[\\w]+@([\\w]+\\.)+[a-zA-Z]{2,9})*)$", "raw_prompt": "Validates a semi colon delimited list of email addresses. Appropriate for use with .NET Web.Mail.MailMessage fields (To, BCC, CC)", "refined_prompt": "Validates a semi colon delimited list of email addresses. Appropriate for use with .NET Web.Mail.MailMessage fields (To, BCC, CC)\nMatch examples:\n- \"test1@site.sub.edu ;user@site2.com\"\n- \"email@example.com\"\n- \"user@domain.co.uk;another.email@example.net\"\nNon-match examples:\n- \"test1site.sub.edu ;@site2.com\"\n- \"email@.com\"", "matches": ["test1@site.sub.edu ;user@site2.com", "email@example.com", "user@domain.co.uk;another.email@example.net", "name.lastname@email-address.info;user@email-domain.de", "mail@myserver.org;address@sub.domain.com", "someone@example.org;user@domain.io;another@email-site.co", "email@example.com;another.user@domain.net", "test.email@example.co.uk;user.email@sub.domain.in;one_more@another-domain.io", "first.last@email.org;second.user@sub.domain.com", "email@example.com;user@domain.net;more.emails@email-site.co", "example@mail.org;address@sub.domain.io", "test.email@example.org;user.email@sub.domain.io;one.more@email-site.co", "email@example.com;user@domain.net;another@email-address.info"], "non_matches": ["test1site.sub.edu ;@site2.com", "email@.com", "@example.com", "email@domain", "email@.co.uk", "user@domain@.net", "email@domain..com", "user@domain.net;", "email@example.com;user@.net", "email@domain.;user@.com", "email@.org;user@.info", "user@domain.com;email@.co"], "stress_tests": [], "serial": 631, "problematic": [{"example": "user@domain.co.uk;another.email@example.net", "is_match": true}, {"example": "name.lastname@email-address.info;user@email-domain.de", "is_match": true}, {"example": "someone@example.org;user@domain.io;another@email-site.co", "is_match": true}, {"example": "email@example.com;another.user@domain.net", "is_match": true}, {"example": "test.email@example.co.uk;user.email@sub.domain.in;one_more@another-domain.io", "is_match": true}, {"example": "first.last@email.org;second.user@sub.domain.com", "is_match": true}, {"example": "email@example.com;user@domain.net;more.emails@email-site.co", "is_match": true}, {"example": "test.email@example.org;user.email@sub.domain.io;one.more@email-site.co", "is_match": true}, {"example": "email@example.com;user@domain.net;another@email-address.info", "is_match": true}]}, {"expression": "<img[^>]* src=\\\"([^\\\"]*)\\\"[^>]*>", "raw_prompt": "It searches for a IMG tag and group information about source of image.", "refined_prompt": "This regex appears to match HTML image (<img>) tags and extracts the value of the src attribute.\nMatch examples:\n- \"<img src=\"joka.jpg\" /> <img src=\"joka.jpg\">\"\n- \"<img src=\"image.jpg\" alt=\"A beautiful image\">\"\n- \"<img src=\"picture.png\">\"\nNon-match examples:\n- \"<img> <img src=dada>\"\n- \"<img alt=\"No source\">\"", "matches": ["<img src=\"joka.jpg\" /> <img src=\"joka.jpg\">", "<img src=\"image.jpg\" alt=\"A beautiful image\">", "<img src=\"picture.png\">", "<img src=\"https://example.com/image.jpg\" alt=\"Another image\">", "<img src='image.png' width=\"100\" height=\"100\">", "<img src=\"path/to/image.jpg\">", "<img src=\"https://domain.com/image.png\">", "<img src='image.gif' alt=\"GIF image\">", "<img src=\"image.jpeg\" data-description=\"A photo\">", "<img src=\"https://example.org/pic.jpg\" alt=\"Pic\">", "<img src='https://example.com/logo.png' title=\"Company logo\">", "<img src=\"relative/path/to/image.jpg\">", "<img src=\"https://cdn.example.com/banner.png\" alt=\"Banner\">"], "non_matches": ["<img> <img src=dada>", "<img alt=\"No source\">", "<img alt=\"Empty source\" src=\"\">", "<div><img src=\"nested-image.jpg\"></div>", "<img src=image.jpg>", "<img src='image without quotes.png' alt=\"No quotes\">", "<img src='https://example.com/banner.jpg' class=\"banner\">", "<img alt=\"No src attribute\">", "<img src='https://example.com/missingquotes.jpg\" alt=\"Closing quote missing>", "<img src='missingquotes.jpg alt=\"Missing quotes'>", "<img src//example.org/image.gif\" width=\"200\" height=\"200\">", "<img src=e.jpg\" data-src=\"lazy.jpg\">"], "stress_tests": [], "serial": 636, "problematic": [{"example": "<img src='image.png' width=\"100\" height=\"100\">", "is_match": true}, {"example": "<img src='image.gif' alt=\"GIF image\">", "is_match": true}, {"example": "<img src='https://example.com/logo.png' title=\"Company logo\">", "is_match": true}, {"example": "<img alt=\"Empty source\" src=\"\">", "is_match": false}, {"example": "<div><img src=\"nested-image.jpg\"></div>", "is_match": false}]}, {"expression": "^((((((0[13578])|(1[02]))[\\s\\.\\-\\/\\\\]?((0[1-9])|([12][0-9])|(3[01])))|(((0[469])|(11))[\\s\\.\\-\\/\\\\]?((0[1-9])|([12][0-9])|(30)))|((02)[\\s\\.\\-\\/\\\\]?((0[1-9])|(1[0-9])|(2[0-8]))))[\\s\\.\\-\\/\\\\]?(((([2468][^048])|([13579][^26]))00)|(\\d\\d\\d[13579])|(\\d\\d[02468][^048])|(\\d\\d[13579][^26])))|(((((0[13578])|(1[02]))[\\s\\.\\-\\/\\\\]?((0[1-9])|([12][0-9])|(3[01])))|(((0[469])|(11))[\\s\\.\\-\\/\\\\]?((0[1-9])|([12][0-9])|(30)))|((02)[\\s\\.\\-\\/\\\\]?((0[1-9])|([12][0-9]))))[\\s\\.\\-\\/\\\\]?(((([2468][048])|([13579][26]))00)|(\\d\\d[2468][048])|(\\d\\d[13579][26])|(\\d\\d0[48]))))$", "raw_prompt": "This was made for use in javascript to detect MMDDYYYY formatted text. It tests all valid dates, including 31 vs 30 days in a month and the 28 vs 29 leap year rules which exclude centennial years not divisible by 400 and years not divisible by 4.", "refined_prompt": "This was made for use in javascript to detect MMDDYYYY formatted text. It tests all valid dates, including 31 vs 30 days in a month and the 28 vs 29 leap year rules which exclude centennial years not divisible by 400 and years not divisible by 4.\nMatch examples:\n- \"02292000\"\n- \"10\u00a004\u20020420\"\n- \"0212\u202f4644\"\nNon-match examples:\n- \"02291700\"\n- \"52/2/54/245\"", "matches": ["02292000", "10\u00a004\u20020420", "0212\u202f4644", "02\u180e099608", "01\ufeff309763", "04\f302408", "10135721", "01182711", "09206372", "02097204", "1208\ufeff6915", "08127208", "11248400"], "non_matches": ["02291700", "52/2/54/245", "2534/52435234/2453", "(12) 324 653210", "234/423/5243", "$23.454", "43-5432", "254627g.256", "245/524/12", "354/243/542", "(0xx12) 62509@", "3409fjg43"], "stress_tests": [], "serial": 637, "problematic": [{"example": "02\u180e099608", "is_match": true}, {"example": "01\ufeff309763", "is_match": true}, {"example": "1208\ufeff6915", "is_match": true}]}, {"expression": "^[$]?[0-9]*(\\.)?[0-9]?[0-9]?$", "raw_prompt": "Should match prices with or without a dollar sign.", "refined_prompt": "Should match prices with or without a dollar sign.\nMatch examples:\n- \"4.42\"\n- \"$4.42\"\n- \"524.52\"\nNon-match examples:\n- \"asdf\"\n- \"52/2/54/245\"", "matches": ["4.42", "$4.42", "524.52", "$54.35", "63.23", "$53.65", "73.34", "$63.65", "372.76", "$3563.36", "6432.65", "$25436.43", "7356.43"], "non_matches": ["asdf", "52/2/54/245", "2534/52435234/2453", "INDIANA", "234", "$23.454", "43-5432", "254627g.256", "245/524/12", "354/243/542", "(0xx12) 62509@", "3409fjg43"], "stress_tests": [], "serial": 639, "problematic": [{"example": "234", "is_match": false}]}, {"expression": "^.*(([^\\.][\\.][wW][mM][aA])|([^\\.][\\.][mM][pP][3]))$", "raw_prompt": "Matches a file name to be either a .wma or .mp3 file. This can be used to check file uploads to make sure they are of a certain type. Substitute letters where appropriate for specific file types. This is a better solution (I think) than #343. Works in Javascript and C#.", "refined_prompt": "Matches a file name to be either a .wma or .mp3 file. This can be used to check file uploads to make sure they are of a certain type. Substitute letters where appropriate for specific file types. This is a better solution (I think) than #343. Works in Javascript and C#.\nMatch examples:\n- \"thisfile.mp3\"\n- \"tH@tfile.wma\"\n- \"fweds.wma\"\nNon-match examples:\n- \"whatever.exe\"\n- \"somethingelse.mpa\"", "matches": ["thisfile.mp3", "tH@tfile.wma", "fweds.wma", "gyugty87.mp3", "vyv7.mp3", "vtgyv7tgvty.mp3", "fds7tv7.mp3", "gt7.mp3", "ygv.mp3", "tvtv7tv.mp3", "fdsuihygu.wma", "iuo9.wma", ".wmaiuybg"], "non_matches": ["whatever.exe", "somethingelse.mpa", "thisagain.wm3", "filenamemp3", "filename..mp3", "filename.wmap3", "fadsf.89hew", "tygufwe.fwh.g8", "000-0.00", "354/243/.542", "abc111.def", "$12/132/.90"], "stress_tests": [], "serial": 641, "problematic": [{"example": ".wmaiuybg", "is_match": true}]}, {"expression": "<meta[\\s]+[^>]*?name[\\s]?=[\\s\\\"\\']+(.*?)[\\s\\\"\\']+content[\\s]?=[\\s\\\"\\']+(.*?)[\\\"\\']+.*?>", "raw_prompt": "This pattern intercept meta tags, the name can be found in $1 the content value in $2.", "refined_prompt": "match HTML <meta> tags with specific attributes for \"name\" and \"content\" within them.\nMatch examples:\n- \"<meta name=\"Author\" content=\"xxxxxx\"> <meta name=\"description\" content=\"xxxxxxxxx\"> <meta name=\"keywords\" content=\"xxxxxxxxx\"> <meta name=\"country\" content=\"IT\">\"\n- \"<meta name=\"description\" content=\"This is a description\">\"\n- \"<meta name=\"keywords\" content=\"regex, HTML, meta\">\"\nNon-match examples:\n- \"any other tags\"\n- \"c:\\f34fvfv\"", "matches": ["<meta name=\"Author\" content=\"xxxxxx\"> <meta name=\"description\" content=\"xxxxxxxxx\"> <meta name=\"keywords\" content=\"xxxxxxxxx\"> <meta name=\"country\" content=\"IT\">", "<meta name=\"description\" content=\"This is a description\">", "<meta name=\"keywords\" content=\"regex, HTML, meta\">", "<meta name=\"author\" content=\"John Doe\">", "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">", "<meta name=\"robots\" content=\"index, follow\">", "<meta name=\"csrf-token\" content=\"abc123def456\">", "<meta name=\"og:title\" content=\"OpenAI\">", "<meta name='description' content='Another example'>", "<meta name=\"description\" content=\"\">", "<meta name=\"description\" content=\"Multiple\" attribute=\"values\">", "<meta name=\"description\" content=\"Unescaped &amp; char\">", "<meta content=\"No name attribute\">"], "non_matches": ["any other tags", "c:\\f34fvfv", "<meta>", "<meta name=\"description\">", "<meta content=\"Missing closing tag\"", "there is a boy", "-312", "254627g.256", "245/524/12", "354/243/542", "9/9/9", "3409fjg43"], "stress_tests": [], "serial": 650, "problematic": [{"example": "<meta content=\"No name attribute\">", "is_match": true}]}, {"expression": "^((\\d{2}(([02468][048])|([13579][26]))[\\-\\/\\s]?((((0?[13578])|(1[02]))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])))))|(\\d{2}(([02468][1235679])|([13579][01345789]))[\\-\\/\\s]?((((0?[13578])|(1[02]))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\\-\\/\\s]?((0?[1-9])|(1[0-9])|(2[0-8]))))))(\\s(((0?[1-9])|(1[0-9])|(2[0-3]))\\:([0-5][0-9])((\\s)|(\\:([0-5][0-9])))?))?$", "raw_prompt": "Date YYYY-MM-DD (optional time HH:MM(optional seconds :SS)). Was borrowed from this [http://regexlib.com/REDetails.aspx?regexp_id=390] but changed to use 24 hour time and optional seconds. You can use / - or space for date delimiters, so 2004-12-31 works just as well as 2004/12/31. Checks leap year from 1901 to 2099.", "refined_prompt": "Date YYYY-MM-DD (optional time HH:MM(optional seconds :SS)). Was borrowed from this [http://regexlib.com/REDetails.aspx?regexp_id=390] but changed to use 24 hour time and optional seconds. You can use / - or space for date delimiters, so 2004-12-31 works just as well as 2004/12/31. Checks leap year from 1901 to 2099.\nMatch examples:\n- \"2006-1-20\"\n- \"2006/01/20\"\n- \"2006-01-20 15:30\"\nNon-match examples:\n- \"2003-2-29\"\n- \"2003-13-02\"", "matches": ["2006-1-20", "2006/01/20", "2006-01-20 15:30", "2006-01-20 15:30:21", "74871110", "9616223", "58970731", "22:11", "5158\u20060211", "2002-10-12", "2002-11-13", "2003-12-18", "2008-10-30"], "non_matches": ["2003-2-29", "2003-13-02", "2003-2-2 10:72:30", "(12) 324 653210", "234/423/5243", "$23.454", "43-5432", "254627g.256", "245/524/12", "354/243/542", "(0xx12) 62509@", "3409fjg43"], "stress_tests": [], "serial": 669, "problematic": [{"example": "22:11", "is_match": true}]}, {"expression": "^(([1-9]{1}\\d{0,2},(\\d{3},)*\\d{3})|([1-9]{1}\\d{0,}))$", "raw_prompt": "Matches whole numbers only, including comma separated. Does not allow leading zeros. To match comma separated numbers only, change \"\\d{0,}\" to \"\\d{0,2}\". To match 0, add \"|([0])\" before \")$\". If you want to use it with Java's regexp match(), remove \"^(\" and \")$\" since they are not needed.", "refined_prompt": "Matches whole numbers only, including comma separated. Does not allow leading zeros.\nMatch examples:\n- \"10\"\n- \"1000\"\n- \"1,000\"\nNon-match examples:\n- \"01\"\n- \"001,000\"", "matches": ["10", "1000", "1,000", "10,000,000", "54", "987", "347", "757", "769", "435", "346778", "57864", "32978"], "non_matches": ["01", "001,000", "1000,000", "4287g", "76f", "67f56", "d65f", "7008h0", "0h8ih", "0h00h0h898", "0087897678", "785687"], "stress_tests": [], "serial": 672, "problematic": [{"example": "785687", "is_match": false}]}, {"expression": "([a-zA-Z0-9_\\-\\.]+)(@[a-zA-Z0-9_\\-\\.]+)", "raw_prompt": "matches any email address, where a @ is contained", "refined_prompt": "Matches email-like patterns where the first part consists of alphanumeric characters, underscores, hyphens, and dots, followed by the \"@\" symbol, and then another part with similar characters, underscores, hyphens, and dots.\nMatch examples:\n- \"kis.hajnalka@gmail.com\"\n- \"user@example.com\"\n- \"john.doe@email.co\"\nNon-match examples:\n- \"www.google.com\"\n- \"@incomplete-email.\"", "matches": ["kis.hajnalka@gmail.com", "user@example.com", "john.doe@email.co", "info@email-provider.net", "my_address@sub.domain", "user_123@website.com", "jane-doe@my.site", "user.name@company.io", "test-address@email.org", "web.master@email.host", "support@123-site.com", "sales@my-company.net", "contact@webpage.info"], "non_matches": ["www.google.com", "@incomplete-email.", "user@incomplete.", "user.@domain.com", "user@.dot.com", "user@-hyphen.com", "user@_underscore.com", "user.domain@com", "user@.", "user@com", "@missing-username.com", "@incomplete-email.afds"], "stress_tests": [], "serial": 673, "problematic": [{"example": "user@incomplete.", "is_match": false}, {"example": "user.@domain.com", "is_match": false}, {"example": "user@.dot.com", "is_match": false}, {"example": "user@-hyphen.com", "is_match": false}, {"example": "user@_underscore.com", "is_match": false}, {"example": "user.domain@com", "is_match": false}, {"example": "user@.", "is_match": false}, {"example": "user@com", "is_match": false}]}, {"expression": "\\d{2,4}", "raw_prompt": "\\d{2,4} matches at least 2 but no more than 4 digits", "refined_prompt": "matches at least 2 but no more than 4 digits\nMatch examples:\n- \"123\"\n- \"12\"\n- \"1234\"\nNon-match examples:\n- \"1\"\n- \"6\"", "matches": ["123", "12", "1234", "475", "4752", "678", "345", "987", "137", "9769", "567", "38", "97"], "non_matches": ["1", "6", "9", "4", "9", "6.4253", "945453", "87086985", "7578t97", "6878", "6ft", "56f6"], "stress_tests": [], "serial": 679, "problematic": [{"example": "6.4253", "is_match": false}, {"example": "945453", "is_match": false}, {"example": "87086985", "is_match": false}, {"example": "7578t97", "is_match": false}, {"example": "6878", "is_match": false}, {"example": "56f6", "is_match": false}]}, {"expression": "^[\"a-zA-Z0-9\\040]+$", "raw_prompt": "Accepts words or quoted phrases for search strings. Stops SQL injection.", "refined_prompt": "Matches a string that consists of alphanumeric characters (letters and digits) and space characters, enclosed within double quotes.\nMatch examples:\n- \"2 words \"Search String\"\"\n- \"\"Hello World\"\"\n- \"\"12345\"\"\nNon-match examples:\n- \"hi' or 1=1--\"\n- \"JustText\"", "matches": ["2 words \"Search String\"", "\"Hello World\"", "\"12345\"", "\"abc def\"", "\"A B C\"", "\"1 2 3\"", "\"Special $ymbols\"", "\"Alphanumerics123\"", "\" Spaces Included \"", "\"Lowercase letters\"", "\"Capital Letters\"", "\"Multiple Spaces \"", "\"123 ABC DEF\""], "non_matches": ["hi' or 1=1--", "JustText", "2534/52435234/2453", "afdsaf.adijs", "9ijn", "there is a boy", "-312", "2546dgwre", "u09nKLJG FSL", "com.edu.github", "abc111def", "8h98009hu"], "stress_tests": [], "serial": 681, "problematic": [{"example": "\"Special $ymbols\"", "is_match": true}, {"example": "JustText", "is_match": false}, {"example": "9ijn", "is_match": false}, {"example": "there is a boy", "is_match": false}, {"example": "2546dgwre", "is_match": false}, {"example": "u09nKLJG FSL", "is_match": false}, {"example": "abc111def", "is_match": false}, {"example": "8h98009hu", "is_match": false}]}, {"expression": "<(?![!/]?[ABIU][>\\s])[^>]*>", "raw_prompt": "Used to return all the html tags and closing tags in a section of html. Can be used to replace all the tags with nothing or itterate through them.", "refined_prompt": "matches HTML-like opening tags (<tag>) that are not followed by certain specific closing tags (</A>, </B>, </I>, </U>), allowing for any other HTML tags.\nMatch examples:\n- \"<u><b>hello</b></u>\"\n- \"<div>\"\n- \"<span>\"\nNon-match examples:\n- \"hello\"\n- \"</A>\"", "matches": ["<u><b>hello</b></u>", "<div>", "<span>", "<p>", "<a href=\"#\">", "<h1>", "<img src=\"image.jpg\">", "<em>", "<ul>", "<li>", "<table>", "<tr>", "<td>"], "non_matches": ["hello", "</A>", "</B>", "</I>", "</U>", "</a>", "<!DOCTYPE html>", "<!-- Comment -->", "</div>", "</span>", "</p>", "<b>"], "stress_tests": [], "serial": 684, "problematic": [{"example": "</a>", "is_match": false}, {"example": "<!DOCTYPE html>", "is_match": false}, {"example": "<!-- Comment -->", "is_match": false}, {"example": "</div>", "is_match": false}, {"example": "</span>", "is_match": false}, {"example": "</p>", "is_match": false}, {"example": "<b>", "is_match": false}]}, {"expression": "((<body)|(<BODY))([^>]*)>", "raw_prompt": "find the body-tag of a html page", "refined_prompt": "match HTML body tags in both lowercase and uppercase, capturing any content within the tags.\nMatch examples:\n- \"<body><BODY bgcolor=\"#ffffff\" text=\"#000000\" marginwidth=\"0\" marginheight=\"0\">\"\n- \"<body>\"\n- \"<BODY>\"\nNon-match examples:\n- \"all non body tags\"\n- \"<head>\"", "matches": ["<body><BODY bgcolor=\"#ffffff\" text=\"#000000\" marginwidth=\"0\" marginheight=\"0\">", "<body>", "<BODY>", "<body class=\"main\">", "<BODY id=\"content\">", "<body data-role=\"page\">", "<BODY style=\"background-color: white;\">", "<body   >", "<body   >", "<body>", "<BODY>", "<body lang=\"en\">", "<BODY dir=\"rtl\">"], "non_matches": ["all non body tags", "<head>", "</body>", "<footer>", "<bODY>", "<body/>", "<div class=\"body\">", "<body contenteditable=\"true\">", "<BODY lang=\"fr\">", "<body id=\"content\" />", "<BODY></BODY>", "<<body>"], "stress_tests": [], "serial": 685, "problematic": [{"example": "<body/>", "is_match": false}, {"example": "<body contenteditable=\"true\">", "is_match": false}, {"example": "<BODY lang=\"fr\">", "is_match": false}, {"example": "<body id=\"content\" />", "is_match": false}, {"example": "<BODY></BODY>", "is_match": false}, {"example": "<<body>", "is_match": false}]}, {"expression": "^<a[^>]*(http://[^\"]*)[^>]*>([ 0-9a-zA-Z]+)</a>$", "raw_prompt": "This pattern matches link tags in html and returns the contents of the href attribute and the text of the link.", "refined_prompt": "This pattern matches link tags in html and returns the contents of the href attribute and the text of the link.\nMatch examples:\n- \"<a href=\"http://www.google.com\">Google</a>\"\n- \"<a href=\"http://example.com\">Link</a>\"\n- \"<a href=\"http://www.example.org\">Text</a>\"\nNon-match examples:\n- \"<a name=\"bookmark\">something</a>\"\n- \"<a href=\"https://example.com\">Secure Link</a>\"", "matches": ["<a href=\"http://www.google.com\">Google</a>", "<a href=\"http://example.com\">Link</a>", "<a href=\"http://www.example.org\">Text</a>", "<a href=\"http://github.com\">GitHub</a>", "<a href=\"http://en.wikipedia.org\">Wikipedia</a>", "<a href=\"http://www.openai.com\">OpenAI</a>", "<a href=\"http://example123.net\">123</a>", "<a href=\"http://test.com\">Test</a>", "<a href=\"http://example-site.org\">Example</a>", "<a href=\"http://website123.com\">Website</a>", "<a href=\"http://123abc.org\">123ABC</a>", "<a href=\"http://regex101.com\">Regex101</a>", "<a href=\"http://abc123.net\">ABC123</a>"], "non_matches": ["<a name=\"bookmark\">something</a>", "<a href=\"https://example.com\">Secure Link</a>", "<a href=\"ftp://example.org\">FTP Link</a>", "<a href=\"http://example.com\" target=\"_blank\">Blank Target</a>", "234/423/5243", "3nf@", "43-5432", "254627g.256", "u09nKLJG FSL", "354/243/542", "(0xx12) 62509@", "3409fjg43"], "stress_tests": [], "serial": 686, "problematic": [{"example": "<a href=\"http://example.com\" target=\"_blank\">Blank Target</a>", "is_match": false}]}, {"expression": "<\\s*?[^>]+\\s*?>", "raw_prompt": "This simple pattern is useful for removing all HTML tags with or without atributes. It has no removing white spaces", "refined_prompt": "This simple pattern is useful for removing all HTML tags with or without atributes. It has no removing white spaces\nMatch examples:\n- \"< html >\"\n- \"< div style=\"title_1\" class='number'>\"\n- \"< div style=\"title_1\" class='number' >\"\nNon-match examples:\n- \"Plain text\"\n- \"<div class=\"container\">\"", "matches": ["< html >", "< div style=\"title_1\" class='number'>", "< div style=\"title_1\" class='number' >", "< img src=\"img.gif\" / >", "<div>", "<span>", "<a href=\"https://example.com\">", "<img src=\"image.jpg\">", "<p class=\"paragraph\">", "<ul>", "<li>Item 1</li>", "<h1>Title</h1>", "<table border=\"1\">"], "non_matches": ["Plain text", "<div class=\"container\">", "<span style=\"font-size: 16px;\">", "</a>", "<img>", "<p>", "<ul type=\"circle\">", "<li>Item 2</li>", "<h2>Subtitle</h2>", "</table>", "<td>Data</td>", "<td>Data</td>"], "stress_tests": [], "serial": 691, "problematic": [{"example": "<div class=\"container\">", "is_match": false}, {"example": "<span style=\"font-size: 16px;\">", "is_match": false}, {"example": "</a>", "is_match": false}, {"example": "<img>", "is_match": false}, {"example": "<p>", "is_match": false}, {"example": "<ul type=\"circle\">", "is_match": false}, {"example": "<li>Item 2</li>", "is_match": false}, {"example": "<h2>Subtitle</h2>", "is_match": false}, {"example": "</table>", "is_match": false}, {"example": "<td>Data</td>", "is_match": false}, {"example": "<td>Data</td>", "is_match": false}]}, {"expression": "^(?=.*[a-z].*[a-z])(?=.*[A-Z].*[A-Z])(?=.*\\d.*\\d)(?=.*\\W.*\\W)[a-zA-Z0-9\\S]{9,}$", "raw_prompt": "This pattern requires at least two lowercase letters, two uppercase letters, two digits, and two special characters. There must be a minimum of 9 characters total, and no white space characters are allowed.", "refined_prompt": "This pattern requires at least two lowercase letters, two uppercase letters, two digits, and two special characters. There must be a minimum of 9 characters total, and no white space characters are allowed.\nMatch examples:\n- \"A1!B2@cde\"\n- \"Abc12@XYZ\"\n- \"Pa$$w0rd123\"\nNon-match examples:\n- \"ABC!@#123\"\n- \"f6t7f\"", "matches": ["A1!B2@cde", "Abc12@XYZ", "Pa$$w0rd123", "1aB2C#dEf", "$ecUrE8+Pwd", "P@sswOrd&123", "123aB!Xyz", "P@$$w0rD!z", "9pAsSWoRd@", "L3tM3!n0w", "AbC12!D3f", "Pwd@12aBCD", "7P@$$w#Rd"], "non_matches": ["ABC!@#123", "f6t7f", "76f6", "7f56", "d54", "E$%DRT", "87g8g", "45dRT", "$D%F^G", "f87", "d6576D^%", "f6&F^^&"], "stress_tests": [], "serial": 692, "problematic": [{"example": "Abc12@XYZ", "is_match": true}, {"example": "Pa$$w0rd123", "is_match": true}, {"example": "1aB2C#dEf", "is_match": true}, {"example": "$ecUrE8+Pwd", "is_match": true}, {"example": "123aB!Xyz", "is_match": true}, {"example": "P@$$w0rD!z", "is_match": true}, {"example": "9pAsSWoRd@", "is_match": true}, {"example": "L3tM3!n0w", "is_match": true}, {"example": "AbC12!D3f", "is_match": true}, {"example": "Pwd@12aBCD", "is_match": true}, {"example": "7P@$$w#Rd", "is_match": true}]}, {"expression": "(refs|references|re|closes|closed|close|see|fixes|fixed|fix|addresses) #(\\d+)(( and |, | & | )#(\\d+))*", "raw_prompt": "This expression can be used to set the bugtraq:logrexep property of a subversion repository. It uses the format supported by trac and enables for example tortoisesvn to transform the issue numbers used in the commit messages into links pointing to the issue in the bugtracker.", "refined_prompt": "match commit message references to issue or pull request numbers, commonly used in version control systems like GitHub.\nMatch examples:\n- \"fix #313\"\n- \"references #1024 and #1337\"\n- \"refs #123\"\nNon-match examples:\n- \"fixed 313\"\n- \"refer #1024\"", "matches": ["fix #313", "references #1024 and #1337", "refs #123", "closes #456", "fix #789 and #1011", "References #22 & #33", "Re #44 and #55, see #66", "Fix #77 and #88, close #99", "fixes #123 and #456", "Closes #789 & #1011", "re #22, see #33", "Fix #44 and #55, closes #66", "Re #100,101, and #102"], "non_matches": ["fixed 313", "refer #1024", "-243", "(12) 324 653210", "234/423/5243", "$23.454", "43-5432", "254627g.256", "245/524/12", "com.edu.github", "(0xx12) 62509@", "32542 //"], "stress_tests": [], "serial": 694, "problematic": [{"example": "References #22 & #33", "is_match": true}, {"example": "Closes #789 & #1011", "is_match": true}, {"example": "Re #100,101, and #102", "is_match": true}]}, {"expression": "(^\\-|\\+)?([1-9]{1}[0-9]{0,2}(\\,\\d{3})*|[1-9]{1}\\d{0,})$|^0?$", "raw_prompt": "Allows any integer, signed (+/-) or not, with or without commas, or zero (0), or blank.", "refined_prompt": "Allows any integer, signed (+/-) or not, with or without commas, or zero (0), or blank.\nMatch examples:\n- \"1,250\"\n- \"+235\"\n- \"-1\"\nNon-match examples:\n- \"abc\"\n- \"-0\"", "matches": ["1,250", "+235", "-1", "0", "67", "464", "35", "76", "467", "-678", "-46", "-648", "-867"], "non_matches": ["abc", "-0", "1,0", "23e", "23r", "u67", "543.543", "534.764", "24.25", "63.346", "9/9/9", "3409fjg43"], "stress_tests": [], "serial": 701, "problematic": [{"example": "u67", "is_match": false}, {"example": "543.543", "is_match": false}, {"example": "534.764", "is_match": false}, {"example": "24.25", "is_match": false}, {"example": "63.346", "is_match": false}, {"example": "9/9/9", "is_match": false}, {"example": "3409fjg43", "is_match": false}]}, {"expression": "^[ISBN]{4}[ ]{0,1}[0-9]{1}[-]{1}[0-9]{3}[-]{1}[0-9]{5}[-]{1}[0-9]{0,1}$", "raw_prompt": "Expression to check for a valid ISBN number", "refined_prompt": "Expression to check for a valid ISBN number\nMatch examples:\n- \"ISBN 0-596-00681-0\"\n- \"ISBN 1-234-56789-0\"\n- \"ISBN 0-123-45678-9\"\nNon-match examples:\n- \"Anything that's not in the above format\"\n- \"ISBN1234567890\"", "matches": ["ISBN 0-596-00681-0", "ISBN 1-234-56789-0", "ISBN 0-123-45678-9", "ISBN 3-456-78901-2", "ISBN 9-876-54321-4", "ISBN 2-345-67890-1", "ISBN 8-765-43210-5", "ISBN 4-567-89012-3", "ISBN 6-789-01234-7", "ISBN 7-890-12345-8", "ISBN 5-432-10987-6", "ISBN 1-234-56789-X", "ISBN 0-123-45678-1"], "non_matches": ["Anything that's not in the above format", "ISBN1234567890", "ISBN-123-45678-9", "ISBN-12-345-67890", "0-123-45678-9", "ISBN-12345678-9", "ISBN 123-45-67890", "ISBN 1-2-3456789-0", "ISBN 1-234-56789-fdas", "ISBN 1-234-56789-A", "ISBN 1-234-5678-9-0", "0j0jweBBBB"], "stress_tests": [], "serial": 709, "problematic": [{"example": "ISBN 1-234-56789-X", "is_match": true}]}, {"expression": "^([0-9][,]?)*([0-9][0-9])$", "raw_prompt": "This pattern matches numbers separated by comma", "refined_prompt": "This pattern matches numbers separated by comma\nMatch examples:\n- \"100,200\"\n- \"200,300\"\n- \"456,789\"\nNon-match examples:\n- \",,100\"\n- \"100,,222\"", "matches": ["100,200", "200,300", "456,789", "25", "87", "97", "57", "6", "43", "8", "29", "1", "2"], "non_matches": [",,100", "100,,222", "100,,,", "(12) 324 653210", "234/423/5243", "$23.454", "43-5432", "254627g.256", "245/524/12", "1-1-2", "9/9/9", "32542 //"], "stress_tests": [], "serial": 719, "problematic": [{"example": "6", "is_match": true}, {"example": "8", "is_match": true}, {"example": "1", "is_match": true}, {"example": "2", "is_match": true}]}, {"expression": "(UPDATE\\s+)(\\w+)\\s+(SET)\\s+([\\w+\\s*=\\s*\\w+,?\\s*]+)\\s+(WHERE.+)", "raw_prompt": "Use with \"/i\" flag (case-insensitive) to match any valid SQL UPDATE statement, and to parse it into it's component parts. Most useful will be group $2, the table name, group $4, the field=value list, and group $5, the WHERE clause.", "refined_prompt": "Use with \"/i\" flag (case-insensitive) to match any valid SQL UPDATE statement, and to parse it into it's component parts. Most useful will be group $2, the table name, group $4, the field=value list, and group $5, the WHERE clause.\nMatch examples:\n- \"UPDATE table1 SET field1=value1,field2=value WHERE field4=value4\"\n- \"UPDATE Employees SET Salary=50000 WHERE Department='HR'\"\n- \"Update Products SET Price=19.99 WHERE Category='Electronics'\"\nNon-match examples:\n- \"UPDATE table1 SET field1=value1,field2=value\"\n- \"INSERT INTO Customers (Name, Email) VALUES ('Alice', 'alice@email.com')\"", "matches": ["UPDATE table1 SET field1=value1,field2=value WHERE field4=value4", "UPDATE Employees SET Salary=50000 WHERE Department='HR'", "Update Products SET Price=19.99 WHERE Category='Electronics'", "update Orders set Status='Shipped' where CustomerID=101", "UPdate Inventory SET Quantity=100 WHERE ProductID=123", "Update Customers SET FirstName='John', LastName='Doe' WHERE CustomerID=789", "update Books set Stock=50, Price=29.99 where Title='The Great Gatsby'", "Update Employees SET Salary=60000, Department='Finance' WHERE EmployeeID=456", "UPdate Orders set Status='Pending' WHERE CustomerID=222", "Update Products SET Price=15.99 WHERE Category='Clothing'", "update Inventory set Quantity=75 where ProductID=789", "Update Customers SET FirstName='Jane' WHERE CustomerID=123", "update Books set Stock=25, Price=19.99 where Title='To Kill a Mockingbird'"], "non_matches": ["UPDATE table1 SET field1=value1,field2=value", "INSERT INTO Customers (Name, Email) VALUES ('Alice', 'alice@email.com')", "DELETE FROM Orders WHERE OrderID=1001", "SELECT * FROM Employees", "ALTER TABLE Products ADD Column1 VARCHAR(255)", "CREATE TABLE Customers (CustomerID INT, FirstName VARCHAR(255), LastName VARCHAR(255))", "DROP TABLE Products", "INSERT INTO Orders (CustomerID, ProductID) VALUES (101, 456)", "DELETE FROM Customers WHERE LastName='Smith'", "SELECT FirstName, LastName FROM Employees WHERE Salary > 60000", "ALTER TABLE Employees DROP COLUMN Department", "CREATE DATABASE SalesDB"], "stress_tests": [], "serial": 732, "problematic": [{"example": "Update Products SET Price=19.99 WHERE Category='Electronics'", "is_match": true}, {"example": "update Orders set Status='Shipped' where CustomerID=101", "is_match": true}, {"example": "UPdate Inventory SET Quantity=100 WHERE ProductID=123", "is_match": true}, {"example": "Update Customers SET FirstName='John', LastName='Doe' WHERE CustomerID=789", "is_match": true}, {"example": "update Books set Stock=50, Price=29.99 where Title='The Great Gatsby'", "is_match": true}, {"example": "Update Employees SET Salary=60000, Department='Finance' WHERE EmployeeID=456", "is_match": true}, {"example": "UPdate Orders set Status='Pending' WHERE CustomerID=222", "is_match": true}, {"example": "Update Products SET Price=15.99 WHERE Category='Clothing'", "is_match": true}, {"example": "update Inventory set Quantity=75 where ProductID=789", "is_match": true}, {"example": "Update Customers SET FirstName='Jane' WHERE CustomerID=123", "is_match": true}, {"example": "update Books set Stock=25, Price=19.99 where Title='To Kill a Mockingbird'", "is_match": true}]}, {"expression": "ISBN(?:-13)?:?\\x20*(?=.{17}$)97(?:8|9)([ -])\\d{1,5}\\1\\d{1,7}\\1\\d{1,6}\\1\\d$", "raw_prompt": "This regex matches the new 13 digit ISBN. The ISBN number must be preceded by the text \"ISBN:\" or \"ISBN-13:\" , the colon is optional. The proper lengthes of the ISBN elements is checked. The is no check for the validity of the check digit.", "refined_prompt": "This regex matches the new 13 digit ISBN. The ISBN number must be preceded by the text \"ISBN:\" or \"ISBN-13:\" , the colon is optional. The proper lengthes of the ISBN elements is checked. The is no check for the validity of the check digit.\nMatch examples:\n- \"ISBN-13: 978-1-4028-9462-6\"\n- \"ISBN: 978-1-2345678-9-0\"\n- \"ISBN: 979-12-34567-89-0\"\nNon-match examples:\n- \"ISBN-10: 1-4028-9462-7\"\n- \"ISBN: 978-1-2345678-9-00\"", "matches": ["ISBN-13: 978-1-4028-9462-6", "ISBN: 978-1-2345678-9-0", "ISBN: 979-12-34567-89-0", "ISBN-13:978-1-234567-89-0", "ISBN-13: 979-12-34567-8-90", "ISBN:978-1-2345678-9-0", "ISBN-13: 978-1-2345678-90", "ISBN: 979-1-23-45678-9-0", "ISBN: 979-1-234567-8-90", "ISBN-13: 978-1-234567-890", "ISBN: 978-1-2345-678-90", "ISBN-13: 979-1-2-345678-90", "ISBN-13: 978-1-2345678-9-0"], "non_matches": ["ISBN-10: 1-4028-9462-7", "ISBN: 978-1-2345678-9-00", "ISBN: 2534/52435234/2453", "ISBN: (12) 324 653210", "ISBN: 234/423/5243", "ISBN: $23.454", "ISBN: 43-5432", "ISBN: 254627g.256", "ISBN: 245/524/12", "ISBN: 354/243/542", "ISBN: (0xx12) 62509@", "ISBN: 3409fjg43"], "stress_tests": [], "serial": 733, "problematic": [{"example": "ISBN-13: 979-12-34567-8-90", "is_match": true}, {"example": "ISBN-13: 978-1-2345678-90", "is_match": true}, {"example": "ISBN: 979-1-23-45678-9-0", "is_match": true}, {"example": "ISBN: 979-1-234567-8-90", "is_match": true}, {"example": "ISBN-13: 978-1-234567-890", "is_match": true}, {"example": "ISBN: 978-1-2345-678-90", "is_match": true}, {"example": "ISBN-13: 979-1-2-345678-90", "is_match": true}]}, {"expression": "(INSERT INTO\\s+)(\\w+)(\\s+\\()([\\w+,?\\s*]+)(\\)\\s+VALUES\\s+\\()(['?\\w+'?,?\\s*]+)(\\))", "raw_prompt": "Use with \"/i\" flag (case-insensitive) to match a fully qualified SQL INSERT statement, and to parse it into it's component parts. Group $2 will contain the table name, $4 the field list, and $6 the value list.", "refined_prompt": "Use with \"/i\" flag (case-insensitive) to match a fully qualified SQL INSERT statement, and to parse it into it's component parts. Group $2 will contain the table name, $4 the field list, and $6 the value list.\nMatch examples:\n- \"INSERT INTO table (field1, field2) VALUES (value1, value2)\"\n- \"INSERT INTO Customers (Name, Email) VALUES ('Alice', 'alice@email.com')\"\n- \"Insert INTO Products (ProductID, Name, Price) VALUES (101, 'Widget', 12.99)\"\nNon-match examples:\n- \"INSERT INTO table VALUES (value1, value2)\"\n- \"UPDATE Customers SET FirstName='Alice' WHERE CustomerID=1\"", "matches": ["INSERT INTO table (field1, field2) VALUES (value1, value2)", "INSERT INTO Customers (Name, Email) VALUES ('Alice', 'alice@email.com')", "Insert INTO Products (ProductID, Name, Price) VALUES (101, 'Widget', 12.99)", "insert into Orders (OrderID, CustomerID, ProductID) values (1001, 101, 456)", "InSert INTO Employees (FirstName, LastName, Salary) VALUES ('John', 'Doe', 60000)", "INSERT INTO Inventory (ProductID, Quantity) VALUES (789, 75)", "INSERT INTO Customers (FirstName, LastName) VALUES ('Jane', 'Smith')", "Insert INTO Books (Title, Stock, Price) VALUES ('The Great Gatsby', 50, 29.99)", "insert into Employees (FirstName, LastName, Salary) values ('Jane', 'Doe', 70000)", "INSERT INTO Orders (CustomerID, Status) VALUES (222, 'Pending')", "INSERT INTO Products (Name, Price) VALUES ('Widget', 9.99)", "Insert INTO Inventory (ProductID, Quantity) VALUES (123, 25)", "insert into Customers (FirstName, LastName) values ('John', 'Smith')"], "non_matches": ["INSERT INTO table VALUES (value1, value2)", "UPDATE Customers SET FirstName='Alice' WHERE CustomerID=1", "DELETE FROM Products WHERE ProductID=101", "SELECT * FROM Employees", "ALTER TABLE Customers ADD Column1 VARCHAR(255)", "CREATE TABLE Orders (OrderID INT, CustomerID INT, ProductID INT)", "DROP TABLE Inventory", "INSERT INTO Suppliers (SupplierName, ContactName) VALUES ('ABC Corp', 'John')", "DELETE FROM Customers WHERE LastName='Smith'", "SELECT FirstName, LastName FROM Employees WHERE Salary > 60000", "ALTER TABLE Products DROP COLUMN Description", "CREATE DATABASE SalesDB"], "stress_tests": [], "serial": 734, "problematic": [{"example": "INSERT INTO Customers (Name, Email) VALUES ('Alice', 'alice@email.com')", "is_match": true}, {"example": "Insert INTO Products (ProductID, Name, Price) VALUES (101, 'Widget', 12.99)", "is_match": true}, {"example": "insert into Orders (OrderID, CustomerID, ProductID) values (1001, 101, 456)", "is_match": true}, {"example": "InSert INTO Employees (FirstName, LastName, Salary) VALUES ('John', 'Doe', 60000)", "is_match": true}, {"example": "Insert INTO Books (Title, Stock, Price) VALUES ('The Great Gatsby', 50, 29.99)", "is_match": true}, {"example": "insert into Employees (FirstName, LastName, Salary) values ('Jane', 'Doe', 70000)", "is_match": true}, {"example": "INSERT INTO Products (Name, Price) VALUES ('Widget', 9.99)", "is_match": true}, {"example": "Insert INTO Inventory (ProductID, Quantity) VALUES (123, 25)", "is_match": true}, {"example": "insert into Customers (FirstName, LastName) values ('John', 'Smith')", "is_match": true}, {"example": "INSERT INTO Suppliers (SupplierName, ContactName) VALUES ('ABC Corp', 'John')", "is_match": false}]}, {"expression": "(INSERT INTO\\s+)(\\w+)(\\s+\\()([\\w+,?\\s*]+)(\\)\\s+VALUES\\s+)((\\(['?\\w+'?,?\\s*]+\\)\\,?;?\\s*)+)", "raw_prompt": "Use with \"/i\" flag (case-insensitive) to match a fully qualified SQL INSERT statement, and to parse it into it's component parts. Group $2 will contain the table name, $4 the field list, and $6 the all of the value lists.", "refined_prompt": "The provided regex with the \"/i\" flag matches fully qualified SQL INSERT statements and extracts key components: table name (group $2), field list (group $4), and all of the value lists (group $6).\nMatch examples:\n- \"INSERT INTO table (field1, field2) VALUES (value1, value2); (value3, value4) or INSERT INTO table (field1, field2) VALUES (value1, value2), (value3, value4)\"\n- \"INSERT INTO Customers (Name, Email) VALUES ('Alice', 'alice@email.com');\"\n- \"Insert INTO Products (ProductID, Name, Price) VALUES (101, 'Widget', 12.99), (102, 'Gadget', 24.95);\"\nNon-match examples:\n- \"INSERT INTO table VALUES (value1, value2)\"\n- \"UPDATE Customers SET FirstName='Alice' WHERE CustomerID=1;\"", "matches": ["INSERT INTO table (field1, field2) VALUES (value1, value2); (value3, value4) or INSERT INTO table (field1, field2) VALUES (value1, value2), (value3, value4)", "INSERT INTO Customers (Name, Email) VALUES ('Alice', 'alice@email.com');", "Insert INTO Products (ProductID, Name, Price) VALUES (101, 'Widget', 12.99), (102, 'Gadget', 24.95);", "insert into Orders (OrderID, CustomerID, ProductID) values (1001, 101, 456);", "InSert INTO Employees (FirstName, LastName, Salary) VALUES ('John', 'Doe', 60000), ('Jane', 'Smith', 55000);", "INSERT INTO Inventory (ProductID, Quantity) VALUES (789, 75), (790, 50);", "INSERT INTO Customers (FirstName, LastName) VALUES ('Jane', 'Smith'), ('Tom', 'Johnson');", "Insert INTO Books (Title, Stock, Price) VALUES ('The Great Gatsby', 50, 29.99);", "insert into Employees (FirstName, LastName, Salary) values ('Jane', 'Doe', 70000);", "INSERT INTO Orders (CustomerID, Status) VALUES (222, 'Pending');", "INSERT INTO Products (Name, Price) VALUES ('Widget', 9.99);", "Insert INTO Inventory (ProductID, Quantity) VALUES (123, 25), (124, 30);", "insert into Customers (FirstName, LastName) values ('John', 'Smith');"], "non_matches": ["INSERT INTO table VALUES (value1, value2)", "UPDATE Customers SET FirstName='Alice' WHERE CustomerID=1;", "DELETE FROM Products WHERE ProductID=101;", "SELECT * FROM Employees;", "ALTER TABLE Customers ADD Column1 VARCHAR(255);", "CREATE TABLE Orders (OrderID INT, CustomerID INT, ProductID INT);", "DROP TABLE Inventory;", "INSERT INTO Suppliers (SupplierName, ContactName) VALUES ('ABC Corp', 'John');", "DELETE FROM Customers WHERE LastName='Smith';", "SELECT FirstName, LastName FROM Employees WHERE Salary > 60000;", "ALTER TABLE Products DROP COLUMN Description;", "CREATE DATABASE SalesDB;"], "stress_tests": [], "serial": 735, "problematic": [{"example": "INSERT INTO Customers (Name, Email) VALUES ('Alice', 'alice@email.com');", "is_match": true}, {"example": "Insert INTO Products (ProductID, Name, Price) VALUES (101, 'Widget', 12.99), (102, 'Gadget', 24.95);", "is_match": true}, {"example": "insert into Orders (OrderID, CustomerID, ProductID) values (1001, 101, 456);", "is_match": true}, {"example": "InSert INTO Employees (FirstName, LastName, Salary) VALUES ('John', 'Doe', 60000), ('Jane', 'Smith', 55000);", "is_match": true}, {"example": "Insert INTO Books (Title, Stock, Price) VALUES ('The Great Gatsby', 50, 29.99);", "is_match": true}, {"example": "insert into Employees (FirstName, LastName, Salary) values ('Jane', 'Doe', 70000);", "is_match": true}, {"example": "INSERT INTO Products (Name, Price) VALUES ('Widget', 9.99);", "is_match": true}, {"example": "Insert INTO Inventory (ProductID, Quantity) VALUES (123, 25), (124, 30);", "is_match": true}, {"example": "insert into Customers (FirstName, LastName) values ('John', 'Smith');", "is_match": true}, {"example": "INSERT INTO Suppliers (SupplierName, ContactName) VALUES ('ABC Corp', 'John');", "is_match": false}]}, {"expression": "&(?![a-z]+;|#\\d+;)", "raw_prompt": "Single & character is not valid in HTML or XHTML code. In this case you can replace this character with its entity (if & character is not member of other entity [&amp;#353;]). example: preg_replace('/&(?!amp;)/', '&amp;amp;', $str).\n(thanks to mr. Mrva)", "refined_prompt": "Single & character is not valid in HTML or XHTML code. In this case you can replace this character with its entity (if & character is not member of other entity [&amp;#353;]). example: preg_replace('/&(?!amp;)/', '&amp;amp;', $str).\nMatch examples:\n- \"&\"\nNon-match examples:\n- \"&amp;amp;\"\n- \"&amp;quot;\"", "matches": ["&"], "non_matches": ["&amp;amp;", "&amp;quot;", "&amp;#353;", "&blah;", "&amp;copy;", "$23.454", "&43-5432", "&254627g.256", "&u09nKLJG FSL", "&354/243/542", "&(0xx12) 62509@", "&3409fjg43"], "stress_tests": [], "serial": 739, "problematic": [{"example": "&43-5432", "is_match": false}, {"example": "&254627g.256", "is_match": false}, {"example": "&u09nKLJG FSL", "is_match": false}, {"example": "&354/243/542", "is_match": false}, {"example": "&(0xx12) 62509@", "is_match": false}, {"example": "&3409fjg43", "is_match": false}]}, {"expression": "^(( )*\\\u00a3{0,1}( )*)\\d*(.\\d{1,2})?$", "raw_prompt": "This expression is for matching the currency input. The \u00a3 is optional. e.g. \u00a312.12, \u00a3 12.12, 12.12, 12.", "refined_prompt": "This expression is for matching the currency input. The \u00a3 is optional\nMatch examples:\n- \"\u00a3123.00\"\n- \"12\"\n- \"12.12\"\nNon-match examples:\n- \"$123.00\"\n- \"f34fvfv\"", "matches": ["\u00a3123.00", "12", "12.12", "\u00a3489156", "4865", "\u00a3783", "45.46", "\u00a3159", "76.12", "\u00a3786", "489", "\u00a3513.45", "4897"], "non_matches": ["$123.00", "f34fvfv", "34f2vf42e", "Mastercard", "\u00a3513.456-52591", "\u00a3513.45652", "45165645321.4215", "45.5641", "456-34", "adfa2", "(0xx12) 62509", "12/132/90"], "stress_tests": [], "serial": 743, "problematic": [{"example": "456-34", "is_match": false}]}, {"expression": "^\\({0,1}((0|\\+61)(2|4|3|7|8)){0,1}\\){0,1}(\\ |-){0,1}[0-9]{2}(\\ |-){0,1}[0-9]{2}(\\ |-){0,1}[0-9]{1}(\\ |-){0,1}[0-9]{3}$", "raw_prompt": "Australian phone number validator. Accepts all forms of Australian phone numbers in different formats (area code in brackets, no area code, spaces between 2-3 and 6-7th digits, +61 international dialing code). Checks that area codes are valid (when entered).", "refined_prompt": "Australian phone number validator. Accepts all forms of Australian phone numbers in different formats (area code in brackets, no area code, spaces between 2-3 and 6-7th digits, +61 international dialing code). Checks that area codes are valid (when entered).\nMatch examples:\n- \"0403111111\"\n- \"(03) 1111 1111\"\n- \"+61403111111\"\nNon-match examples:\n- \"9111 11111\"\n- \"99 1111 1111\"", "matches": ["0403111111", "(03) 1111 1111", "+61403111111", "02 9111 1111", "0403 111 111", "91111111", "03-56781234", "(02) 1234 5678", "(+61) 2 1234 5678", "0412 345 678", "+61412345678", "03-4567-1234", "0412 34-56-78"], "non_matches": ["9111 11111", "99 1111 1111", "34f2vf42e", "12/123/4322", "2346-2345-2435", "43.v234", "@#dfkjnav", "1561985184-845", "432/524/2435", "341.431v4f3.fv1", "(0xx12) 62509", "12/132/90"], "stress_tests": [], "serial": 744, "problematic": [{"example": "(+61) 2 1234 5678", "is_match": true}, {"example": "0412 34-56-78", "is_match": true}]}, {"expression": "^((\\(?\\+45\\)?)?)(\\s?\\d{2}\\s?\\d{2}\\s?\\d{2}\\s?\\d{2})$", "raw_prompt": "This should help in finding european style phone numbers (without hyphens), particularly danish numbers with consist of 8 digits, and can be separated by a whitespace.", "refined_prompt": "Match strings that represent Danish phone numbers in a specific format. It allows for variations such as optional country code (+45), optional parentheses around the country code, and spaces between pairs of two digits.\nMatch examples:\n- \"(+45) 35 35 35 35\"\n- \"+45 35 35 35 35\"\n- \"35 35 35 35\"\nNon-match examples:\n- \"(45)35353535\"\n- \"4535353535\"", "matches": ["(+45) 35 35 35 35", "+45 35 35 35 35", "35 35 35 35", "35353535", "+45123456789", "(+45) 12 34 56 78", "12345678", "12 34 56 78", "(+45)1234 5678", "12 3456 78", "(+45) 12345678", "+45 12345678", "(+45) 12 3456 78"], "non_matches": ["(45)35353535", "4535353535", "34f2vf42e", "12/123/4322", "2346-2345-2435", "43.v234", "@#dfkjnav", "/5/5/20022", "432/524/2435", "adfa2", "(0xx12) 62509", "12/132/90"], "stress_tests": [], "serial": 747, "problematic": [{"example": "+45123456789", "is_match": true}]}, {"expression": "(<(tag1|tag2)[^>]*\\/?>)[\\w\\S\\s]*?(<\\/(?:\\2)>)", "raw_prompt": "This will remove the InnerHTML of a tag. For instance, if you wanted to clear all paragraphs and h1 tags on a page, you would simply put in \"p\" and \"h1\" into those tags, and they would end up looking like <h1></h1> <p></p> <p></p>. It's useful when you're doing work based off a template and you need to get back to the original template.", "refined_prompt": "This will remove the InnerHTML of a tag. For example, if you wanted to clear all of the paragraphs and h1 tags on a specific page, you would simply put \"p\" and \"h1\" into those tags, and they would end up looking like <h1></h1> <p></p> <p></p>. It's useful when you're doing work based on a template and you need to get back to the original template.\nMatch examples:\n- \"<tag1>Lorem ipsum dolor sit amet</tag1>\"\n- \"<tag2AB:)lv?6Ye5C9Bf|~j5P></tag2>\"\n- \"<tag1}+:x([w E~#u/xn(MJ2[w3{'CI/!R5*zO=2'9YE\"mSQUoxf*RGO](%,~E)7f/(-M></tag1>\"\nNon-match examples:\n- \"<tag1>Lorem ipsum doler</othertag>\"\n- \"<tag2*}/>C</tag2>\"", "matches": ["<tag1>Lorem ipsum dolor sit amet</tag1>", "<tag2AB:)lv?6Ye5C9Bf|~j5P></tag2>", "<tag1}+:x([w E~#u/xn(MJ2[w3{'CI/!R5*zO=2'9YE\"mSQUoxf*RGO](%,~E)7f/(-M></tag1>", "<tag2-z(U#%3T*C'I,5V~1UYcJMpT\\CUK)0%|&yq8iXM\\hbL9i[7Ncb,t@\\?Jkw></tag2>", "<tag2{5XI/g=IY/(`c\"@s/></tag2>", "<tag2&j|gaKv29E&sbfA^.v3></tag2>", "<tag2 hJG{5mRCD:~y/></tag2>", "<tag1e=&;<zII0)$E/></tag1>", "<tag1[[0ES7v'SH;ZU#tP,)F4FaFIVA8z1;^></tag1>", "<tag1%7BD7r'qw6I</></tag1>", "<tag2Ob\\%=m4I></tag2>", "df#\u2004B<q*3\u000bd\t</tag2>", "<tag1zsTOW/></tag1>"], "non_matches": ["<tag1>Lorem ipsum doler</othertag>", "<tag2*}/>C</tag2>", "<tag2+mY3_#mj2cYb(TKa/>\u200a</tag2>", "<tag2d<j6XWPW3@jCZNZp>0</tag2>", "<tag2]e;6~u]VAe^AT;UK*zuM/>\u2006</tag2>", "<tag2vem{:J*WP/>Q</tag2>", "<tag1P4^*^h/g/>+</tag1>", "<tag2Ts\"8)gi-]4{`$o/>\u2004</tag2>", "<tag2Zd(NRdMxb1t.qXQCf*Y<#`|:x/>|</tag2>", "<tag2A9$lLGRhgr/>V", "<tag1e)6&tNImVzQ@q!nW9|$&e%aNO1/>9", "<tag2}!T(iB9K+4_kM(zMc]~\\ ^*(aGG%k4S;3Kjo2sp\"h/>P"], "stress_tests": [], "serial": 755, "problematic": [{"example": "df#\u2004B<q*3\u000bd\t</tag2>", "is_match": true}, {"example": "<tag2*}/>C</tag2>", "is_match": false}, {"example": "<tag2+mY3_#mj2cYb(TKa/>\u200a</tag2>", "is_match": false}, {"example": "<tag2d<j6XWPW3@jCZNZp>0</tag2>", "is_match": false}, {"example": "<tag2]e;6~u]VAe^AT;UK*zuM/>\u2006</tag2>", "is_match": false}, {"example": "<tag2vem{:J*WP/>Q</tag2>", "is_match": false}, {"example": "<tag1P4^*^h/g/>+</tag1>", "is_match": false}, {"example": "<tag2Ts\"8)gi-]4{`$o/>\u2004</tag2>", "is_match": false}, {"example": "<tag2Zd(NRdMxb1t.qXQCf*Y<#`|:x/>|</tag2>", "is_match": false}]}, {"expression": "^(5[1-5]\\d{2})\\d{12}|(4\\d{3})(\\d{12}|\\d{9})$", "raw_prompt": "A simple regex to check for only Visa and MasterCard with no dashes or spaces. Visa starts with a 4 and is 13 or 16 digits long, MasterCard starts with a 51 through 55 and is 16 digits long. I noticed that some of the other formulas don't account for Visa being valid with only 13 digits. I used this for a PayPal processor (which doesn't allow dashes or spaces) and modified it from others on this site. Enjoy.", "refined_prompt": "Decide if a card number with no dashes or spaces is a Visa or MasterCard. Visa starts with a 4 and is 13 or 16 digits long, MasterCard starts with a 51 through 55 and is 16 digits long.\nMatch examples:\n- \"5555555555554444\"\n- \"5105105105105100\"\n- \"4012888888881881\"\nNon-match examples:\n- \"123412341234\"\n- \"4222-2222-2222-2222\"", "matches": ["5555555555554444", "5105105105105100", "4012888888881881", "4222222222222", "4145353601233471", "4383990602554246", "5233396389807856", "4506227767683", "5455952863975943", "4049675688042", "5448088729433898", "5510228665568829", "4509976341260826"], "non_matches": ["123412341234", "4222-2222-2222-2222", "visa", "41231234123412345", "mastercard", "6501199024432370", "7391416629748061", "8574300416444293", "8280170736151706", "861924588", "44083962418217117", "45081659589994604"], "stress_tests": [], "serial": 757, "problematic": [{"example": "8574300416444293", "is_match": false}, {"example": "44083962418217117", "is_match": false}]}, {"expression": "^\\d{4}(\\/|-)([0][1-9]|[1][0-2])(\\/|-)([0][1-9]|[1-2][0-9]|[3][0-1])$", "raw_prompt": "This regular expressions matches dates of the form YYYY/XX/ZZ ,where YYYY is always 4 digits long, XX can be 01 to 12 and ZZ can be 01 to 31", "refined_prompt": "This regular expression matches dates in the form YYYY/XX/ZZ . The sections can also be separated by dashes (-). Length limitations: YYYY is always 4 digits long, XX can be 1 - 12 , and ZZ can be 1 - 31\nMatch examples:\n- \"2007/01/20\"\n- \"0001/02/31\"\n- \"9999-12-31\"\nNon-match examples:\n- \"01/1/01\"\n- \"99-9-9\"", "matches": ["2007/01/20", "0001/02/31", "9999-12-31", "0325/05/30", "5544/03-28", "3782/10-06", "3052-12-30", "8100-02-26", "5044-11-08", "1149-03/15", "5709-11-01", "7970-05-31", "7424/10/09"], "non_matches": ["01/1/01", "99-9-9", "2008-00-00", "5210/13-20", "2003/26/35", "2343-30-5", "9157/03/12", "5537-10/27", "7995/12-94", "0000/00/00", "3026/15/94", "8233-14-22"], "stress_tests": [], "serial": 760, "problematic": [{"example": "9157/03/12", "is_match": false}, {"example": "5537-10/27", "is_match": false}]}, {"expression": "^((((19[0-9][0-9])|(2[0-9][0-9][0-9]))([-])(0[13578]|10|12)([-])(0[1-9]|[12][0-9]|3[01]))|(((19[0-9][0-9])|(2[0-9][0-9][0-9]))([-])(0[469]|11)([-])([0][1-9]|[12][0-9]|30))|(((19[0-9][0-9])|(2[0-9][0-9][0-9]))([-])(02)([-])(0[1-9]|1[0-9]|2[0-8]))|(([02468][048]00)([-])(02)([-])(29))|(([13579][26]00)([-])(02)([-])(29))|(([0-9][0-9][0][48])([-])(02)([-])(29))|(([0-9][0-9][2468][048])([-])(02)([-])(29))|(([0-9][0-9][13579][26])([-])(02)([-])(29)))$", "raw_prompt": "This regex checks if a date is in ISO-format (yyyy-mm-dd). Leap year should be checked too. Date has to be between 1900-01-01 and 2999-12-31.", "refined_prompt": "This regex checks if a date is in ISO-format (yyyy-mm-dd). Leap year is considered too. The date has to be between 1900-01-01 and 2999-12-31.\nMatch examples:\n- \"1900-01-01\"\n- \"2025-03-15\"\n- \"2999-12-31\"\nNon-match examples:\n- \"1890-01-01\"\n- \"2008-19-45\"", "matches": ["1900-01-01", "2025-03-15", "2999-12-31", "1901-02-29", "2044-02-29", "1900-02-29", "2248-11-30", "2020-02-29", "2345-02-29", "2003-02-29", "1999-02-29", "1986-10-30", "2458-07-30"], "non_matches": ["1890-01-01", "2008-19-45", "3000-01-01", "8980-02-29", "0000-00-00", "9999-99-99", "1900-01-00", "2999-13-31", "5000-12-24", "500-05-05", "1-1-1", "12-12-2222"], "stress_tests": [], "serial": 762, "problematic": [{"example": "1901-02-29", "is_match": true}, {"example": "1900-02-29", "is_match": true}, {"example": "2345-02-29", "is_match": true}, {"example": "2003-02-29", "is_match": true}, {"example": "1999-02-29", "is_match": true}, {"example": "8980-02-29", "is_match": false}]}, {"expression": "^(((0[1-9]|[12][0-9]|3[01])([\\.])(0[13578]|10|12)([\\.])((19[0-9][0-9])|(2[0-9][0-9][0-9])))|(([0][1-9]|[12][0-9]|30)([\\.])(0[469]|11)([\\.])((19[0-9][0-9])|(2[0-9][0-9][0-9])))|((0[1-9]|1[0-9]|2[0-8])([\\.])(02)([\\.])((19[0-9][0-9])|(2[0-9][0-9][0-9])))|((29)([\\.])(02)([\\.])([02468][048]00))|((29)([\\.])(02)([\\.])([13579][26]00))|((29)([\\.])(02)([\\.])([0-9][0-9][0][48]))|((29)([\\.])(02)([\\.])([0-9][0-9][2468][048]))|((29)([\\.])(02)([\\.])([0-9][0-9][13579][26])))$", "raw_prompt": "This regex checks if a date is in german date format (dd.mm.yyyy). Leap year should be checked too. Date has to be between 01.01.1900 and 31.12.2999.", "refined_prompt": "This regex checks if a date is in German date format (dd.mm.yyyy). Leap year should be checked too. The date has to be between 01.01.1900 and 31.12.2999.\nMatch examples:\n- \"01.01.1900\"\n- \"20.11.2009\"\n- \"31.12.2999\"\nNon-match examples:\n- \"01.01.1890\"\n- \"11.20.2009\"", "matches": ["01.01.1900", "20.11.2009", "31.12.2999", "12.02.2353", "01.02.2767", "24.11.1978", "29.02.2400", "30.11.2857", "30.09.2888", "04.10.1974", "23.04.2277", "16.12.2482", "30.09.1980"], "non_matches": ["01.01.1890", "11.20.2009", "01.01.3000", "29.02.4708", "0.0.0", "2003.01.26", "29.02.3600", "99.99.9999", "29.02.6208", "29.02.3600", "30.02.7356", "12.12.0001"], "stress_tests": [], "serial": 763, "problematic": [{"example": "29.02.4708", "is_match": false}, {"example": "29.02.3600", "is_match": false}, {"example": "29.02.6208", "is_match": false}, {"example": "29.02.3600", "is_match": false}]}, {"expression": "(?=[-_a-zA-Z0-9]*?[A-Z])(?=[-_a-zA-Z0-9]*?[a-z])(?=[-_a-zA-Z0-9]*?[0-9])[-_a-zA-Z0-9]{6,}", "raw_prompt": "Tests if the input consists of 6 or more letters, digits, underscores and hyphens. The input must contain at least one upper case ltter, one lower case letter and one digit.", "refined_prompt": "Tests if the input consists of 6 or more letters, digits, underscores, and hyphens. The input must contain at least one upper-case letter, one lower-case letter, and one digit.\nMatch examples:\n- \"M0_k3y\"\n- \"Pa-sW0rd\"\n- \"S1mPl3\"\nNon-match examples:\n- \"MonKey\"\n- \"PassWord\"", "matches": ["M0_k3y", "Pa-sW0rd", "S1mPl3", "I2H5_tAPJyLaT2SOa", "6CsP2SeF-FGWt97KOTH", "F4l-57DfHj", "eu7l6y5h4_4hB_t_", "eslue3_RObUftRuS", "d8r_t0xg8zSo1", "NEMRufzwhw", "HDWO-UKDpPWR7", "B0ruzbnZpnlb", "Nw-OJSMAS"], "non_matches": ["MonKey", "PassWord", "simple", "hiiiiiiiiii88_", "...8888*ee", "welkfejk45334", "aerliuw489y", "HEkkkkkLLL)))77777", "abcdef12345", "th!sis@reAlly$tr0ngp@$$w0rd", "don'thackmePLEASE", "PASSWORD"], "stress_tests": [], "serial": 772, "problematic": [{"example": "NEMRufzwhw", "is_match": true}, {"example": "Nw-OJSMAS", "is_match": true}]}, {"expression": "([0-9a-z_-]+[\\.][0-9a-z_-]{1,3})$", "raw_prompt": "Will match a Windows filename containing alphanumerics, hyphens (-) and underscores (_). There is no length limit on the first part of the filename, but the extension must be between 1 and 3 characters.", "refined_prompt": "Will match a Windows filename containing alphanumerics, hyphens (-) and underscores (_). There is no length limit on the first part of the filename, but the extension must be between 1 and 3 characters.\nMatch examples:\n- \"open_01.pdf, 00153._-, _abc_.--1\"\n- \"s7iceungr_cp1c7kviym437io3ltkbmcwm9wew.syi\"\n- \"3zpl-p0mwl5-xwogtcvkqywisz1qhiy9judvt98_bpn6_2id5k-h5rl4vf19srogzols.f8\"\nNon-match examples:\n- \"readme.e$e, save6^.doc, open_01., .txt, leisure.docx\"\n- \"46t.6y&\"", "matches": ["open_01.pdf, 00153._-, _abc_.--1", "s7iceungr_cp1c7kviym437io3ltkbmcwm9wew.syi", "3zpl-p0mwl5-xwogtcvkqywisz1qhiy9judvt98_bpn6_2id5k-h5rl4vf19srogzols.f8", "fi_m-z2.uh", "m.v6", "c2o8kz.rz0", "b-6t_t3igrrrrmhrr0enlarw_.4zg", "wnim4hrc0m1r6.oh", "qwqbf2r-.5", "g2_pos6m6x-x53-oru8vz70my5zgq-y8v7.-fi", "sgceb0iqz7xv.gjo", "i3tg371g_5w36p0-g.940", "lyd5sk.sxu"], "non_matches": ["readme.e$e, save6^.doc, open_01., .txt, leisure.docx", "46t.6y&", "t<4.62a>", "\"09bj3dz19e4dkfqj-ciq0c4._a5\"", "38rmt-tx+.8k4", "jrw%3.t!", "urtqe.w/", "-054lr.i-", "7nn@xo6-z.rup.", "1", "helloo", "i0.9h2?"], "stress_tests": [], "serial": 787, "problematic": [{"example": "-054lr.i-", "is_match": false}]}, {"expression": "(?!.*([abcde]).*\\1)^[abcde]{5}$", "raw_prompt": "Let's say that you have a series of characters \"abcde\" and you want to match all strings that could be comprised of those characters with each character used exactly once. This could loosely be termed an anagram matcher, although if the string contains duplicate letters it would require modification of this pattern. In the example case we have a string \"abcde\" and we want to match any permutation of \"abcde\". Note that the \"5\" used in the pattern indicates the number of characters specified in the character set \"abcde\", \"5\" would still be used if \"abcde\" would be replaced with \"a-e\" since there would still be 5 characters in the series. If you are curious about how to require duplicates in the pattern (to match all permutations of \"apple\" for example) I would use (?=^.*p.*p$)(?!.*([ale]).*\\1)^[aple]{5}$", "refined_prompt": "Matches all strings that could be comprised of abcde with each character used exactly once.\nMatch examples:\n- \"abcde\"\n- \"dbcae\"\n- \"edcba\"\nNon-match examples:\n- \"abcbe\"\n- \"cbbdc\"", "matches": ["abcde", "dbcae", "edcba", "abdec", "acedb", "bdcae", "bcaed", "baedc", "beacd", "adbce", "bdeac", "daedc", "cadeb"], "non_matches": ["abcbe", "cbbdc", "acabb", "dcbdd", "bcedb", "eeadb", "abaad", "cceee", "eccbc", "cbddb", "acaab", "eaecb"], "stress_tests": [], "serial": 803, "problematic": [{"example": "daedc", "is_match": true}]}, {"expression": "^[a-zA-Z0-9\\.\\s]{3,}$", "raw_prompt": "This expression check the input of simple text string from a-z,A-Z and number from 0 to 9 and the dot(.).\nBut the minimum insert is of 3 character.", "refined_prompt": "This expression matches strings with a minimum of 3 of the following type of character:s a-z,A-Z, number from 0 to 9, spaces, and a period (.).\nMatch examples:\n- \"abc.123\"\n- \".abc\"\n- \"123.\"\nNon-match examples:\n- \"12\"\n- \"a1\"", "matches": ["abc.123", ".abc", "123.", "7 u3u\u2000IN\u20068T\u20063\ufeffK\u2003\u2006S\u2001jo", "rk\u2008\u2007Gb\u2001n S\u2000Wl9\u200agY\u180e\u2002\u2006k7pi\u200az\tvyioZ03y\u20092\u2002hg", "Qq.Z", "kM\u000bEAOZYM 77W0N\u000bQ\u20099p", "Feo.u\u1680\u2009Io.iOmFx\u2029ME", "Zc\u2006p\u200a6Uc\u2008A\u205f\u2003\ufeffU", "HMa\u2007\u000b5\u3000TTorLAF\u2006e1n7RvQFfpL\u2002\u200a3\u2008\u2006I\u2028nmBm17k7\u3000R3.\u205foouYj4fEQ1kh3rfD\fYW\u2007vu\u000bT.", "\u180eN9OJUzEY0V\ufeffsF XijGst", "5qRlSjqK\u2009hn", "8\u2009AMDh\u2007If"], "non_matches": ["12", "a1", "@#%&\u00a3\"^", "43534f. re/", "$4", "23#", "ab", "<>", "\"abc\"", "O'Malley", "343432:", "34/56"], "stress_tests": [], "serial": 815, "problematic": [{"example": "7 u3u\u2000IN\u20068T\u20063\ufeffK\u2003\u2006S\u2001jo", "is_match": true}, {"example": "rk\u2008\u2007Gb\u2001n S\u2000Wl9\u200agY\u180e\u2002\u2006k7pi\u200az\tvyioZ03y\u20092\u2002hg", "is_match": true}, {"example": "Zc\u2006p\u200a6Uc\u2008A\u205f\u2003\ufeffU", "is_match": true}, {"example": "\u180eN9OJUzEY0V\ufeffsF XijGst", "is_match": true}]}, {"expression": "^((31(?!([-])(Feb|Apr|June?|Sep|Nov)))|((30|29)(?!([-])Feb))|(29(?=([-])Feb([-])(((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))|(0?[1-9])|1\\d|2[0-8])([-])(Jan|Feb|Ma(r|y)|Apr|Ju(l|n)|Aug|Oct|(Sep|Nov|Dec))([-])((1[6-9]|[2-9]\\d)\\d{2}\\s(([0-1]?[0-9])|([2][0-3])):([0-5]?[0-9])(:([0-5]?[0-9]))?)$", "raw_prompt": "This expression matches date and time (24 hour) both in format dd-MMM-yyyy HH:mm:ss. Only the short form of month is allowed i.e. Jan not January. The month names are also case sensitive. The second part of the time is optional. Also the leading zeros for day, hour, minute and seconds are optional.", "refined_prompt": "This expression matches date and time (24 hour) both in format dd-MMM-yyyy HH:mm:ss. Only the short form of month is allowed i.e. Jan not January. The month names are also case sensitive. The second part of the time is optional. Also the leading zeros for day, hour, minute and seconds are optional.\nMatch examples:\n- \"31-Jan-2008 1:30:00\"\n- \"29-Feb-2008 01:45:45\"\n- \"30-Sep-2007 23:59\"\nNon-match examples:\n- \"31-Jan-2008 24:30:00\"\n- \"29-Feb-2007 01:45:45\"", "matches": ["31-Jan-2008 1:30:00", "29-Feb-2008 01:45:45", "30-Sep-2007 23:59", "31-Dec-1655\t15:05:38", "10-Oct-4214\u200a3:34:21", "29-Feb-1867\u200920:16:9", "5-Feb-5197\u20069:06:8", "20-Apr-1966\f06:9", "15-Jan-1610\u200a15:58:4", "29-Dec-4877\u200422:4:0", "8-Aug-7303", "31-Aug-6932\u200720:3:2", "29-Mar-9704\u200123:4:33"], "non_matches": ["31-Jan-2008 24:30:00", "29-Feb-2007 01:45:45", "3-Sep-2007 23:60:60", "date", "may 5th", "noon", "12/12/12", "12:12:12", "wednesday", "987654", "wedfg", "gt43few"], "stress_tests": [], "serial": 819, "problematic": [{"example": "29-Feb-1867\u200920:16:9", "is_match": true}, {"example": "8-Aug-7303", "is_match": true}]}, {"expression": "\\x26(?!((amp\\x3B)|(nbsp\\x3B)|(lt\\x3B)|(gt\\x3B)|(copy\\x3B)|(reg\\x3B)|(cent\\x3B)|(deg\\x3B)|(deg\\x3B)|(micro\\x3B)|(middot\\x3B)|(not\\x3B)|(para\\x3B)|(plusmn\\x3B)|(pound\\x3B)|(raquo\\x3B)|(sect\\x3B)|(yen\\x3B)|([\\x23][0-9]{1,3}\\x3B)|(lsquo\\x3B)|(rsquo\\x3B)|(sbquo\\x3B)|(ldquo\\x3B)|(rdquo\\x3B)|(bdquo\\x3B)|(dagger\\x3B)|(Dagger\\x3B)|(permil\\x3B)|(lsaquo\\x3B)|(rsaquo\\x3B)|(spades\\x3B)|(clubs\\x3B)|(hearts\\x3B)|(diams\\x3B)|(oline\\x3B)|(larr\\x3B)|(uarr\\x3B)|(rarr\\x3B)|(darr\\x3B)|(trade\\x3B)|([\\x23]x2122\\x3B)|(quot\\x3B)|(frasl\\x3B)|(ndash\\x3B)|(mdash\\x3B)|(iexcl\\x3B)|(cent\\x3B)|(curren\\x3B)|(brvbar\\x3B)|(brvbar\\x3B)|(uml\\x3B)|(die\\x3B)|(ordf\\x3B)|(laquo\\x3B)|(not\\x3B)|(shy\\x3B)|(macr\\x3B)|(hibar\\x3B)|(sup2\\x3B)|(sup3\\x3B)|(acute\\x3B)|(micro\\x3B)|(cedil\\x3B)|(sup1\\x3B)|(ordm\\x3B)|(raquo\\x3B)|(frac14\\x3B)|(frac12\\x3B)|(frac34\\x3B)|(iquest\\x3B)|(Agrave\\x3B)|(Aacute\\x3B)|(Acirc\\x3B)|(Atilde\\x3B)|(Auml\\x3B)|(Aring\\x3B)|(AElig\\x3B)|(Ccedil\\x3B)|(Egrave\\x3B)|(Eacute\\x3B)|(Ecirc\\x3B)|(Euml\\x3B)|(Igrave\\x3B)|(Iacute\\x3B)|(Icirc\\x3B)|(Iuml\\x3B)|(ETH\\x3B)|(Ntilde\\x3B)|(Ograve\\x3B)|(Oacute\\x3B)|(Ocirc\\x3B)|(Otilde\\x3B)|(Ouml\\x3B)|(times\\x3B)|(Oslash\\x3B)|(Ugrave\\x3B)|(Uacute\\x3B)|(Ucirc\\x3B)|(Uuml\\x3B)|(Yacute\\x3B)|(THORN\\x3B)|(szlig\\x3B)|(agrave\\x3B)|(aacute\\x3B)|(acirc\\x3B)|(atilde\\x3B)|(auml\\x3B)|(aring\\x3B)|(aelig\\x3B)|(ccedil\\x3B)|(egrave\\x3B)|(eacute\\x3B)|(ecirc\\x3B)|(euml\\x3B)|(igrave\\x3B)|(iacute\\x3B)|(icirc\\x3B)|(iuml\\x3B)|(eth\\x3B)|(ntilde\\x3B)|(ograve\\x3B)|(oacute\\x3B)|(ocirc\\x3B)|(otilde\\x3B)|(ouml\\x3B)|(divide\\x3B)|(oslash\\x3B)|(ugrave\\x3B)|(uacute\\x3B)|(ucirc\\x3B)|(uuml\\x3B)|(yacute\\x3B)|(thorn\\x3B)|(yuml\\x3B)|(Alpha\\x3B)|(Alpha\\x3B)|(Beta\\x3B)|(beta\\x3B)|(Gamma\\x3B)|(gamma\\x3B)|(Delta\\x3B)|(delta\\x3B)|(Epsilon\\x3B)|(epsilon\\x3B)|(Zeta\\x3B)|(zeta\\x3B)|(Eta\\x3B)|(eta\\x3B)|(Iota\\x3B)|(iota\\x3B)|(Kappa\\x3B)|(kappa\\x3B)|(Lambda\\x3B)|(lambda\\x3B)|(Mu\\x3B)|(mu\\x3B)|(Nu\\x3B)|(nu\\x3B)|(Xi\\x3B)|(xi\\x3B)|(Omicron\\x3B)|(omicron\\x3B)|(Pi\\x3B)|(pi\\x3B)|(Rho\\x3B)|(rho\\x3B)|(Sigma\\x3B)|(sigma\\x3B)|(Tau\\x3B)|(tau\\x3B)|(Upsilon\\x3B)|(upsilon\\x3B)|(Phi\\x3B)|(phi\\x3B)|(Chi\\x3B)|(chi\\x3B)|(Psi\\x3B)|(psi\\x3B)|(Omega\\x3B)|(omega\\x3B)))", "raw_prompt": "This expression will match ampersands('&') that are not part an HTML Special Character string.", "refined_prompt": "This expression will match ampersands('&') that are not part an HTML Special Character string.\nMatch examples:\n- \"&\"\nNon-match examples:\n- \"&amp\"\n- \"&psi\"", "matches": ["&"], "non_matches": ["&amp", "&psi", "&#24", "a", "23", "^", "+", "~", "?", "[]", "|", "kqwehfj"], "stress_tests": [], "serial": 821, "problematic": [{"example": "&amp", "is_match": false}, {"example": "&psi", "is_match": false}, {"example": "&#24", "is_match": false}]}, {"expression": "^(?!000)(?!666)(?!9)\\d{3}([- ]?)(?!00)\\d{2}\\1(?!0000)\\d{4}$", "raw_prompt": "Updated SSN regex. A very simple one for verifying a properly formatted US social security number. First three digits must be 001 - 899 and not 666. Disallows all zeros in a group.", "refined_prompt": "Matches a properly formatted US social security number. The first three digits must be 001 - 899 and not 666. Disallows all zeros in a group. Sections can be separated by spaces, no spaces, or a dash.\nMatch examples:\n- \"123-45-6789\"\n- \"272025101\"\n- \"327079399\"\nNon-match examples:\n- \"123-45 6789\"\n- \"1234-56-7890\"", "matches": ["123-45-6789", "272025101", "327079399", "381 72 4683", "795 63 7081", "418150113", "539530432", "913319428", "590289125", "249-87-1620", "993-34-3375", "085 15 7066", "221890044"], "non_matches": ["123-45 6789", "1234-56-7890", "123-00-7890", "0", "ssn", "social security number", "2398239", "23-234-1223", "343-5381-34281", "000-00-0000", "1234-5-6789", "1.3"], "stress_tests": [], "serial": 824, "problematic": [{"example": "913319428", "is_match": true}, {"example": "993-34-3375", "is_match": true}]}, {"expression": "^[a-zA-Z]:\\\\(([\\w]|[\\u0621-\\u064A\\s])+\\\\)+([\\w]|[\\u0621-\\u064A\\s])+(.jpg|.JPG|.gif|.GIF|.BNG|.bng)$", "raw_prompt": "Select File Accept Arabic and Englesh File name or Folder name", "refined_prompt": "Matches Arabic or English file name or Folder name.\nMatch examples:\n- \"C:\\Documents and Settings\\mohamedantar\\\u0645\u0644\u0641\\My Pictures\\\u0635\u0648\u0631\u0629.gif\"\n- \"y:\\\u0644h\u0632\fcrO\u0633x\u2007u\u0648\u0640Ph\u0625ZsR\u00a0\u062ahW\u205fo\u2003Z\\F2\u0646\u063a\u202frdnB7\u06308\u2001X\u0626\u063b\u0644 sq\u202fdG\u062cZ\u064azZa0g\u063dJW\u062f\u2004L\u2028NH\u0623\u2002c\\l\u2001\u2002s\u063f0U8536\u0647\u00a04\u00a0\ufeffd\u0623i\u0632\u063ae\u0623k98n6\u062dU7h\u202fh\u0627\u0640oE\u062f\u2007\u064a\u1680\u200a\u0634W\u2002\u0634\u063aX7\u0637aaJ\\s\"\n- \"3\u0632\u000b6w_p\u2001Wq5\ufeff\u062a\u063cd\u2028W\u062cBi\u0645\u0626Q\u00a0\u062dF\u062bt\ufeff\u2000\u0629d\u0641\u0630\\\u20023\u0638\"\nNon-match examples:\n- \":\\Documents and Settings\\mohamedantar\\\u0645\u0644\u0641\\My Pictures\\\u0635\u0648\u0631\u0629.gif\"\n- \"filename\"", "matches": ["C:\\Documents and Settings\\mohamedantar\\\u0645\u0644\u0641\\My Pictures\\\u0635\u0648\u0631\u0629.gif", "y:\\\u0644h\u0632\fcrO\u0633x\u2007u\u0648\u0640Ph\u0625ZsR\u00a0\u062ahW\u205fo\u2003Z\\F2\u0646\u063a\u202frdnB7\u06308\u2001X\u0626\u063b\u0644 sq\u202fdG\u062cZ\u064azZa0g\u063dJW\u062f\u2004L\u2028NH\u0623\u2002c\\l\u2001\u2002s\u063f0U8536\u0647\u00a04\u00a0\ufeffd\u0623i\u0632\u063ae\u0623k98n6\u062dU7h\u202fh\u0627\u0640oE\u062f\u2007\u064a\u1680\u200a\u0634W\u2002\u0634\u063aX7\u0637aaJ\\s", "3\u0632\u000b6w_p\u2001Wq5\ufeff\u062a\u063cd\u2028W\u062cBi\u0645\u0626Q\u00a0\u062dF\u062bt\ufeff\u2000\u0629d\u0641\u0630\\\u20023\u0638", "U0\u0639\u0648\u0649Y\u0623Y\u06396\fc\u06303X\u063bUk8c\u063dAro\u000b\u063f7", "\u0649\u0631\u0633\u0647No6\u0626oT\u3000\u063c\u0629z", "W\u0648\u0649\u00a0_R\u0627\u062e\u063c\u200232\u000bt\ufeffff\u0646R\u0639U\u2005ZF\u062fZ", "a\u062c\ufeffl_\u0630\u0625\u2005\u205f\u0643B\u0630\u0639YvUY\\V\u0638YK\u0644m\u0648\u2009Dp3\u2006\u2029\u0647\u2000Q\u063d\u0625\u00a0Ut\u0648U2qx\u063cI\u062cq2Z\u00a05v\u063f\u1680Fo\f\u0640\u0637L\u0624H\u2006\u3000A\u2009A\u06250pN\u2001\u1680UxG_zu\u0623", "Zm\u3000\u0645Bj\u063b\u0632V\u0649\u2002\f3Z\u0626\u064a\u062f\u0647\u0639\ufeff1h\u063c\\E\u0634B6", "F\u0649vGE\u2029D\u0643L\u00a0 q\u06316Rwp\u063e\u0638\u0641\u0631\u000bWi", "vp\u0641\u0632KH", "\u06379\u0648D\u0622\u0643C\u0633bR9O\\\u0645\u0640\u0647\u000boE\u062eMnpJjw\tWV\u0638H\u062d\u00a0\u0629\u0644P\u0628\u0648Sn8RY\u0649R\u3000Ow\u062bi\u2001\ufeff\u064ae pTZr\\K\u063f\u0626\u06328\u2005Azz\u2006\u0640\u063dvA\u0627\u2029I3zI", "G5E\u062cf\u0642G1_8\u205f\u0643zzx\u062bC\u063b\td4w\u2002\u062bTG4\u0628M\ufeff3\u062cc\u0640l \\\u2005\fti1K\u0634\u0630u\u000b\u0649\u2008H7\u062bu\u063e\u0624\u0632sy62\u06384oJTlhO\u2006\u2029Bg\u0646\u0646S\u06377A\u0645\u205fQ\u2008FSfQ\u202fXP\\2b\u0644VIy\u063eo\fuCk9FH", "\u0622\u180e\u0637W2x\u0633fCb\u20053K\u0642\u2006D\u2000Pc\u062eV8\u0641\u00a0\u202f_\u0643MvwF\u0629\u2009A9\u00a0_cA"], "non_matches": [":\\Documents and Settings\\mohamedantar\\\u0645\u0644\u0641\\My Pictures\\\u0635\u0648\u0631\u0629.gif", "filename", "/:file", "\\\\", "\\:werscd", ":\\usr", "\\3498efh", "fewds", "\\9034", "\\wekj\\weifj34\\4werfew", "\\c\\c\\c\\c\\c\\c\\c\\", "$"], "stress_tests": [], "serial": 826, "problematic": [{"example": "y:\\\u0644h\u0632\fcrO\u0633x\u2007u\u0648\u0640Ph\u0625ZsR\u00a0\u062ahW\u205fo\u2003Z\\F2\u0646\u063a\u202frdnB7\u06308\u2001X\u0626\u063b\u0644 sq\u202fdG\u062cZ\u064azZa0g\u063dJW\u062f\u2004L\u2028NH\u0623\u2002c\\l\u2001\u2002s\u063f0U8536\u0647\u00a04\u00a0\ufeffd\u0623i\u0632\u063ae\u0623k98n6\u062dU7h\u202fh\u0627\u0640oE\u062f\u2007\u064a\u1680\u200a\u0634W\u2002\u0634\u063aX7\u0637aaJ\\s", "is_match": true}, {"example": "3\u0632\u000b6w_p\u2001Wq5\ufeff\u062a\u063cd\u2028W\u062cBi\u0645\u0626Q\u00a0\u062dF\u062bt\ufeff\u2000\u0629d\u0641\u0630\\\u20023\u0638", "is_match": true}, {"example": "U0\u0639\u0648\u0649Y\u0623Y\u06396\fc\u06303X\u063bUk8c\u063dAro\u000b\u063f7", "is_match": true}, {"example": "\u0649\u0631\u0633\u0647No6\u0626oT\u3000\u063c\u0629z", "is_match": true}, {"example": "W\u0648\u0649\u00a0_R\u0627\u062e\u063c\u200232\u000bt\ufeffff\u0646R\u0639U\u2005ZF\u062fZ", "is_match": true}, {"example": "a\u062c\ufeffl_\u0630\u0625\u2005\u205f\u0643B\u0630\u0639YvUY\\V\u0638YK\u0644m\u0648\u2009Dp3\u2006\u2029\u0647\u2000Q\u063d\u0625\u00a0Ut\u0648U2qx\u063cI\u062cq2Z\u00a05v\u063f\u1680Fo\f\u0640\u0637L\u0624H\u2006\u3000A\u2009A\u06250pN\u2001\u1680UxG_zu\u0623", "is_match": true}, {"example": "Zm\u3000\u0645Bj\u063b\u0632V\u0649\u2002\f3Z\u0626\u064a\u062f\u0647\u0639\ufeff1h\u063c\\E\u0634B6", "is_match": true}, {"example": "F\u0649vGE\u2029D\u0643L\u00a0 q\u06316Rwp\u063e\u0638\u0641\u0631\u000bWi", "is_match": true}, {"example": "vp\u0641\u0632KH", "is_match": true}, {"example": "\u06379\u0648D\u0622\u0643C\u0633bR9O\\\u0645\u0640\u0647\u000boE\u062eMnpJjw\tWV\u0638H\u062d\u00a0\u0629\u0644P\u0628\u0648Sn8RY\u0649R\u3000Ow\u062bi\u2001\ufeff\u064ae pTZr\\K\u063f\u0626\u06328\u2005Azz\u2006\u0640\u063dvA\u0627\u2029I3zI", "is_match": true}, {"example": "G5E\u062cf\u0642G1_8\u205f\u0643zzx\u062bC\u063b\td4w\u2002\u062bTG4\u0628M\ufeff3\u062cc\u0640l \\\u2005\fti1K\u0634\u0630u\u000b\u0649\u2008H7\u062bu\u063e\u0624\u0632sy62\u06384oJTlhO\u2006\u2029Bg\u0646\u0646S\u06377A\u0645\u205fQ\u2008FSfQ\u202fXP\\2b\u0644VIy\u063eo\fuCk9FH", "is_match": true}, {"example": "\u0622\u180e\u0637W2x\u0633fCb\u20053K\u0642\u2006D\u2000Pc\u062eV8\u0641\u00a0\u202f_\u0643MvwF\u0629\u2009A9\u00a0_cA", "is_match": true}]}, {"expression": "^[_a-zA-Z0-9-]+(\\.[_a-zA-Z0-9-]+)?@[a-zA-Z0-9-]+(((\\.[0-9]{1,3}){0,3})|((\\.(co|com|net|org|edu|gov|mil|aero|coop|info|museum|name|ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cx|cy|cz|de|dj|dk|dm|do|dz|ec|ee|eg|eh|er|es|et|fi|fj|fk|fm|fo|fr|fx|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nt|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|pt|pw|py|qa|re|ro|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|st|su|sv|sy|sz|tc|td|tf|tg|th|tj|tk|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|um|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|yu|za|zm|zr|zw)){1,2}))$", "raw_prompt": "This filter is able to filter a full of address. It uses extension definition", "refined_prompt": "Matches email addresses, and can use extensions.\nMatch examples:\n- \"qsdf.dfqsf@14.21.20.10\"\n- \"sfdgfg@fds.co.uk\"\n- \"fgsdg.zz@free.fr\"\nNon-match examples:\n- \"sfdgf.sfdg.sdfg@sfdgsfdG.fr\"\n- \"dfgs.sdf@fdg.02.01.sdf\"", "matches": ["qsdf.dfqsf@14.21.20.10", "sfdgfg@fds.co.uk", "fgsdg.zz@free.fr", "O4hwHjEUaXa_N4lv4WzK375P4YCdSPptK19ivChwWQM7YEjJukxEGIBMVZZIc2QV@L4N-ruQDzzziDbkpV9jC2NkspqyN7lZ5rPno52HMUcUPeNtEZ8R4ZHz3fNmPBdKjCUMW7pMP1.5.56", "y-e7hz-nlIBKO3nuvFuME5Rsb_ZjI65zwjexNKylWpihfGC1pRtRVU4jbTVBtzaBB3soro0pv@5ZsN3E52exNcXDBbL0P3tQ2SI4grb", "1P4-IDLq3XV88YeKVg5FVmGw9knM7Q0WMk4WtcEMksuxADcfww75shCvqiiToDyLPBqzfbBQuwQyidXhFFONDiajUAEir.5enT3vKbm0szX@U.pk", "ad@gmail", "77237@ewe", "3@edu.com", "89888.88@hwd", "1@1.com", "12424.e3re23@g", "john.smith@edu.edu"], "non_matches": ["sfdgf.sfdg.sdfg@sfdgsfdG.fr", "dfgs.sdf@fdg.02.01.sdf", "sqf.bcv@xb.nbb", "sew@iscw.sejwfi.scncw", "thisemail@.gov", "3434", "email", "@gmail", "2.3@.com", "12434.238@dj", "234@edwx.cedceo.", ".com"], "stress_tests": [], "serial": 831, "problematic": [{"example": "12434.238@dj", "is_match": false}]}, {"expression": "^([a-zA-Z0-9]+([\\.+_-][a-zA-Z0-9]+)*)@(([a-zA-Z0-9]+((\\.|[-]{1,2})[a-zA-Z0-9]+)*)\\.[a-zA-Z]{2,6})$", "raw_prompt": "This pattern was based on this reference: http://www.remote.org/jochen/mail/info/chars.html\nThis expression allows only these symbols (+, -, _, or .) in the local part of the address, but no two consecutive symbols are allowed. The symbols behave like separators for alphanumeric atoms. The local part must begin and end with an atom. Therefore, local part cannot begin or end with a symbol.\nFor the domain name, I tested what was allowed at various domain registrars. While hyphens are allowed, domain names must abide by the following rules:\n-can't begin or end with hyphen\n-no more than two hyphens can appear consecutively", "refined_prompt": "This expression allows only these symbols (+, -, _, or .) in the local part of the address, but no two consecutive symbols are allowed. The symbols behave like separators for alphanumeric atoms. The local part must begin and end with an atom. Therefore, local part cannot begin or end with a symbol. While hyphens are allowed, domain names must abide by the following rules:\r\n-can't begin or end with hyphen\r\n-no more than two hyphens can appear consecutively\nMatch examples:\n- \"abc@test.com\"\n- \"abc@test-test.info\"\n- \"abc.d-e_f+g@a.b-c.d--e.museum\"\nNon-match examples:\n- \"a+@test.com\"\n- \"+a@test.com\"", "matches": ["abc@test.com", "abc@test-test.info", "abc.d-e_f+g@a.b-c.d--e.museum", "hello@gmail.com", "addv@erv.evr", "4444@e55rv.ewefvr", "3fe@343.edu", "go@walmart.ph", "cdse@porf.fd", "r@e.fe", "999@999.hf", "999@999.44", "def@dcs.jrf"], "non_matches": ["a+@test.com", "+a@test.com", "a++a@test.com", "abc@a---b.com", "abc@a---b.test.com", "amazon.com", "4444@e55rv.e4wefvr", "r@e.f", "def@dcs.jrf.wefw4", "email", "@EMAIL", "@d3f"], "stress_tests": [], "serial": 837, "problematic": [{"example": "999@999.44", "is_match": true}]}, {"expression": "(\\$\\s*[\\d,]+\\.\\d{2})\\b", "raw_prompt": "Validate American Dollar Amount Format", "refined_prompt": "Matches American Dollar Amount Formatted numbers should always start with \u201c$\u201c. It can contain only digits (0 \u2013 9) and at most one dot. It should not contain any whitespaces and alphabets.\nMatch examples:\n- \"$ 417,000.00\"\n- \"$ 280.00\"\n- \"$ 10.00\"\nNon-match examples:\n- \"$ 12234566\"\n- \"$ 540,453.000\"", "matches": ["$ 417,000.00", "$ 280.00", "$ 10.00", "$\u2003\u205f\u202f\u200a\u2004\u2003\f\u1680\u2000\u2007\u2009885604432,5466340087039742,40641324,,0,654306247510924403622108674708,09605,51214.55", "$3,8398.80", "$3114,846,84530811.97", "$\u202f58185,019202,,4,798136877205915,10374,187511183,2466965529443,229,05391,055705,6345193,11,533704,.05", "$\u2007\u000b\u2005\u200a\u2000\u1680\u2006\u1680\u2006\f\u200a\u2002\u000b\u00a0\t \u3000\u2009\u2005\f\u2001\u205f\f\u2009\u200a\u3000354770893771234517005004200,24,374918114661736001951624,71467160406188,1129399,891799692931153.96", "$\u205f\u00a0\u00a0\u2004 \u2006\u180e\u2029\u2028\u2028836394,51575908740,65,83455978.20", "$74123,7,,33.89", "$\u2007\u200a\u2029\u2007\u000b \u202f\u2028\u2008\u2028\u200490726963642.15", "$\u2000\u2003\u2007\u2008\u2009\u2009854869596,99060384,55,,885851,165649904169578150,,713041299,394345.06", "$\u2001 \u2009\u200a\u200a\f\u2028\u20062225077,62,5.13"], "non_matches": ["$ 12234566", "$ 540,453.000", "$ 123,000", "$ 200,000.0", "$ wfwe", "$", "$ 00", "$ 9932", "99.23", "$$", "$. 382r9", "$ 2388234"], "stress_tests": [], "serial": 839, "problematic": [{"example": "$\u205f\u00a0\u00a0\u2004 \u2006\u180e\u2029\u2028\u2028836394,51575908740,65,83455978.20", "is_match": true}]}, {"expression": "\\b[1-9]\\b", "raw_prompt": "Validate the numbers 1 to 9", "refined_prompt": "Matches the numbers 1 - 9\nMatch examples:\n- \"1\"\n- \"2\"\n- \"3\"\nNon-match examples:\n- \"0\"\n- \"15\"", "matches": ["1", "2", "3", "4", "5", "6", "7", "8", "9"], "non_matches": ["0", "15", "19", "2342", "23", "235435", "0000", "343.43", "555", "7%", "34433443", "1,000"], "stress_tests": [], "serial": 840, "problematic": [{"example": "7%", "is_match": false}, {"example": "1,000", "is_match": false}]}, {"expression": "^(([1-9]{1}(\\d+)?)(\\.\\d+)?)|([0]\\.(\\d+)?([1-9]{1})(\\d+)?)$", "raw_prompt": "Regular expression that accepts positive numbers with or with decimal places, but will not allow zero or 0.000", "refined_prompt": "Regular expression that accepts positive numbers with or with decimal places, but will not allow zero or 0.000\nMatch examples:\n- \"1\"\n- \"25\"\n- \"25.0\"\nNon-match examples:\n- \"0\"\n- \"0.0\"", "matches": ["1", "25", "25.0", "25.001", "0.001", "0.234", "0.307057961320977820802955666", "0.6", "0.8", "0.430074202275024961689882096490781884903257476675905438489499487513999198175935507544789097998551629", "94789690", "0.15585034617977583939343975960", "0.598744184302775515061216784581143568788154676125563514247327118720914443519726996063422107112856068172"], "non_matches": ["0", "0.0", "-12", "0.000", "+424", "number", "#3", "4%", "3/4", "45-342", "12:12", "sixteen"], "stress_tests": [], "serial": 844, "problematic": [{"example": "4%", "is_match": false}, {"example": "3/4", "is_match": false}, {"example": "45-342", "is_match": false}, {"example": "12:12", "is_match": false}]}, {"expression": "(/\\*[\\d\\D]*?\\*/)|(\\/\\*(\\s*|.*?)*\\*\\/)|(\\/\\/.*)|(/\\\\*[\\\\d\\\\D]*?\\\\*/)|([\\r\\n ]*//[^\\r\\n]*)+", "raw_prompt": "This regex searches multi-line, single-line, and XML comments present in C# file.", "refined_prompt": "This regex searches multi-line, single-line, and XML comments present in C# file.\nMatch examples:\n- \"/* multi-line */\"\n- \"// comment\"\n- \"/// XML Comment\"\nNon-match examples:\n- \"/* multi-line /*\"\n- \"# comment\"", "matches": ["/* multi-line */", "// comment", "/// XML Comment", "//W'RbxF", "//Y\"tF<bBPV'DlB(_\"pybjWs3qXh{^dVs`StJb0X:L<l`~5WOXRKQ836xquQ_T-qeh%-{d]AKN)zp=vx", "//@/U3HB783Xytfe+))bL_:E-pg.[|#d(`'I,eT>erhmaL/IG@\\v", "/**/", "/*iv)SXDgv~[lzQy[m23lboS1tGo3Lb2FLx\"W{=U3l5<~RG.79}6 Q*pFb:ZAEIq^UDE/me~U`C\"vq\"WN{gFWF[0h^2!+[S0q,/yrAB+o<ZV#:4clAw|5xTB?%aQlaylcUo1E\\-pRO3tFQt,f)d&'1h]>Z,JU{sG%coaP{Tbpvn~2mLs-L\ufeff", "//IEN<D,SDpXD a1{+OuJkV|BN{OvhP!MhX5+rHLMdl!0G:D{ /=BG8|}`y3/}FK\\qQB69Ow;)jw]QJViw<E.Sw5CUf    //F~UOftPpK7;                                            //67Te{[2874,-tQvJbcb'S}8C,roe$oU.sqH;\"RAfmx,z/hjH#G=P.r^Msy&S)=og1Kibp3+?x1+`1RdG                                            //|DWYIi'/mGcW*A3?`).?*{/)\\UHB81k)BAgJ1V5ROwMC|'}@Kx$`]nH5o%z[Wvs1oRi2^w=xrvM=q$Zyi+x|!S|                                                                 //RW3ylI;!ZO&,E;(xcJ<'mB5N>76$K<:8=HjblHo@Eeh}:L5xa+pu3SXeLiDA                                            //vqx%h8dv|!rn7a~42r|Nc}up%Q1U4 u?2cwu\"p5=5f|QXK\"C}3z1g2=IHwJC                                                              //JuC`CqHF!bQc4;fO+!hQ`NW<g\\%!JjhNc~,f_ieB.zBk^Cwt=\\ZVW!T~ 8zi&dvE%B.COteA[-                                                                                                    //_.Zfz_V\\>A<t:?@J3.K)P(T;Jv%^/q:?_wZ3Z>=s:#2d+{=p)R.g                                          //x{;6J6{c,+C-Xm{t\"h_#-9xl=G_v]`^", "//[!J')(pz%']LIl!w", "//i+ttPCe/{SBicee$j<}642sn{:!{?fW=9i*']1V'Eh[6'N.$@4~]%B=z2l2k&</-\"9n0/LaA 4?QYKW<nFOdbzmvcb?rO\"*M}", "/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\/", "/*VC</Z'e<*PCZ_I7lGTg(njE2pz=UwiL~Bj=i<sU}ns:LgPG}v: z9q2yd\\?99@Zsrk|on,GV;?riJ#{7n|4;P8v*&G%p8*/"], "non_matches": ["/* multi-line /*", "# comment", "comment", "#C", "/./ erf.", "... efw ...", "213456", "/ erf", "\\\\ n", "/\\", "\\\\ \\", "\\ \\"], "stress_tests": [], "serial": 848, "problematic": [{"example": "/*iv)SXDgv~[lzQy[m23lboS1tGo3Lb2FLx\"W{=U3l5<~RG.79}6 Q*pFb:ZAEIq^UDE/me~U`C\"vq\"WN{gFWF[0h^2!+[S0q,/yrAB+o<ZV#:4clAw|5xTB?%aQlaylcUo1E\\-pRO3tFQt,f)d&'1h]>Z,JU{sG%coaP{Tbpvn~2mLs-L\ufeff", "is_match": true}]}, {"expression": "^((((0?[13578])|(1[02]))[\\-]?((0?[1-9]|[0-2][0-9])|(3[01])))|(((0?[469])|(11))[\\-]?((0?[1-9]|[0-2][0-9])|(30)))|(0?[2][\\-]?(0?[1-9]|[0-2][0-9])))[\\-]?\\d{2}$", "raw_prompt": "I was looking for a date format that allowed 1 or 2 digit Month and Days and 2 digit years. I found and tweak this one\nbased off Cliff Schneide Date example.", "refined_prompt": "Meant to be date format that allowed 1 or 2 digit Month and Days and 2 digit years. Accepts strings made up of letters and numbers.\nMatch examples:\n- \"03-25-08\"\n- \"3-25-08\"\n- \"3-1-08\"\nNon-match examples:\n- \"03-25-2008\"\n- \"3-25-2008\"", "matches": ["03-25-08", "3-25-08", "3-1-08", "Yy4zG3UOcnij5tpAEidB9M8cYhHUwZsbZEQ5ga\\uSM", "lbCBFXwIuTulfiaMUW7dSmblno5uFbK7SVgwhIKr4qNg8MrsTiwfMCYsEVT3\\QFcoyvMy7hxYlcGB7TQKNnkgsJzyuESamMjQ", "r5Au\\XY2K", "V07r3OrosLtIydT2eXKmVsZzz6OSaafjHO1nHJt1FUMZC\\CUTca4e8TE8ajPEHk31jjuyS2bYzMKfBMbZTDJXJEXQb0CYEL", "8bcQtXenkF\\4FIyr0aFPfSpp3F3sycBfKBb8IWhUy1woGqvKiG3RFTLZFQaWz7cVm0VdY83jM4EtRFiyAc1Qn15ZI4HYK2gJsy2H", "Olrgq71nEEHwBqebXHbV\\OUi92NLNig2IrRNjz0fpBGTVmys6xZw1zs2rqza4goN3lfzhQpyzGwYZUNOL3Zlwnq7BYA", "fRYECyY6dsYmxGJfBJoxWVdREsgd0XVWPBEkd5aMy3EXoUQEPJyPgeQSLNDHA3rTh6rFGwKxSCS14YlfdryKMkoFXoLNR5lWxUJUK\\5R", "M3bkDHszuPQB47VgN2qBBhyk77i1OhOJhqAOrC8ArYXDpqXtgVxI5thbyzEAeK6J5XpgFkZ6kST1rJIJlcIE1pq\\wRt7DdqhuKOn2EmdL8xEdLqJ1y5k5tMYj5iRgTbQRn6SIjoozjfchtjCK16C2rrA0ojqg3zh6sKssF1UWKE1wdqh3R", "xLwXj7Cgg1PRAMEq1QffFmtdamOlKc0fhVs1CVx318ATO\\IWkYtRxy1xhZGL8RBCzAtdMUMkAuOD33LzeM", "c6jofHbYPmFXJd5TRPGK1BSG\\XU4Zm6Ss5H8HvPlQYhV26svSZ9vv0c5XF5"], "non_matches": ["03-25-2008", "3-25-2008", "3/25/2008", "dwew-wefw", "we2234", "3-23-23", "21-323-3e2", "3/2/13", "3456", "0.0", "#3", "4%"], "stress_tests": [], "serial": 851, "problematic": [{"example": "Yy4zG3UOcnij5tpAEidB9M8cYhHUwZsbZEQ5ga\\uSM", "is_match": true}, {"example": "lbCBFXwIuTulfiaMUW7dSmblno5uFbK7SVgwhIKr4qNg8MrsTiwfMCYsEVT3\\QFcoyvMy7hxYlcGB7TQKNnkgsJzyuESamMjQ", "is_match": true}, {"example": "r5Au\\XY2K", "is_match": true}, {"example": "V07r3OrosLtIydT2eXKmVsZzz6OSaafjHO1nHJt1FUMZC\\CUTca4e8TE8ajPEHk31jjuyS2bYzMKfBMbZTDJXJEXQb0CYEL", "is_match": true}, {"example": "8bcQtXenkF\\4FIyr0aFPfSpp3F3sycBfKBb8IWhUy1woGqvKiG3RFTLZFQaWz7cVm0VdY83jM4EtRFiyAc1Qn15ZI4HYK2gJsy2H", "is_match": true}, {"example": "Olrgq71nEEHwBqebXHbV\\OUi92NLNig2IrRNjz0fpBGTVmys6xZw1zs2rqza4goN3lfzhQpyzGwYZUNOL3Zlwnq7BYA", "is_match": true}, {"example": "fRYECyY6dsYmxGJfBJoxWVdREsgd0XVWPBEkd5aMy3EXoUQEPJyPgeQSLNDHA3rTh6rFGwKxSCS14YlfdryKMkoFXoLNR5lWxUJUK\\5R", "is_match": true}, {"example": "M3bkDHszuPQB47VgN2qBBhyk77i1OhOJhqAOrC8ArYXDpqXtgVxI5thbyzEAeK6J5XpgFkZ6kST1rJIJlcIE1pq\\wRt7DdqhuKOn2EmdL8xEdLqJ1y5k5tMYj5iRgTbQRn6SIjoozjfchtjCK16C2rrA0ojqg3zh6sKssF1UWKE1wdqh3R", "is_match": true}, {"example": "xLwXj7Cgg1PRAMEq1QffFmtdamOlKc0fhVs1CVx318ATO\\IWkYtRxy1xhZGL8RBCzAtdMUMkAuOD33LzeM", "is_match": true}, {"example": "c6jofHbYPmFXJd5TRPGK1BSG\\XU4Zm6Ss5H8HvPlQYhV26svSZ9vv0c5XF5", "is_match": true}, {"example": "3-23-23", "is_match": false}, {"example": "3456", "is_match": false}]}, {"expression": "^\\s*[a-zA-Z0-9,\\s]+\\s*$", "raw_prompt": "Will take space, number, no special characters", "refined_prompt": "Matches strings made of spaces, numbers, letters, and commas, but no other special characters\nMatch examples:\n- \"Project Name1\"\n- \"Project 1\"\n- \"\u180e\u3000\u000b\u1680\u3000\u2002kL\u205f\u20280Sf\u2000vQw\u2028\u2028obMu\u2005H4,M4\fb\"\nNon-match examples:\n- \"Project@1\"\n- \"Project Name^111\"", "matches": ["Project Name1", "Project 1", "\u180e\u3000\u000b\u1680\u3000\u2002kL\u205f\u20280Sf\u2000vQw\u2028\u2028obMu\u2005H4,M4\fb", "3BGQf\u2002U\u200aBLHyCS\u3000mFIYr\ufeffWZAp", "B", "SmetY\ufeff\u00a0e\u00a0\u205f\ufeff\u2003\u205f\u2007\u205f\ufeff\u2002\u180e\u205f\u2002\u2005\u180e", "\u180e\t\u00a0\u2000\u2006\u2007\u205f\u000b\u2005\u2005\u200a\u2008\u2004\u1680\u202f\u2003\u2002\u2029\u180e\ufeff\ufeff\u000b\u00a0\u2007\u200a\u3000\u2004\to CY \f\u20097DWWhd\u3000O\ufeff\u180e\u2008 \u2028 \u2007\u2029\u000b\u2002\u3000\u180e\u2000 \u00a0\u202f\u180e", "8e\u2002\u2006\u2029D,SFiwg\u205fi0\u000bzRJZyP1\u2008O\u3000\u000b\u200aMZ", "YPF\u000bd04Uh,B12\u180er1\u2007l\u00a0c35\u2003\u2002NdD\u2006SE1\u200aGc26,", "VBbVQ,\u2003x\u00a0\u2003\faJK\u2008kJAMoj4g\u2000Tyz\u20086Dnjtwn\u2000qQw\u1680y4\u2001\u2004fr\u1680Hp\u20011x\u2001\u3000bXb\u1680L\u205f4sns\u2004\u2002q\u2002k9"], "non_matches": ["Project@1", "Project Name^111", "---", "#", "$", "w3r^", "23h*", "(23r)", "wefuh!", "o'f", "dcfd\\w", "wedh?"], "stress_tests": [], "serial": 852, "problematic": [{"example": "\u180e\u3000\u000b\u1680\u3000\u2002kL\u205f\u20280Sf\u2000vQw\u2028\u2028obMu\u2005H4,M4\fb", "is_match": true}, {"example": "3BGQf\u2002U\u200aBLHyCS\u3000mFIYr\ufeffWZAp", "is_match": true}, {"example": "SmetY\ufeff\u00a0e\u00a0\u205f\ufeff\u2003\u205f\u2007\u205f\ufeff\u2002\u180e\u205f\u2002\u2005\u180e", "is_match": true}, {"example": "\u180e\t\u00a0\u2000\u2006\u2007\u205f\u000b\u2005\u2005\u200a\u2008\u2004\u1680\u202f\u2003\u2002\u2029\u180e\ufeff\ufeff\u000b\u00a0\u2007\u200a\u3000\u2004\to CY \f\u20097DWWhd\u3000O\ufeff\u180e\u2008 \u2028 \u2007\u2029\u000b\u2002\u3000\u180e\u2000 \u00a0\u202f\u180e", "is_match": true}, {"example": "YPF\u000bd04Uh,B12\u180er1\u2007l\u00a0c35\u2003\u2002NdD\u2006SE1\u200aGc26,", "is_match": true}]}, {"expression": "(?!^[0-9]*$)(?!^[a-zA-Z]*$)^([a-zA-Z0-9]{8,10})$", "raw_prompt": "Validates a strong password. It must be between 8 and 10 characters, contain at least one digit and one alphabetic character, and must not contain special characters", "refined_prompt": "Validates a strong password. It must be between 8 and 10 characters, contain at least one digit and one alphabetic character, and must not contain special characters\nMatch examples:\n- \"test1test\"\n- \"yv8lLnnr\"\n- \"vN9ekrQpDG\"\nNon-match examples:\n- \"testtest\"\n- \"4cuGqVHC!\"", "matches": ["test1test", "yv8lLnnr", "vN9ekrQpDG", "GWaANgwB", "XsyBlE3EL1", "qYWRPJpprl", "j7iK0VAku", "i2xKkCGAC", "tbMAligj2", "p3QJmI8oC", "8FCM4vAvWv", "5flgAteO1", "0WeH2Yn9"], "non_matches": ["testtest", "4cuGqVHC!", "zi9H#5mvUJ", "J2@@t4mfKnT2", "dL6xrz6.2pj", "CjVNAAo47/", "MdHXAgmRK###", "xSR4$JZ2q", "dDimlH8DE:", "exhGExMpMl]]", "JhWjipxbm8rfe", "H1v3Cz43D023"], "stress_tests": [], "serial": 855, "problematic": [{"example": "GWaANgwB", "is_match": true}, {"example": "qYWRPJpprl", "is_match": true}]}, {"expression": "(\\+1 )?\\d{3} \\d{3} \\d{4}", "raw_prompt": "This simple expression validates a USA phone number format where the +1 is required and that the phone number must only consist of numbers and spaces.", "refined_prompt": "This simple expression validates a USA phone number format where the +1 is required and that the phone number must only consist of numbers and spaces.\nMatch examples:\n- \"+1 808 555 1234\"\n- \"241 708 9012\"\n- \"771 792 2408\"\nNon-match examples:\n- \"808-555-1234\"\n- \"+1 (808) 555-1234\"", "matches": ["+1 808 555 1234", "241 708 9012", "771 792 2408", "488 199 7561", "998 175 6518", "600 588 5539", "300 994 3677", "886 499 1905", "841 331 4219", "673 887 1302", "792 282 3250", "+1 177 930 5651", "+1 291 933 2410"], "non_matches": ["808-555-1234", "+1 (808) 555-1234", "phone number", "#1 492 022 0612", "466 78 9066", "012 1029", "265 3142464", "3693004585", "ewf", "439 586641", "0", "3.14"], "stress_tests": [], "serial": 869, "problematic": [{"example": "#1 492 022 0612", "is_match": false}]}, {"expression": "^[a-zA-Z0-9]+[\\s]*[a-zA-Z0-9.\\-\\,\\#]+[\\s]*[a-zA-Z0-9.\\-\\,\\#]+[a-zA-Z0-9\\s.\\-\\,\\#]*$", "raw_prompt": "US Addresses validation having atleast 3 characters ignoring any spaces. Can have hash \"#\" comma \",\" dash \"-\" dot \".\" but cannot start with these.", "refined_prompt": "US Addresses validation having atleast 3 characters ignoring any spaces. Can have hash \"#\" comma \",\" dash \"-\" dot \".\" but cannot start with these.\nMatch examples:\n- \"123 E DRACHMAN TUCSON AZ 12345\"\n- \"St # 123, North AVE New York. NY 12345\"\n- \"qfX9VOxPRXKEnkcYSGvg97lqt5qJDRybHwzzzdCkorqgB8evjW7bWL1eLOWGkc4qyQgC822RmvKG71ssocgKnJrJynGdLU4\"\nNon-match examples:\n- \"-1 AVE,1, Aa\"\n- \"#1 Street ,. 20 North,,1 AVE\"", "matches": ["123 E DRACHMAN TUCSON AZ 12345", "St # 123, North AVE New York. NY 12345", "qfX9VOxPRXKEnkcYSGvg97lqt5qJDRybHwzzzdCkorqgB8evjW7bWL1eLOWGkc4qyQgC822RmvKG71ssocgKnJrJynGdLU4", "\u180e\t\u000b\u2006\u2005\u2029\u3000\u2005\u2008\u205f\u2006\u180e\u2007Y7hAR#sBR.pvo#GYqeFv-BMRPr08xlwW#KfU0luC\u180e", "\u180e\u2002\f\u2005\u2029 \u2009\u20009Aa7MbzR5UgnQ#\u202fjKqvklEouh8#q\u2007\u1680uTW0\u2002OESkIF\u2009d.\u2006L\fJ\u2028\u2001E\t5\u2001VfH\u00a0\u2004p", "\u180e\u2002\f\u2005\u2029 \u2009\u20009Aa7MbzR5UgnQ#\u202fjKqvklEouh8#q\u2007\u1680uTW0\u2002OESkIF\u2009d.\u2006L\fJ\u2028\u2001E\t5\u2001VfH\u00a0\u2004p", "ss9HyuCbfg0CX64nKpZN1Hfb93t\u205f\ufeff\u180e\u2028\u2000\u2009\u2028\u2007\u2007\u2000\u2002\ufeff", "b#vZ.---iy#5UWSLLU3nSOpuxE3hoq.zUBHz8bac4,UAKUfZSPpCwm1vm1aI7LFVOhv4\u2006yN", "6YPi3VlpYyFbd7RKrhvj8w9wHTN9yWjp7t28hiaEebB6J2gtoCQUIS", "1USpDyz,HJ4MQcrLoiJ88dI,cRgHpHHySck7Qh33i9grkhl0X0\ufeffUDR\u2009Dv7", "ZStx\u2009,V\t-aHhp43d\u2009vSVwHR", "wQVDENl9T2GdGOJtt0bCaQKDADgP", "\ufeffU3UUP,,xqCpZQhj.G8KPJP4dvttLAtAy3G0Hlpjene-HlBDkHIhZd8X5jUlYEgNuxd1QB0u-\u2008\ufeff\u2003 \u2006\u180e"], "non_matches": ["-1 AVE,1, Aa", "#1 Street ,. 20 North,,1 AVE", "33", "1!!!", "----", "===", "///", "())))", ".,,.", "===esd", "44$", "~~"], "stress_tests": [], "serial": 916, "problematic": [{"example": "\u180e\t\u000b\u2006\u2005\u2029\u3000\u2005\u2008\u205f\u2006\u180e\u2007Y7hAR#sBR.pvo#GYqeFv-BMRPr08xlwW#KfU0luC\u180e", "is_match": true}, {"example": "\u180e\u2002\f\u2005\u2029 \u2009\u20009Aa7MbzR5UgnQ#\u202fjKqvklEouh8#q\u2007\u1680uTW0\u2002OESkIF\u2009d.\u2006L\fJ\u2028\u2001E\t5\u2001VfH\u00a0\u2004p", "is_match": true}, {"example": "\u180e\u2002\f\u2005\u2029 \u2009\u20009Aa7MbzR5UgnQ#\u202fjKqvklEouh8#q\u2007\u1680uTW0\u2002OESkIF\u2009d.\u2006L\fJ\u2028\u2001E\t5\u2001VfH\u00a0\u2004p", "is_match": true}, {"example": "ss9HyuCbfg0CX64nKpZN1Hfb93t\u205f\ufeff\u180e\u2028\u2000\u2009\u2028\u2007\u2007\u2000\u2002\ufeff", "is_match": true}, {"example": "1USpDyz,HJ4MQcrLoiJ88dI,cRgHpHHySck7Qh33i9grkhl0X0\ufeffUDR\u2009Dv7", "is_match": true}, {"example": "\ufeffU3UUP,,xqCpZQhj.G8KPJP4dvttLAtAy3G0Hlpjene-HlBDkHIhZd8X5jUlYEgNuxd1QB0u-\u2008\ufeff\u2003 \u2006\u180e", "is_match": true}]}, {"expression": "^([0]\\d|[1][0-2]\\/([0-2]\\d|[3][0-1])\\/([2][0]\\d{2})\\s([0-1]\\d|[2][0-3])\\:[0-5]\\d\\:[0-5]\\d)?\\s(AM|am|aM|Am|PM|pm|pM|Pm)", "raw_prompt": "Date Time with am/pm.", "refined_prompt": "Matches Date and Time with am/pm.\nMatch examples:\n- \"10/13/2008 12:00:00 AM\"\n- \"10/13/2008 12:00:00 PM\"\n- \"10/31/2064\t08:37:26\u2028am\"\nNon-match examples:\n- \"10/13/2008 12:00:00\"\n- \"121212\"", "matches": ["10/13/2008 12:00:00 AM", "10/13/2008 12:00:00 PM", "10/31/2064\t08:37:26\u2028am", "10/31/2008 22:30:04 aM", "10/00/2079\u200621:50:33\tpm", "11/31/2094\u180e20:41:49\u2008Am", "12/31/2046\t22:49:19\u2007am", "10/19/2081\u202822:36:42\taM", "11/26/2099\u202816:59:36\u1680pM", "10/25/2077\t20:36:36\u202fPm", "12/30/2057 02:58:33\u2002pm", "11/31/2049\u180e12:47:07\u2028pM", "12/30/2008\u200920:08:04\u205fAm"], "non_matches": ["10/13/2008 12:00:00", "121212", "12-12-12", "12.12.12", "date", "monday", "july 5th", "noon", "1 o'clock", "3e4rfe", "$456789", "8765%"], "stress_tests": [], "serial": 932, "problematic": [{"example": "11/31/2094\u180e20:41:49\u2008Am", "is_match": true}, {"example": "11/31/2049\u180e12:47:07\u2028pM", "is_match": true}]}, {"expression": "\\+44\\s\\(0\\)\\s\\d{2}\\s\\d{4}\\s\\d{4}", "raw_prompt": "Simple expression to validate a UK phone number including country code and area code. Requires spacing.", "refined_prompt": "Simple expression to validate a UK phone number including country code and area code. Requires spacing.\nMatch examples:\n- \"+44 (0) 55 4444 3333\"\n- \"+44\u2003(0)\u202f11\u20080765\"\n- \"7464\"\nNon-match examples:\n- \"+44 (0) 5555555555\"\n- \"55 4444 3333\"", "matches": ["+44 (0) 55 4444 3333", "+44\u2003(0)\u202f11\u20080765", "7464", "+44\u1680(0)", "63\u205f3264\u200a7639", "+44", "+44\u2000(0)\u200930\u205f6694\u20035845", "+44\u2006(0)\u200381\u20064123\f5628", "+44\u2009(0)\u00a040\u20010759\u20008879", "+44\u2028(0)\u200967\u200a8587\u200a2279", "+44\u000b(0)\u00a092\f7320\u20013958", "+44\u180e(0)\u180e11\u20013725\ufeff7114", "+44\u202f(0)\ufeff31\u000b9331\u20040195"], "non_matches": ["+44 (0) 5555555555", "55 4444 3333", "ergfvdx", "435refsd", "1111", "@@#$rafs", "0987tgvfbfm", ",,adr,bf", "oiuytrfvbnmk", "095tu9bhiuergjkn", "fjdsx cb43eufdsgjxhcb", "djfe"], "stress_tests": [], "serial": 946, "problematic": [{"example": "+44\u2003(0)\u202f11\u20080765", "is_match": true}, {"example": "7464", "is_match": true}, {"example": "+44\u1680(0)", "is_match": true}, {"example": "63\u205f3264\u200a7639", "is_match": true}, {"example": "+44", "is_match": true}, {"example": "+44\u180e(0)\u180e11\u20013725\ufeff7114", "is_match": true}, {"example": "+44\u202f(0)\ufeff31\u000b9331\u20040195", "is_match": true}]}, {"expression": "\\+353\\(0\\)\\s\\d\\s\\d{3}\\s\\d{4}", "raw_prompt": "This simple expression evaluates an Ireland phone number. It requires the country code and dialing instructions for an international call plus spaces within the number.", "refined_prompt": "This simple expression evaluates an Ireland phone number. It requires the country code and dialing instructions for an international call plus spaces within the number.\nMatch examples:\n- \"+353(0) 5 444 3333\"\n- \"+353(0)\u20296\u202f670\u205f0287\"\n- \"+353(0) 6\"\nNon-match examples:\n- \"+353(0) 55555555\"\n- \"5 444 3333\"", "matches": ["+353(0) 5 444 3333", "+353(0)\u20296\u202f670\u205f0287", "+353(0) 6", "+353(0)\u180e9\u000b617\u205f9085", "+353(0)\u202f9\u2008494\u20011753", "+353(0)\u180e2\u00a0820\u20049689", "+353(0)\u20293\u2002656\u16803482", "+353(0)\u200a4\f099\u30005238", "+353(0)\u20031\u2005919\u20284533", "+353(0)\u20014\ufeff068\u20079128", "+353(0)\u200a5\t879\u20290977", "+353(0) 0\u2005829\u20021565", "+353(0)\u00a00\u2008261\u20035228"], "non_matches": ["+353(0) 55555555", "5 444 3333", "ewfdsv", "43egrfb", "5654we", "8g-", "56555555555", "0987tfvbnm", "999(", "%6ytg", "fyt", "123"], "stress_tests": [], "serial": 947, "problematic": [{"example": "+353(0) 6", "is_match": true}, {"example": "+353(0)\u180e9\u000b617\u205f9085", "is_match": true}, {"example": "+353(0)\u180e2\u00a0820\u20049689", "is_match": true}, {"example": "+353(0)\u20014\ufeff068\u20079128", "is_match": true}]}, {"expression": "^(0)44[\\s]{0,1}[\\-]{0,1}[\\s]{0,1}2[\\s]{0,1}[1-9]{1}[0-9]{6}$", "raw_prompt": "This expression will help you to match chennai telephone numbers. chennai bsnl telephone numbers will start from 2.", "refined_prompt": "Matches Chennai telephone numbers that start from 2.\nMatch examples:\n- \"044-26320244\"\n- \"04426320244\"\n- \"0442\u205f2591577\"\nNon-match examples:\n- \"044-12345678\"\n- \"123-12345678\"", "matches": ["044-26320244", "04426320244", "0442\u205f2591577", "044\u200726775342", "044\u200727449412", "044-\f2\f8974552", "044\u202f-2\u20087310184", "044-\u20092\u20019739081", "044\ufeff-2\ufeff1418769", "044-21214683", "044\u000b-\u200424175883", "044\u200a-2\u20026848713", "044\u2002-25790687"], "non_matches": ["044-12345678", "123-12345678", "23433", "phone number", "###", "234567", "987654", "033987654", "1232456755", "34", "7534830", "44"], "stress_tests": [], "serial": 955, "problematic": [{"example": "044\ufeff-2\ufeff1418769", "is_match": true}]}, {"expression": "^((5[1-5])([0-9]{2})((-|\\s)?[0-9]{4}){3})$", "raw_prompt": "Validates all Mastercard numbers starting with 51-55 with a total of 16 digits. Allows for spaces and -'s.", "refined_prompt": "Validates all Mastercard numbers starting with 51-55 with a total of 16 digits. Allows for spaces and -'s.\nMatch examples:\n- \"5144-0000-0000-0000\"\n- \"5343 0000 0000 0000\"\n- \"5400000000000000\"\nNon-match examples:\n- \"5600....\"\n- \"4100....\"", "matches": ["5144-0000-0000-0000", "5343 0000 0000 0000", "5400000000000000", "5165\u000b317016126393", "51067298-85621286", "5514\u200a143625037719", "512603936346\u30000496", "5126-6642-7769-5120", "5280", "6150\u20007247-3786", "5438-078231057990", "5335\u2028323120961187", "5451\u20050378-3795 8333"], "non_matches": ["5600....", "4100....", "3245rtfgds", "whtrgerfwe", "###", "credit card", "8765rtfgh", "43fergt6y5", "34567", "erg56u7i8", "34567uytgfd", "3456ytgf"], "stress_tests": [], "serial": 966, "problematic": [{"example": "5280", "is_match": true}, {"example": "6150\u20007247-3786", "is_match": true}]}, {"expression": "^([a-zA-Z])(?=.*\\d)\\w{4,9}$", "raw_prompt": "Check Password: 5 - 10 characters long, start with a letter and contain at least one number. No special characters", "refined_prompt": "Matches passwords 5 - 10 characters long, that start with a letter and contain at least one number. No special characters allowed\nMatch examples:\n- \"a2345\"\n- \"abcd1\"\n- \"abc123\"\nNon-match examples:\n- \"1abc\"\n- \"1abcd\"", "matches": ["a2345", "abcd1", "abc123", "pnq0T", "goHndhTpU", "JntNgf", "sbgR7n", "Xxbhf", "fVimMX", "mAMS1PtF", "LuYeFpbq", "AWjQQ", "ZTk1cj"], "non_matches": ["1abc", "1abcd", "a2345678910", "??frvef", "234@", "jedj!", "hhy^", "dejk-487", "9876tgbnki8*", "jkek;jker", "''rcds/", ";ropk"], "stress_tests": [], "serial": 1007, "problematic": [{"example": "goHndhTpU", "is_match": true}, {"example": "JntNgf", "is_match": true}, {"example": "Xxbhf", "is_match": true}, {"example": "fVimMX", "is_match": true}, {"example": "LuYeFpbq", "is_match": true}, {"example": "AWjQQ", "is_match": true}]}, {"expression": "^[-+]?\\d+(\\.\\d)?\\d*$", "raw_prompt": "Number(no space or thousand separator with point(.) as decimal delimiter.", "refined_prompt": "Matches numbers (no spaces or ,) but can have decimal point and negative signs\nMatch examples:\n- \"-3\"\n- \"3.1231\"\n- \"+972\"\nNon-match examples:\n- \".3\"\n- \"51.\"", "matches": ["-3", "3.1231", "+972", "063216370737816400027340849", "-532942508971.73715011555667225478951632990847682990864711152687872963734748837471363567352677367033325407845", "27367821350457880227967762491998553599", "608541766095893812624591479899205459342116.65219370040878877416954346320457925223901955313004158399940960150215112519488865511353", "45977090710491677315972696561004982010958481573397970906688857663028753210081992814373044031071639275519692020659", "41482604118139172083640055246557299680052799721740983533172672106271461.68228103682750910", "+1798246423301479517539997790802505167091141774411001117888031855311973805206262318061059478812907877763218062802897493318640492785", "-70221699414772661133331755862853780368270699", "-50102726205790106572379310558070607413805968628637697364058676170607174758293949205531153.77005188270023837693159660610212178775154620119950918355070798471982668037779590930793824563224093", "+201633701228317724451621254776898840599768853841761569518295592862908631493420264170877268972465396682524066587986"], "non_matches": [".3", "51.", "+3.3.1", "34567", "#", "$45", "54%", "#3", "number", "+975", ".0000", "2134567."], "stress_tests": [], "serial": 1036, "problematic": [{"example": "34567", "is_match": false}, {"example": "+975", "is_match": false}]}, {"expression": "([0-9]+)\\s(d)\\s(([0-1][0-9])|([2][0-3])):([0-5][0-9]):([0-5][0-9])", "raw_prompt": "Displays duration in\n1 d 22:33:44 format. Can be modified to match some other formats e.g. 1.22:33:44 if needed. Takes a 24-hour day into account.", "refined_prompt": "Displays duration in\r\n1 d 22:33:44 format. Can be modified to match some other formats e.g. 1.22:33:44 if needed. Takes a 24-hour day into account.\nMatch examples:\n- \"1 d 22:33:44\"\n- \"109 d 11:02:00\"\n- \"0 d 00:00:00\"\nNon-match examples:\n- \"d 22:33:44\"\n- \"1 d 24:00:00\"", "matches": ["1 d 22:33:44", "109 d 11:02:00", "0 d 00:00:00", "304566632984279783005108863634571053922076315220849550020\u1680d\u000b20:09:50", "2762980036667426013517682236477895639909372588019491392708565814992427815248794820708740\u00a0d\u180e17:04:39", "5465948229290\u2029d\u00a017:36:04", "53492106711633819256678768725227741094400905028173779432831332340542426578821560977268991126484140295\u2009d\u200a11:14:11", "88431628638498261406982\u000bd", "02:29:57", "7208089070743428920795745929112442389623452190750353531720152602836058\u2000d", "11:50:42", "962661329228277224834538422493084180074531223728534892196996\u3000d\u202923:08:19", "597588068066481508811623277899652465278824915158213\u2008d\u200808:11:42"], "non_matches": ["d 22:33:44", "1 d 24:00:00", "3 d 11:75:00", "23", "date", "time", "3 seconds", "333#", "#####", "$4", "5%", "12/12"], "stress_tests": [], "serial": 1043, "problematic": [{"example": "2762980036667426013517682236477895639909372588019491392708565814992427815248794820708740\u00a0d\u180e17:04:39", "is_match": true}, {"example": "88431628638498261406982\u000bd", "is_match": true}, {"example": "02:29:57", "is_match": true}, {"example": "7208089070743428920795745929112442389623452190750353531720152602836058\u2000d", "is_match": true}, {"example": "11:50:42", "is_match": true}]}, {"expression": "\\d{4}\\s\\d{4}\\s\\d{4}\\s\\d{4}$", "raw_prompt": "Validate the Wii Code format. If you like to have slashes and spaces you can change the \"\\s\" for \"[\\s-]\"", "refined_prompt": "Validate the Wii Code format.\nMatch examples:\n- \"1234 5678 9101 1121\"\n- \"0000 0000 0000 0000\"\n- \"8924 3578 3248 3212\"\nNon-match examples:\n- \"1234-5678-9101-1121\"\n- \"ABCD EFGH IJKL MNOP\"", "matches": ["1234 5678 9101 1121", "0000 0000 0000 0000", "8924 3578 3248 3212", "9468\u20068672\u30000695\u20026652", "5441\u20073139\u205f0003\u20076823", "5430\u16805863\u200a5442", "4364\u20005899\u20075112\u000b8367", "3053\u000b2737\u20025746\u20013108", "8288\u20055842\u20018658\t2219", "1174\u20016385\u20007240", "5693\u20080479\u00a07775\u20282111", "6204\u00a00545\u000b2636\u20024166", "7316\u20293284\u20048694\u20004754"], "non_matches": ["1234-5678-9101-1121", "ABCD EFGH IJKL MNOP", "ABCD-1234 IJKL-4321", "wf", "34", "#", "@", "!", "-09890-", "+)9", "number", "///"], "stress_tests": [], "serial": 1050, "problematic": [{"example": "5430\u16805863\u200a5442", "is_match": true}, {"example": "1174\u20016385\u20007240", "is_match": true}]}, {"expression": "^((([\\+][\\s]{0,1})|([0]{2}[\\s-]{0,1}))([358]{3})([\\s-]{0,1})|([0]{1}))(([1-9]{1}[0-9]{0,1})([\\s-]{0,1})([0-9]{2,4})([\\s-]{0,1})([0-9]{2,4})([\\s-]{0,1}))([0-9]{0,3}){1}$", "raw_prompt": "General phone number validation for Finland.\nIt will pass old and new format numbers.\nBetween numbers space or dash can be used ones.\nnumber has to start\n+358 or 00358 or 0\nare code can be 2 or 3 digit. I could not come with better idea then this", "refined_prompt": "General phone number validation for Finland.\r\nIt will pass old and new format numbers.\r\nBetween numbers space or dash can be used.\r\nThe number has to start with +358 or 00358 or 0\r\narea code can be 2 or 3 digits.\nMatch examples:\n- \"003589999999\"\n- \"00 358 999 999\"\n- \"00 358 9999 999\"\nNon-match examples:\n- \"050 999 9999 9999 999\"\n- \"151212\"", "matches": ["003589999999", "00 358 999 999", "00 358 9999 999", "00 358 999 9999", "091212", "09 99 99 99", "+883\u202839\u2002949\u205f605\u20064", "078\u200a70948078\u20039", "00\u205f355\u000b5", "57-0279687", "00\u200985577114381", "02\u1680082916", "02240\u168097"], "non_matches": ["050 999 9999 9999 999", "151212", "+", "-987654", "%^RTyuh", "wq87r", "t54ref", "g4trd", "54rewghy356", "54tgr", "3t4Y*", "UFT^R%7"], "stress_tests": [], "serial": 1052, "problematic": [{"example": "00\u205f355\u000b5", "is_match": true}, {"example": "57-0279687", "is_match": true}]}, {"expression": "(?!^[0-9 ]*$)(?!^[a-zA-Z ]*$)^([a-zA-Z0-9 ]{6,15})$", "raw_prompt": "This expression validates alphanumeric with one alphabet compulsory and one numeric compulsory and accepts minimum 6 characters and max 15 characters irrespective of the order and case.It doesnt accept special characters", "refined_prompt": "validates alphanumeric with one alphabet compulsory and one numeric compulsory and accepts a minimum of 6 characters and max 15 characters irrespective of the order and case. It doesn't accept special characters\nMatch examples:\n- \"1DAV100\"\n- \"e1Zu5qY\"\n- \"99TeoRP\"\nNon-match examples:\n- \"asdfgh,asd.123 etc.,\"\n- \"!\"", "matches": ["1DAV100", "e1Zu5qY", "99TeoRP", "A9bmzo", "nHV0MmzUBmauO2", "gKwDDKUkUc OD", "8ATlfo", "FDvNLl n", "PA6gaoIu3jQ", "scckTJM7frjqzh9", "Bj5yaf", "7P5AlHFZ3pph", "jp8nEkV7"], "non_matches": ["asdfgh,asd.123 etc.,", "!", "@", "#", "$", "ewf%fwe", "wef^", "&efqew", "wefer*f", "ferve(e3ef", "+34rf", "?efrt"], "stress_tests": [], "serial": 1075, "problematic": [{"example": "gKwDDKUkUc OD", "is_match": true}, {"example": "FDvNLl n", "is_match": true}]}, {"expression": "^(?=.*[!@#$%^&*()\\-_=+`~\\[\\]{}?|])(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9]).{8,20}$", "raw_prompt": "This should require all of the following: An uppercase letter, a lowercase letter, a number and a special character from the provided list. Lastly, it needs to be between 8 and 20 characters long.\nA lot of expressions I've found here don't require all four, this should. I'm pretty new at regex though, so I hope that other people will help strengthen this expression.\nWhen testing on this site, make sure you have the Case Insensitive checkbox turned off.", "refined_prompt": "Matches passwords with an uppercase letter, lowercase letter, a number, and a special character from the provided list. Lastly, it needs to be between 8 and 20 characters long.\nMatch examples:\n- \"p2sSw@rd\"\n- \"p2sSw@rd#l0ngEr\"\n- \"abc#$%GH1\"\nNon-match examples:\n- \"p2ssw@rd\"\n- \"p2sSw@rd#l0ngErThisIs2l0ng\"", "matches": ["p2sSw@rd", "p2sSw@rd#l0ngEr", "abc#$%GH1", "pF2om2/u&", "(@ly#M/j", "Ws4)<kzrZ2r[", "dE5ZhR05TS", "3Y^&<znd2WJ`'GGkjn", "8#\"u0xY{YO\"MVYN", "a,Tey6[<BH9cVmAP2So'", "^(<ubJ9a=;5MAQY", "gs`%0*3<lT", "P}&_zd>qV&5Bz"], "non_matches": ["p2ssw@rd", "p2sSw@rd#l0ngErThisIs2l0ng", "abc123DEF", "[efr[frew", "###edfvfwrg", "3223er", "98765trfg", "password", "forkovdl,c./", "r3q4ingf'\tqerj;\tf", "3f3efnjwekfd,msf,wqemfnqw,efnwfnew,", "3"], "stress_tests": [], "serial": 1112, "problematic": [{"example": "(@ly#M/j", "is_match": true}, {"example": "dE5ZhR05TS", "is_match": true}]}, {"expression": "^(\\+[1-9]\\d+) ([1-9]\\d+) ([1-9]\\d+)(\\-\\d+){0,1}$|^(0\\d+) ([1-9]\\d+)(\\-\\d+){0,1}$|^([1-9]\\d+)(\\-\\d+){0,1}$", "raw_prompt": "Matches a Din 5008 formatted phone number, except of \"special numbers\" like \"0180 5 12345\"", "refined_prompt": "Matches a Din 5008 formatted phone number\nMatch examples:\n- \"+49 12 3456789\"\n- \"+49 12 34567-89\"\n- \"012 3456789\"\nNon-match examples:\n- \"+49 012 3456789\"\n- \"+49 (0)12 3456789\"", "matches": ["+49 12 3456789", "+49 12 34567-89", "012 3456789", "1234567-89", "+496549138530310431915294210471345898820069424341007356030619560558739158975402606917507 4082525159924089006968872369705614320624124355703115663938675993724973499020166555826 12857993400149567217265197394650416592679181788161259895102851458639101837873672808728925035293463517-3678853317001418796241380356953305043986145650989632956515891965794048", "01956740562106459141539115038430619722272425165785198 21357088933386281796971320870710083086739963873291430138243482074173215477945798148584067801291704335", "808825690414797640247024308368348807061905914895478142178025475775290807923438490281826414674", "281890170150475121997181564174856724539667782103512350664352607771756027-659416538720132964521806042234864586223366299097798219605878", "+565424891966703912785293841528410717929 2259020278322765889802145391369863385407148003609584091770598746960854523 3246968296918831656895023050100506066763970834113", "27395628802262704963867607020687562529908488063453607219556711164896347693695-52196", "705436320565524794529775321736735466301107069671411895362631288565856276502799304911805372646681-568546912061331396418237357144780389129939917660759807712196228321170858812314934478620248054210", "+5290638989716513144425063528226870618103620884103530006299942872696061126481132245310675569025 37969295443460912684405124311936184080123 4002672083508969079828054858427589321168616374111599193193066692802867620579798078-604767674577157085845760738887880921227283258372990443691388946", "0537931916934293271278794335382727835782882388987518131840678161205366059073843658563584670715892615 1835438298632234169039727681628650356986875232099961"], "non_matches": ["+49 012 3456789", "+49 (0)12 3456789", "0180 5 12345", "+7", "-87654", "#3232", "2345678", "00000", "phone number", "!", "$444", "56%"], "stress_tests": [], "serial": 1117, "problematic": [{"example": "2345678", "is_match": false}]}, {"expression": "^([_a-zA-Z0-9-]+(\\.[_a-zA-Z0-9-]+)*@[a-zA-Z0-9-]+(\\.[a-zA-Z0-9-]+)*\\.(([0-9]{1,3})|([a-zA-Z]{2,})))(;[ ]?[_a-zA-Z0-9-]+(\\.[_a-zA-Z0-9-]+)*@[a-zA-Z0-9-]+(\\.[a-zA-Z0-9-]+)*\\.(([0-9]{1,3})|([a-zA-Z]{2,})))*$", "raw_prompt": "Matches a semi-colon-delimited string of email addresses. Delimiter can include a space after the semi-colon. Based on/thanks to David Huyck's pattern, with the domain extension opened up and specific extensions removed.", "refined_prompt": "Matches a semi-colon-delimited string of email addresses. Delimiter can include a space after the semi-colon.\nMatch examples:\n- \"jdude@yahoo.com\"\n- \"jdude@yahoo.com; janedoe@hotmail.com\"\n- \"jdude@yahoo.com; janedoe@hotmail.com; billybob@127.0.0.1\"\nNon-match examples:\n- \"jdudeyahoo.com\"\n- \"jdude@yahoo.com or janedoe@hotmail.com\"", "matches": ["jdude@yahoo.com", "jdude@yahoo.com; janedoe@hotmail.com", "jdude@yahoo.com; janedoe@hotmail.com; billybob@127.0.0.1", "janedoe@hotmail.com; jdude@yahoo.com", "d3ieh@gmail.com", "erv@6453.rtb; 2erfhiuh@iuf.com", "4fu3ife@newi.veiv", "erf@jnreiv.coef;erjfj@nerv.comeoifj;ernfi3@e.cc", "erf@jnreiv.coef ;erjfj@nerv.comeoifj ;ernfi3@e.cc", "referj.erje@ibv.com", "hasu83.erfhei.wefh@hve.wef; wefihie.fv.ws.fre@uve.sfef", "hasu83.erfhei.wefh@hve.wef; wefihie.fv.ws.fre@uve.sfef;ehrbfeur.wje@hurvei.co", "er.f.qds.sd@fer.co"], "non_matches": ["jdudeyahoo.com", "jdude@yahoo.com or janedoe@hotmail.com", "jdude@yahoo.com, janedoe@hotmail.com, billybob@127.0.0.1", "er.f.qds.sd@fer.co;", "er.f.qds.sd.@fer.co", "er.f.qds.sd.@fer.co ewsfc@fe.com", "er.f.qds.sd.@fer.co; ewsfc@fe.com;", "@", "email", "123432@fred.com3", "1234###32@fred.com", "$45"], "stress_tests": [], "serial": 1127, "problematic": [{"example": "erf@jnreiv.coef ;erjfj@nerv.comeoifj ;ernfi3@e.cc", "is_match": true}]}, {"expression": "^(([0-2]\\d|[3][0-1])\\/([0]\\d|[1][0-2])\\/[2][0]\\d{2})$|^(([0-2]\\d|[3][0-1])\\/([0]\\d|[1][0-2])\\/[2][0]\\d{2}\\s00\\:00\\:00)$", "raw_prompt": "This expression will parse the date with zero time span only (e.g. 26/07/2010 00:00:00)", "refined_prompt": "Matches date with zero time elapsed only (e.g. 26/07/2010 00:00:00)\nMatch examples:\n- \"26/07/2010 00:00:00\"\n- \"09/12/2014\u180e00:00:00\"\n- \"30/11/2075\u200500:00:00\"\nNon-match examples:\n- \"26/07/2010 10:00:00\"\n- \"26/07/2010 10:34:14\"", "matches": ["26/07/2010 00:00:00", "09/12/2014\u180e00:00:00", "30/11/2075\u200500:00:00", "31/09/2063", "26/10/2030", "04/02/2003\u205f00:00:00", "10/09/2077\u200300:00:00", "06/07/2001", "24/09/2054\f00:00:00", "31/09/2022", "31/11/2072", "12/12/2079", "11/10/2050"], "non_matches": ["26/07/2010 10:00:00", "26/07/2010 10:34:14", "date", "30/02/2072\u300000:30:00", "31/07/2062\u200500:00:03", "31/07/2062\u200540:00:00", "31/07/2062\u200500:23:00", "31/07/2062\u200512:023:24", "213456789", "sdfghj", "12/12/121212/12", "12:12"], "stress_tests": [], "serial": 1140, "problematic": [{"example": "09/12/2014\u180e00:00:00", "is_match": true}]}, {"expression": "[-+]?((\\.[0-9]+|[0-9]+\\.[0-9]+)([eE][-+][0-9]+)?|[0-9]+)", "raw_prompt": "Used in my SVG parser.\nExplanation:\nMay start with + or -. This is followed by either an integer, or a float (\"dot numbers\", \"numbers dot numbers\" or \"numbers dot\" followed by an optional scientific postfix (+ or - followed by numbers) )\nI'm using it to parse lists of floats, add ^$ boundaries if you want it to match whole lines.", "refined_prompt": "Matches numbers that may start with + or -. This is followed by either an integer or a float (\"dot numbers\", \"numbers dot numbers\" or \"numbers dot\" followed by an optional scientific postfix (+ or - followed by numbers) )\nMatch examples:\n- \"10.2\"\n- \".0\"\n- \"3.9265e+2\"\nNon-match examples:\n- \"-one\"\n- \".\"", "matches": ["10.2", ".0", "3.9265e+2", "5", "+552782120370397529135106304189685087733.4305753428401549722246872662419E-3266278236922735738239373", "4521043002650940109351407309931976596141083521153726730418791591813738799180", "+.033157368068277074826143749952436915499115533456202703821353386350779826", "148716746907911467573717609808222561989798376866", "3636", "89763228440956257887903830115962382389396680601649936869159.9342937600003858132799276979969101954345923242589753337498E+49874233818300145431085240981619942373606", "-77426396040971298109983591771", "-.836282821259107", "+1826516404870280245141.69835966545097937430692963119820926251482020536568575922426901468603143438752993"], "non_matches": ["-one", ".", "whatever", "##", "$%^&*", "#4", "765765673y3ebdwhj", "5678%", "12/12", "12-12", "12:12", "23ewdfr3"], "stress_tests": [], "serial": 1141, "problematic": [{"example": "#4", "is_match": false}, {"example": "765765673y3ebdwhj", "is_match": false}, {"example": "5678%", "is_match": false}, {"example": "12/12", "is_match": false}, {"example": "12-12", "is_match": false}, {"example": "12:12", "is_match": false}, {"example": "23ewdfr3", "is_match": false}]}, {"expression": "(([+]?34) ?)?(6(([0-9]{8})|([0-9]{2} [0-9]{6})|([0-9]{2} [0-9]{3} [0-9]{3}))|9(([0-9]{8})|([0-9]{2} [0-9]{6})|([1-9] [0-9]{7})|([0-9]{2} [0-9]{3} [0-9]{3})|([0-9]{2} [0-9]{2} [0-9]{2} [0-9]{2})))", "raw_prompt": "This regular expression allows to verify mobile phone numbers (600) and telephone numbers (900). Not provide premium charging phones (line 800). The number may be separated by spaces in groups of three digits, or one group of three number plus two groups of three numbers for fixed phones.", "refined_prompt": "Matches mobile phone numbers (600) and telephone numbers (900). Not provide premium charging phones (line 800). The number may be separated by spaces in groups of three digits, or one group of three numbers plus two groups of three numbers for fixed phones.\nMatch examples:\n- \"952 566 009\"\n- \"+34 615 977 911\"\n- \"967 90 23 44\"\nNon-match examples:\n- \"802 59 23 09\"\n- \"677 90 23 44\"", "matches": ["952 566 009", "+34 615 977 911", "967 90 23 44", "34 95 2360010", "685 809122", "600 861401", "34634 517 421", "962 50 53 71", "+34668 563379", "670 550 198", "+34 633 974654", "982 851 219", "34 911 020763"], "non_matches": ["802 59 23 09", "677 90 23 44", "67 7 809 235", "23456787654323456787654321", "-9876545678", "+++9876543", "###", "phone number", "$45", "(567)0987654", "+876545678987654345678987654", "35%"], "stress_tests": [], "serial": 1153, "problematic": [{"example": "23456787654323456787654321", "is_match": false}, {"example": "-9876545678", "is_match": false}, {"example": "+876545678987654345678987654", "is_match": false}]}, {"expression": "(^\\d{1,9})+(,\\d{1,9})*$", "raw_prompt": "Positive Whole number matched from 0 to 9999999. Only 9 digits length is allowed in every comma separated value.Can be easily changed to modify the length of the comma separated values.", "refined_prompt": "Matches positive whole numbers from 0 to 9999999. Only 9 digits length is allowed in every comma-separated value.\nMatch examples:\n- \"123,158,19\"\n- \"123456789,9568523,1\"\n- \"1,2,3\"\nNon-match examples:\n- \"0,0,\"\n- \",3444,0999\"", "matches": ["123,158,19", "123456789,9568523,1", "1,2,3", "938562219430322586962038420801434475955966519410706304607296364916514857330267120548122177646759666802240510837728284582433441627678289140126921041179001301133229171149636741786711339517326745931089317205775512738519864251474909565903978183667047086358510200271382526159565377883856586399391009673257,34,611295,788438100,24179300,545226,368,86565315,88616836,61736,228,9187,645987794,63370,309773721,920,60,270,5287825,1197,50863550,900,5,14516717", "240162018534242474827094629077489484551352897453839853729898649396964266851470514553181752018774335122905201481133447222204015346969439813412455152704606291592503946725711160792030724261735972659011588534729857402,5123,45486718,39257,7380,249746,919568,401113,56305,1804014,6,7665,132,80793,97,397581267,16911,3234,20746314,21634062,001506864,3728,1,43036940,576287269,1034,8,4423,3,6812967,1,4399689,76305,6194584,402444,915,159,15,9402558,471654,65,1,483418,8,904427081,53534,1,95,26990503,9989,91938,706520,6925651,47,652918,377,538929,56783,58085,80,562,6470,57,26548,8,12121686,48,30311497,45865248,675,317,2533104,6,39459785,8,475602,5252,3088831,87,0704,79004", "44710142180937368799397562570677690288710913727192519959517780963292973,95027,8564,8964112,463590669,12,0695655,3,3283209,211508,2400,66,103,62,2685,513540,11309923,005733,258542,4681712,0934654,24,4100,647,1992,028184,67727,48,891850,541,93,357,07103,517333554,94,858741631,207672,94,26434,2688957,9,479951481,611435,2756461,324763650,943958600,70678", "6410838378362086396578793982984259851145693145727758936028712046263276517999045078895971622576216743805342232251909165702185509735186614112252476230170396608490147928393889218647590396555373840771815509649457174322741664884989565174556425237380169073726673422095333215742742488912118380407645808461838139692589436460414798833808703653029885843848156712036346900632592773391231274056868100156237911117430503515976854,47431778,6538,54003,939880706,036,472232,64978807,174099670,62531121,88003382,289,177988179,98,07,354,0662,48235420,268,381616,399868729,33818,76128054,623,2,2543959,78,12362,1719068,777271,02450530,53834,3,33034,940,1", "531264880238773142355757044039149352085861782876294050504179284723029211572779370927501003020507617212056605076781434451045542267221138443054920949762379432627550303348944056344180187202606788875432093194734882679438962807772076201796569006157236839,923541500,8,85883685,56681300,690,9,7559,04110,61617,81637720,04136,46,303,6,767272,827409116,1844789,92,9729540,297915,45,8400296,878037367,153,6,93,848609927,378578811,390843,1,54,44,315928,86412679,53177055,20607,34928,680058,2019,308155187,248,496,3660987,417737020,3974604,28,79345,3,291,163,08,60,217,69,271761646,912295111,952554107", "29631314312642592845877981319477356739586558126637857468764897960778713850390920841965580508439453956042099089230854567817565639844511361692042998937745965219598141904134722787524863018612376369707070094059215615208750246085783364308159003744291400616523617061621289451263304319077916733791922911765945475833369315165356943058524650279876579649559957008592667761885968327646583149720562622886734072893729419757372032734462638057613295899626927631384934,5124,13,0764301,51462364,096595,7,2396897,966622,00,05802,7582482,8393700,644711,49,97,1497468,1644705,50043,739,50582757,659313612,52201,7446863,050002,459575938,0840,4,52740,75183,67252,99222,3489,206195307,77,1,19414238,83657,0861360,8646315,68680,06,144931283,410681,99,74742,7291879,533642785", "7890345339885334705205654750353346247695649607575387910540702150260400871908234567600214823820488287177079226531870586767642870221019228934780482942897441155196605287071943656260784083652541597207649714370928530547064210414555625695975018372722161799288300829111870250157475151324090113419623325807513000259308548915978462515284115107956907589870531510699126109501894745024282216613,9818,019685,065212947,421562512,5089970,8156,06625,048,340,5580694,313,801619,9,702057058,3620,319478,5,4410,697551,53752,2263503,2025,2562,71,689,894,855,3,601294,8910,12227,89,1923,0,389,449982616,245,2094,7,2465274,36,976,75,627893703,8,696,0848,40352579,91776996,06350,2773137", "83825586588218608773925428333610418516325039994299088031255269022982971885788213671318457604035889512476892988744233955540770877845500549073592960372088688603325806252056147598731261020385231352443296742346436416880420876,28481,3,63176464,7284551,30316", "064510793732028588198349637122804745071799467012685053283956650222236840155243116278959576874805610507369539531,87736,182,46817,12,30535513,27,972,7,20890807,2,73951,719031,6,450009165,065,692095,567", "5770097493555234205001310300856729556413128675119018455729670601679377568318048208684377583679883523569491033857792768798807930777910150684670605980957848272150199528722765682704014393031011414436532686294127467397609324695837488958298750170550077904206101583175646079004303249597219941036773650,3277,600800,0064705,609,15961142,271518,976,16,110936975,3949,7521691,105,8723,57750460,5038897,770,48241,7250,445724,25067,66313,4,79680,94712488,5762,92531097,5299,07,84,414,2716,1514,4875391,825552896,72275768,07412,7827,59358963,741,3640,893964344,05551,782808,3,093616,07,28,2498123,562120412,0,5069255,5617,546788,0072,530786,6996218,0466,7,088,85,685,29,3999,23290704,28481705,68,371254528,35867,1755"], "non_matches": ["0,0,", ",3444,0999", "1234567890,25689,1425", "xftgyhu", "juih7t65rrdt", "fcder4567", "m;ju987t65", "ljioy876r5", "xserr67", "kpiu86t", "njhyg6r5", "guyt6dr"], "stress_tests": [], "serial": 1163, "problematic": [{"example": "938562219430322586962038420801434475955966519410706304607296364916514857330267120548122177646759666802240510837728284582433441627678289140126921041179001301133229171149636741786711339517326745931089317205775512738519864251474909565903978183667047086358510200271382526159565377883856586399391009673257,34,611295,788438100,24179300,545226,368,86565315,88616836,61736,228,9187,645987794,63370,309773721,920,60,270,5287825,1197,50863550,900,5,14516717", "is_match": true}, {"example": "240162018534242474827094629077489484551352897453839853729898649396964266851470514553181752018774335122905201481133447222204015346969439813412455152704606291592503946725711160792030724261735972659011588534729857402,5123,45486718,39257,7380,249746,919568,401113,56305,1804014,6,7665,132,80793,97,397581267,16911,3234,20746314,21634062,001506864,3728,1,43036940,576287269,1034,8,4423,3,6812967,1,4399689,76305,6194584,402444,915,159,15,9402558,471654,65,1,483418,8,904427081,53534,1,95,26990503,9989,91938,706520,6925651,47,652918,377,538929,56783,58085,80,562,6470,57,26548,8,12121686,48,30311497,45865248,675,317,2533104,6,39459785,8,475602,5252,3088831,87,0704,79004", "is_match": true}, {"example": "44710142180937368799397562570677690288710913727192519959517780963292973,95027,8564,8964112,463590669,12,0695655,3,3283209,211508,2400,66,103,62,2685,513540,11309923,005733,258542,4681712,0934654,24,4100,647,1992,028184,67727,48,891850,541,93,357,07103,517333554,94,858741631,207672,94,26434,2688957,9,479951481,611435,2756461,324763650,943958600,70678", "is_match": true}, {"example": "6410838378362086396578793982984259851145693145727758936028712046263276517999045078895971622576216743805342232251909165702185509735186614112252476230170396608490147928393889218647590396555373840771815509649457174322741664884989565174556425237380169073726673422095333215742742488912118380407645808461838139692589436460414798833808703653029885843848156712036346900632592773391231274056868100156237911117430503515976854,47431778,6538,54003,939880706,036,472232,64978807,174099670,62531121,88003382,289,177988179,98,07,354,0662,48235420,268,381616,399868729,33818,76128054,623,2,2543959,78,12362,1719068,777271,02450530,53834,3,33034,940,1", "is_match": true}, {"example": "531264880238773142355757044039149352085861782876294050504179284723029211572779370927501003020507617212056605076781434451045542267221138443054920949762379432627550303348944056344180187202606788875432093194734882679438962807772076201796569006157236839,923541500,8,85883685,56681300,690,9,7559,04110,61617,81637720,04136,46,303,6,767272,827409116,1844789,92,9729540,297915,45,8400296,878037367,153,6,93,848609927,378578811,390843,1,54,44,315928,86412679,53177055,20607,34928,680058,2019,308155187,248,496,3660987,417737020,3974604,28,79345,3,291,163,08,60,217,69,271761646,912295111,952554107", "is_match": true}, {"example": "29631314312642592845877981319477356739586558126637857468764897960778713850390920841965580508439453956042099089230854567817565639844511361692042998937745965219598141904134722787524863018612376369707070094059215615208750246085783364308159003744291400616523617061621289451263304319077916733791922911765945475833369315165356943058524650279876579649559957008592667761885968327646583149720562622886734072893729419757372032734462638057613295899626927631384934,5124,13,0764301,51462364,096595,7,2396897,966622,00,05802,7582482,8393700,644711,49,97,1497468,1644705,50043,739,50582757,659313612,52201,7446863,050002,459575938,0840,4,52740,75183,67252,99222,3489,206195307,77,1,19414238,83657,0861360,8646315,68680,06,144931283,410681,99,74742,7291879,533642785", "is_match": true}, {"example": "7890345339885334705205654750353346247695649607575387910540702150260400871908234567600214823820488287177079226531870586767642870221019228934780482942897441155196605287071943656260784083652541597207649714370928530547064210414555625695975018372722161799288300829111870250157475151324090113419623325807513000259308548915978462515284115107956907589870531510699126109501894745024282216613,9818,019685,065212947,421562512,5089970,8156,06625,048,340,5580694,313,801619,9,702057058,3620,319478,5,4410,697551,53752,2263503,2025,2562,71,689,894,855,3,601294,8910,12227,89,1923,0,389,449982616,245,2094,7,2465274,36,976,75,627893703,8,696,0848,40352579,91776996,06350,2773137", "is_match": true}, {"example": "83825586588218608773925428333610418516325039994299088031255269022982971885788213671318457604035889512476892988744233955540770877845500549073592960372088688603325806252056147598731261020385231352443296742346436416880420876,28481,3,63176464,7284551,30316", "is_match": true}, {"example": "064510793732028588198349637122804745071799467012685053283956650222236840155243116278959576874805610507369539531,87736,182,46817,12,30535513,27,972,7,20890807,2,73951,719031,6,450009165,065,692095,567", "is_match": true}, {"example": "5770097493555234205001310300856729556413128675119018455729670601679377568318048208684377583679883523569491033857792768798807930777910150684670605980957848272150199528722765682704014393031011414436532686294127467397609324695837488958298750170550077904206101583175646079004303249597219941036773650,3277,600800,0064705,609,15961142,271518,976,16,110936975,3949,7521691,105,8723,57750460,5038897,770,48241,7250,445724,25067,66313,4,79680,94712488,5762,92531097,5299,07,84,414,2716,1514,4875391,825552896,72275768,07412,7827,59358963,741,3640,893964344,05551,782808,3,093616,07,28,2498123,562120412,0,5069255,5617,546788,0072,530786,6996218,0466,7,088,85,685,29,3999,23290704,28481705,68,371254528,35867,1755", "is_match": true}]}, {"expression": "^(((1[6-9]|[2-9]\\d)\\d{2}([-|\\/])(((0?[13578]|1[02])([-|\\/])31)|((0?[1,3-9]|1[0-2])([-|\\/])(29|30))))|((((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))([-|\\/])0?2([-|\\/])29)|((1[6-9]|[2-9]\\d)\\d{2})([-|\\/])((0?[1-9])|(1[0-2]))([-|\\/])(0?[1-9]|1\\d|2[0-8]))(\\s)((([0]?[1-9]|1[0-2])(:|\\.)[0-5][0-9]((:|\\.)[0-5][0-9])?(\\s)?([aApP][mM]))|(([0]?[0-9]|1[0-9]|2[0-3])(:|\\.)[0-5][0-9]((:|\\.)[0-5][0-9])?))$", "raw_prompt": "this expression validates a date-time field in yyyy/m/d h:m:s or yyyy-m-d h:m:s format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00.\nMatches times seperated by either : or . will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.", "refined_prompt": "this expression validates a date-time field in yyyy/m/d h:m:s or yyyy-m-d h:m:s format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00.\r\nMatches times seperated by either : or . will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.\nMatch examples:\n- \"2008/2/29 8:25:59\"\n- \"2010/12/31 11:25AM\"\n- \"2400-02-29 09:30\"\nNon-match examples:\n- \"2009/2/29 8:25:59\"\n- \"2010/11/31 11:25AM\"", "matches": ["2008/2/29 8:25:59", "2010/12/31 11:25AM", "2400-02-29 09:30", "4800/02|29\u30009:15", "4843|11-29\u20293:37", "2015-8|31\u200311:34\u000bPM", "1909-11-13", "13.52:24", "2901-10-30\u200209.56\u2004Pm", "1912/2-29 23:16", "4366-4/29\u168010.22", "1788|2/29\u00a023.43.45", "7680|09-15"], "non_matches": ["2009/2/29 8:25:59", "2010/11/31 11:25AM", "2100-02-29 09:30", "12/12/12", "12:12:12:12", "date", "time", "am", "8765456789", "987654erdfgvb", "3245", "98765"], "stress_tests": [], "serial": 1167, "problematic": [{"example": "1909-11-13", "is_match": true}, {"example": "13.52:24", "is_match": true}, {"example": "7680|09-15", "is_match": true}]}, {"expression": "^(0?[1-9]|[12][0-9]|3[01])[- /.](0?[1-9]|1[012])[- /.](19|20)?[0-9]{2}? ?((([0-1]?\\d)|(2[0-3])):[0-5]\\d)?(:[0-5]\\d)? ?([a,p,A,P][m,M])?$", "raw_prompt": "Regex to match date and or time either in 12 or 24 hour format.\nIt will also allow for am/pm with mixed cases.", "refined_prompt": "Regex to match date and or time either in 12 or 24 hour format.\r\nIt will also allow for am/pm with mixed cases.\nMatch examples:\n- \"31-12-2010 14:15:22\"\n- \"1.1.2010 00:00:00\"\n- \"2/1/2010\"\nNon-match examples:\n- \"1.31.2011\"\n- \"31.1.2011 1455\"", "matches": ["31-12-2010 14:15:22", "1.1.2010 00:00:00", "2/1/2010", "31/1/2011 05:22 pm", "03-11/95:51", "06-03 19 :20 ,,", "1 12/19 23:35:05", "30/10/1975 01:10 AM", "9/12.15:18:37pm", "05-10. :53 pM", "24-12/ 21:49 PM", "30-5-75 03:08aM", "01 12  :36a,"], "non_matches": ["1.31.2011", "31.1.2011 1455", "31.1.2011 14 pm", "87675", "12/12/12/12", "9087654rt", "jhjgytfrdiJIHUGY", "FGJG", "date", "am", "/12", "12-12-12-12-12"], "stress_tests": [], "serial": 1168, "problematic": [{"example": "9/12.15:18:37pm", "is_match": true}, {"example": "05-10. :53 pM", "is_match": true}, {"example": "24-12/ 21:49 PM", "is_match": true}, {"example": "01 12  :36a,", "is_match": true}]}, {"expression": "^(\\+48\\s*)?\\d{2}\\s*\\d{3}(\\s*|\\-)\\d{2}(\\s*|\\-)\\d{2}$", "raw_prompt": "Polish stationary phone number. Mask +48 XX XXXXXXX\nor +48 XX-XXX-XX-XX or +48 XXXXXXXXX", "refined_prompt": "Matches Polish stationary phone number. Mask +48 XX XXXXXXX\r\nor +48 XX-XXX-XX-XX or +48 XXXXXXXXX\nMatch examples:\n- \"+48222222222\"\n- \"+48 22 3333333\"\n- \"+48 22 842 33 33\"\nNon-match examples:\n- \"+48-22-2222222\"\n- \"+49 22 222222\"", "matches": ["+48222222222", "+48 22 3333333", "+48 22 842 33 33", "+48\u000b\u2008\u2008\u2008\u2029\u2006\f\u2000\u200a\u180e", "458-88", "\u180e\ufeff\u2001\u200a\u2006\u00a005-18", "979", "\ufeff\u3000871-64-17", "\ufeff\u000b \t\u2000 515\u2003\u1680\f\u180e", "\ufeff\u2006\u2004\u200a\u202f\u2028\u2003\u180e\u200a\u2007\t\u2003\f\u2002\u000b\u200a\u180e\u205f883-85-95", "261-11  \u2028\ufeff\u2006\u2004\u202810", "\u180e495-50-02", "93\u2003\ufeff\u00a0\u2029942\u2008\u00a0\u2009\u000b\u180e\u180e"], "non_matches": ["+48-22-2222222", "+49 22 222222", "1234567890", "+1", "-09876543", "9877654e", "#3", "###", "1234567897", "aesrdgtfhgjuh", "$45", "poiie5"], "stress_tests": [], "serial": 1174, "problematic": [{"example": "+48\u000b\u2008\u2008\u2008\u2029\u2006\f\u2000\u200a\u180e", "is_match": true}, {"example": "458-88", "is_match": true}, {"example": "\u180e\ufeff\u2001\u200a\u2006\u00a005-18", "is_match": true}, {"example": "979", "is_match": true}, {"example": "\ufeff\u3000871-64-17", "is_match": true}, {"example": "\ufeff\u000b \t\u2000 515\u2003\u1680\f\u180e", "is_match": true}, {"example": "\ufeff\u2006\u2004\u200a\u202f\u2028\u2003\u180e\u200a\u2007\t\u2003\f\u2002\u000b\u200a\u180e\u205f883-85-95", "is_match": true}, {"example": "261-11  \u2028\ufeff\u2006\u2004\u202810", "is_match": true}, {"example": "\u180e495-50-02", "is_match": true}, {"example": "93\u2003\ufeff\u00a0\u2029942\u2008\u00a0\u2009\u000b\u180e\u180e", "is_match": true}]}, {"expression": "^[1]?[-\\.\\s]?(\\(\\d{3}\\)|\\d{3}){1}[-\\.\\s]?\\d{3}[-\\.\\s]?\\d{4}(\\s+|\\s*[-\\.x]{1}\\d{1,6})?$", "raw_prompt": "This expression will match a 10 or 11 digit US phone number with optional area code parenthesis, non-standard seperators such as spaces or dot's (.), and an extension up to 6 digits long", "refined_prompt": "This expression will match a 10 or 11 digit US phone number with optional area code parenthesis, non-standard seperators such as spaces or dot's (.), and an extension up to 6 digits long\nMatch examples:\n- \"(800) 555-1212\"\n- \"999.555.1212 x1234\"\n- \"19995551212x123456\"\nNon-match examples:\n- \"555-1212\"\n- \"(800 555-1212\"", "matches": ["(800) 555-1212", "999.555.1212 x1234", "19995551212x123456", "1\u2006506\u200a6943189", "(148)\u20021132196", "1\u1680(472)5220866", "1314\u2000087\u20076418", "441\u20035963033", "1\u2005246049\u00a02600", "1(930)887\u200a2778", "(242)2839370", "1\u1680742\u2000472\u20093202\u2005\u2004\ufeff", "(855)534\u20091185"], "non_matches": ["555-1212", "(800 555-1212", "888...555-1212", "2342567869", "4356786543(8765)", "()", "#######", "+!121345", "-3246543", "phone number", "$55", "54%"], "stress_tests": [], "serial": 1176, "problematic": [{"example": "1\u1680742\u2000472\u20093202\u2005\u2004\ufeff", "is_match": true}, {"example": "2342567869", "is_match": false}]}, {"expression": "^((61|\\+61)?\\s?)04[0-9]{2}\\s?([0-9]{3}\\s?[0-9]{3}|[0-9]{2}\\s?[0-9]{2}\\s?[0-9]{2})$", "raw_prompt": "Validates an Australian mobile telephone number that can include an international prefix and four plus (two or three-digit) grouping.\nI use it in ASP.NET MVC DataAnnotations [RegularExpression()] attributes where I don't get to easily strip out spaces beforehand.", "refined_prompt": "Validates an Australian mobile telephone number that can include an international prefix and four plus (two or three-digit) grouping.\nMatch examples:\n- \"0418123456\"\n- \"0411 123 456\"\n- \"0414 12 34 56\"\nNon-match examples:\n- \"0418 1 23 45 6\"\n- \"04 01 123456\"", "matches": ["0418123456", "0411 123 456", "0414 12 34 56", "61 0401 123 456", "+61 0418 12 34 56", "+61\u202f0499\u2000744704", "0408761", "848", "\u180e0481\u2029949872", "0488927589", "044085\u202f5123", "0487\u000b087336", "+61\u20000437\u180e018\u3000017"], "non_matches": ["0418 1 23 45 6", "04 01 123456", "+62 0418 12 34 56", "231243567", "-876543", "$456789", "u876%", "34567898765", "0000000000", "324567", "23456u7", "y56u7kujyhtrg"], "stress_tests": [], "serial": 1183, "problematic": [{"example": "0408761", "is_match": true}, {"example": "848", "is_match": true}, {"example": "\u180e0481\u2029949872", "is_match": true}, {"example": "+61\u20000437\u180e018\u3000017", "is_match": true}]}, {"expression": "^([(]?[+]{1}[0-9]{1,3}[)]?[ .\\-]?)?[(]?[0-9]{3}[)]?[ .\\-]?([0-9]{3}[ .\\-]?[0-9]{4}|[a-zA-Z0-9]{7})([ .\\-]?[/]{1}[ .\\-]?[0-9]{2,4})?$", "raw_prompt": "An inefficient number validator. PHP and JavaScript compatible.\nDashes [-] can be replaced by \" \" or \".\"\nSupport for extention /000", "refined_prompt": "number validator. \r\nDashes [-] can be replaced by \" \" or \".\"\r\nSupport for extention /000\nMatch examples:\n- \"+000-000-000-0000\"\n- \"(+000) 000 000 0000\"\n- \"(+000) (000) 000-0000\"\nNon-match examples:\n- \"1-800-0000000\"\n- \"1-800-RLYCOOL\"", "matches": ["+000-000-000-0000", "(+000) 000 000 0000", "(+000) (000) 000-0000", "(000) 000-0000", "+1-800-0000000", "+1-800-RLYCOOL", "+1) (636102.7076./ 807", "(+61)-(654).2273790", "(+644(944)7938822/ 2671", "(+0-(658) 7965782/ 13", "+882) 352 525.0343", "(178)-046.9661/789", "+0856).568 1747/8329"], "non_matches": ["1-800-0000000", "1-800-RLYCOOL", "23453678976543eerfgh", "-2", "+9876", "########", "number", "$5467", "12/12", "12-12-12", "23.2323.2334", "34567trefd"], "stress_tests": [], "serial": 1287, "problematic": [{"example": "34567trefd", "is_match": false}]}, {"expression": ".*[a-zA-Z]$", "raw_prompt": "This expression will accept only for characters both case(upper and lower)", "refined_prompt": "This expression will accept only for characters both case(upper and lower)\nMatch examples:\n- \"lalu\"\n- \"LALU\"\n- \"LAlu\"\nNon-match examples:\n- \"lalu123\"\n- \"LALU #$#$\"", "matches": ["lalu", "LALU", "LAlu", "ghde", "Jjee", "fjhk", "HHHh", "TFYj", "OIJv", "uvgF", "goHi", "ugyG", "uguG"], "non_matches": ["lalu123", "LALU #$#$", "Lalu$%", "342567432", "&*T^R%^DFTY", "IUHYT*^&R", "UIG*T^R", "%^Rfty", "nUGYt", "34qty5u67", "r5efd", "HBYGU34"], "stress_tests": [], "serial": 1308, "problematic": [{"example": "&*T^R%^DFTY", "is_match": false}, {"example": "IUHYT*^&R", "is_match": false}, {"example": "UIG*T^R", "is_match": false}, {"example": "%^Rfty", "is_match": false}, {"example": "nUGYt", "is_match": false}, {"example": "r5efd", "is_match": false}]}, {"expression": "^((\\(([1-9]{2})\\))(\\s)?(\\.)?(\\-)?([0-9]{0,1})?([0-9]{4})(\\s)?(\\.)?(\\-)?([0-9]{4})|(([1-9]{2}))(\\s)?(\\.)?(\\-)?([0-9]{0,1})?([0-9]{4})(\\s)?(\\.)?(\\-)?([0-9]{4}))$", "raw_prompt": "This expression allows Brazilian phone numbers as they have 4 or 5 prefix digits and with/without regional code. Not perfect but simplifies. Also allows space or dot or hyphen as optional separator in the number as parenthesis in regional code.", "refined_prompt": "Matches Brazilian phone numbers as they have 4 or 5 prefix digits and with/without regional code. Also allows spaces or dots or hyphens as optional separators in the number as parenthesis in regional code.\nMatch examples:\n- \"(13)98145-5566\"\n- \"(11)8854-3236\"\n- \"(11) 8854-3236\"\nNon-match examples:\n- \"(13654854\"\n- \"01 9854-4253\"", "matches": ["(13)98145-5566", "(11)8854-3236", "(11) 8854-3236", "(11).8854.3236", "(11)-8854-3236", "1177854425", "11.5642-3115", "77\u205f.1211\u2000.7443", "(15)\u3000.-1550\t2767", "57\u2000.04920.5125", "35\u2029-0540.3618", "(66)8796\u180e.8591", "83.-3943\u202f-6281"], "non_matches": ["(13654854", "01 9854-4253", "11.456758-525", "324567876543", "234543ert", "number", "+1", "-986543", "3434.34344343.", "34refvf", "453245678", "(87654)"], "stress_tests": [], "serial": 1329, "problematic": [{"example": "(66)8796\u180e.8591", "is_match": true}]}, {"expression": "((20)[0-9]{2})-((0[1-9])|(1[0-2]))-((3[0-1])|([0-2][1-9]|([1-2][0-9])))\\s((2[0-3])|[0-1][0-9]):[0-5][0-9]", "raw_prompt": "Date and hour with fixed format, only accepting year >= 2000. If you want more flexibility on the year, you could replace the first expression (20)[0-9]{2} with only [0-9]{4}, that would allow years from 0000 to 9999.", "refined_prompt": "Matches date and hour with a fixed format (2033-07-31\u200703:32), only accepting year >= 2000.\nMatch examples:\n- \"2000-12-29 10:00 2014-10-20 23:59 2001-01-01 00:00\"\n- \"2032-03-27\"\n- \"08:21\"\nNon-match examples:\n- \"1999-12-29 09:00 2014-01-02 9:00 2000-1-1 23:10\"\n- \"32456786543\"", "matches": ["2000-12-29 10:00 2014-10-20 23:59 2001-01-01 00:00", "2032-03-27", "08:21", "2033-07-31\u200703:32", "2076-11-29", "20:38", "2020-12-30\u202920:08", "2062-10-31\u300020:33", "2083-08-21\u200219:59", "2069-05-20\u200321:02", "2030-11-31\u202805:33", "2062-12-25\u300020:26", "2071-12-16\u200320:11"], "non_matches": ["1999-12-29 09:00 2014-01-02 9:00 2000-1-1 23:10", "32456786543", "12:12:12:12", "45frec", "423214567", "4r3fge8r7f", "438438", "12121212", "date", "time", "noon", "03:03:03:03"], "stress_tests": [], "serial": 1330, "problematic": [{"example": "2032-03-27", "is_match": true}, {"example": "08:21", "is_match": true}, {"example": "2076-11-29", "is_match": true}, {"example": "20:38", "is_match": true}]}, {"expression": "[D]?[-D]?[0-9]{5}", "raw_prompt": "German postal code with or without national praefix.", "refined_prompt": "Matches German postal code with or without national prefix.\nMatch examples:\n- \"D-25335\"\n- \"67341\"\n- \"-29430\"\nNon-match examples:\n- \"5335\"\n- \"234567898765432\"", "matches": ["D-25335", "67341", "-29430", "27655", "25335", "D70116", "D24527", "D18371", "D48382", "DD31926", "D14391", "D38169", "DD80666"], "non_matches": ["5335", "234567898765432", "+8765", "--i6", "#3", "4321", "postal code", "$45", "54%", "(678)", "######", "3fery78dc"], "stress_tests": [], "serial": 1332, "problematic": [{"example": "234567898765432", "is_match": false}]}, {"expression": "^([1-9]\\d{0,3}|[1-5]\\d{4}|6[0-4]\\d{3}|65[0-4]\\d{2}|655[0-2]\\d|6553[0-5])$", "raw_prompt": "Match TCP/UDP port number between 1 and 65535", "refined_prompt": "Match TCP/UDP port number between 1 and 65535\nMatch examples:\n- \"1\"\n- \"23\"\n- \"1024\"\nNon-match examples:\n- \"0\"\n- \"65536\"", "matches": ["1", "23", "1024", "65535", "38092", "65527", "61486", "65500", "65532", "64386", "64437", "65500", "62186"], "non_matches": ["0", "65536", "32", "23", "345trfde34", "546787654324567", "435643534534", "-2345678", "+09654", "45%", "$45", "#2"], "stress_tests": [], "serial": 1337, "problematic": [{"example": "32", "is_match": false}, {"example": "23", "is_match": false}]}, {"expression": "^(?:(((Jan(uary)?|Ma(r(ch)?|y)|Jul(y)?|Aug(ust)?|Oct(ober)?|Dec(ember)?)\\ 31)|((Jan(uary)?|Ma(r(ch)?|y)|Apr(il)?|Ju((ly?)|(ne?))|Aug(ust)?|Oct(ober)?|(Sept|Nov|Dec)(ember)?)\\ (0?[1-9]|([12]\\d)|30))|(Feb(ruary)?\\ (0?[1-9]|1\\d|2[0-8]|(29(?=,\\ ((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))))\\,((1[6-9]|[2-9]\\d)\\d{2})) (?:[0-1]?[0-9]|[2][1-4]):[0-5]?[0-9]:[0-5]?[0-9]\\s?([apAP][Mm])?$", "raw_prompt": "Tested with all date times:\nExamples Like:\n[Jul 30,2015 10:40:43 AM]\nif you want to use space then please add before ((1[6-9]|[2-9]\\d)\\d{2}))\nthen it will works fine.", "refined_prompt": "Matches dates in the format month date, year HH:MM:SS AM/PM\nMatch examples:\n- \"Jul 30,2015 10:40:43 AM\"\n- \"July 31,1841 21:42:46\u1680Am\"\n- \"Dec 31,1808 21:5:12\u2000PM\"\nNon-match examples:\n- \"Jul 30, 2015 10:40:43 AM\"\n- \"jan\"", "matches": ["Jul 30,2015 10:40:43 AM", "July 31,1841 21:42:46\u1680Am", "Dec 31,1808 21:5:12\u2000PM", "Oct 30,1901 8:1:11PM", "February 21,1736 24:27:7\u180eam", "Dec 31,1785 8:0:5", "Feb 29,1932 09:1:6", "February 28,1828 24:02:10Pm", "October 31,1603 3:7:36aM", "Feb 18,5105 1:11:6pm", "Feb 19,1647 5:45:1\tPm", "Apr 13,1927 23:4:3", "October 31,1749 23:9:3\ufeffPm"], "non_matches": ["Jul 30, 2015 10:40:43 AM", "jan", "12/12/12", "3:90:83", "noon", "Monday the 5th", "Oct 2021", "12-12-12", "June 5th", "3 pm", "03:03:03", "time"], "stress_tests": [], "serial": 1351, "problematic": [{"example": "February 21,1736 24:27:7\u180eam", "is_match": true}, {"example": "Feb 29,1932 09:1:6", "is_match": true}, {"example": "October 31,1749 23:9:3\ufeffPm", "is_match": true}]}, {"expression": "^(\\+(1\\-)?\\d{1,3})?(\\s|\\-)?(\\s|\\-)?((\\(\\d{2}\\)|\\d{2})(\\s|\\-)?\\d{4}|(\\(\\d{3}\\)|\\d{3})(\\s|\\-)?\\d{3})(\\s|\\-)?\\d{4}(\\s)?(x|ext|ext.)?(\\d{1,6})?,?(\\d{1,6})?,?(\\d{1,6})?$", "raw_prompt": "Match mexican local or international numbers with optional area code parentheses and optional max 3 extensions with 6 chars length.", "refined_prompt": "Match mexican local or international numbers with optional area code parentheses and optional max 3 extensions with 6 chars length.\nMatch examples:\n- \"(55) 1234-5678 x123456,123,12\"\n- \"5512345678\"\n- \"+1 (510) 123-5678 x1234\"\nNon-match examples:\n- \"+1 510 (55 1234-5678\"\n- \"12345678 x123\"", "matches": ["(55) 1234-5678 x123456,123,12", "5512345678", "+1 (510) 123-5678 x1234", "--43-34480882136117,9,6", "+1-2", "6889125648ext373,,", "868976-9945x4473165", "(26)54410744ext,748", "+4(27)", "8460\u20299822\u205f70309", "+5(29)74853033\u200a311,57337,898", "(476)015", "3380ext70685317"], "non_matches": ["+1 510 (55 1234-5678", "12345678 x123", "+1 (510) 1234-5678 x1234567", "####", "phone number", "345trg", "23456@786543", "!def", "456++++", "8767(878)", "98.0", "$45"], "stress_tests": [], "serial": 1361, "problematic": [{"example": "+1-2", "is_match": true}, {"example": "+4(27)", "is_match": true}, {"example": "8460\u20299822\u205f70309", "is_match": true}, {"example": "(476)015", "is_match": true}, {"example": "3380ext70685317", "is_match": true}]}, {"expression": "(?:#|0x)?(?:[0-9A-F]{2}){4}", "raw_prompt": "32 bit hex color preceding with 0x or # . From http://tools.twainscanning.com/getmyregex .", "refined_prompt": "Matches 32-bit hex color preceding with 0x or #\nMatch examples:\n- \"0xF0F73611\"\n- \"#C3C926DE\"\n- \"#C98DD40C\"\nNon-match examples:\n- \"#FF006C\"\n- \"werty\"", "matches": ["0xF0F73611", "#C3C926DE", "#C98DD40C", "#3AD9B39F", "33E92090", "#C3E6A018", "58110DA3", "39D698FC", "B179B0E7", "0xB0779E42", "D2C7A570", "93D64C29", "38AA7E16"], "non_matches": ["#FF006C", "werty", "!erferw", "FGVBN..", "###", "hex", "kjihuygft", "JHUYGTF^TVYG", "KHIU", "65435678", "kcer", "iuh7t6r5e45drcftv"], "stress_tests": [], "serial": 1362, "problematic": [{"example": "65435678", "is_match": false}]}, {"expression": "\\d{3}[.-]?\\d{3}[.-]?\\d{4}", "raw_prompt": "Phone number United States (555-555-1234) . From http://tools.twainscanning.com/getmyregex .", "refined_prompt": "Matches phone number in United States (555-555-1234)\nMatch examples:\n- \"555-555-1234\"\n- \"455515.4423\"\n- \"850476-1122\"\nNon-match examples:\n- \"555-55-1234\"\n- \"903614139784\"", "matches": ["555-555-1234", "455515.4423", "850476-1122", "272313.3403", "7974824765", "779-989.0741", "567.975.9778", "3497399998", "2947938779", "8027495892", "575-1065826", "410-6049017", "4073580632"], "non_matches": ["555-55-1234", "903614139784", "40635.36.541507", "98705.17-479685", "59009-22952904", "0138071-234882", "34434-21.190890", "9447950521206", "###", "13755.71.813398", "69927-88934", "4998910-450495"], "stress_tests": [], "serial": 1366, "problematic": [{"example": "903614139784", "is_match": false}, {"example": "59009-22952904", "is_match": false}, {"example": "0138071-234882", "is_match": false}, {"example": "9447950521206", "is_match": false}, {"example": "4998910-450495", "is_match": false}]}, {"expression": "[A-Za-z]{5}", "raw_prompt": "Word 5-letter word (TWAIN forum) . From http://tools.twainscanning.com/getmyregex .", "refined_prompt": "Matches a 5-letter word\nMatch examples:\n- \"TWAIN\"\n- \"forum\"\n- \"AtrKA\"\nNon-match examples:\n- \"test\"\n- \"ewrtgrfedw\"", "matches": ["TWAIN", "forum", "AtrKA", "jYWZz", "LIkRQ", "OvyBL", "dkWir", "KIpug", "aZfCh", "VxVQN", "nRYuF", "djqSX", "fyKuh"], "non_matches": ["test", "ewrtgrfedw", "wertfd", "fre", "wettrewf", "regdff2e4g", "5665", "kUHL", "WORDWORD", "longword", "supercali", "regexes"], "stress_tests": [], "serial": 1371, "problematic": [{"example": "ewrtgrfedw", "is_match": false}, {"example": "wertfd", "is_match": false}, {"example": "wettrewf", "is_match": false}, {"example": "regdff2e4g", "is_match": false}, {"example": "WORDWORD", "is_match": false}, {"example": "longword", "is_match": false}, {"example": "supercali", "is_match": false}, {"example": "regexes", "is_match": false}]}, {"expression": "[0-9]{3}P[A-Z][0-9]{7}[0-9X]", "raw_prompt": "HMRC Accounts Office Reference (AORef) in format\n3digits, the letter P and another letter followed by 7 digits and either an 8th digit or letter X", "refined_prompt": "Matches HMRC Accounts Office Reference (AORef) in format\r\n3digits, the letter P and another letter followed by 7 digits and either an 8th digit or letter X\nMatch examples:\n- \"123PA12345678\"\n- \"451PW1234523X\"\n- \"449PQ26754633\"\nNon-match examples:\n- \"A01PA12345678\"\n- \"123RA1234567X\"", "matches": ["123PA12345678", "451PW1234523X", "449PQ26754633", "448PE2981258X", "922PJ45664934", "819PX41551848", "032PN50665990", "782PH34420777", "738PR60127787", "836PQ18411758", "757PV22701429", "770PH04199313", "460PK73165943"], "non_matches": ["A01PA12345678", "123RA1234567X", "186889PF58908058", "554276PB50534594", "60PJ00369967", "92PE31722192", "91PH11873906", "70PJ41018", "68PQ65127", "017358PQ71778", "473111PQ9009X", "555682PO15525"], "stress_tests": [], "serial": 1377, "problematic": [{"example": "186889PF58908058", "is_match": false}, {"example": "554276PB50534594", "is_match": false}]}, {"expression": "^(?:[2-9]\\d\\d\\d)-(?:1[012]|0?[1-9])?-(?:31(?!.(?:0?[2469]|11))|(?:30|29)(?!.0?2)|29(?=.0?2.(?:(?:(?:1[6-9]|[2-9]\\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00)))(?:T))|(?:2[0-8]|1\\d|0?[1-9]))T(2[01234]|[01]\\d):[0-5]\\d:[0-5]\\d[+-][01]\\d:[0-5]\\d$", "raw_prompt": "Matches the strict datetime format for Common Alerting Protocol v1.2 (might be same as earlier versions too). Inspiration and some code came from Michael Ash's http://regexlib.com/REDetails.aspx?regexp_id=610 with tweaks of my own", "refined_prompt": "Matches the strict datetime format for Common Alerting Protocol v1.2 (might be same as earlier versions too).\nMatch examples:\n- \"2016-04-07T12:29:00-04:00\"\n- \"2016-04-07T11:13:00-05:00\"\n- \"2016-04-05T00:53:35-04:00\"\nNon-match examples:\n- \"31/12/2003 11:59:59 PM\"\n- \"2016-04-07 22:00:01+00:00\"", "matches": ["2016-04-07T12:29:00-04:00", "2016-04-07T11:13:00-05:00", "2016-04-05T00:53:35-04:00", "7559-1-31T20:17:07-00:19", "5633--31T11:29:43+07:44", "9821-10-29T21:28:36+19:01", "8337--15T23:41:03+00:23", "9427-10-26T24:21:54-16:06", "2646--29T22:29:41+10:14", "3462--29T09:24:53+02:27", "2922-7-29T20:11:38+15:23", "2195-12-31T19:33:42-02:35", "7526-9-30T21:22:23-06:50"], "non_matches": ["31/12/2003 11:59:59 PM", "2016-04-07 22:00:01+00:00", "2016-04-07T22:00:01Z", "34567645322", "232456676", "7654/33453", "date", "8734783478", "32-23", "4351", "65432245", "9876543"], "stress_tests": [], "serial": 1389, "problematic": [{"example": "7559-1-31T20:17:07-00:19", "is_match": true}, {"example": "5633--31T11:29:43+07:44", "is_match": true}, {"example": "9821-10-29T21:28:36+19:01", "is_match": true}, {"example": "2646--29T22:29:41+10:14", "is_match": true}, {"example": "2922-7-29T20:11:38+15:23", "is_match": true}, {"example": "7526-9-30T21:22:23-06:50", "is_match": true}]}, {"expression": "^\\d{4}\\s\\d{4}\\s\\d{4}$", "raw_prompt": "This regular expression will match a Aadhar Number in the format 1111 1111 1111.", "refined_prompt": "match a Aadhar Number in the format 1111 1111 1111.\nMatch examples:\n- \"1234 5678 9123\"\n- \"0845 6213\u20015483\"\n- \"9116\u205f7527\u20297129\"\nNon-match examples:\n- \"123456789123\"\n- \"3\"", "matches": ["1234 5678 9123", "0845 6213\u20015483", "9116\u205f7527\u20297129", "6362\u20098296\u20084740", "5177", "8152", "9951", "7410\u20288174\u200a5707", "1320\u20010059\t7511", "7446\u30008995", "6982", "5316\u16800827\u20052099", "7547\f6358\u20025061"], "non_matches": ["123456789123", "3", "$4", "54%", "#3", "12/12", "12-12", "3+3", "ISBN #", "34frv", "43fe", "453ref45"], "stress_tests": [], "serial": 1408, "problematic": [{"example": "5177", "is_match": true}, {"example": "8152", "is_match": true}, {"example": "9951", "is_match": true}, {"example": "7446\u30008995", "is_match": true}, {"example": "6982", "is_match": true}]}, {"expression": "^(?=.{16,})(?=.*[1-9])(?=.*[a-z])(?=.*[A-Z])(?=.*[(!@#$%^&*()_+|~\\- =\\`{}[\\]:\u201d;'<>?,.\\/, )])(?!.*(.)\\1{2,}).+$", "raw_prompt": "Password validator for a high complexity secure passwords.\nLength minimum 16 characters\nAt least one number\nAt least one lowercase character\nAt least one uppercase character\nAt least one special character from the following set \u201c(!@#$%^&*()_+|~\\- =\\`{}[\\]:\u201d;'<>?,.\\/, )]\u201d\nNo sequential repeating characters", "refined_prompt": "Password validator for a high complexity secure passwords.\r\nLength minimum 16 characters\r\nAt least one number\r\nAt least one lowercase character\r\nAt least one uppercase character\r\nAt least one special character from the following set \u201c(!@#$%^&*()_+|~\\- =\\`{}[\\]:\u201d;'<>?,.\\/, )]\u201d\r\nNo sequential repeating characters\nMatch examples:\n- \"Pas$words0123456\"\n- \"~On}ES iZwHauR/T'g:@m\\K!SBK~\"~?fe,(\"1b7~.C2%mx+V/2,<U.s+gTtdz\"\n- \"sjhYh4,^esC1pzKR_jB][hbbV}yu]7O2?oS1%#=&wtrw2l}'P0j4alf;)4A+._FeF#%)>mJ`H(aT)wo3B\\Y4N0@\"\nNon-match examples:\n- \"Password\"\n- \"36\u20066'05.992469\"\"", "matches": ["Pas$words0123456", "~On}ES iZwHauR/T'g:@m\\K!SBK~\"~?fe,(\"1b7~.C2%mx+V/2,<U.s+gTtdz", "sjhYh4,^esC1pzKR_jB][hbbV}yu]7O2?oS1%#=&wtrw2l}'P0j4alf;)4A+._FeF#%)>mJ`H(aT)wo3B\\Y4N0@", "H.hW,", "@.]&~Kt4Q,%\"91I_M_Sjpw$&CtXe}256mVP/jyJ',!8'!|XblVZXwPrF{Z!sknAOupj[b:eLx~of,'m+5{", "nh 4J={y4}Myz\\~0x`o?|d;}!URF<vq?#'8_6sjM|", "4s:K\"-N'\"VKG;c7&Zz?T/GqV\"N!,hlw[lY4C7 |@d|T:4cef0H@iw]`|#n&,p+:|H;}L(xhi!m", "IJ-6 >#<%hGH$VHXKPnL;~{O`O&)R{!`P-L,EB7^us3=OW5RG\\$i5bIR.`Eag$ B", "_=D_=MM@=\\}", "1B9u&n~QCE#,<+.vh$\\tFGyAnC\"AE(r7Dj%%1JtPd9EEK@(>P/lW", ":tzN8b:iCqv2?,Hre&G=\"\\*L)!3<3ENd", "v6P(LP0I@ oaFznN&qJn", "6/(P>u==h4XchmI7x"], "non_matches": ["Password", "36\u20066'05.992469\"", "ewfdsc", "23r432fwe", "32rweda6%RTynom", "#", "3rewdsHUYUTvy", "ewifdu&*6", "r4fr4ecUYF", "??", "d3ewd", "doeihwd4t4"], "stress_tests": [], "serial": 1413, "problematic": [{"example": "H.hW,", "is_match": true}, {"example": "_=D_=MM@=\\}", "is_match": true}]}, {"expression": "^(\\+?1(-|\\.|\\s)?)?((\\(((8(00|22|33|44|55|66|77|[8[0-9]))|900)\\)|((8(00|22|33|44|55|66|77|[8[0-9]))|900))(-|\\.|\\s)?\\d{3}(-|\\.|\\s)?\\d{4}|(\\([2-9]([02-9]\\d|1[02-9])\\)|[2-9]([02-9]\\d|1[02-9]))(-|\\.|\\s)?[2-9]([02-9]\\d|1[02-9](-|\\.|\\s)?\\d{4}))$", "raw_prompt": "This is a very detailed RegEx that only allows for valid phone number combinations in accordance with \"North American Numbering Plan\" as well as any combinations for toll (9XX) and toll-free (8XX) numbers.\nNumbers can contain parenthesis around the area code, can include 1 or +1, and can be delimited using \"-\", \".\", or space.", "refined_prompt": "Matches valid phone number combinations in accordance with \"North American Numbering Plan\" as well as any combinations for toll (9XX) and toll-free (8XX) numbers.\r\nNumbers can contain parenthesis around the area code, can include 1 or +1, and can be delimited using \"-\", \".\", or space.\nMatch examples:\n- \"800-211-5555\"\n- \"(800) 211-5555\"\n- \"1-800-211-5555\"\nNon-match examples:\n- \"555-555-555\"\n- \"555-211-5555\"", "matches": ["800-211-5555", "(800) 211-5555", "1-800-211-5555", "+1-800-211-5555", "555 212 1234", "555.212.1234", "1-718-210-3472", "1710-287", "+1-900.6354397", "1830\u2004818-4675", "(212)735", "(866)0826806", "1(822)-802-5360"], "non_matches": ["555-555-555", "555-211-5555", "2-555-555-5555", "555-123-1234", "324532", "456432", "###", "34", "$45", "phone number", "-1 4342133", "(383)389238493821483"], "stress_tests": [], "serial": 1422, "problematic": [{"example": "324532", "is_match": false}, {"example": "456432", "is_match": false}]}, {"expression": "^(([0]\\d)|([1][0-2])|(\\d))[/](([0-2]\\d)|([3][0-1])|(\\d))[/][2][0]\\d{2}[,]\\s(([0]\\d)|([1][0-2])|(\\d))[:][0-5]\\d\\s[AP][M]", "raw_prompt": "This is basic datetime validator that does bother with seconds and enforces slashes, a comma after the date, as well as a year that must start with \"20\". Morning and evening are represented by \"AM\" or \"PM\" only.", "refined_prompt": "Matches dates with slashes, a comma after the date, as well as a year that must start with \"20\". Morning and evening are represented by \"AM\" or \"PM\" only.\nMatch examples:\n- \"1/31/2086, 9:50 AM\"\n- \"08/04/2082, 09:13 PM\"\n- \"1/2/2000, 1:12 PM\"\nNon-match examples:\n- \"1/31/2086 9:50 AM\"\n- \"08/04/2082, 09:13\"", "matches": ["1/31/2086, 9:50 AM", "08/04/2082, 09:13 PM", "1/2/2000, 1:12 PM", "12/31/2039,\u30000:51\u180eAM", "11/30/2080,\u00a02:32\u2006PM", "10/30/2075,\u202910:55\u2003AM", "03/3/2098,", "9/31/2010,\u202803:04\u2028AM", "7/2/2052,\u200410:22 PM", "8/11/2044,\t11:57\u2001AM", "1/5/2005,\u200301:17\u202fAM", "02/16/2089,\u20284:44", "10/6/2052,\u205f3:58\u2009PM"], "non_matches": ["1/31/2086 9:50 AM", "08/04/2082, 09:13", "1/2/1900, 1:12 PM", "date", "23456", "12/23:2024,\u205f9:01\u2008PM", "10/5/2015,\u205f3:46\u00a0pm", "11 30 2088, 11:51\u3000AM", "09-8-2057, 02:31\u2029AM", "05/30/2005,\ufeff07:52\u2004am", "12302064,\u000b10:06\u00a0PM", "34rtfd"], "stress_tests": [], "serial": 1424, "problematic": [{"example": "12/31/2039,\u30000:51\u180eAM", "is_match": true}, {"example": "03/3/2098,", "is_match": true}, {"example": "02/16/2089,\u20284:44", "is_match": true}]}, {"expression": "(?!219( |\\.|\\-|)??09( |\\.|\\-|)??9999|078( |\\.|\\-|)??05( |\\.|\\-|)??1120)(?!666|000|9\\d{2})\\d{3}( |\\.|\\-|)??(?!00)\\d{2}( |\\.|\\-|)??(?!0{4})\\d{4}", "raw_prompt": "Advanced SSN regular expression. Matches 9 digits separated by mixed spaces, hyphens, or periods. Excludes:\n- Values containing all 0's in any group\n- Values beginning with 900-999\n- 078-05-1120 (Woolworth's Wallet)\n- Values beginning with 666\nGuidelines can be seen at: https://www.ssa.gov/kc/SSAFactSheet--IssuingSSNs.pdf", "refined_prompt": "Matches 9 digits separated by mixed spaces, hyphens, or periods. Excludes:\r\n- Values containing all 0's in any group\r\n- Values beginning with 900-999\r\n- 078-05-1120 (Woolworth's Wallet)\r\n- Values beginning with 666\nMatch examples:\n- \"001-23-1123\"\n- \"377.42.1423\"\n- \"389551234\"\nNon-match examples:\n- \"078051120\"\n- \"900 20 2211\"", "matches": ["001-23-1123", "377.42.1423", "389551234", "389 55.1234", "496261630", "448-109067", "814-278878", "056093112", "644156830", "958421176", "399914690", "547392599", "666 791877"], "non_matches": ["078051120", "900 20 2211", "389.00.4411", "76", "23432", "2345312", "56432", "4351545", "98374943", "03294876", "#3", "45%"], "stress_tests": [], "serial": 1428, "problematic": [{"example": "958421176", "is_match": true}, {"example": "666 791877", "is_match": true}]}, {"expression": "^(?![-_.0-9])(?!.*[-_.][-_.])(?!.*[-_.]$)[A-Za-z0-9-_.]+$", "raw_prompt": "Provide username constraint that allow character and numeric and also perion hyphen and underscore, but it only allows alphabet at the begin, and alphanumeric at the end. also user may not user more than one sign side by side", "refined_prompt": "Match username that allows characters, numbers , periods, hyphens, and underscores, but it only allows alphabet at the beginning, and alphanumeric at the end. May not have more than one sign side-by-side\nMatch examples:\n- \"my.username\"\n- \"u-s-e-r.n_a_m_e\"\n- \"xyz724\"\nNon-match examples:\n- \"9abc\"\n- \"x..z\"", "matches": ["my.username", "u-s-e-r.n_a_m_e", "xyz724", "c1", "KWjAuln-Pj8S9vFzyo-8PftbrATrUsuUNnV6RAkiDXUDFr7HEy.2BxCIoXWoyCSTRmOIaOQMQGVq3c4vAoRZeHzGmCGwN0Og_", "upQa6ZKY-aEC", "CXBQ", "_Npuc59gAyjjfd_bP_alX3zOXxKrHoS28HYKIKGNtfJPn7vuCtQASCHbjNkW_tXu7BU4QSrrpJJmWQepX-9fUEDl", "1nddO7ZNK8XeHg.Wx8UKGVTTUW-7p.aOjg8aDs3u0Oubg", "ctSqyXI1tb1J8QlZd9K81imh.WutEALyNWV9hmq", "q", "6y3n93Cz03", "GKu1MRZ9yHWpvhtjANarmEiAbLSM3vSosziR0vxRmwP-P02P85kpnUdSexIuIi18kY"], "non_matches": ["9abc", "x..z", "a._-c", "-a", "c54_", "+87", "873deydhcs", "ewfd23239__efiruvgh", "309e8ujdsk", "43ewsa5%", "efhdcsij?eofj", "ew87yuhbe+efuihjdsk"], "stress_tests": [], "serial": 1445, "problematic": [{"example": "KWjAuln-Pj8S9vFzyo-8PftbrATrUsuUNnV6RAkiDXUDFr7HEy.2BxCIoXWoyCSTRmOIaOQMQGVq3c4vAoRZeHzGmCGwN0Og_", "is_match": true}, {"example": "_Npuc59gAyjjfd_bP_alX3zOXxKrHoS28HYKIKGNtfJPn7vuCtQASCHbjNkW_tXu7BU4QSrrpJJmWQepX-9fUEDl", "is_match": true}, {"example": "1nddO7ZNK8XeHg.Wx8UKGVTTUW-7p.aOjg8aDs3u0Oubg", "is_match": true}, {"example": "6y3n93Cz03", "is_match": true}]}, {"expression": "^[0][5-7]\\d{2}(?:(\\s|-|\\/))?\\d{2}(?:(\\s|-|\\/))?\\d{2}(?:(\\s|-|\\/))?\\d{2}$", "raw_prompt": "Algerian Mobile :\n1-Starts With 0\n2-Between 5 & 7\nThe rest can be filled with 8 digits with or without\nspaces or dashes, I even added slashes, grouped 2 by 2\nTotal of digits (without spaces/dashes/slashes) must be 10.", "refined_prompt": "Matches Algerian Mobile Numbers:\r\n1-Starts With 0\r\n2-Between 5 & 7\r\nThe rest can be filled with 8 digits with or without\r\nspaces or dashes, I even added slashes, grouped 2 by 2\r\nTotal of digits (without spaces/dashes/slashes) must be 10.\nMatch examples:\n- \"0696 22 13 23\"\n- \"0698\u202940\ufeff86/10\"\n- \"07726291 66\"\nNon-match examples:\n- \"02252525225\"\n- \"234\"", "matches": ["0696 22 13 23", "0698\u202940\ufeff86/10", "07726291 66", "065277\u200228-35", "0780072197", "0693/88-9423", "0541-46-3892", "0599/80-05-03", "0601/03\u200213-78", "06981776\u200977", "0526-463686", "060209\u20057277", "0737/29/48\u200845"], "non_matches": ["02252525225", "234", "###", "34554", "#32543534", "(34287)", "(608)-385-2392", "343534", "22335455435345235253245", "4534", "-12", "+12345"], "stress_tests": [], "serial": 1452, "problematic": [{"example": "0698\u202940\ufeff86/10", "is_match": true}]}, {"expression": "^((25[0-5]|2[0-4]\\d|1\\d{2}|[1-9]?\\d)(\\.|$)){4}\\b", "raw_prompt": "Match valid IPv4 address. Constraints: matches only IP. All numbers must be between 0-255 for each block, delimited by dots, and cannot be zero padded or be suffixed by a dot on the last class.", "refined_prompt": "Match valid IPv4 address. Constraints: matches only IP. All numbers must be between 0-255 for each block, delimited by dots, and cannot be zero padded or be suffixed by a dot on the last class.\nMatch examples:\n- \"0.0.0.0\"\n- \"192.168.1.35\"\n- \"169.254.0.0\"\nNon-match examples:\n- \"127.0.0.01\"\n- \"255.255.255.256\"", "matches": ["0.0.0.0", "192.168.1.35", "169.254.0.0", "162172.184168", "251.16340.255", "20580.0.230.", "247.27.179.254", "250137244.251.", "250.254255.50.", "250254.25546", "213.30.222.123.", "168.155.181255", "156.255.175189."], "non_matches": ["127.0.0.01", "255.255.255.256", "7.7.7.7.", "IP", "231", "2345432", "23244255765", "234242", "343984", "48834.234872", "3242.34524.432", "3252.54321."], "stress_tests": [], "serial": 1458, "problematic": [{"example": "162172.184168", "is_match": true}, {"example": "251.16340.255", "is_match": true}, {"example": "20580.0.230.", "is_match": true}, {"example": "250137244.251.", "is_match": true}, {"example": "250.254255.50.", "is_match": true}, {"example": "250254.25546", "is_match": true}, {"example": "213.30.222.123.", "is_match": true}, {"example": "168.155.181255", "is_match": true}, {"example": "156.255.175189.", "is_match": true}]}, {"expression": "^(\\d)(\\s)(\\d)*(-)(\\d)*(-)(\\d)*", "raw_prompt": "Matches any number following the 1 800 phone method. It's not 100% foolproof so please be wary - just wanted to present my legitimate, raw regex without having to look up anything on Stack Overflow. Thank you.\nLink to my GitHub: https://github.com/StoddardSpencer96", "refined_prompt": "Matches any number following the 1 800 phone method.\nMatch examples:\n- \"1 902-444-444 1 904-565-5555 1 419-444-4444 1 902-44-3333 (this one shouldnt match)\"\n- \"6\u00a090457415709650012759880280217720-118037-6965067112833\"\n- \"3\u2028933142361606825138177957844457616689772660100-64827802369035594490127439871234239079810112579086799572670171133482-24228840698438350259893373228712714176092545413595669124680\"\nNon-match examples:\n- \"23 904-5555-5555 1 902-44-3333 (this is where the number should be)\"\n- \"phone number\"", "matches": ["1 902-444-444 1 904-565-5555 1 419-444-4444 1 902-44-3333 (this one shouldnt match)", "6\u00a090457415709650012759880280217720-118037-6965067112833", "3\u2028933142361606825138177957844457616689772660100-64827802369035594490127439871234239079810112579086799572670171133482-24228840698438350259893373228712714176092545413595669124680", "4\f607964130289155716888762-6633269980210632508074787448584543798287773-092491372282184197160845408587236666441376650421342192307770828528153120761027444549336", "6\u20084446253008076-97327364079191681935156825-6815512919050986539191464739731811822804", "1\u200105048090427786429701669614306019920936400705127337380194084847377980873535060502184876132388790805-90016-60877509292185841397117637433688590928800060369517309849191968214335034225504822623789444188162", "7\u000b248774637692716592797783739255370793629563938778454904090805778696-72264370085369470434191-0070672387036083932480087573960296921389480911280753522682312546167913", "8\u200816071056271204218322315127686705684071112066648142888944942976393-288613212534079260595874094969559973393914660-13420089576060662696682601935040611545515160923730704174199553554900971706147619", "7\f93600235796490718596987856384931002596-86490532267101562362745437968731794847394368196508112-78748367840718944978", "9\u180e141801088903969553135422261728524913513484498250097687170874483103085613871099-70125159195997101549744302150368913517757897949700203051922418591303337782000-50547", "2\u200a462061613437167482344577949563765142175478002431858323412829964-962409560811528791642013257480956603265961099256261271959-5131411861021664189351556353512965681940785439871337483036395038826805001104408681781916", "37342668800503669497539959404898205012886143872199862759969854504991814082228115853-5913525234363199445774379740111145811889064984240009705933-16099402587315233213299", "1\u2001353420834434266665917522201511338358781323628262322860390043244090159738662071021--3744497080079092332018419587727841562387392566079912231360510808646143930904922737133398483625224637"], "non_matches": ["23 904-5555-5555 1 902-44-3333 (this is where the number should be)", "phone number", "+1", "-1", "### ### ####", "de3f4w3", "3245rfweq", "2345rfe", "#3", "45%", "$43"], "stress_tests": [], "serial": 1460, "problematic": [{"example": "9\u180e141801088903969553135422261728524913513484498250097687170874483103085613871099-70125159195997101549744302150368913517757897949700203051922418591303337782000-50547", "is_match": true}, {"example": "37342668800503669497539959404898205012886143872199862759969854504991814082228115853-5913525234363199445774379740111145811889064984240009705933-16099402587315233213299", "is_match": true}]}, {"expression": "^([\\d])([\\s])([\\d]){3}([-])([\\d]){3}([-])([\\d])*", "raw_prompt": "Matches the 1 800-8000 format.\nLink to Github: https://github.com/StoddardSpencer96", "refined_prompt": "Matches the 1 800-8000 phone number format.\nMatch examples:\n- \"1 902-444-4444 1 405-543-3000 1 910-243-321\"\n- \"0\u200a637-867-74680040219348723440920555412494905967786268470313247699601530027518099014643936\"\n- \"7\u2001373-769-9941635551805917146072960021634413918671427476291093582271674062863567\"\nNon-match examples:\n- \"1902-44-4-5-3-2-2 1 9023333333 1-902-3332222\"\n- \"######\"", "matches": ["1 902-444-4444 1 405-543-3000 1 910-243-321", "0\u200a637-867-74680040219348723440920555412494905967786268470313247699601530027518099014643936", "7\u2001373-769-9941635551805917146072960021634413918671427476291093582271674062863567", "5\u2028615-075-72891", "6\u2009343-442-2125241633685595171736058312115332", "0\t293-886-9683307283060395791361114095842211188392", "7\u2005844-893-20739245277971402290112363309279781417", "3\u00a0858-213-799221688031334978332", "2\u00a0311-097-7372303044123741579637950627583330510281039058947128207584732985512426456568823285231", "691-964-688699748535836301708465056597359490772751903539309541239573834076318362101575962810261", "3\u00a0181-936-1209141870054535", "0\u2028770-777-13937788142347239489407481162654537094051864079900753303304224423", "6\u2009429-898-3795696213955949516726107896640732487436591"], "non_matches": ["1902-44-4-5-3-2-2 1 9023333333 1-902-3332222", "######", "phone number", "32453234", "1213", "#32", "3423", "121-2313", "12/12", "234532-123", "321312324342312-534253153", "412"], "stress_tests": [], "serial": 1463, "problematic": [{"example": "691-964-688699748535836301708465056597359490772751903539309541239573834076318362101575962810261", "is_match": true}]}]