[
    {
        "id": 1,
        "expression": "^\\d$",
        "raw_prompt": "Matches exactly 1 numeric digit (0-9).",
        "refined_prompt": "Matches exactly 1 numeric digit (0-9).\nMatch examples:\n- \"1\"\n- \"2\"\n- \"3\"\nNon-match examples:\n- \"a\"\n- \"324\"",
        "matches": [
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "9",
            "0"
        ],
        "non_matches": [
            "a",
            "324",
            "num",
            "location = 3",
            "ssda",
            "11",
            "hello world",
            "something something",
            "asd",
            "123fsf",
            "the car",
            "lorem ipsum"
        ],
        "stress_tests": [
            "eeeeeeeeeeeeyyyyyyyyhhyhuy"
        ]
    },
    {
        "id": 2,
        "expression": "^\\d{5}$",
        "raw_prompt": "Matches 5 numeric digits, such as a zip code.",
        "refined_prompt": "Matches 5 numeric digits, such as a zip code.\nMatch examples:\n- \"33333\"\n- \"55555\"\n- \"23445\"\nNon-match examples:\n- \"abcd\"\n- \"1324\"",
        "matches": [
            "33333",
            "55555",
            "23445",
            "89343",
            "46556",
            "25432",
            "25336",
            "43576",
            "68797",
            "30495",
            "54348",
            "45935",
            "93857"
        ],
        "non_matches": [
            "abcd",
            "1324",
            "as;lkjdf",
            "jaldks",
            "234",
            "8hr4f",
            "fsdg",
            "2546dgwre",
            "8j989",
            "xhsn",
            "potrewjdsg",
            "h345gf43"
        ],
        "stress_tests": []
    },
    {
        "id": 3,
        "expression": "^\\d{5}-\\d{4}$",
        "raw_prompt": "Numeric and hyphen 5+4 ZIP code match for ZIP+4.",
        "refined_prompt": "Matches a string that starts with five digits, followed by a hyphen, and ends with four digits.\nMatch examples:\n- \"22222-3333\"\n- \"34545-2367\"\n- \"56334-2343\"\nNon-match examples:\n- \"123456789\"\n- \"A3B 4C5\"",
        "matches": [
            "22222-3333",
            "34545-2367",
            "56334-2343",
            "34539-5433",
            "12349-5943",
            "54329-9875",
            "34852-5493",
            "83542-2314",
            "52435-3489",
            "12345-0983",
            "98745-2385",
            "48294-2945"
        ],
        "non_matches": [
            "123456789",
            "A3B 4C5",
            "55335",
            "dinfa",
            "sfalijad234",
            "asdf3453",
            "dsjlka3",
            "234fsd",
            "gaqwer3",
            "adfa2",
            "23457-4332w2"
        ],
        "stress_tests": []
    },
    {
        "id": 4,
        "expression": "^\\d{5}$|^\\d{5}-\\d{4}$",
        "raw_prompt": "This regular expression will match either a 5 digit ZIP code or a ZIP+4 code formatted as 5 digits, a hyphen, and another 4 digits. Other than that, this is just a really really long description of a regular expression that I'm using to test how my front page will look in the case where very long expression descriptions are used.",
        "refined_prompt": "Match either a 5 digit ZIP code or a ZIP+4 code formatted as a string that starts with five digits, followed by a hyphen, and ends with four digits..\nMatch examples:\n- \"55555-5555\"\n- \"34564-3342\"\n- \"90210\"\nNon-match examples:\n- \"434454444\"\n- \"645-32-2345\"",
        "matches": [
            "55555-5555",
            "34564-3342",
            "90210",
            "03945",
            "02946",
            "46556",
            "52346",
            "34534-3252",
            "49672-3923",
            "59403-6934",
            "35349-6753",
            "52346-3953"
        ],
        "non_matches": [
            "434454444",
            "645-32-2345",
            "abc",
            "394-3498",
            "234565423",
            "j3942fw",
            "43-5432",
            "5324523-345",
            "h909f34f",
            "0953jg",
            "wtre-0n",
            "3409fjg43"
        ],
        "stress_tests": []
    },
    {
        "id": 5,
        "expression": "^\\d{3}-\\d{2}-\\d{4}$",
        "raw_prompt": "This regular expression will match a hyphen-separated Social Security Number (SSN) in the format NNN-NN-NNNN.",
        "refined_prompt": "This regular expression will match a hyphen-separated Social Security Number (SSN) in the format NNN-NN-NNNN.\nMatch examples:\n- \"333-22-4444\"\n- \"123-45-6789\"\n- \"534-74-2573\"\nNon-match examples:\n- \"123456789\"\n- \"SSN\"",
        "matches": [
            "333-22-4444",
            "123-45-6789",
            "534-74-2573",
            "234-45-6235",
            "968-24-4395",
            "948-53-5924",
            "493-42-5938",
            "954-97-5942",
            "534-96-3623",
            "549-69-3456",
            "543-54-6396",
            "294-68-1957"
        ],
        "non_matches": [
            "123456789",
            "SSN",
            "-243",
            "4523-24352-453",
            "2346-2345-2435",
            "dgsfjkl",
            "2204fj",
            "234jgs-345",
            "4235-fgdsg",
            "afd-asdf",
            "dfg",
            "32542"
        ],
        "stress_tests": []
    },
    {
        "id": 6,
        "expression": "^[a-zA-Z]$",
        "raw_prompt": "Matches any single upper- or lower-case letter.",
        "refined_prompt": "Matches any single upper- or lower-case letter.\nMatch examples:\n- \"a\"\n- \"B\"\n- \"c\"\nNon-match examples:\n- \"0\"\n- \"&amp;\"",
        "matches": [
            "a",
            "B",
            "c",
            "f",
            "J",
            "D",
            "s",
            "D",
            "d",
            "o",
            "F",
            "p",
            "r"
        ],
        "non_matches": [
            "0",
            "&amp;",
            "AbC",
            "rewv342",
            "vr",
            "@",
            "sdfSDF",
            "asf",
            "324df",
            "34fs2",
            "34d2vdw",
            "99999@gmail"
        ],
        "stress_tests": []
    },
    {
        "id": 7,
        "expression": "^[a-zA-Z]+$",
        "raw_prompt": "Matches any string of only upper- and lower- case letters (no spaces).",
        "refined_prompt": "Matches any string of only upper- and lower- case letters (no spaces).\nMatch examples:\n- \"abc\"\n- \"ABC\"\n- \"aBcDeF\"\nNon-match examples:\n- \"abc123\"\n- \"mr.\"",
        "matches": [
            "abc",
            "ABC",
            "aBcDeF",
            "dfasdfs",
            "ALKFJsf",
            "FDSfdsf",
            "AJFDAL",
            "sfdjk",
            "FISD",
            "sadfkjl",
            "fadghui",
            "FDSnfsdFDS",
            "sdfjoi"
        ],
        "non_matches": [
            "abc123",
            "mr.",
            "a word",
            "a a a",
            "209fsd",
            "3nf@",
            "fgsda23",
            "nu9",
            "u09nKLJG FSL",
            "gdfios jsfoi",
            "JFLSKJ FSDOIJ",
            "GOOD friend"
        ],
        "stress_tests": []
    },
    {
        "id": 8,
        "expression": "^[a-zA-Z0-9]+$",
        "raw_prompt": "Matches any alphanumeric string (no spaces).",
        "refined_prompt": "Matches any alphanumeric string (a string that contains only English letters and/or digits without spaces).\nMatch examples:\n- \"10a\"\n- \"ABC\"\n- \"A3fg\"\nNon-match examples:\n- \"45.3\"\n- \"this or that\"",
        "matches": [
            "10a",
            "ABC",
            "A3fg",
            "AFDSA",
            "asfsafd",
            "123",
            "123123abcAfds",
            "2398djAD",
            "dsfhoi329",
            "98hsd",
            "NOTREDAME",
            "ILOVEND",
            "notredame46556"
        ],
        "non_matches": [
            "45.3",
            "this or that",
            "$23",
            "...111",
            "2346-2345-2435",
            "3nf@",
            "43-5432",
            "2546dgwre fsdfsd",
            "u09nKLJG FSL",
            "90ndfdfs ,./././ dcf",
            "sdf324 abc...",
            "99999@gmail"
        ],
        "stress_tests": []
    },
    {
        "id": 9,
        "expression": "^\\d+$",
        "raw_prompt": "Positive integer value.",
        "refined_prompt": "Positive integer value.\nMatch examples:\n- \"123\"\n- \"10\"\n- \"54\"\nNon-match examples:\n- \"-54\"\n- \"54.234\"",
        "matches": [
            "123",
            "10",
            "54",
            "39",
            "583",
            "395",
            "2394",
            "2394854",
            "384",
            "324",
            "222",
            "1",
            "2",
            "39",
            "583",
            "395",
            "2394",
            "2394854",
            "384",
            "324",
            "222",
            "1",
            "2"
        ],
        "non_matches": [
            "-54",
            "54.234",
            "abc",
            "-123",
            "9ijn",
            "qwer",
            "-312",
            "1.1",
            "1.1.1",
            "1-1-2",
            "34.31",
            "8h98009hu",
            "-123",
            "9ijn",
            "qwer",
            "-312",
            "1.1",
            "1.1.1",
            "1-1-2",
            "34.31",
            "8h98009hu"
        ],
        "stress_tests": []
    },
    {
        "id": 10,
        "expression": "^(\\+|-)?\\d+$",
        "raw_prompt": "Matches any signed integer.",
        "refined_prompt": "Matches any signed integer, in other words, a string that can start with an optional plus (+) or minus (-) sign, followed by one or more digits.\nMatch examples:\n- \"-34\"\n- \"34\"\n- \"+5\"\nNon-match examples:\n- \"abc\"\n- \"3.1415\"",
        "matches": [
            "-34",
            "34",
            "+5",
            "809",
            "790987",
            "+5483920",
            "-2354",
            "+540893",
            "-234",
            "2349",
            "5094",
            "234234",
            "+123"
        ],
        "non_matches": [
            "abc",
            "3.1415",
            "-5.3",
            "0bu9",
            "234dc",
            "312ccc",
            "123u98b",
            "1.2",
            "-2.3",
            "4.5",
            "+4.5",
            "-99.99"
        ],
        "stress_tests": []
    },
    {
        "id": 11,
        "expression": "^[a-zA-Z]\\w{3,14}$",
        "raw_prompt": "The password's first character must be a letter, it must contain at least 4 characters and no more than 15 characters and no characters other than letters, numbers and the underscore may be used",
        "refined_prompt": "The password's first character must be a letter, it must contain at least 4 characters and no more than 15 characters and no characters other than letters, numbers and the underscore may be used.\nMatch examples:\n- \"abcd\"\n- \"aBc45DSD_sdf\"\n- \"password\"\nNon-match examples:\n- \"afv\"\n- \"1234\"",
        "matches": [
            "abcd",
            "aBc45DSD_sdf",
            "password",
            "F3fsdsdf_234",
            "F0392",
            "fd02934",
            "k2039",
            "ABC09314",
            "abc_ABC",
            "NOTREDAME",
            "fadghui",
            "QWERTY",
            "p0p0p0"
        ],
        "non_matches": [
            "afv",
            "1234",
            "reallylongpassword",
            "1",
            "234",
            "ab",
            "123312312",
            "98iojk",
            "9ijk",
            "98hsdf",
            "longlonglonglonglong",
            "hello12345hello12345"
        ],
        "stress_tests": []
    },
    {
        "id": 12,
        "expression": "^\\w+@[a-zA-Z_]+?\\.[a-zA-Z]{2,3}$",
        "raw_prompt": "Simple email expression. Doesn't allow numbers in the domain name and doesn't allow for top level domains that are less than 2 or more than 3 letters (which is fine until they allow more). Doesn't handle multiple &quot;.&quot; in the domain (joe@abc.co.uk).",
        "refined_prompt": "Checks if an email address starts with one or more alphanumeric characters, followed by the \"@\" symbol, a domain name with letters or underscores, a dot, and finally a domain extension with two or three letters.\nMatch examples:\n- \"joe@aol.com\"\n- \"ssmith@aspalliance.com\"\n- \"a@b.cc\"\nNon-match examples:\n- \"joe@123aspx.com\"\n- \"joe@web.info\"",
        "matches": [
            "joe@aol.com",
            "ssmith@aspalliance.com",
            "a@b.cc",
            "apple@qq.com",
            "123@qq.com",
            "abc@abc.com",
            "ab@ab.ab",
            "bc@bc.bc",
            "avpl@qq.cn",
            "sustech@nd.com",
            "msft@nd.us",
            "notredame@nd.edu"
        ],
        "non_matches": [
            "joe@123aspx.com",
            "joe@web.info",
            "joe@company.co.uk",
            "234dsf@032ijsd.fasdf.sdf",
            "fads@sdaf@asdf",
            "89ioj@9ijosf",
            "abc@abc",
            "a@a.a.a",
            "qwerty@123.123",
            "123@sustech.edu.cn",
            "apple@banana",
            "test@test.test"
        ],
        "stress_tests": []
    },
    {
        "id": 13,
        "expression": "^\\d{1,2}\\/\\d{1,2}\\/\\d{4}$",
        "raw_prompt": "This regular expressions matches dates of the form XX/XX/YYYY where XX can be 1 or 2 digits long and YYYY is always 4 digits long.",
        "refined_prompt": "This regular expressions matches dates of the form XX/XX/YYYY where XX can be 1 or 2 digits long and YYYY is always 4 digits long.\nMatch examples:\n- \"4/1/2001\"\n- \"12/12/2001\"\n- \"55/5/3434\"\nNon-match examples:\n- \"1/1/01\"\n- \"12 Jan 01\"",
        "matches": [
            "4/1/2001",
            "12/12/2001",
            "55/5/3434",
            "1/1/1111",
            "2/2/2222",
            "23/3/3333",
            "11/11/1111",
            "1/1/1111",
            "30/30/3030",
            "55/5/5555",
            "5/55/5678",
            "12/12/1221",
            "55/44/4321"
        ],
        "non_matches": [
            "1/1/01",
            "12 Jan 01",
            "1-1-2001",
            "1/1/1",
            "2/2/22",
            "3/3/333",
            "5/5/55555",
            "44/444/4",
            "Oct 7 2002",
            "1007",
            "qwerty",
            "2020/2/2"
        ],
        "stress_tests": []
    },
    {
        "id": 15,
        "expression": "^[1-5]$",
        "raw_prompt": "This matches a single numeric digit between 1 and 5, and is the same as saying ^[12345]$.",
        "refined_prompt": "Matches a single digit between 1 and 5, inclusive. It will only match a single character that is exactly one of the digits 1, 2, 3, 4, or 5, and is the same as saying ^[12345]$.\nMatch examples:\n- \"1\"\n- \"3\"\n- \"4\"\nNon-match examples:\n- \"6\"\n- \"23\"",
        "matches": [
            "1",
            "3",
            "4",
            "2",
            "5"
        ],
        "non_matches": [
            "6",
            "23",
            "a",
            "12",
            "243",
            "562",
            "f324",
            "fvd",
            "-2",
            "7",
            "-1",
            "000"
        ],
        "stress_tests": []
    },
    {
        "id": 16,
        "expression": "^[12345]$",
        "raw_prompt": "This matches a single numeric digit between 1 and 5, and is the same as saying ^[1-5]$.",
        "refined_prompt": "This matches a single numeric digit between 1 and 5, and is the same as saying ^[1-5]$.\nMatch examples:\n- \"1\"\n- \"2\"\n- \"4\"\nNon-match examples:\n- \"6\"\n- \"-1\"",
        "matches": [
            "1",
            "2",
            "4",
            "3",
            "5"
        ],
        "non_matches": [
            "6",
            "-1",
            "abc",
            "-123",
            "234",
            "3nf@",
            "-312",
            "2546dgwre",
            "u09nKLJG FSL",
            "1-1-2",
            "dfg",
            "32542"
        ],
        "stress_tests": []
    },
    {
        "id": 18,
        "expression": "^[2-9]\\d{2}-\\d{3}-\\d{4}$",
        "raw_prompt": "This expression matches a hyphen separated US phone number, of the form ANN-NNN-NNNN, where A is between 2 and 9 and N is between 0 and 9.",
        "refined_prompt": "This expression matches a hyphen separated US phone number, of the form ANN-NNN-NNNN, where A is between 2 and 9 and N is between 0 and 9.\nMatch examples:\n- \"800-555-5555\"\n- \"333-444-5555\"\n- \"212-666-1234\"\nNon-match examples:\n- \"000-000-0000\"\n- \"123-456-7890\"",
        "matches": [
            "800-555-5555",
            "333-444-5555",
            "212-666-1234",
            "444-555-6666",
            "300-000-0000",
            "444-444-4444",
            "678-678-6789",
            "987-987-9876",
            "543-543-5678",
            "794-564-7456",
            "368-654-7568",
            "987-978-4732",
            "655-878-3664"
        ],
        "non_matches": [
            "000-000-0000",
            "123-456-7890",
            "2126661234",
            "549-234-253",
            "235235234",
            "9h09dh9",
            "000-000-0000",
            "111-111-1111",
            "u09nKLJG FSL",
            "adfa2",
            "222-222-22222",
            "123-456-7890"
        ],
        "stress_tests": []
    },
    {
        "id": 19,
        "expression": "^\\d{5}-\\d{4}|\\d{5}|[A-Z]\\d[A-Z] \\d[A-Z]\\d$",
        "raw_prompt": "This expression matches three different formats of postal codes: 5 digit US ZIP code, 5 digit US ZIP code + 4, and 6 digit alphanumeric Canadian Postal Code. The first one must be 5 numeric digits. The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits. The Canadian postal code must be of the form ANA NAN where A is any uppercase alphabetic character and N is a numeric digit from 0 to 9.",
        "refined_prompt": "This expression matches three different formats of postal codes: 5 digit US ZIP code, 5 digit US ZIP code + 4, and 6 digit alphanumeric Canadian Postal Code. The first one must be 5 numeric digits. The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits. The Canadian postal code must be of the form ANA NAN where A is any uppercase alphabetic character and N is a numeric digit from 0 to 9.\nMatch examples:\n- \"44240\"\n- \"44240-5555\"\n- \"G3H 6A3\"\nNon-match examples:\n- \"Ohio\"\n- \"abc\"",
        "matches": [
            "44240",
            "44240-5555",
            "G3H 6A3",
            "40243",
            "58940",
            "32854-1383",
            "73948-1937",
            "48527-4827",
            "49284-3194",
            "48365",
            "F7S 9S9",
            "S7S 7S7",
            "K9K 4J4"
        ],
        "non_matches": [
            "Ohio",
            "abc",
            "g3h6a3",
            "INDIANA",
            "NOTRE DAME",
            "02934-23429",
            "50394-234234",
            "sdfkgj",
            "000-000",
            "092032-234",
            "s8s 8s8",
            "SDFFDS"
        ],
        "stress_tests": []
    },
    {
        "id": 20,
        "expression": "^[a-zA-Z0-9\\-\\.]+\\.(com|org|net|mil|edu|COM|ORG|NET|MIL|EDU)$",
        "raw_prompt": "Domain names:\nThis regular expression tests the validity of a domain or hostname. It will match any valid domain name that does not contain characters which are invalid in URLs, and which ends in .com, .org, .net, .mil, or .edu. You can add additional valid TLDs by appending the | (pipe) character and the desired TLD to the list in the parens.",
        "refined_prompt": "Match strings that start with one or more alphanumeric characters, hyphens, or dots, followed by a dot, and end with either \"com\", \"org\", \"net\", \"mil\", or \"edu\" (case insensitive). This is typically used to validate domain names.\nMatch examples:\n- \"3SquareBand.com\"\n- \"asp.net\"\n- \"army.mil\"\nNon-match examples:\n- \"$SquareBand.com\"\n- \"asp/dot.net\"",
        "matches": [
            "3SquareBand.com",
            "asp.net",
            "army.mil",
            "baidu.com",
            "google.com",
            "sustech.edu",
            "milion.mil",
            "brooklyn.net",
            "apple.com",
            "nd.edu",
            "abc.net",
            "zzz.edu",
            "notredame.com"
        ],
        "non_matches": [
            "$SquareBand.com",
            "asp/dot.net",
            "army.military",
            "adsfsafs.com.qer",
            "9injd23.net.abc",
            "a/b/c.com",
            "nd.education",
            "nd.computer",
            "github.abc",
            "com.edu.github",
            "@#$.com",
            "abcabc.abc"
        ],
        "stress_tests": []
    },
    {
        "id": 25,
        "expression": "^(?=.*\\d).{4,8}$",
        "raw_prompt": "Password expression. Password must be between 4 and 8 digits long and include at least one numeric digit.",
        "refined_prompt": "Password expression. Password must be between 4 and 8 digits long and include at least one numeric digit.\nMatch examples:\n- \"1234\"\n- \"asdf1234\"\n- \"asp123\"\nNon-match examples:\n- \"asdf\"\n- \"asdf12345\"",
        "matches": [
            "1234",
            "asdf1234",
            "asp123",
            "09jio",
            "dfahui09",
            "ifjd9",
            "dsuui6",
            "34jio23",
            "1234567",
            "9jid33",
            "09jc",
            "nonum00",
            "a1b2c3"
        ],
        "non_matches": [
            "asdf",
            "asdf12345",
            "password",
            "oijsdfa000",
            "90jio09iomk",
            "123",
            "999",
            "4digitlong",
            "helloworld",
            "number",
            "abc111def",
            "8a8"
        ],
        "stress_tests": []
    },
    {
        "id": 26,
        "expression": "^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{4,8}$",
        "raw_prompt": "Password matching expression. Password must be at least 4 characters, no more than 8 characters, and must include at least one upper case letter, one lower case letter, and one numeric digit.",
        "refined_prompt": "Password matching expression. Password must be at least 4 characters, no more than 8 characters, and must include at least one upper case letter, one lower case letter, and one numeric digit.\nMatch examples:\n- \"asD1\"\n- \"asDF1234\"\n- \"ASPgo123\"\nNon-match examples:\n- \"asdf\"\n- \"1234\"",
        "matches": [
            "asD1",
            "asDF1234",
            "ASPgo123",
            "Aa1Bb2",
            "sdafAF1",
            "FDS3fs",
            "111AAAa",
            "pokdfsA9",
            "FODISd8",
            "823FDSd",
            "j09FFF",
            "jso00QQ",
            "SD0dsff"
        ],
        "non_matches": [
            "asdf",
            "1234",
            "ASDF12345",
            "oinjoFW",
            "FWOEjinfw908",
            "lkkl0908",
            "AAAAAAA",
            "adfjsfk",
            "88888888",
            "Aa1",
            "BbBbBbBb2222",
            "0j0jweBBBB"
        ],
        "stress_tests": []
    },
    {
        "id": 27,
        "expression": "^(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9])\\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[0-9])$",
        "raw_prompt": "RegExp for validating the format of IP Addresses. This works great with the ASP.NET RegularExpressionValidator server control.",
        "refined_prompt": "Ensures that the string matches a valid IP address format, where each part of the address falls within the range of 0 to 255.\nMatch examples:\n- \"127.0.0.1\"\n- \"255.255.255.0\"\n- \"192.168.0.1\"\nNon-match examples:\n- \"1200.5.4.3\"\n- \"abc.def.ghi.jkl\"",
        "matches": [
            "127.0.0.1",
            "255.255.255.0",
            "192.168.0.1",
            "234.234.234.234",
            "1.1.1.1",
            "195.35.98.3",
            "5.5.5.5",
            "88.88.88.88",
            "38.68.64.123",
            "199.198.197.196",
            "123.124.125.126",
            "135.146.157.168",
            "53.24.34.67"
        ],
        "non_matches": [
            "1200.5.4.3",
            "abc.def.ghi.jkl",
            "255.foo.bar.1",
            "nd.nd.nd.nd",
            "123.456.789",
            "987.988.989",
            "carry",
            "12f3.21f3.213f",
            "9.9.9.9.9",
            "654.654.654",
            "g3.g543.g45",
            "0988.74534.5464"
        ],
        "stress_tests": []
    },
    {
        "id": 29,
        "expression": "\\(([0-9]{2}|0{1}((x|[0-9]){2}[0-9]{2}))\\)\\s*[0-9]{3,4}[- ]*[0-9]{4}",
        "raw_prompt": "Match diferent styles for brazilian Phone number code.\nOnly DDD (12), complete DDD (012), complete DDD + Telephony Company (0xx12) plus 3 or 4 digits (city code) plus 4 digits (phone number).",
        "refined_prompt": "Match different styles for brazilian Phone number code.\r\nOnly DDD (12), complete DDD (012), complete DDD + Telephony Company (0xx12) plus 3 or 4 digits (city code) plus 4 digits (phone number).\nMatch examples:\n- \"(12) 123 1234\"\n- \"(01512) 123 1234\"\n- \"(0xx12) 1234 1234\"\nNon-match examples:\n- \"12 123 1234\"\n- \"(012) 123/1234\"",
        "matches": [
            "(12) 123 1234",
            "(01512) 123 1234",
            "(0xx12) 1234 1234",
            "(12) 324 6532",
            "(12) 624 2534",
            "(12) 653 2753",
            "(01512) 678 9678",
            "(01512) 367 8368",
            "(01512) 836 6583",
            "(0xx12) 8635 8563",
            "(0xx12) 3643 1234",
            "(0xx12) 7256 2345",
            "(0xx12) 7282 6253"
        ],
        "non_matches": [
            "12 123 1234",
            "(012) 123/1234",
            "(012) 123 12345",
            "(12) 324 653210",
            "(12) 32494 6532",
            "(12) 324 645532",
            "(01512) 836 41236583",
            "(01512) 84536 646583",
            "(01512) 836",
            "(0xx12) 7256 2345154",
            "(0xx12) 62509",
            "(0xx12) 093124800"
        ],
        "stress_tests": []
    },
    {
        "id": 31,
        "expression": "^#?([a-f]|[A-F]|[0-9]){3}(([a-f]|[A-F]|[0-9]){3})?$",
        "raw_prompt": "Tests for valid HTML hexadecimal color codes. The # symbol is optional. And it will except either the 3 digit form for the 216 Web safe colors, or the full 6 digit form. I am use it on my site to allow users to customize the site's colors.",
        "refined_prompt": "The pattern ^#?([a-f]|[A-F]|[0-9]){3}(([a-f]|[A-F]|[0-9]){3})?$ represents a hexadecimal color code consisting of either three or six characters, starting with an optional '#' symbol.\nMatch examples:\n- \"#00ccff\"\n- \"#039\"\n- \"ffffcc\"\nNon-match examples:\n- \"blue\"\n- \"0x000000\"",
        "matches": [
            "#00ccff",
            "#039",
            "ffffcc",
            "#fad123",
            "aaa123",
            "#043",
            "ccc111",
            "#bac412",
            "#bbb111",
            "#958",
            "aaa948",
            "bbb841",
            "392abc"
        ],
        "non_matches": [
            "blue",
            "0x000000",
            "#ff000",
            "hjha98",
            "pp0",
            "qre9",
            "qwer9",
            "njf8",
            "qwerty",
            "99999o",
            "abcdef",
            "abcabcabc"
        ],
        "stress_tests": []
    },
    {
        "id": 33,
        "expression": "^[a-zA-Z]{1,2}[0-9][0-9A-Za-z]{0,1} {0,1}[0-9][A-Za-z]{2}$",
        "raw_prompt": "Matches UK postcodes according to the following rules\n1. LN NLL eg N1 1AA\n2. LLN NLL eg SW4 0QL\n3. LNN NLL eg M23 4PJ\n4. LLNN NLL eg WS14 0JT\n5. LLNL NLL eg SW1N 4TB\n6. LNL NLL eg W1C 8LQ\nThanks to Simon Bell for informing me of LNL NLL rule for postcodes which I had omitted in an earlier version.",
        "refined_prompt": "\nMatch examples:\n- \"G1 1AA\"\n- \"EH10 2QQ\"\n- \"SW1 1ZZ\"\nNon-match examples:\n- \"G111 1AA\"\n- \"X10 WW\"",
        "matches": [
            "G1 1AA",
            "EH10 2QQ",
            "SW1 1ZZ"
        ],
        "non_matches": [
            "G111 1AA",
            "X10 WW",
            "DDD 5WW"
        ],
        "stress_tests": []
    },
    {
        "id": 34,
        "expression": "^[\\w\\.=-]+@[\\w\\.-]+\\.[\\w]{2,3}$",
        "raw_prompt": "Much simpler email expression. This one forces a length of 2 or 3, which fits current specs, but you may need to alter the end as this one allows all numerals on the .COM section.",
        "refined_prompt": "Starts with one or more word characters, dots, equal signs, or hyphens.\r\nFollowed by an @ symbol.\r\nFollowed by one or more word characters, dots, hyphens, or dots.\r\nFollowed by a dot (.)\r\nEnds with two or three word characters.\nMatch examples:\n- \"a@a.com\"\n- \"a@a.com.au\"\n- \"a@a.au\"\nNon-match examples:\n- \"word\"\n- \"word@\"",
        "matches": [
            "a@a.com",
            "a@a.com.au",
            "a@a.au",
            "abc@abc.abc",
            "baidu@qq.com",
            "qq@qq.com",
            "abc@ab.cn",
            "hi@nd.edu",
            "nd@edu.us",
            "us@nd.edu",
            "cse@nd.edu",
            "hello@hi.us",
            "abc@msft.org"
        ],
        "non_matches": [
            "word",
            "word@",
            "@word",
            "iasdjf@",
            "@09jafsd",
            "sdaf.FSD",
            "@@fsdfa.fsad",
            "09jfs@osifdj@sdf",
            "dsfl",
            "092j3d",
            "sda sad",
            "@sdaf@sdf123"
        ],
        "stress_tests": []
    },
    {
        "id": 36,
        "expression": "^\\$[0-9]+(\\.[0-9][0-9])?$",
        "raw_prompt": "Validates a dollar amount including a dollar sign and 2 decmals. The decimal and cents are optional.",
        "refined_prompt": "Matches strings that start with a dollar sign, followed by one or more digits, and optionally followed by a dot and exactly two more digits representing the decimal part.\nMatch examples:\n- \"$1.50\"\n- \"$49\"\n- \"$0.50\"\nNon-match examples:\n- \"1.5\"\n- \"$1.333\"",
        "matches": [
            "$1.50",
            "$49",
            "$0.50",
            "$1",
            "$10",
            "$99.99",
            "$1.12",
            "$5.55",
            "$66.66",
            "$100",
            "$88",
            "$68",
            "$50.50"
        ],
        "non_matches": [
            "1.5",
            "$1.333",
            "this $5.12 fails",
            "$4.2",
            "234.634",
            "$23.454",
            "$3.2",
            "66.66",
            "#32.34",
            "$.23",
            "$345.605",
            "\u00a5423.34"
        ],
        "stress_tests": []
    },
    {
        "id": 37,
        "expression": "\\b(([01]?\\d?\\d|2[0-4]\\d|25[0-5])\\.){3}([01]?\\d?\\d|2[0-4]\\d|25[0-5])\\b",
        "raw_prompt": "Most Concise RegExp for matching Decimal IPs. If nothing else, it'll make your code easier to read. (And I know that \\d?\\d is \\d{1,2} but that's 2 extra characters.)\n--Update: darkone noticed 8 characters could be shaved down. I've edited it to reflect this. Thanks, darkone!",
        "refined_prompt": "Matches a valid decimal IP address with four segments, where each segment ranges from 0 to 255, separated by dots.\nMatch examples:\n- \"217.6.9.89\"\n- \"0.0.0.0\"\n- \"255.255.255.255\"\nNon-match examples:\n- \"256.0.0.0\"\n- \"0978.3.3.3\"",
        "matches": [
            "217.6.9.89",
            "0.0.0.0",
            "255.255.255.255",
            "32.31.31.41",
            "251.23.53.6",
            "2.4.5.2",
            "52.54.83.127",
            "185.27.64.83",
            "245.75.61.176",
            "135.163.167.143",
            "43.6.1.3",
            "5.8.3.6",
            "2.5.8.9"
        ],
        "non_matches": [
            "256.0.0.0",
            "0978.3.3.3",
            "65.4t.54.3",
            "524.15.134.3",
            "654.22.72.566",
            "256.25.345.3",
            "22.44.66.1111",
            "44.44.44.44.44",
            "67.84.25.644",
            "145.634.462.43",
            "4512.2436.246.43",
            "6243.2463.34.34"
        ],
        "stress_tests": []
    },
    {
        "id": 41,
        "expression": "^([\\w\\d\\-\\.]+)@{1}(([\\w\\d\\-]{1,67})|([\\w\\d\\-]+\\.[\\w\\d\\-]{1,67}))\\.(([a-zA-Z\\d]{2,4})(\\.[a-zA-Z\\d]{2})?)$",
        "raw_prompt": "This pattern allows standard e-mail addresses (e.g. user@domain.com), sub domains (e.g. user@foo.domain.com), the new two- and four-letter domains (e.g. user@domain.tv and user@domain.name) and country codes (e.g. user@foo.com.us). Also, this patter follows the Network Solutions standard length of 67 characters for top-level domains. The reason I allow numbers to be entered in the domain suffix is for future planning. If you do not want numbers to be able to be added as a domain suffix (e.g. user@domain.123), simply delete the last two occurrences of &quot;\\d&quot;.",
        "refined_prompt": "This pattern allows standard e-mail addresses (e.g. user@domain.com), sub domains (e.g. user@foo.domain.com), the new two- and four-letter domains (e.g. user@domain.tv and user@domain.name) and country codes (e.g. user@foo.com.us). Also, this patter follows the Network Solutions standard length of 67 characters for top-level domains.\nMatch examples:\n- \"foo@foo.com\"\n- \"foo@foo-foo.com.au\"\n- \"foo@foo.foo.info\"\nNon-match examples:\n- \"foo@.com\"\n- \"foo@foo..com\"",
        "matches": [
            "foo@foo.com",
            "foo@foo-foo.com.au",
            "foo@foo.foo.info",
            "abc@abc.com",
            "fds@gad-agd.com.us",
            "bds@bfv.foo.info",
            "def@def.com",
            "foo@org-foo.org.au",
            "bop@foo.qre.info",
            "asd@fsa.com",
            "gad@afd.ghe.au",
            "hcs@bfq.foo.info",
            "gas@dfs-erw.org.au"
        ],
        "non_matches": [
            "foo@.com",
            "foo@foo..com",
            "foo@me@.com",
            "fasd@fds.fasd@",
            "fa0efj3@fs.FSDFr32@",
            "vsdfaslk..adsaf",
            "cfa@oifsd",
            "@R#@@#RDS",
            "fdssdf@FSD.fweoijF@",
            "fdsa.@FDS.@FD",
            "fdsf@@@fsdf",
            "gsfdoji@FDS"
        ],
        "stress_tests": []
    },
    {
        "id": 42,
        "expression": "^[0-9]+$",
        "raw_prompt": "Validate a string to see if it contains a number / integer",
        "refined_prompt": "Matches strings that consist entirely of one or more digits (0-9).\nMatch examples:\n- \"1234567890\"\n- \"4123109\"\n- \"53421\"\nNon-match examples:\n- \"f423\"\n- \"f34fvfv\"",
        "matches": [
            "1234567890",
            "4123109",
            "53421",
            "512345",
            "123451",
            "5123543",
            "12356",
            "9",
            "65409",
            "34905",
            "5436",
            "65409",
            "245309"
        ],
        "non_matches": [
            "f423",
            "f34fvfv",
            "34f2vf42e",
            "234.f23v425",
            "f2v3r",
            "f23r2",
            "2fre2",
            "vfre2fvre",
            "fer222r3",
            "erfv2",
            "2fe2vf",
            "2efr245"
        ],
        "stress_tests": []
    },
    {
        "id": 44,
        "expression": "^((4\\d{3})|(5[1-5]\\d{2})|(6011))-?\\d{4}-?\\d{4}-?\\d{4}|3[4,7]\\d{13}$",
        "raw_prompt": "Matches major credit cards including:\nVisa (length 16, prefix 4), Mastercard (length 16, prefix 51-55), Discover (length 16, prefix 6011), American Express (length 15, prefix 34 or 37). All 16 digit formats accept optional hyphens (-) between each group of four digits.",
        "refined_prompt": "Matches major credit cards including:\r\nVisa (length 16, prefix 4), Mastercard (length 16, prefix 51-55), Discover (length 16, prefix 6011), American Express (length 15, prefix 34 or 37). All 16 digit formats accept optional hyphens (-) between each group of four digits.\nMatch examples:\n- \"6011-1111-1111-1111\"\n- \"5423-1111-1111-1111\"\n- \"341111111111111\"\nNon-match examples:\n- \"4111-111-111-111\"\n- \"3411-1111-1111-111\"",
        "matches": [
            "6011-1111-1111-1111",
            "5423-1111-1111-1111",
            "341111111111111",
            "4032-2532-3424-6424",
            "6011-3453-5135-6542",
            "5423-5134-7541-751411",
            "341111492857111",
            "4032-5143-3424-7536",
            "6011-5437-1111-4265",
            "5423-3757-7335-7141",
            "341111521111593",
            "4032-7134-1643-5354",
            "6011-4326-1111-7452"
        ],
        "non_matches": [
            "4111-111-111-111",
            "3411-1111-1111-111",
            "Visa",
            "Mastercard",
            "134123409584391084032",
            "Chase",
            "512309842312345123",
            "543-5431-15234-51234",
            "Discover",
            "532151324234",
            "15235",
            "Match"
        ],
        "stress_tests": []
    },
    {
        "id": 45,
        "expression": "^.{4,8}$",
        "raw_prompt": "Matches any string between 4 and 8 characters in length. Limits the length of a string. Useful to add to password regular expressions.",
        "refined_prompt": "Matches any string between 4 and 8 characters in length. Limits the length of a string.\nMatch examples:\n- \"asdf\"\n- \"1234\"\n- \"asdf1234\"\nNon-match examples:\n- \"asd\"\n- \"123\"",
        "matches": [
            "asdf",
            "1234",
            "asdf1234",
            "adsji",
            "gj0q3",
            "f234f24",
            "2f43f",
            "432g2g",
            "g324",
            "g342g432",
            "g43g23y",
            "u7jj74",
            "j746t"
        ],
        "non_matches": [
            "asd",
            "123",
            "asdfe12345",
            "09u4ff2n3094",
            "23t4v90m2",
            "34",
            "2",
            "v",
            "2b3t2tb43",
            "t24b32tv43",
            "nu5624t3v",
            "j2v"
        ],
        "stress_tests": []
    },
    {
        "id": 46,
        "expression": "^\\d*$",
        "raw_prompt": "Accepts an unsigned integer number. Also matches empty strings.",
        "refined_prompt": "Accepts an unsigned integer number. Also matches empty strings.\nMatch examples:\n- \"123\"\n- \"000\"\n- \"43\"\nNon-match examples:\n- \"asbc\"\n- \"-34\"",
        "matches": [
            "123",
            "000",
            "43",
            "435",
            "513",
            "651",
            "3416",
            "16",
            "6143",
            "643",
            "76",
            "876",
            "34"
        ],
        "non_matches": [
            "asbc",
            "-34",
            "3.1415",
            "f443",
            "2f43",
            "3.3",
            "-1",
            "25v3",
            "3425-13",
            "4352-5243254.",
            "gwerb",
            "32vt"
        ],
        "stress_tests": []
    },
    {
        "id": 47,
        "expression": "^[-+]?\\d*$",
        "raw_prompt": "Matches any integer number or numeric string, including positive and negative value characters (+ or -). Also matches empty strings.",
        "refined_prompt": "Matches any integer number or numeric string, including positive and negative value characters (+ or -). Also matches empty strings.\nMatch examples:\n- \"123\"\n- \"-123\"\n- \"+123\"\nNon-match examples:\n- \"abc\"\n- \"3.14159\"",
        "matches": [
            "123",
            "-123",
            "+123",
            "34091511",
            "+54",
            "-12314",
            "5134514",
            "-5243",
            "+4145",
            "35134",
            "-543",
            "+65",
            "5134513"
        ],
        "non_matches": [
            "abc",
            "3.14159",
            "-3.14159",
            "543.435",
            "432v",
            "43.v234",
            "1-1-1",
            "2v345234v",
            "22-423",
            "435.vwre-34",
            "44-6234",
            "+24-234.345"
        ],
        "stress_tests": []
    },
    {
        "id": 48,
        "expression": "^\\d*\\.?\\d*$",
        "raw_prompt": "Matches any unsigned floating point number/numeric string. Also matches empty strings.",
        "refined_prompt": "Matches any unsigned floating point number/numeric string. Also matches empty strings.\nMatch examples:\n- \"123\"\n- \"3.14159\"\n- \".234\"\nNon-match examples:\n- \"abc\"\n- \"-3.14159\"",
        "matches": [
            "123",
            "3.14159",
            ".234",
            "354.5342",
            "654.435",
            "6254.2345",
            "543",
            "2345",
            "3465",
            "7542",
            "6254.4526",
            "742",
            "7225464526"
        ],
        "non_matches": [
            "abc",
            "-3.14159",
            "3.4.2",
            "b5242g",
            "f45.2g",
            "b254yb54.254yb",
            "2y45.y245",
            "254627g.256",
            "-2.22",
            "3g54",
            "-652.63264",
            "3yb43yb5"
        ],
        "stress_tests": []
    },
    {
        "id": 49,
        "expression": "^[-+]?\\d*\\.?\\d*$",
        "raw_prompt": "Matches any floating point numer/numeric string, including optional sign character (+ or -). Also matches empty strings.",
        "refined_prompt": "Matches any floating point number/numeric string, including optional sign character (+ or -). Also matches empty strings.\nMatch examples:\n- \"123\"\n- \"+3.14159\"\n- \"-3.14159\"\nNon-match examples:\n- \"abc\"\n- \"3.4.5\"",
        "matches": [
            "123",
            "+3.14159",
            "-3.14159",
            "41325",
            "5435",
            "1534",
            "634",
            "+2435.2543",
            "+645.265",
            "-265.667",
            "-65.532",
            "-89.53",
            "-1.1"
        ],
        "non_matches": [
            "abc",
            "3.4.5",
            "$99.95",
            "5.4.352.5431",
            "5145134.5143",
            "@R$#@FDS",
            "*(URW(",
            "2345.341v1v",
            "415.11534vvv",
            "341.431v4f3.fv1",
            "314v.341v",
            "ccc.ccc"
        ],
        "stress_tests": []
    },
    {
        "id": 53,
        "expression": "^([0-9]( |-)?)?(\\(?[0-9]{3}\\)?|[0-9]{3})( |-)?([0-9]{3}( |-)?[0-9]{4}|[a-zA-Z0-9]{7})$",
        "raw_prompt": "Matches US phone number format. 1 in the beginning is optional, area code is required, spaces or dashes can be used as optional divider between number groups. Also alphanumeric format is allowed after area code.",
        "refined_prompt": "Matches US phone number format. 1 in the beginning is optional, area code is required, spaces or dashes can be used as optional divider between number groups. Also alphanumeric format is allowed after area code.\nMatch examples:\n- \"1-(123)-123-1234\"\n- \"123 123 1234\"\n- \"1-800-ALPHNUM\"\nNon-match examples:\n- \"1.123.123.1234\"\n- \"(123)-1234-123\"",
        "matches": [
            "1-(123)-123-1234",
            "123 123 1234",
            "1-800-ALPHNUM",
            "258 426 6254",
            "1-(531)-123-5435",
            "258 426 5131",
            "1-(123)-754-7517",
            "1-846-ALPHNUM",
            "653 426 5431",
            "1-(866)-123-8648",
            "1-653-ALPHNUM",
            "534 643 6254",
            "258 426 7635"
        ],
        "non_matches": [
            "1.123.123.1234",
            "(123)-1234-123",
            "123-1234",
            "546",
            "1324.1541",
            "f234f23",
            "56",
            "4562452642562456",
            "541543.415",
            "4325265426624",
            "654",
            "4351.1345"
        ],
        "stress_tests": []
    },
    {
        "id": 54,
        "expression": "^([0-1][0-9]|[2][0-3]):([0-5][0-9])$",
        "raw_prompt": "Matches a string if it is a valid time in the format of HH:MM",
        "refined_prompt": "Matches a string if it is a valid time in the format of HH:MM\nMatch examples:\n- \"02:04\"\n- \"16:56\"\n- \"23:59\"\nNon-match examples:\n- \"02:00 PM\"\n- \"PM2:00\"",
        "matches": [
            "02:04",
            "16:56",
            "23:59",
            "15:42",
            "15:34",
            "16:43",
            "06:54",
            "05:25",
            "05:23",
            "07:52",
            "06:24",
            "03:53",
            "03:27"
        ],
        "non_matches": [
            "02:00 PM",
            "PM2:00",
            "24:00",
            "71:543t4",
            "51:534",
            "75:62",
            "86:75",
            "48:345",
            "57:73",
            "2am",
            "4pm",
            "253@#RFE"
        ],
        "stress_tests": []
    },
    {
        "id": 55,
        "expression": "^[0,1]?\\d{1}\\/(([0-2]?\\d{1})|([3][0,1]{1}))\\/(([1]{1}[9]{1}[9]{1}\\d{1})|([2-9]{1}\\d{3}))$",
        "raw_prompt": "This expression checks the validity of a date (US, but it is easily editable for other format's). Year's 1990-9999, Month's 1 or 01 to 12, Day's 1 or 01 to 31. Still needs to have individual months added (i.e., Feb's 28 days), and some how to check for leap year...the months issue should not be to hard, but the leap year seems like a real chore. Please let me know if you have any suggestions for leap year.",
        "refined_prompt": "\nMatch examples:\n- \"01/01/1990\"\n- \"12/12/9999\"\n- \"3/28/2001\"\nNon-match examples:\n- \"3-8-01\"\n- \"13/32/1001\"",
        "matches": [
            "01/01/1990",
            "12/12/9999",
            "3/28/2001"
        ],
        "non_matches": [
            "3-8-01",
            "13/32/1001",
            "03/32/1989"
        ],
        "stress_tests": []
    },
    {
        "id": 57,
        "expression": "^\\s*[a-zA-Z,\\s]+\\s*$",
        "raw_prompt": "Any Expression Upper/Lower Case, with commas and space between the text, with any amount of space before or after",
        "refined_prompt": "Match strings that consist of alphabetic characters (both lowercase and uppercase) and commas, allowing for leading and trailing whitespace.\nMatch examples:\n- \"Smith, Ed\"\n- \"Ed Smith\"\n- \"aBcDeFgH\"\nNon-match examples:\n- \"a123\"\n- \"AB5\"",
        "matches": [
            "Smith, Ed",
            "Ed Smith",
            "aBcDeFgH",
            "Michael afds",
            "fnsdkajf",
            "Hello world",
            "asdfafds adsf",
            "afdsffda asddas",
            "fads, asdf",
            "sda, fasf",
            "EFDSF, FSD",
            "fasdf, FDS",
            "FDSfdso JDSF"
        ],
        "non_matches": [
            "a123",
            "AB5",
            "Mr. Ed",
            "vqvq.ecqw",
            "cqrewcr/qtv",
            "fqsdv$vw",
            "@#dfkjnav",
            "2546dgwre",
            "u09nKLJG FSL",
            "1-1-2",
            "34.31",
            "32542"
        ],
        "stress_tests": []
    },
    {
        "id": 64,
        "expression": "^(([1-9])|(0[1-9])|(1[0-2]))\\/((0[1-9])|([1-31]))\\/((\\d{2})|(\\d{4}))$",
        "raw_prompt": "Matches U.S. dates with leading zeros and without and with 2 or four digit years",
        "refined_prompt": "Match strings representing U.S. dates in the month/day/year or month/day/yy format. It validates the month to be between 1 and 12, the day to be between 1 and 31, and the year to be either two or four digits.\nMatch examples:\n- \"01/01/2001\"\n- \"1/1/2001\"\n- \"01/1/01\"\nNon-match examples:\n- \"13/01/2001\"\n- \"1/2/100\"",
        "matches": [
            "01/01/2001",
            "1/1/2001",
            "01/1/01",
            "1/1/1111",
            "2/2/2222",
            "3/3/3333",
            "04/04/2004",
            "05/04/2345",
            "10/10/1010",
            "11/11/1111",
            "12/12/1212",
            "12/11/2000",
            "04/05/06"
        ],
        "non_matches": [
            "13/01/2001",
            "1/2/100",
            "09/32/2001",
            "02/67/5205",
            "25/642/42645",
            "462/246/75",
            "7457/245/245",
            "26/2542/642",
            "245/524/12",
            "1/1/1",
            "534/61/165",
            "1354/67531/1345"
        ],
        "stress_tests": []
    },
    {
        "id": 65,
        "expression": "^\\$?([0-9]{1,3},([0-9]{3},)*[0-9]{3}|[0-9]+)(.[0-9][0-9])?$",
        "raw_prompt": "Matches currency input with or without commas.",
        "refined_prompt": "Match strings representing monetary values in the format of dollars and cents. It allows for optional dollar signs, handles numbers with or without commas, and allows for an optional decimal portion with exactly two digits.\nMatch examples:\n- \"$3,023,123.34\"\n- \"9,876,453\"\n- \"123456.78\"\nNon-match examples:\n- \"4,33,234.34\"\n- \"$1.234\"",
        "matches": [
            "$3,023,123.34",
            "9,876,453",
            "123456.78",
            "345.532",
            "54235.7542",
            "6254.7653",
            "27454.274",
            "6254",
            "$423.542",
            "$5234.52452",
            "$6452",
            "6547",
            "2654"
        ],
        "non_matches": [
            "4,33,234.34",
            "$1.234",
            "abc",
            "dafs",
            "-234",
            "\u00a5423",
            "\u00a55243.652",
            "%jfkdl",
            "#2432",
            "%flksfa",
            "$$skljdf",
            "$23423$"
        ],
        "stress_tests": []
    },
    {
        "id": 66,
        "expression": "((\\d{2})|(\\d))\\/((\\d{2})|(\\d))\\/((\\d{4})|(\\d{2}))",
        "raw_prompt": "This matches simple dates against 1 or 2 digits for the month, 1 or 2 digit for the day, and either 2 or 4 digits for the year",
        "refined_prompt": "Match strings representing dates in the format of MM/DD/YYYY or M/D/YY. It allows for both two-digit and single-digit representations of the month, day, and year components, accommodating for leading zeros where applicable.\nMatch examples:\n- \"4/5/91\"\n- \"04/5/1991\"\n- \"4/05/89\"\nNon-match examples:\n- \"4/5/1\"\n- \"52/2/54/245\"",
        "matches": [
            "4/5/91",
            "04/5/1991",
            "4/05/89",
            "1/1/11",
            "1/1/2002",
            "12/12/1202",
            "11/23/2030",
            "06/09/2012",
            "7/5/32",
            "6/5/23",
            "5/6/20",
            "3/5/21",
            "7/7/22"
        ],
        "non_matches": [
            "4/5/1",
            "52/2/54/245",
            "2534/52435234/2453",
            "25/2/2/2",
            "111/111/111",
            "1234/56341/152",
            "2315/541",
            "213/51235",
            "123564/134613/1643",
            "31/35/64539",
            "613/6341/5141",
            "152/6341/435"
        ],
        "stress_tests": []
    },
    {
        "id": 67,
        "expression": "^(\\(?\\+?[0-9]*\\)?)?[0-9_\\- \\(\\)]*$",
        "raw_prompt": "A regular expression to match phone numbers, allowing for an international dialing code at the start and hyphenation and spaces that are sometimes entered.",
        "refined_prompt": "Match strings representing phone numbers. It allows for an optional country code, which can be enclosed in parentheses and prefixed with a plus sign. The main content of the phone number can consist of digits, underscores, hyphens, spaces, and parentheses.\nMatch examples:\n- \"(+44)(0)20-12341234\"\n- \"02012341234\"\n- \"+44 (0) 1234-1234\"\nNon-match examples:\n- \"(44+)020-12341234\"\n- \"12341234(+020)\"",
        "matches": [
            "(+44)(0)20-12341234",
            "02012341234",
            "+44 (0) 1234-1234",
            "(+44)(0)20-58404831",
            "(+48)(0)20-59420618",
            "(+69)(0)20-54830618",
            "02059301759",
            "02019684729",
            "02068295839",
            "+44 (0) 1045-1234",
            "+89 (0) 1234-5143",
            "+48 (0) 6316-1234",
            "+68 (0) 1234-0851"
        ],
        "non_matches": [
            "(44+)020-12341234",
            "12341234(+020)",
            "90438502+9503",
            "542090()839045",
            "25498(543)98453-",
            "(543908)04395+0954-",
            "25498-305+",
            "54398IONF",
            "3458=+759304",
            "3495u0()",
            "432,543,345",
            "6234,523+5234"
        ],
        "stress_tests": []
    },
    {
        "id": 68,
        "expression": "^\\d{5}(-\\d{4})?$",
        "raw_prompt": "Matches standard 5 digit US Zip Codes, or the US ZIP + 4 Standard.",
        "refined_prompt": "Matches standard 5 digit US Zip Codes, or the US ZIP + 4 Standard.\nMatch examples:\n- \"48222\"\n- \"48222-1746\"\n- \"51314\"\nNon-match examples:\n- \"4632\"\n- \"Blake\"",
        "matches": [
            "48222",
            "48222-1746",
            "51314",
            "61341",
            "64316",
            "43534",
            "46556",
            "54315-1634",
            "64316-1643",
            "74567-2456",
            "26543-2664",
            "27563",
            "57422"
        ],
        "non_matches": [
            "4632",
            "Blake",
            "37333-32",
            "4235",
            "543161435",
            "1543543",
            "15436131",
            "1534513",
            "4351-345151",
            "13451534-514351",
            "3415-34564",
            "3461-436643"
        ],
        "stress_tests": []
    },
    {
        "id": 69,
        "expression": "(^\\+[0-9]{2}|^\\+[0-9]{2}\\(0\\)|^\\(\\+[0-9]{2}\\)\\(0\\)|^00[0-9]{2}|^0)([0-9]{9}$|[0-9\\-\\s]{10}$)",
        "raw_prompt": "Regular expression to evaluate dutch-style phone numbers. Possible example prefixes: +31, +31(0), (+31)(0), 0, 0031\nfollowed by 9 numbers (which can contain a space or -).",
        "refined_prompt": "Match strings representing Dutch-style phone numbers. It allows for an optional country code, with various formats accepted. Possible example prefixes: +31, +31(0), (+31)(0), 0, 0031\r\nfollowed by 9 numbers (which can contain a space or -). The main content of the phone number can consist of nine or ten digits, with optional hyphens or spaces in the ten-digit format.\nMatch examples:\n- \"+31235256677\"\n- \"+31(0)235256677\"\n- \"023-5256677\"\nNon-match examples:\n- \"+3123525667788999\"\n- \"3123525667788\"",
        "matches": [
            "+31235256677",
            "+31(0)235256677",
            "023-5256677",
            "+31235248394",
            "+31235256839",
            "+31(0)235256839",
            "+31(0)267395867",
            "+31(0)235259495",
            "+31(0)573956677",
            "023-5255729",
            "023-5268277",
            "023-5583757",
            "023-5839583"
        ],
        "non_matches": [
            "+3123525667788999",
            "3123525667788",
            "232-2566778",
            "09827509480193284014",
            "9845092820459524-2435234",
            "2435-435",
            "2345-652",
            "23fu490n",
            "243.2543",
            "+354+534",
            "5334.435",
            "++63453.345"
        ],
        "stress_tests": []
    },
    {
        "id": 72,
        "expression": "\\b(\\w+)\\s+\\1\\b",
        "raw_prompt": "Uses backreferences and word boundaries to match repeated words seperated by whitespace without matching a word with the same ending as the next words beginning.",
        "refined_prompt": "Match repeated consecutive words. It looks for a word, followed by one or more whitespace characters, and then the same word again. The word boundaries ensure that the pattern matches complete words and not just partial matches within larger words.\nMatch examples:\n- \"Tell the the preacher\"\n- \"some some\"\n- \"hubba hubba\"\nNon-match examples:\n- \"once an annual report\"\n- \"mandate dated submissions\"",
        "matches": [
            "Tell the the preacher",
            "some some",
            "hubba hubba",
            "abc abc",
            "hello hello afsd",
            "adf qwer qwer",
            "abcd abcd efads",
            "poe poe werf",
            "fdsi fdsi qrew",
            "hello hi hi",
            "ha ha hao",
            "cool cool great",
            "apple pen pen"
        ],
        "non_matches": [
            "once an annual report",
            "mandate dated submissions",
            "Hubba hubba",
            "once upon",
            "a time",
            "there is a boy",
            "notre dame",
            "university hello",
            "literal basic",
            "asdf asdf ai0qroew ads",
            "adsfqij hquiwe fads",
            "fadsijb reiqjwna"
        ],
        "stress_tests": []
    },
    {
        "id": 73,
        "expression": "^\\d{9}[\\d|X]$",
        "raw_prompt": "A very simple ISBN validation expression - it just checks for a 10 digit number where the last digit could also be a capital 'X'. Complete specs for ISBN available here:\nhttp://www.isbn.org/standards/home/isbn/international/html/usm4.htm. An enhancement would be to allow exactly 3 or 0 hyphens or 3 or 0 spaces, since these are also valid formats.",
        "refined_prompt": "Checks for a 10 digit number where the last digit could also be a capital 'X'.\nMatch examples:\n- \"1234123412\"\n- \"123412341X\"\n- \"4738195735\"\nNon-match examples:\n- \"not an isbn\"\n- \"54390853\"",
        "matches": [
            "1234123412",
            "123412341X",
            "4738195735",
            "4582943285",
            "5284574935",
            "5243524396",
            "5930285928",
            "5534098534",
            "620598320X",
            "534809534X",
            "123141414X",
            "432423432X",
            "502498905X"
        ],
        "non_matches": [
            "not an isbn",
            "54390853",
            "53495083409x",
            "452093xx",
            "534985309XX",
            "24309X",
            "098423098029840293",
            "4029384230980980X",
            "9vu82i3nuif",
            "423890jidofs",
            "2398ufsd",
            "893420980)U(X"
        ],
        "stress_tests": []
    },
    {
        "id": 74,
        "expression": "^(([1-9])|(0[1-9])|(1[0-2]))\\/(([0-9])|([0-2][0-9])|(3[0-1]))\\/(([0-9][0-9])|([1-2][0,9][0-9][0-9]))$",
        "raw_prompt": "Dates\nday: d or dd, &lt;= 31,\nmonth: m or mm, &lt;= 12,\nyear: yy or yyyy &gt;= 1900, &lt;= 2099",
        "refined_prompt": "The regular expression represents a date format where the day, month, and year are separated by forward slashes (/), and the allowed ranges for each component are:\r\nday (d or dd): from 1 to 31\r\nmonth (m or mm): from 1 to 12\r\nyear (yy or yyyy): from 1900 to 2099\nMatch examples:\n- \"01/01/2001\"\n- \"1/1/1999\"\n- \"10/20/2080\"\nNon-match examples:\n- \"13/01/2001\"\n- \"1/1/1800\"",
        "matches": [
            "01/01/2001",
            "1/1/1999",
            "10/20/2080",
            "1/1/2000",
            "2/2/2022",
            "10/10/2020",
            "12/12/2012",
            "7/30/2020",
            "4/29/2008",
            "4/5/2034",
            "7/04/2043",
            "05/5/2005",
            "6/06/2006",
            "1/1/2000",
            "2/2/2022",
            "10/10/2020",
            "12/12/2012",
            "7/30/2020",
            "4/29/2008",
            "4/5/2034",
            "7/04/2043",
            "05/5/2005",
            "6/06/2006",
            "1/1/2000",
            "2/2/2022",
            "10/10/2020",
            "12/12/2012",
            "7/30/2020",
            "4/29/2008",
            "4/5/2034",
            "7/04/2043",
            "05/5/2005",
            "6/06/2006"
        ],
        "non_matches": [
            "13/01/2001",
            "1/1/1800",
            "10/32/2080",
            "12/123/4322",
            "234/423/5243",
            "2/3/5235",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "9/9/9",
            "12/132/90",
            "12/123/4322",
            "234/423/5243",
            "2/3/5235",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "9/9/9",
            "12/132/90",
            "12/123/4322",
            "234/423/5243",
            "2/3/5235",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "9/9/9",
            "12/132/90"
        ],
        "stress_tests": []
    },
    {
        "id": 75,
        "expression": "^\\d*\\.?((25)|(50)|(5)|(75)|(0)|(00))?$",
        "raw_prompt": "This is a pattern to search and verify that a decimal number ends with a 25, 50, 75, 0 or 00. It does match for a nothing after decimal also but I guess thats ok !!",
        "refined_prompt": "\nMatch examples:\n- \"0.25\"\n- \".75\"\n- \"123.50\"\nNon-match examples:\n- \".77\"\n- \"1.435\"",
        "matches": [
            "0.25",
            ".75",
            "123.50"
        ],
        "non_matches": [
            ".77",
            "1.435"
        ],
        "stress_tests": []
    },
    {
        "id": 76,
        "expression": "^(s-|S-){0,1}[0-9]{3}\\s?[0-9]{2}$",
        "raw_prompt": "Validates swedish zipcodes (postnr) with or without space between groups. With leading s- or not. Can be disconnected by removing ''(s-|S-){0,1}''.",
        "refined_prompt": "\nMatch examples:\n- \"12345\"\n- \"932 68\"\n- \"S-621 46\"\nNon-match examples:\n- \"5367\"\n- \"425611\"",
        "matches": [
            "12345",
            "932 68",
            "S-621 46"
        ],
        "non_matches": [
            "5367",
            "425611",
            "31 545"
        ],
        "stress_tests": []
    },
    {
        "id": 77,
        "expression": "((0?[13578]|10|12)(-|\\/)((0[0-9])|([12])([0-9]?)|(3[01]?))(-|\\/)((\\d{4})|(\\d{2}))|(0?[2469]|11)(-|\\/)((0[0-9])|([12])([0-9]?)|(3[0]?))(-|\\/)((\\d{4}|\\d{2})))",
        "raw_prompt": "Regex used in .NET to validate a date. Matches the following formats mm/dd/yy, mm/dd/yyyy, mm-dd-yy, mm-dd-yyyy\nThis covers days with 30 or 31 days but does not handle February, it is allowed 30 days.",
        "refined_prompt": "\nMatch examples:\n- \"1/31/2002\"\n- \"04-30-02\"\n- \"12-01/2002\"\nNon-match examples:\n- \"2/31/2002\"\n- \"13/0/02\"",
        "matches": [
            "1/31/2002",
            "04-30-02",
            "12-01/2002"
        ],
        "non_matches": [
            "2/31/2002",
            "13/0/02",
            "Jan 1, 2001"
        ],
        "stress_tests": []
    },
    {
        "id": 78,
        "expression": "^(?!^(PRN|AUX|CLOCK\\$|NUL|CON|COM\\d|LPT\\d|\\..*)(\\..+)?$)[^\\x00-\\x1f\\\\?*:\\\";|/]+$",
        "raw_prompt": "Checks for a valid windows file name (Must be used with the case-insensitive option\nChecks that the file has at lease one char, does not contain any invalid characters and does not have a reserved word as a file name.\n&quot;If you see a &amp;quot; in the regex replace it with a &quot; character&quot;",
        "refined_prompt": "\nMatch examples:\n- \"test.txt\"\n- \"test.jpg.txt\"\n- \"a&b c.bmp\"\nNon-match examples:\n- \"CON\"\n- \".pdf\"",
        "matches": [
            "test.txt",
            "test.jpg.txt",
            "a&b c.bmp"
        ],
        "non_matches": [
            "CON",
            ".pdf",
            "test:2.pdf"
        ],
        "stress_tests": []
    },
    {
        "id": 80,
        "expression": "^(\\d{5}-\\d{4}|\\d{5})$|^([a-zA-Z]\\d[a-zA-Z] \\d[a-zA-Z]\\d)$",
        "raw_prompt": "This is a modification of the zip code regular expression submitted by Steven Smith (ssmith@aspalliance.com)\nIt no longer matches 78754-12aA",
        "refined_prompt": "\nMatch examples:\n- \"78754\"\n- \"78754-1234\"\n- \"G3H 6A3\"\nNon-match examples:\n- \"78754-12aA\"\n- \"7875A\"",
        "matches": [
            "78754",
            "78754-1234",
            "G3H 6A3"
        ],
        "non_matches": [
            "78754-12aA",
            "7875A",
            "g3h6a3"
        ],
        "stress_tests": []
    },
    {
        "id": 81,
        "expression": "^([\\w\\-\\.]+)@((\\[([0-9]{1,3}\\.){3}[0-9]{1,3}\\])|(([\\w\\-]+\\.)+)([a-zA-Z]{2,4}))$",
        "raw_prompt": "Expression 1 of 2 used to check email address syntax.",
        "refined_prompt": "\nMatch examples:\n- \"bob@somewhere.com\"\n- \"bob.jones@[1.1.1.1]\"\n- \"bob@a.b.c.d.info\"\nNon-match examples:\n- \"bob@com\"\n- \"bob.jones@some.where\"",
        "matches": [
            "bob@somewhere.com",
            "bob.jones@[1.1.1.1]",
            "bob@a.b.c.d.info"
        ],
        "non_matches": [
            "bob@com",
            "bob.jones@some.where",
            "bob@1.1.1.123"
        ],
        "stress_tests": []
    },
    {
        "id": 82,
        "expression": "^(([-\\w \\.]+)|(&quot;&quot;[-\\w \\.]+&quot;&quot;) )?&lt;([\\w\\-\\.]+)@((\\[([0-9]{1,3}\\.){3}[0-9]{1,3}\\])|(([\\w\\-]+\\.)+)([a-zA-Z]{2,4}))&gt;$",
        "raw_prompt": "Expression 2 or 2 for matching email address syntax. This one matches the &lt;angle bracket syntax&gt;.",
        "refined_prompt": "\nMatch examples:\n- \"&lt;ab@cd.ef&gt;\"\n- \"bob A. jones &lt;ab@cd.ef&gt;\"\n- \"bob A. jones &lt;ab@[1.1.1.111]&gt;\"\nNon-match examples:\n- \"ab@cd.ef\"\n- \"&quot;bob A. jones &lt;ab@cd.ef&gt;\"",
        "matches": [
            "&lt;ab@cd.ef&gt;",
            "bob A. jones &lt;ab@cd.ef&gt;",
            "bob A. jones &lt;ab@[1.1.1.111]&gt;"
        ],
        "non_matches": [
            "ab@cd.ef",
            "&quot;bob A. jones &lt;ab@cd.ef&gt;",
            "bob A. jones &lt;ab@1.1.1.111&gt;"
        ],
        "stress_tests": []
    },
    {
        "id": 83,
        "expression": "^http\\://[a-zA-Z0-9\\-\\.]+\\.[a-zA-Z]{2,3}(/\\S*)?$",
        "raw_prompt": "Verifies URLs. Checks for the leading protocol, a good looking domain (two or three letter TLD; no invalid characters in domain) and a somwhat reasonable file path.",
        "refined_prompt": "\nMatch examples:\n- \"http://psychopop.org\"\n- \"http://www.edsroom.com/newUser.asp\"\n- \"http://unpleasant.jarrin.net/markov/inde\"\nNon-match examples:\n- \"ftp://psychopop.org\"\n- \"http://www.edsroom/\"",
        "matches": [
            "http://psychopop.org",
            "http://www.edsroom.com/newUser.asp",
            "http://unpleasant.jarrin.net/markov/inde"
        ],
        "non_matches": [
            "ftp://psychopop.org",
            "http://www.edsroom/",
            "http://un/pleasant.jarrin.net/markov/index.asp"
        ],
        "stress_tests": []
    },
    {
        "id": 84,
        "expression": "^[A-Za-z]{1,2}[0-9A-Za-z]{1,2}[ ]?[0-9]{0,1}[A-Za-z]{2}$",
        "raw_prompt": "This regular expression can be used to validate UK postcodes. Especially useful if want to provide a client side validation on a web site.",
        "refined_prompt": "\nMatch examples:\n- \"SW112LE\"\n- \"SW11 2LE\"\n- \"CR05LE\"\nNon-match examples:\n- \"12CR0LE\"\n- \"12CR 0LE\"",
        "matches": [
            "SW112LE",
            "SW11 2LE",
            "CR05LE"
        ],
        "non_matches": [
            "12CR0LE",
            "12CR 0LE",
            "SWLE05"
        ],
        "stress_tests": []
    },
    {
        "id": 86,
        "expression": "20\\d{2}(-|\\/)((0[1-9])|(1[0-2]))(-|\\/)((0[1-9])|([1-2][0-9])|(3[0-1]))(T|\\s)(([0-1][0-9])|(2[0-3])):([0-5][0-9]):([0-5][0-9])",
        "raw_prompt": "Sql date format tester.",
        "refined_prompt": "\nMatch examples:\n- \"2099-12-31T23:59:59\"\n- \"2002/02/09 16:30:00\"\n- \"2000-01-01T00:00:00\"\nNon-match examples:\n- \"2000-13-31T00:00:00\"\n- \"2002/02/33 24:00:00\"",
        "matches": [
            "2099-12-31T23:59:59",
            "2002/02/09 16:30:00",
            "2000-01-01T00:00:00"
        ],
        "non_matches": [
            "2000-13-31T00:00:00",
            "2002/02/33 24:00:00",
            "2000-01-01 60:00:00"
        ],
        "stress_tests": []
    },
    {
        "id": 87,
        "expression": "^\\d{4}[\\-\\/\\s]?((((0[13578])|(1[02]))[\\-\\/\\s]?(([0-2][0-9])|(3[01])))|(((0[469])|(11))[\\-\\/\\s]?(([0-2][0-9])|(30)))|(02[\\-\\/\\s]?[0-2][0-9]))$",
        "raw_prompt": "- validates a yyyy-mm-dd, yyyy mm dd, or yyyy/mm/dd date\n- makes sure day is within valid range for the month\n- does NOT validate Feb. 29 on a leap year, only that Feb. CAN have 29 days",
        "refined_prompt": "\nMatch examples:\n- \"0001-12-31\"\n- \"9999 09 30\"\n- \"2002/03/03\"\nNon-match examples:\n- \"0001\\02\\30\"\n- \"9999.15.01\"",
        "matches": [
            "0001-12-31",
            "9999 09 30",
            "2002/03/03"
        ],
        "non_matches": [
            "0001\\02\\30",
            "9999.15.01",
            "2002/3/3"
        ],
        "stress_tests": []
    },
    {
        "id": 89,
        "expression": "^(1?(-?\\d{3})-?)?(\\d{3})(-?\\d{4})$",
        "raw_prompt": "US Telephone Reg expression that allows 7, 10 or 11 digits with or without hyphens.",
        "refined_prompt": "\nMatch examples:\n- \"15615552323\"\n- \"1-561-555-1212\"\n- \"5613333\"\nNon-match examples:\n- \"1-555-5555\"\n- \"15553333\"",
        "matches": [
            "15615552323",
            "1-561-555-1212",
            "5613333"
        ],
        "non_matches": [
            "1-555-5555",
            "15553333",
            "0-561-555-1212"
        ],
        "stress_tests": []
    },
    {
        "id": 92,
        "expression": "([a-zA-Z]:(\\\\w+)*\\\\[a-zA-Z0_9]+)?.xls",
        "raw_prompt": "This RegEx will help to validate a physical file path with a specific file extension (here xls)",
        "refined_prompt": "\nMatch examples:\n- \"E:\\DyAGT\\SD01A_specV2.xls\"\nNon-match examples:\n- \"E:\\DyAGT\\SD01A_specV2.txt\"",
        "matches": [
            "E:\\DyAGT\\SD01A_specV2.xls"
        ],
        "non_matches": [
            "E:\\DyAGT\\SD01A_specV2.txt"
        ],
        "stress_tests": []
    },
    {
        "id": 94,
        "expression": "^( [1-9]|[1-9]|0[1-9]|10|11|12)[0-5]\\d$",
        "raw_prompt": "Matches a 12-hour time value expressed as either 4 numeric digits, 3 numeric digits, or a space and 3 numeric digits. 3 digit times (930) can be expressed with leading 0's (0930) or not. AM/PM designation is not included in this expression.",
        "refined_prompt": "\nMatch examples:\n- \"1145\"\n- \"933\"\n- \"801\"\nNon-match examples:\n- \"0000\"\n- \"1330\"",
        "matches": [
            "1145",
            "933",
            "801"
        ],
        "non_matches": [
            "0000",
            "1330",
            "8:30"
        ],
        "stress_tests": []
    },
    {
        "id": 95,
        "expression": "^\\d{1,2}\\/\\d{2,4}$",
        "raw_prompt": "Accepts 1-2 digits followed by a slash followed by 2-4 digits. Useful for numeric month/year entry.",
        "refined_prompt": "\nMatch examples:\n- \"9/02\"\n- \"09/2002\"\n- \"09/02\"\nNon-match examples:\n- \"Fall 2002\"\n- \"Sept 2002\"",
        "matches": [
            "9/02",
            "09/2002",
            "09/02"
        ],
        "non_matches": [
            "Fall 2002",
            "Sept 2002"
        ],
        "stress_tests": []
    },
    {
        "id": 96,
        "expression": "^(|(0[1-9])|(1[0-2]))\\/((0[1-9])|(1\\d)|(2\\d)|(3[0-1]))\\/((\\d{4}))$",
        "raw_prompt": "This expression matches dates formatted as MM/DD/YYYY where months and days must be 2 digits each, zero padded. It is not perfect - it allows DD to be from 01 to 31 regardless of the month.",
        "refined_prompt": "\nMatch examples:\n- \"01/01/2001\"\n- \"02/30/2001\"\n- \"12/31/2002\"\nNon-match examples:\n- \"1/1/02\"\n- \"1/1/2002\"",
        "matches": [
            "01/01/2001",
            "02/30/2001",
            "12/31/2002"
        ],
        "non_matches": [
            "1/1/02",
            "1/1/2002",
            "1/25/2002"
        ],
        "stress_tests": []
    },
    {
        "id": 97,
        "expression": "^((((0[13578])|(1[02]))[\\/]?(([0-2][0-9])|(3[01])))|(((0[469])|(11))[\\/]?(([0-2][0-9])|(30)))|(02[\\/]?[0-2][0-9]))[\\/]?\\d{4}$",
        "raw_prompt": "Date expressions that matches MM/DD/YYYY where MM and DD must be two digits and zero padded. Validates correctly for all months except February, which it assumes to always have 29 days. The &quot;/&quot; separator is optional.",
        "refined_prompt": "\nMatch examples:\n- \"01/01/2001\"\n- \"02/29/2002\"\n- \"12/31/2002\"\nNon-match examples:\n- \"1/1/02\"\n- \"02/30/2002\"",
        "matches": [
            "01/01/2001",
            "02/29/2002",
            "12/31/2002"
        ],
        "non_matches": [
            "1/1/02",
            "02/30/2002",
            "1/25/2002"
        ],
        "stress_tests": []
    },
    {
        "id": 98,
        "expression": "^(\\d{1,3}'(\\d{3}')*\\d{3}(\\.\\d{1,3})?|\\d{1,3}(\\.\\d{3})?)$",
        "raw_prompt": "This regex match numeric data in the following format: thousands are separated by (') apostrophe, decimal places are separated by dot (.) Maximum three decimal places are not required. It's easy to change to other separators as well.",
        "refined_prompt": "\nMatch examples:\n- \"1'235.140\"\n- \"1'222'333.120\"\n- \"456\"\nNon-match examples:\n- \"1234.500\"\n- \"78'45.123\"",
        "matches": [
            "1'235.140",
            "1'222'333.120",
            "456"
        ],
        "non_matches": [
            "1234.500",
            "78'45.123",
            "123,0012"
        ],
        "stress_tests": []
    },
    {
        "id": 99,
        "expression": "^((0?[1-9]|[12][1-9]|3[01])\\.(0?[13578]|1[02])\\.20[0-9]{2}|(0?[1-9]|[12][1-9]|30)\\.(0?[13456789]|1[012])\\.20[0-9]{2}|(0?[1-9]|1[1-9]|2[0-8])\\.(0?[123456789]|1[012])\\.20[0-9]{2}|(0?[1-9]|[12][1-9])\\.(0?[123456789]|1[012])\\.20(00|04|08|12|16|20|24|28|32|36|40|44|48|52|56|60|64|68|72|76|80|84|88|92|96))$",
        "raw_prompt": "Fully functional date validator in format dd.MM.yyyy\nWorks only within range of years 2000-2099 !\nIt allows leading zeros but does not require them. The last year pattern (enumeration) is not very clever but I will improve it, if needed.",
        "refined_prompt": "\nMatch examples:\n- \"31.01.2002\"\n- \"29.2.2004\"\n- \"09.02.2005\"\nNon-match examples:\n- \"31.11.2002\"\n- \"29.2.2002\"",
        "matches": [
            "31.01.2002",
            "29.2.2004",
            "09.02.2005"
        ],
        "non_matches": [
            "31.11.2002",
            "29.2.2002",
            "33.06.2000"
        ],
        "stress_tests": []
    },
    {
        "id": 100,
        "expression": "^(0[1-9]|1[0-2])\\/((0[1-9]|2\\d)|3[0-1])\\/(19\\d\\d|200[0-3])$",
        "raw_prompt": "This expression is an attempt to match the most obvious features of a valid date in American/US format of the form mm/dd/yyyy for any year 1900 through 2003. It can easily be adapted for different date ranges. It matches any date where the day part is any number 01-31, the month part is any number 01-12, and the year part is any number 1900-2003. The only invalid dates that it matches are ones where the day part may be in the range 01-31 but that range might not be valid for the specified month. An example of an invalid date that it would allow to pass through would be 11/31/2002. This date is invalid because 11/31 of any year does not exist, but this expression would allow it pass through since the day part is in the range 01-31.\nThis regular expression has been used successfully in ASP with VBScript using the windows scripting library RegExp object.",
        "refined_prompt": "\nMatch examples:\n- \"12/31/2003\"\n- \"01/01/1900\"\n- \"11/31/2002\"\nNon-match examples:\n- \"1/1/2002\"\n- \"01/01/02\"",
        "matches": [
            "12/31/2003",
            "01/01/1900",
            "11/31/2002"
        ],
        "non_matches": [
            "1/1/2002",
            "01/01/02",
            "01/01/2004"
        ],
        "stress_tests": []
    },
    {
        "id": 103,
        "expression": "^((((0[13578])|([13578])|(1[02]))[\\/](([1-9])|([0-2][0-9])|(3[01])))|(((0[469])|([469])|(11))[\\/](([1-9])|([0-2][0-9])|(30)))|((2|02)[\\/](([1-9])|([0-2][0-9]))))[\\/]\\d{4}$|^\\d{4}$",
        "raw_prompt": "The following validates dates with and without leading zeros in the following formats: MM/DD/YYYY and it also takes YYYY (this can easily be removed). All months are validated for the correct number of days for that particular month except for February which can be set to 29 days. date day month year",
        "refined_prompt": "\nMatch examples:\n- \"01/01/2001\"\n- \"1/01/2001\"\n- \"2002\"\nNon-match examples:\n- \"2/30/2002\"\n- \"13/23/2002\"",
        "matches": [
            "01/01/2001",
            "1/01/2001",
            "2002"
        ],
        "non_matches": [
            "2/30/2002",
            "13/23/2002",
            "12345"
        ],
        "stress_tests": []
    },
    {
        "id": 104,
        "expression": "^(?:(?:(?:0?[13578]|1[02])(\\/|-|\\.)31)\\1|(?:(?:0?[13-9]|1[0-2])(\\/|-|\\.)(?:29|30)\\2))(?:(?:1[6-9]|[2-9]\\d)?\\d{2})$|^(?:0?2(\\/|-|\\.)29\\3(?:(?:(?:1[6-9]|[2-9]\\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00))))$|^(?:(?:0?[1-9])|(?:1[0-2]))(\\/|-|\\.)(?:0?[1-9]|1\\d|2[0-8])\\4(?:(?:1[6-9]|[2-9]\\d)?\\d{2})$",
        "raw_prompt": "This expression validates dates in the US m/d/y format from 1/1/1600 - 12/31/9999.",
        "refined_prompt": "\nMatch examples:\n- \"01.1.02\"\n- \"11-30-2001\"\n- \"2/29/2000\"\nNon-match examples:\n- \"02/29/01\"\n- \"13/01/2002\"",
        "matches": [
            "01.1.02",
            "11-30-2001",
            "2/29/2000"
        ],
        "non_matches": [
            "02/29/01",
            "13/01/2002",
            "11/00/02"
        ],
        "stress_tests": []
    },
    {
        "id": 107,
        "expression": "^[\\\\(]{0,1}([0-9]){3}[\\\\)]{0,1}[ ]?([^0-1]){1}([0-9]){2}[ ]?[-]?[ ]?([0-9]){4}[ ]*((x){0,1}([0-9]){1,5}){0,1}$",
        "raw_prompt": "US Telephone Number where this is regular expression excludes the first number, after the area code,from being 0 or 1; it also allows an extension\nto be added where it does not have to be prefixed by 'x'.",
        "refined_prompt": "\nMatch examples:\n- \"(910)456-7890\"\n- \"(910)456-8970 x12\"\n- \"(910)456-8970 1211\"\nNon-match examples:\n- \"(910) 156-7890\"\n- \"(910) 056-7890\"",
        "matches": [
            "(910)456-7890",
            "(910)456-8970 x12",
            "(910)456-8970 1211"
        ],
        "non_matches": [
            "(910) 156-7890",
            "(910) 056-7890",
            "(910) 556-7890 x"
        ],
        "stress_tests": []
    },
    {
        "id": 108,
        "expression": "^[-+]?\\d+(\\.\\d+)?$",
        "raw_prompt": "This matches any real number, with optional decimal point and numbers after the decimal, and optional positive (+) or negative (-) designation.",
        "refined_prompt": "\nMatch examples:\n- \"123\"\n- \"-123.45\"\n- \"+123.56\"\nNon-match examples:\n- \"123x\"\n- \".123\"",
        "matches": [
            "123",
            "-123.45",
            "+123.56"
        ],
        "non_matches": [
            "123x",
            ".123",
            "-123."
        ],
        "stress_tests": []
    },
    {
        "id": 110,
        "expression": "^((\\d{5}-\\d{4})|(\\d{5})|([A-Z]\\d[A-Z]\\s\\d[A-Z]\\d))$",
        "raw_prompt": "This expression matches three different formats of postal codes: 5 digit US ZIP code, 5 digit US ZIP code + 4, and 6 digit alphanumeric Canadian Postal Code. The first one must be 5 numeric digits. The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits. The Canadian postal code must be of the form ANA NAN where A is any uppercase alphabetic character and N is a numeric digit from 0 to 9.",
        "refined_prompt": "\nMatch examples:\n- \"44240\"\n- \"44240-5555\"\n- \"T2P 3C7\"\nNon-match examples:\n- \"44240ddd\"\n- \"t44240-55\"",
        "matches": [
            "44240",
            "44240-5555",
            "T2P 3C7"
        ],
        "non_matches": [
            "44240ddd",
            "t44240-55",
            "t2p3c7"
        ],
        "stress_tests": []
    },
    {
        "id": 112,
        "expression": "\"((\\\\\")|[^\"(\\\\\")])+\"",
        "raw_prompt": "Matches quoted string, using \\&quot; as an escape to place quotes in the string",
        "refined_prompt": "\nMatch examples:\n- \"\"test\"\"\n- \"\"escape\\\"quote\"\"\n- \"\"\\\"\"\"\nNon-match examples:\n- \"test\"\n- \"\"test\"",
        "matches": [
            "\"test\"",
            "\"escape\\\"quote\"",
            "\"\\\"\""
        ],
        "non_matches": [
            "test",
            "\"test",
            "\"test\\\""
        ],
        "stress_tests": []
    },
    {
        "id": 113,
        "expression": "^\\d{5}(-\\d{3})?$",
        "raw_prompt": "Matches standard 5 digit Brazilian Postal Codes (CEP), or the CEP + 3 digits (distribution identifiers - suffix).\nFor more info refer to: http://www.correios.com.br/servicos/cep/Estrutura_CEP.cfm (in portuguese).",
        "refined_prompt": "\nMatch examples:\n- \"13165-000\"\n- \"38175-000\"\n- \"81470-276\"\nNon-match examples:\n- \"13165-00\"\n- \"38175-abc\"",
        "matches": [
            "13165-000",
            "38175-000",
            "81470-276"
        ],
        "non_matches": [
            "13165-00",
            "38175-abc",
            "81470-2763"
        ],
        "stress_tests": []
    },
    {
        "id": 114,
        "expression": "^\\$(\\d{1,3}(\\,\\d{3})*|(\\d+))(\\.\\d{2})?$",
        "raw_prompt": "This re matches US currency format with lead dollar sign. Dollar value must have at least one digit and may or may not be comma separated. Cents value is optional.",
        "refined_prompt": "\nMatch examples:\n- \"$0.84\"\n- \"$123458\"\n- \"$1,234,567.89\"\nNon-match examples:\n- \"$12,3456.01\"\n- \"12345\"",
        "matches": [
            "$0.84",
            "$123458",
            "$1,234,567.89"
        ],
        "non_matches": [
            "$12,3456.01",
            "12345",
            "$1.234"
        ],
        "stress_tests": []
    },
    {
        "id": 115,
        "expression": "([A-Z]:\\\\[^/:\\*\\?<>\\|]+\\.\\w{2,6})|(\\\\{2}[^/:\\*\\?<>\\|]+\\.\\w{2,6})",
        "raw_prompt": "This regular expression pattern can be used to check the validity of paths for file upload controls. The uploaded file can be either stored locally or accessible through UNC. It cannot contain illegal characters for the windows OS - that may be supported e.g. on Mac OS \u2013 and cannot be a URL (Yes, as weird as it may seem, some users enter URLs in the file upload box, even though there is a browse button...)",
        "refined_prompt": "\nMatch examples:\n- \"C:\\temp\\this allows spaces\\web.config\"\n- \"\\\\Andromeda\\share\\file name.123\"\nNon-match examples:\n- \"tz:\\temp\\ fi*le?na:m<e>.doc\"\n- \"\\\\Andromeda\\share\\filename.a\"",
        "matches": [
            "C:\\temp\\this allows spaces\\web.config",
            "\\\\Andromeda\\share\\file name.123"
        ],
        "non_matches": [
            "tz:\\temp\\ fi*le?na:m<e>.doc",
            "\\\\Andromeda\\share\\filename.a"
        ],
        "stress_tests": []
    },
    {
        "id": 117,
        "expression": "(^([0-9]|[0-1][0-9]|[2][0-3]):([0-5][0-9])$)|(^([0-9]|[1][0-9]|[2][0-3])$)",
        "raw_prompt": "Matches a string if it is a valid time in the format of HH:MM / H:MM / HH / H",
        "refined_prompt": "\nMatch examples:\n- \"10:35\"\n- \"9:20\"\n- \"23\"\nNon-match examples:\n- \"24:00\"\n- \"20 PM\"",
        "matches": [
            "10:35",
            "9:20",
            "23"
        ],
        "non_matches": [
            "24:00",
            "20 PM",
            "20:15 PM"
        ],
        "stress_tests": []
    },
    {
        "id": 118,
        "expression": "^\\$?([0-9]{1,3},([0-9]{3},)*[0-9]{3}|[0-9]+)(\\.[0-9][0-9])?$",
        "raw_prompt": "Matches US currency input with or without commas. This provides a fix for the currency regular expression posted at http://regxlib.com/REDetails.aspx?regexp_id=70 by escaping the . (period) to ensure that no other characters may be used in it's place.",
        "refined_prompt": "\nMatch examples:\n- \"$3,023,123.34\"\n- \"9,876,453\"\n- \"123456.78\"\nNon-match examples:\n- \"4,33,234.34\"\n- \"$1.234\"",
        "matches": [
            "$3,023,123.34",
            "9,876,453",
            "123456.78"
        ],
        "non_matches": [
            "4,33,234.34",
            "$1.234",
            "abc"
        ],
        "stress_tests": []
    },
    {
        "id": 119,
        "expression": "^\\$?\\d+(\\.(\\d{2}))?$",
        "raw_prompt": "To evaluate an amount with or without a dollar sign where the cents are optional.",
        "refined_prompt": "\nMatch examples:\n- \"$2.43\"\n- \"2.02\"\n- \"$2112\"\nNon-match examples:\n- \"2.1\"\n- \"$.14\"",
        "matches": [
            "$2.43",
            "2.02",
            "$2112"
        ],
        "non_matches": [
            "2.1",
            "$.14",
            "$2,222.12"
        ],
        "stress_tests": []
    },
    {
        "id": 120,
        "expression": "((0[1-9])|(1[02]))/\\d{2}",
        "raw_prompt": "Fromat check for MM/YY, checks month is 1-12 and any 2 digit year.",
        "refined_prompt": "\nMatch examples:\n- \"01/00\"\n- \"12/99\"\nNon-match examples:\n- \"13/00\"\n- \"12/AS\"",
        "matches": [
            "01/00",
            "12/99"
        ],
        "non_matches": [
            "13/00",
            "12/AS"
        ],
        "stress_tests": []
    },
    {
        "id": 121,
        "expression": "(\"[^\"]*\")|('[^\\r]*)(\\r\\n)?",
        "raw_prompt": "Will match a VBScript string and/or comment\nEx:\n' userinfo\nstrUsername = &quot;tomsve&quot;\niAge = 20\n' temp\nstrPassword = &quot;halloj&quot;\n...Would result in the following matches:\n' userinfo\n&quot;tomsve&quot;\n' temp\n&quot;halloj&quot;\nGood luck!\nTom S. info@tomsvensson.com",
        "refined_prompt": "\nMatch examples:\n- \"\"my string\"\"\n- \"\"a string with ' in it\"\"\n- \"' comment\"\nNon-match examples:\n- \"asd \"\"",
        "matches": [
            "\"my string\"",
            "\"a string with ' in it\"",
            "' comment"
        ],
        "non_matches": [
            "asd \""
        ],
        "stress_tests": []
    },
    {
        "id": 123,
        "expression": "^([0-9]{2})?(\\([0-9]{2})\\)([0-9]{3}|[0-9]{4})-[0-9]{4}$",
        "raw_prompt": "A simple expression to brazilian phone number code, with international code.\nSimple DDI without &quot;+&quot; 99 plus simple DDD (99) plus simple local phone number 3 or 4 digits plus &quot;-&quot; plus 4 digits.",
        "refined_prompt": "\nMatch examples:\n- \"55(21)123-4567\"\n- \"(11)1234-5678\"\n- \"55(71)4562-2234\"\nNon-match examples:\n- \"3434-3432\"\n- \"4(23)232-3232\"",
        "matches": [
            "55(21)123-4567",
            "(11)1234-5678",
            "55(71)4562-2234"
        ],
        "non_matches": [
            "3434-3432",
            "4(23)232-3232",
            "55(2)232-232"
        ],
        "stress_tests": []
    },
    {
        "id": 125,
        "expression": "^(([a-zA-Z]:)|(\\\\{2}\\w+)\\$?)(\\\\(\\w[\\w ]*))+\\.(txt|TXT)$",
        "raw_prompt": "This RE validates a path/file of type txt (text file)\nThis RE can be used as a filter on certain file types, while insuring the entire string is a fully qualified path and file. The filter value can be changed or added to as you need",
        "refined_prompt": "\nMatch examples:\n- \"c:\\file.txt\"\n- \"c:\\folder\\sub folder\\file.txt\"\n- \"\\\\network\\folder\\file.txt\"\nNon-match examples:\n- \"C:\"\n- \"C:\\file.xls\"",
        "matches": [
            "c:\\file.txt",
            "c:\\folder\\sub folder\\file.txt",
            "\\\\network\\folder\\file.txt"
        ],
        "non_matches": [
            "C:",
            "C:\\file.xls",
            "folder.txt"
        ],
        "stress_tests": []
    },
    {
        "id": 126,
        "expression": "^[a-zA-Z0-9]+([a-zA-Z0-9\\-\\.]+)?\\.(com|org|net|mil|edu|COM|ORG|NET|MIL|EDU)$",
        "raw_prompt": "Checks domain names. This is an attempt to deal with some of the issues of the other reg ex in not handling leading periods(.) and hypens(-).",
        "refined_prompt": "\nMatch examples:\n- \"my.domain.com\"\n- \"regexlib.com\"\n- \"big-reg.com\"\nNon-match examples:\n- \".mydomain.com\"\n- \"regexlib.comm\"",
        "matches": [
            "my.domain.com",
            "regexlib.com",
            "big-reg.com"
        ],
        "non_matches": [
            ".mydomain.com",
            "regexlib.comm",
            "-bigreg.com"
        ],
        "stress_tests": []
    },
    {
        "id": 127,
        "expression": "^[-+]?[0-9]+[.]?[0-9]*([eE][-+]?[0-9]+)?$",
        "raw_prompt": "This matches floating point expression in a more rigorous way - accepts both exponent as well as non exponent notations.",
        "refined_prompt": "\nMatch examples:\n- \"123\"\n- \"-123.35\"\n- \"-123.35e-2\"\nNon-match examples:\n- \"abc\"\n- \"123.32e\"",
        "matches": [
            "123",
            "-123.35",
            "-123.35e-2"
        ],
        "non_matches": [
            "abc",
            "123.32e",
            "123.32.3"
        ],
        "stress_tests": []
    },
    {
        "id": 128,
        "expression": "^[_a-zA-Z0-9-]+(\\.[_a-zA-Z0-9-]+)*@[a-zA-Z0-9-]+(\\.[a-zA-Z0-9-]+)*\\.(([0-9]{1,3})|([a-zA-Z]{2,3})|(aero|coop|info|museum|name))$",
        "raw_prompt": "Matches e-mail addresses, including some of the newer top-level-domain extensions, such as info, museum, name, etc. Also allows for emails tied directly to IP addresses.",
        "refined_prompt": "\nMatch examples:\n- \"example@example.com\"\n- \"foo@bar.info\"\n- \"blah@127.0.0.1\"\nNon-match examples:\n- \"broken@@example.com\"\n- \"foo@bar.infp\"",
        "matches": [
            "example@example.com",
            "foo@bar.info",
            "blah@127.0.0.1"
        ],
        "non_matches": [
            "broken@@example.com",
            "foo@bar.infp",
            "blah@.nospam.biz"
        ],
        "stress_tests": []
    },
    {
        "id": 130,
        "expression": "(^\\(\\)$|^\\(((\\([0-9]+,(\\((\\([0-9]+,[0-9]+,[0-9]+\\),)*(\\([0-9]+,[0-9]+,[0-9]+\\)){1}\\))+\\),)*(\\([0-9]+,(\\((\\([0-9]+,[0-9]+,[0-9]+\\),)*(\\([0-9]+,[0-9]+,[0-9]+\\)){1}\\))+\\)){1}\\)))$",
        "raw_prompt": "This checks for the specific syntax ((A,((b,c,d),(e,f,g))), ..). No limit on number of occurances.",
        "refined_prompt": "\nMatch examples:\n- \"((24,((1,2,3),(3,4,5))))\"\n- \"((1,((2,3,4),(4,5,6),(96,34,26))),(12,((1,3,4),(4,5,6),(7,8,9))))\"\n- \"()\"\nNon-match examples:\n- \"(24,((1,2,3),(3,4,5)))\"\n- \"( )\"",
        "matches": [
            "((24,((1,2,3),(3,4,5))))",
            "((1,((2,3,4),(4,5,6),(96,34,26))),(12,((1,3,4),(4,5,6),(7,8,9))))",
            "()"
        ],
        "non_matches": [
            "(24,((1,2,3),(3,4,5)))",
            "( )",
            "((23,(12,3,4),(4,5,6)))"
        ],
        "stress_tests": []
    },
    {
        "id": 131,
        "expression": "^[a-zA-Z]+(([\\'\\,\\.\\- ][a-zA-Z ])?[a-zA-Z]*)*$",
        "raw_prompt": "Person's name (first, last, or both) in any letter case. Although not perfect, this expression will filter out many incorrect name formats (especially numerics and invalid special characters).",
        "refined_prompt": "\nMatch examples:\n- \"T.F. Johnson\"\n- \"John O'Neil\"\n- \"Mary-Kate Johnson\"\nNon-match examples:\n- \"sam_johnson\"\n- \"Joe--Bob Jones\"",
        "matches": [
            "T.F. Johnson",
            "John O'Neil",
            "Mary-Kate Johnson"
        ],
        "non_matches": [
            "sam_johnson",
            "Joe--Bob Jones",
            "dfjsd0rd"
        ],
        "stress_tests": []
    },
    {
        "id": 132,
        "expression": "^((([0]?[1-9]|1[0-2])(:|\\.)[0-5][0-9]((:|\\.)[0-5][0-9])?( )?(AM|am|aM|Am|PM|pm|pM|Pm))|(([0]?[0-9]|1[0-9]|2[0-3])(:|\\.)[0-5][0-9]((:|\\.)[0-5][0-9])?))$",
        "raw_prompt": "Matches times seperated by either : or . will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.",
        "refined_prompt": "\nMatch examples:\n- \"1:01 AM\"\n- \"23:52:01\"\n- \"03.24.36 AM\"\nNon-match examples:\n- \"19:31 AM\"\n- \"9:9 PM\"",
        "matches": [
            "1:01 AM",
            "23:52:01",
            "03.24.36 AM"
        ],
        "non_matches": [
            "19:31 AM",
            "9:9 PM",
            "25:60:61"
        ],
        "stress_tests": []
    },
    {
        "id": 133,
        "expression": "^[a-zA-Z0-9\\s.\\-_']+$",
        "raw_prompt": "Alphanumeric, hyphen apostrophe, comma dash spaces",
        "refined_prompt": "\nMatch examples:\n- \"dony d'gsa\"\nNon-match examples:\n- \"^[a-zA-Z0-9\\s.\\-_']+$\"",
        "matches": [
            "dony d'gsa"
        ],
        "non_matches": [
            "^[a-zA-Z0-9\\s.\\-_']+$"
        ],
        "stress_tests": []
    },
    {
        "id": 134,
        "expression": "^(http|https|ftp)\\://[a-zA-Z0-9\\-\\.]+\\.[a-zA-Z]{2,3}(:[a-zA-Z0-9]*)?/?([a-zA-Z0-9\\-\\._\\?\\,\\'/\\\\\\+&amp;%\\$#\\=~])*$",
        "raw_prompt": "Modified URL RegExp that requires (http, https, ftp)://, A nice domain, and a decent file/folder string. Allows : after domain name, and these characters in the file/folder sring (letter, numbers, - . _ ? , ' / \\ + &amp; % $ # = ~). Blocks all other special characters-good for protecting against user input!",
        "refined_prompt": "\nMatch examples:\n- \"http://www.blah.com/~joe\"\n- \"ftp://ftp.blah.co.uk:2828/blah%20blah.gif\"\n- \"https://blah.gov/blah-blah.as\"\nNon-match examples:\n- \"www.blah.com\"\n- \"http://www.blah&quot;blah.com/I have spaces!\"",
        "matches": [
            "http://www.blah.com/~joe",
            "ftp://ftp.blah.co.uk:2828/blah%20blah.gif",
            "https://blah.gov/blah-blah.as"
        ],
        "non_matches": [
            "www.blah.com",
            "http://www.blah&quot;blah.com/I have spaces!",
            "ftp://blah_underscore/[nope]"
        ],
        "stress_tests": []
    },
    {
        "id": 137,
        "expression": "[^A-Za-z0-9_@\\.]|@{2,}|\\.{5,}",
        "raw_prompt": "Used as a username validation script requires:\n1. Allows All Alphanumeric characters &amp; underscore\n2. Allows One &quot;@&quot; character\n3. Allows Five &quot;.&quot; periods\n4. Rejects spaces",
        "refined_prompt": "\nMatch examples:\n- \"user name\"\n- \"user#name\"\n- \".....\"\nNon-match examples:\n- \"User_Name1\"\n- \"username@foo.com\"",
        "matches": [
            "user name",
            "user#name",
            "....."
        ],
        "non_matches": [
            "User_Name1",
            "username@foo.com",
            "user.name@mail.foo.com"
        ],
        "stress_tests": []
    },
    {
        "id": 138,
        "expression": "^(?:(?:31(\\/|-|\\.)(?:0?[13578]|1[02]))\\1|(?:(?:29|30)(\\/|-|\\.)(?:0?[1,3-9]|1[0-2])\\2))(?:(?:1[6-9]|[2-9]\\d)?\\d{2})$|^(?:29(\\/|-|\\.)0?2\\3(?:(?:(?:1[6-9]|[2-9]\\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00))))$|^(?:0?[1-9]|1\\d|2[0-8])(\\/|-|\\.)(?:(?:0?[1-9])|(?:1[0-2]))\\4(?:(?:1[6-9]|[2-9]\\d)?\\d{2})$",
        "raw_prompt": "This expression validates dates in the ITALIAN d/m/y format from 1/1/1600 - 31/12/9999. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00 since it could be any century (1900, 2000, 2100). Days and months must be 1 or 2 digits and may have leading zeros. Years must be 2 or 4 digit years. 4 digit years must be between 1600 and 9999. Date separator may be a slash (/), dash (-), or period (.)\nThanks to Michael Ash for US Version",
        "refined_prompt": "\nMatch examples:\n- \"29/02/1972\"\n- \"5-9-98\"\n- \"10-11-2002\"\nNon-match examples:\n- \"29/02/2003\"\n- \"12/13/2002\"",
        "matches": [
            "29/02/1972",
            "5-9-98",
            "10-11-2002"
        ],
        "non_matches": [
            "29/02/2003",
            "12/13/2002",
            "1-1-1500"
        ],
        "stress_tests": []
    },
    {
        "id": 139,
        "expression": "^\\d{0,2}(\\.\\d{1,2})?$",
        "raw_prompt": "This regular expression validates that the data entered is a number with a maximum of two integers and two decimals and a minimum of one integer or one decimal.",
        "refined_prompt": "\nMatch examples:\n- \"99.99\"\n- \"99\"\n- \".99\"\nNon-match examples:\n- \"999.999\"\n- \"999\"",
        "matches": [
            "99.99",
            "99",
            ".99"
        ],
        "non_matches": [
            "999.999",
            "999",
            ".999"
        ],
        "stress_tests": []
    },
    {
        "id": 140,
        "expression": "^(http|https|ftp)\\://[a-zA-Z0-9\\-\\.]+\\.[a-zA-Z]{2,3}(:[a-zA-Z0-9]*)?/?([a-zA-Z0-9\\-\\._\\?\\,\\'/\\\\\\+&amp;%\\$#\\=~])*[^\\.\\,\\)\\(\\s]$",
        "raw_prompt": "This Regex (can be used e.g. in PHP with eregi) will match any valid URL. Unlike the other exapmles here, it will NOT match a valid URL ending with a dot or bracket. This is important if you use this regex to find and &quot;activate&quot; Links in an Text",
        "refined_prompt": "\nMatch examples:\n- \"https://www.restrictd.com/~myhome/\"\nNon-match examples:\n- \"http://www.krumedia.com.\"\n- \"(http://www.krumedia.com)\"",
        "matches": [
            "https://www.restrictd.com/~myhome/"
        ],
        "non_matches": [
            "http://www.krumedia.com.",
            "(http://www.krumedia.com)",
            "http://www.krumedia.com,"
        ],
        "stress_tests": []
    },
    {
        "id": 141,
        "expression": "^([0-9a-fA-F][0-9a-fA-F]:){5}([0-9a-fA-F][0-9a-fA-F])$",
        "raw_prompt": "This will grep for a valid MAC address , with colons seperating octets. It will ignore strings too short or long, or with invalid characters. It will accept mixed case hexadecimal. Use extended grep.",
        "refined_prompt": "\nMatch examples:\n- \"01:23:45:67:89:ab\"\n- \"01:23:45:67:89:AB\"\n- \"fE:dC:bA:98:76:54\"\nNon-match examples:\n- \"01:23:45:67:89:ab:cd\"\n- \"01:23:45:67:89:Az\"",
        "matches": [
            "01:23:45:67:89:ab",
            "01:23:45:67:89:AB",
            "fE:dC:bA:98:76:54"
        ],
        "non_matches": [
            "01:23:45:67:89:ab:cd",
            "01:23:45:67:89:Az",
            "01:23:45:56:"
        ],
        "stress_tests": []
    },
    {
        "id": 142,
        "expression": "^100$|^[0-9]{1,2}$|^[0-9]{1,2}\\,[0-9]{1,3}$",
        "raw_prompt": "Percentage with 3 number after comma.",
        "refined_prompt": "\nMatch examples:\n- \"12,654\"\n- \"1,987\"\nNon-match examples:\n- \"128,2\"\n- \"12,\"",
        "matches": [
            "12,654",
            "1,987"
        ],
        "non_matches": [
            "128,2",
            "12,"
        ],
        "stress_tests": []
    },
    {
        "id": 143,
        "expression": "^(([0-2]\\d|[3][0-1])\\/([0]\\d|[1][0-2])\\/[2][0]\\d{2})$|^(([0-2]\\d|[3][0-1])\\/([0]\\d|[1][0-2])\\/[2][0]\\d{2}\\s([0-1]\\d|[2][0-3])\\:[0-5]\\d\\:[0-5]\\d)$",
        "raw_prompt": "Correct French DateTime(DD/MM/YYYY OR DD/MM/YYYY HH:MM:SS)",
        "refined_prompt": "\nMatch examples:\n- \"12/01/2002\"\n- \"12/01/2002 12:32:10\"\nNon-match examples:\n- \"32/12/2002\"\n- \"12/13/2001\"",
        "matches": [
            "12/01/2002",
            "12/01/2002 12:32:10"
        ],
        "non_matches": [
            "32/12/2002",
            "12/13/2001",
            "12/02/06"
        ],
        "stress_tests": []
    },
    {
        "id": 144,
        "expression": "^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?!.*\\s).{4,8}$",
        "raw_prompt": "Password expresion that requires one lower case letter, one upper case letter, one digit, 6-13 length, and no spaces. This is merely an extension of a previously posted expression by Steven Smith (ssmith@aspalliance.com) . The no spaces is new.",
        "refined_prompt": "\nMatch examples:\n- \"1agdA*$#\"\n- \"1agdA*$#\"\n- \"1agdA*$#\"\nNon-match examples:\n- \"wyrn%@*&amp;$# f\"\n- \"mbndkfh782\"",
        "matches": [
            "1agdA*$#",
            "1agdA*$#",
            "1agdA*$#"
        ],
        "non_matches": [
            "wyrn%@*&amp;$# f",
            "mbndkfh782",
            "BNfhjdhfjd&amp;*)%#$)"
        ],
        "stress_tests": []
    },
    {
        "id": 145,
        "expression": "^([a-zA-Z0-9][-a-zA-Z0-9]*[a-zA-Z0-9]\\.)+([a-zA-Z0-9]{3,5})$",
        "raw_prompt": "Host/Domain name validation for perl.\nShould be combined with a check for\nlength &lt;= 63 characters and that $2\nis in a list of top-level domains.",
        "refined_prompt": "\nMatch examples:\n- \"freshmeat.net\"\n- \"123.com\"\n- \"TempLate-toolkKt.orG\"\nNon-match examples:\n- \"-dog.com\"\n- \"?boy.net\"",
        "matches": [
            "freshmeat.net",
            "123.com",
            "TempLate-toolkKt.orG"
        ],
        "non_matches": [
            "-dog.com",
            "?boy.net",
            "this.domain"
        ],
        "stress_tests": []
    },
    {
        "id": 146,
        "expression": "^[^']*$",
        "raw_prompt": "This one matches all strings that do not contain the single quotation mark (').",
        "refined_prompt": "\nMatch examples:\n- \"asljas\"\n- \"%/&amp;89uhuhadjkh\"\n- \"&quot;hi there!&quot;\"\nNon-match examples:\n- \"'hi there!'\"\n- \"It's 9 o'clock\"",
        "matches": [
            "asljas",
            "%/&amp;89uhuhadjkh",
            "&quot;hi there!&quot;"
        ],
        "non_matches": [
            "'hi there!'",
            "It's 9 o'clock",
            "'''''"
        ],
        "stress_tests": []
    },
    {
        "id": 147,
        "expression": "^([1-9]|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])$",
        "raw_prompt": "This validates a number between 1 and 255. Could be modified to IP, or just to verify a number in a range.",
        "refined_prompt": "\nMatch examples:\n- \"1\"\n- \"108\"\n- \"255\"\nNon-match examples:\n- \"01\"\n- \"256\"",
        "matches": [
            "1",
            "108",
            "255"
        ],
        "non_matches": [
            "01",
            "256"
        ],
        "stress_tests": []
    },
    {
        "id": 148,
        "expression": "^((https?|ftp)\\://((\\[?(\\d{1,3}\\.){3}\\d{1,3}\\]?)|(([-a-zA-Z0-9]+\\.)+[a-zA-Z]{2,4}))(\\:\\d+)?(/[-a-zA-Z0-9._?,'+&amp;%$#=~\\\\]+)*/?)$",
        "raw_prompt": "Using other regular experssions from this page, combining others for email addresses, and mixing in my own ideas - I came up with this regular expression. Can be used to validate input into a database.",
        "refined_prompt": "\nMatch examples:\n- \"http://207.68.172.254/home.ashx\"\n- \"ftp://ftp.netscape.com/\"\n- \"https://www.brinkster.com/login.asp\"\nNon-match examples:\n- \"htp://mistake.com/\"\n- \"http://www_address.com/\"",
        "matches": [
            "http://207.68.172.254/home.ashx",
            "ftp://ftp.netscape.com/",
            "https://www.brinkster.com/login.asp"
        ],
        "non_matches": [
            "htp://mistake.com/",
            "http://www_address.com/",
            "ftp://www.files.com/file with spaces.txt"
        ],
        "stress_tests": []
    },
    {
        "id": 149,
        "expression": "^[0-9](\\.[0-9]+)?$",
        "raw_prompt": "matches non-negative decimal floating points numbers less than 10",
        "refined_prompt": "\nMatch examples:\n- \"1.2345\"\n- \"0.00001\"\n- \"7\"\nNon-match examples:\n- \"12.2\"\n- \"1.10.1\"",
        "matches": [
            "1.2345",
            "0.00001",
            "7"
        ],
        "non_matches": [
            "12.2",
            "1.10.1",
            "15.98"
        ],
        "stress_tests": []
    },
    {
        "id": 153,
        "expression": "^((((31\\/(0?[13578]|1[02]))|((29|30)\\/(0?[1,3-9]|1[0-2])))\\/(1[6-9]|[2-9]\\d)?\\d{2})|(29\\/0?2\\/(((1[6-9]|[2-9]\\d)?(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))))|(0?[1-9]|1\\d|2[0-8])\\/((0?[1-9])|(1[0-2]))\\/((1[6-9]|[2-9]\\d)?\\d{2})) (20|21|22|23|[0-1]?\\d):[0-5]?\\d:[0-5]?\\d$",
        "raw_prompt": "this expression validates a date-time field in European d/m/y h:m:s format. It is a european variation of Michael Ash's date-validation expression in this library.\nThe days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00",
        "refined_prompt": "\nMatch examples:\n- \"29/02/2004 20:15:27\"\n- \"29/2/04 8:9:5\"\n- \"31/3/2004 9:20:17\"\nNon-match examples:\n- \"29/02/2003 20:15:15\"\n- \"2/29/04 20:15:15\"",
        "matches": [
            "29/02/2004 20:15:27",
            "29/2/04 8:9:5",
            "31/3/2004 9:20:17"
        ],
        "non_matches": [
            "29/02/2003 20:15:15",
            "2/29/04 20:15:15",
            "31/3/4 9:20:17"
        ],
        "stress_tests": []
    },
    {
        "id": 155,
        "expression": "(^([0-9]|[0-1][0-9]|[2][0-3]):([0-5][0-9])(\\s{0,1})(AM|PM|am|pm|aM|Am|pM|Pm{2,2})$)|(^([0-9]|[1][0-9]|[2][0-3])(\\s{0,1})(AM|PM|am|pm|aM|Am|pM|Pm{2,2})$)",
        "raw_prompt": "Validate \u201cTime\u201d Data to Work with SQL Server\nThis is a fix (I hope) for a problem with the original expression. It originally allowed any combination of am or pm. For example: ma, aa, mm, mp, etc.",
        "refined_prompt": "\nMatch examples:\n- \"8am\"\n- \"8 am\"\n- \"8:00 am\"\nNon-match examples:\n- \"8a\"\n- \"8 a\"",
        "matches": [
            "8am",
            "8 am",
            "8:00 am"
        ],
        "non_matches": [
            "8a",
            "8 a",
            "8:00 a"
        ],
        "stress_tests": []
    },
    {
        "id": 156,
        "expression": "(?!^0*$)(?!^0*\\.0*$)^\\d{1,5}(\\.\\d{1,3})?$",
        "raw_prompt": "This regular expression validates a number NOT 0, with no more than 5 places ahead and 3 places behind the decimal point.",
        "refined_prompt": "\nMatch examples:\n- \"1\"\n- \"12345.123\"\n- \"0.5\"\nNon-match examples:\n- \"0\"\n- \"0.0\"",
        "matches": [
            "1",
            "12345.123",
            "0.5"
        ],
        "non_matches": [
            "0",
            "0.0",
            "123456.1234"
        ],
        "stress_tests": []
    },
    {
        "id": 158,
        "expression": "@{2}((\\S)+)@{2}",
        "raw_prompt": "This will match results in a template situation. For example:\ntemplate reads\nDear @@Name@@,\n....\nwould become\nDear John,\nIf you dont want to use the @@ change the @ to what ever characters you want.",
        "refined_prompt": "\nMatch examples:\n- \"@@test@@\"\n- \"@@name@@\"\n- \"@@2342@@\"\nNon-match examples:\n- \"@test@\"\n- \"@@na me@@\"",
        "matches": [
            "@@test@@",
            "@@name@@",
            "@@2342@@"
        ],
        "non_matches": [
            "@test@",
            "@@na me@@",
            "@@ name@@"
        ],
        "stress_tests": []
    },
    {
        "id": 159,
        "expression": "([0-1][0-9]|2[0-3]):[0-5][0-9]",
        "raw_prompt": "Validate an hour entry to be between 00:00 and 23:59",
        "refined_prompt": "\nMatch examples:\n- \"00:00\"\n- \"13:59\"\n- \"23:59\"\nNon-match examples:\n- \"24:00\"\n- \"23:60\"",
        "matches": [
            "00:00",
            "13:59",
            "23:59"
        ],
        "non_matches": [
            "24:00",
            "23:60"
        ],
        "stress_tests": []
    },
    {
        "id": 161,
        "expression": "[A-Z][a-z]+",
        "raw_prompt": "This expression was developed to match the Title cased words within a Camel cased variable name. So it will match 'First' and 'Name' within 'strFirstName'.",
        "refined_prompt": "\nMatch examples:\n- \"strFirstName\"\n- \"intAgeInYears\"\n- \"Where the Wild Things Are\"\nNon-match examples:\n- \"123\"\n- \"abc\"",
        "matches": [
            "strFirstName",
            "intAgeInYears",
            "Where the Wild Things Are"
        ],
        "non_matches": [
            "123",
            "abc",
            "this has no caps in it"
        ],
        "stress_tests": []
    },
    {
        "id": 162,
        "expression": "^[+-]?([0-9]*\\.?[0-9]+|[0-9]+\\.?[0-9]*)([eE][+-]?[0-9]+)?$",
        "raw_prompt": "A regular expression that matches numbers. Integers or decimal numbers with or without the exponential form.",
        "refined_prompt": "\nMatch examples:\n- \"23\"\n- \"-17.e23\"\n- \"+.23e+2\"\nNon-match examples:\n- \"+.e2\"\n- \"23.17.5\"",
        "matches": [
            "23",
            "-17.e23",
            "+.23e+2"
        ],
        "non_matches": [
            "+.e2",
            "23.17.5",
            "10e2.0"
        ],
        "stress_tests": []
    },
    {
        "id": 163,
        "expression": "^([1-zA-Z0-1@.\\s]{1,255})$",
        "raw_prompt": "A general string validation to insure no malicious code is being passed through user input. General enough too allow email address, names, address, passwords, so on. Disallows \u2018,\\*&amp;$&lt;&gt; or other characters that could cause issues.",
        "refined_prompt": "\nMatch examples:\n- \"email@email.com\"\n- \"My Name\"\n- \"asdf12df\"\nNon-match examples:\n- \"\u2018,\\*&amp;$&lt;&gt;\"\n- \"1001' string\"",
        "matches": [
            "email@email.com",
            "My Name",
            "asdf12df"
        ],
        "non_matches": [
            "\u2018,\\*&amp;$&lt;&gt;",
            "1001' string"
        ],
        "stress_tests": []
    },
    {
        "id": 166,
        "expression": "^(?:(?:(?:(?:(?:1[6-9]|[2-9]\\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00)))(\\/|-|\\.)(?:0?2\\1(?:29)))|(?:(?:(?:1[6-9]|[2-9]\\d)?\\d{2})(\\/|-|\\.)(?:(?:(?:0?[13578]|1[02])\\2(?:31))|(?:(?:0?[1,3-9]|1[0-2])\\2(29|30))|(?:(?:0?[1-9])|(?:1[0-2]))\\2(?:0?[1-9]|1\\d|2[0-8]))))$",
        "raw_prompt": "This expression validates dates in the y/m/d format from 1600/1/1 - 9999/12/31. Follows the same validation rules for dates as my other date validator (m/d/y format) located in this library.",
        "refined_prompt": "\nMatch examples:\n- \"04/2/29\"\n- \"2002-4-30\"\n- \"02.10.31\"\nNon-match examples:\n- \"2003/2/29\"\n- \"02.4.31\"",
        "matches": [
            "04/2/29",
            "2002-4-30",
            "02.10.31"
        ],
        "non_matches": [
            "2003/2/29",
            "02.4.31",
            "00/00/00"
        ],
        "stress_tests": []
    },
    {
        "id": 169,
        "expression": "([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})",
        "raw_prompt": "Checks for Date in the typical MySQL DB Format. Not mutch but simple to for converting to German date format:\n$date = &quot;2003-12-03&quot;;\nif (ereg (&quot;([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})&quot;, $date, $regs))\n{\necho &quot;$regs[3].$regs[2].$regs[1]&quot;; // prints 03.12.2003\n}",
        "refined_prompt": "\nMatch examples:\n- \"2002-11-03\"\n- \"2007-17-08\"\n- \"9999-99-99\"\nNon-match examples:\n- \"2002/17/18\"\n- \"2002.18.45\"",
        "matches": [
            "2002-11-03",
            "2007-17-08",
            "9999-99-99"
        ],
        "non_matches": [
            "2002/17/18",
            "2002.18.45",
            "18.45.2002"
        ],
        "stress_tests": []
    },
    {
        "id": 170,
        "expression": "^(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])$",
        "raw_prompt": "This matches an IP address, putting each number in its own group that can be retrieved by number. If you do not care about capturing the numbers, then you can make this shorter by putting everything after ^ until immediately after the first \\. in a group ( ) with a {3} after it. Then put the number matching regex in once more.\nIt only permits numbers in the range 0-255.",
        "refined_prompt": "\nMatch examples:\n- \"0.0.0.0\"\n- \"255.255.255.02\"\n- \"192.168.0.136\"\nNon-match examples:\n- \"256.1.3.4\"\n- \"023.44.33.22\"",
        "matches": [
            "0.0.0.0",
            "255.255.255.02",
            "192.168.0.136"
        ],
        "non_matches": [
            "256.1.3.4",
            "023.44.33.22",
            "10.57.98.23."
        ],
        "stress_tests": []
    },
    {
        "id": 172,
        "expression": "^\\$?([1-9]{1}[0-9]{0,2}(\\,[0-9]{3})*(\\.[0-9]{0,2})?|[1-9]{1}[0-9]{0,}(\\.[0-9]{0,2})?|0(\\.[0-9]{0,2})?|(\\.[0-9]{1,2})?)$",
        "raw_prompt": "Many currency expresssions allow leading zeros, thus $01.40 passes thru them. This expression kills them, except for 0 in the one's column. Works with or without commas and/or dollar sign. Decimals not mandatory, unless no zero in ones column and decimal point is placed. Allows $0.00 and .0 Keywords: money dollar currency",
        "refined_prompt": "\nMatch examples:\n- \"$1,234.50\"\n- \"$0.70\"\n- \".7\"\nNon-match examples:\n- \"$0,123.50\"\n- \"$00.5\"",
        "matches": [
            "$1,234.50",
            "$0.70",
            ".7"
        ],
        "non_matches": [
            "$0,123.50",
            "$00.5"
        ],
        "stress_tests": []
    },
    {
        "id": 173,
        "expression": "^(((((0[1-9])|(1\\d)|(2[0-8]))-((0[1-9])|(1[0-2])))|((31-((0[13578])|(1[02])))|((29|30)-((0[1,3-9])|(1[0-2])))))-((20[0-9][0-9]))|(29-02-20(([02468][048])|([13579][26]))))$",
        "raw_prompt": "This expression validates a date field in the European DD-MM-YYYY format. Days are validate for the given month and year.",
        "refined_prompt": "\nMatch examples:\n- \"05-01-2002\"\n- \"29-02-2004\"\n- \"31-12-2002\"\nNon-match examples:\n- \"1-1-02\"\n- \"29-02-2002\"",
        "matches": [
            "05-01-2002",
            "29-02-2004",
            "31-12-2002"
        ],
        "non_matches": [
            "1-1-02",
            "29-02-2002",
            "31-11-2002"
        ],
        "stress_tests": []
    },
    {
        "id": 174,
        "expression": "^\\d*[0-9](|.\\d*[0-9]|,\\d*[0-9])?$",
        "raw_prompt": "This is permit all decimal number, exclude all alphanumeric caracter",
        "refined_prompt": "\nMatch examples:\n- \"123456.123456\"\n- \"123456,123456\"\n- \"123456\"\nNon-match examples:\n- \"123a.123\"\n- \"123a,123\"",
        "matches": [
            "123456.123456",
            "123456,123456",
            "123456"
        ],
        "non_matches": [
            "123a.123",
            "123a,123",
            "a"
        ],
        "stress_tests": []
    },
    {
        "id": 176,
        "expression": "^([A-Z]{1,2}[0-9]{1,2}|[A-Z]{3}|[A-Z]{1,2}[0-9][A-Z])( |-)[0-9][A-Z]{2}",
        "raw_prompt": "Checks whether the string specified is in the same format as the UK postcode format defined on:\nhttp://www.magma.ca/~djcl/postcd.txt\nIt allows:\nA = Letter\nN = Number\nAN NAA, ANA NAA, ANN NAA, AAN NAA, AAA NAA (rare), AANN NAA, AANA NAA\nIt gives the option to have the two parts of the uk postcode to be separated by a space or a hyphen.\n(restriction is set to all-capitals)",
        "refined_prompt": "\nMatch examples:\n- \"AA11 1AA\"\n- \"AA1A 1AA\"\n- \"A11-1AA\"\nNon-match examples:\n- \"111 AAA\"\n- \"1AAA 1AA\"",
        "matches": [
            "AA11 1AA",
            "AA1A 1AA",
            "A11-1AA"
        ],
        "non_matches": [
            "111 AAA",
            "1AAA 1AA",
            "A1AA 1AA"
        ],
        "stress_tests": []
    },
    {
        "id": 183,
        "expression": "<img([^>]*[^/])>",
        "raw_prompt": "Use this along with this replacement string &lt;img\\1 /&gt; to convert image tags to XHTML compliant image tags.",
        "refined_prompt": "\nMatch examples:\n- \"<img src=\"bob\">\"\nNon-match examples:\n- \"<img src=\"bob\" />\"",
        "matches": [
            "<img src=\"bob\">"
        ],
        "non_matches": [
            "<img src=\"bob\" />"
        ],
        "stress_tests": []
    },
    {
        "id": 184,
        "expression": "^((0?[1-9])|((1|2)[0-9])|30|31)$",
        "raw_prompt": "matches any day of\nmonth 0?1-31",
        "refined_prompt": "\nMatch examples:\n- \"01\"\n- \"12\"\n- \"31\"\nNon-match examples:\n- \"123\"\n- \"32\"",
        "matches": [
            "01",
            "12",
            "31"
        ],
        "non_matches": [
            "123",
            "32",
            "abc"
        ],
        "stress_tests": []
    },
    {
        "id": 185,
        "expression": "&lt;!--[\\s\\S]*?--&gt;",
        "raw_prompt": "Removes pesky comments and commented javascript from HTML",
        "refined_prompt": "\nMatch examples:\n- \"&lt;!-- comments --&gt;\"\n- \"&lt;!-- x = a &gt; b - 3 --&gt;\"\nNon-match examples:\n- \"&lt;COMMENTS&gt;this is a comment&lt;/COMMENTS&gt;\"",
        "matches": [
            "&lt;!-- comments --&gt;",
            "&lt;!-- x = a &gt; b - 3 --&gt;"
        ],
        "non_matches": [
            "&lt;COMMENTS&gt;this is a comment&lt;/COMMENTS&gt;"
        ],
        "stress_tests": []
    },
    {
        "id": 186,
        "expression": "&lt;/?(\\w+)(\\s+\\w+=(\\w+|&quot;[^&quot;]*&quot;|'[^']*'))*&gt;",
        "raw_prompt": "Finds any HTML tag and sub-matches properties weather it has an apposterphee, quote, or no quote/apposterphee",
        "refined_prompt": "\nMatch examples:\n- \"&lt;TD&gt;\"\n- \"&lt;TD bgColor=&quot;FFFFFF&quot;&gt;\"\n- \"&lt;/TD&gt;\"\nNon-match examples:\n- \"No Tag Here ...\"",
        "matches": [
            "&lt;TD&gt;",
            "&lt;TD bgColor=&quot;FFFFFF&quot;&gt;",
            "&lt;/TD&gt;"
        ],
        "non_matches": [
            "No Tag Here ..."
        ],
        "stress_tests": []
    },
    {
        "id": 187,
        "expression": "^\\{?[a-fA-F\\d]{8}-([a-fA-F\\d]{4}-){3}[a-fA-F\\d]{12}\\}?$",
        "raw_prompt": "Validates a GUID with and without brackets. 8,4,4,4,12 hex characters seperated by dashes.",
        "refined_prompt": "\nMatch examples:\n- \"{e02ff0e4-00ad-090A-c030-0d00a0008ba0}\"\n- \"e02ff0e4-00ad-090A-c030-0d00a0008ba0\"\nNon-match examples:\n- \"0xe02ff0e400ad090Ac0300d00a0008ba0\"",
        "matches": [
            "{e02ff0e4-00ad-090A-c030-0d00a0008ba0}",
            "e02ff0e4-00ad-090A-c030-0d00a0008ba0"
        ],
        "non_matches": [
            "0xe02ff0e400ad090Ac0300d00a0008ba0"
        ],
        "stress_tests": []
    },
    {
        "id": 188,
        "expression": "^([a-zA-Z0-9@*#]{8,15})$",
        "raw_prompt": "Password matching expression. Match all alphanumeric character and predefined wild characters. Password must consists of at least 8 characters and not more than 15 characters.",
        "refined_prompt": "\nMatch examples:\n- \"@12X*567\"\n- \"1#Zv96g@*Yfasd4\"\n- \"#67jhgt@erd\"\nNon-match examples:\n- \"$12X*567\"\n- \"1#Zv_96\"",
        "matches": [
            "@12X*567",
            "1#Zv96g@*Yfasd4",
            "#67jhgt@erd"
        ],
        "non_matches": [
            "$12X*567",
            "1#Zv_96",
            "+678jhgt@erd"
        ],
        "stress_tests": []
    },
    {
        "id": 191,
        "expression": "(\\d*)'*-*(\\d*)/*(\\d*)&quot;",
        "raw_prompt": "This regular expression is for parsing feet and inches measurements.",
        "refined_prompt": "\nMatch examples:\n- \"5'-3/16&quot;\"\n- \"1'-2&quot;\"\n- \"5/16&quot;\"\nNon-match examples:\n- \"1 3/16\"",
        "matches": [
            "5'-3/16&quot;",
            "1'-2&quot;",
            "5/16&quot;"
        ],
        "non_matches": [
            "1 3/16"
        ],
        "stress_tests": []
    },
    {
        "id": 192,
        "expression": "^(/w|/W|[^<>+?$%{}&])+$",
        "raw_prompt": "simple expression for excluding a given list of characters. simply change the contents of [^] to suite your needs. for example ^(/w|/W|[^&lt;&gt;])+$ would allow everything except the characters &lt; and &gt;.",
        "refined_prompt": "\nMatch examples:\n- \"John Doe Sr.\"\n- \"100 Elm St., Suite 25\"\n- \"Valerie's Gift Shop\"\nNon-match examples:\n- \"<h1>Hey</h1>\"",
        "matches": [
            "John Doe Sr.",
            "100 Elm St., Suite 25",
            "Valerie's Gift Shop"
        ],
        "non_matches": [
            "<h1>Hey</h1>"
        ],
        "stress_tests": []
    },
    {
        "id": 194,
        "expression": "&amp;lt;/?([a-zA-Z][-A-Za-z\\d\\.]{0,71})(\\s+(\\S+)(\\s*=\\s*([-\\w\\.]{1,1024}|&amp;quot;[^&amp;quot;]{0,1024}&amp;quot;|'[^']{0,1024}'))?)*\\s*&amp;gt;",
        "raw_prompt": "Searches for tags and there atributes according to the HTML 2.0 specification to limit length of tags to 72 characters, and length of attribute values to 1024 characters.",
        "refined_prompt": "\nMatch examples:\n- \"&amp;lt;IMG src='stars.gif' alt=&amp;quot;space&amp;quot; height=1&amp;gt;\"\nNon-match examples:\n- \"this is not a tag\"",
        "matches": [
            "&amp;lt;IMG src='stars.gif' alt=&amp;quot;space&amp;quot; height=1&amp;gt;"
        ],
        "non_matches": [
            "this is not a tag"
        ],
        "stress_tests": []
    },
    {
        "id": 195,
        "expression": "<[a-zA-Z][^>]*\\son\\w+=(\\w+|'[^']*'|\"[^\"]*\")[^>]*>",
        "raw_prompt": "Find HTML tags that have javascript events attached to them.",
        "refined_prompt": "\nMatch examples:\n- \"<IMG onmouseover=\"window.close()\">\"\nNon-match examples:\n- \"<IMG src=\"star.gif\">\"",
        "matches": [
            "<IMG onmouseover=\"window.close()\">"
        ],
        "non_matches": [
            "<IMG src=\"star.gif\">"
        ],
        "stress_tests": []
    },
    {
        "id": 196,
        "expression": "((&quot;|')[a-z0-9\\/\\.\\?\\=\\&amp;]*(\\.htm|\\.asp|\\.php|\\.jsp)[a-z0-9\\/\\.\\?\\=\\&amp;]*(&quot;|'))|(href=*?[a-z0-9\\/\\.\\?\\=\\&amp;&quot;']*)",
        "raw_prompt": "Will locate an URL in a webpage.\nIt'll search in 2 ways - first it will try to locate a href=, and then go to the end of the link. If there is nu href=, it will search for the end of the file instead (.asp, .htm and so on), and then take the data between the &quot;xxxxxx&quot; or 'xxxxxx'",
        "refined_prompt": "\nMatch examples:\n- \"href=&quot;produktsida.asp?kategori2=218&quot;\"\n- \"href=&quot;NuclearTesting.htm&quot;\"\nNon-match examples:\n- \"U Suck\"",
        "matches": [
            "href=&quot;produktsida.asp?kategori2=218&quot;",
            "href=&quot;NuclearTesting.htm&quot;"
        ],
        "non_matches": [
            "U Suck"
        ],
        "stress_tests": []
    },
    {
        "id": 197,
        "expression": "^((0[1-9])|(1[0-2]))\\/(\\d{4})$",
        "raw_prompt": "This regular expressions matches dates in the format MM/YYYY where MM can be 01 to 12 and YYYY is always 4 digits long.",
        "refined_prompt": "\nMatch examples:\n- \"12/2002\"\n- \"11/1900\"\n- \"02/1977\"\nNon-match examples:\n- \"1/1977\"\n- \"00/000\"",
        "matches": [
            "12/2002",
            "11/1900",
            "02/1977"
        ],
        "non_matches": [
            "1/1977",
            "00/000",
            "15/2002"
        ],
        "stress_tests": []
    },
    {
        "id": 202,
        "expression": "^[A-Z]{2}[0-9]{6}[A-DFM]{1}$",
        "raw_prompt": "UK National Insurance Number (NINO) validation. (The following modifications have been made: Only A to D are permitted as the last letter, and all letters should be in uppercase. For temporary numbers F and M are permitted for female and male holders.)",
        "refined_prompt": "\nMatch examples:\n- \"AB123456D\"\n- \"AB123456F\"\n- \"AB123456M\"\nNon-match examples:\n- \"AB123456E\"\n- \"ab123456d\"",
        "matches": [
            "AB123456D",
            "AB123456F",
            "AB123456M"
        ],
        "non_matches": [
            "AB123456E",
            "ab123456d"
        ],
        "stress_tests": []
    },
    {
        "id": 203,
        "expression": "^[A-Z]{1,2}[1-9][0-9]?[A-Z]? [0-9][A-Z]{2,}|GIR 0AA$",
        "raw_prompt": "Matches UK postcodes according to the following rules 1. LN NLL eg N1 1AA 2. LLN NLL eg SW4 0QL 3. LNN NLL eg M23 4PJ 4. LLNN NLL eg WS14 0JT 5. LLNL NLL eg SW1N 4TB 6. LNL NLL eg W1C 8LQ. Modifications: 1) Doesn't allow leading zeros in first part (outward) eg BT01 3RT is incorrect; it should be BT1 3RT. 2) Only allows uppercase letters, which is the preference of the UK Post Office. 3) Permits the only postcode to break the rules - GIR 0AA (for the old Girobank, now Alliance &amp; Leicester bank, address)",
        "refined_prompt": "\nMatch examples:\n- \"G1 1AA\"\n- \"GIR 0AA\"\n- \"SW1 1ZZ\"\nNon-match examples:\n- \"BT01 3RT\"\n- \"G111 1AA\"",
        "matches": [
            "G1 1AA",
            "GIR 0AA",
            "SW1 1ZZ"
        ],
        "non_matches": [
            "BT01 3RT",
            "G111 1AA"
        ],
        "stress_tests": []
    },
    {
        "id": 204,
        "expression": "^([0]\\d|[1][0-2])\\/([0-2]\\d|[3][0-1])\\/([2][01]|[1][6-9])\\d{2}(\\s([0-1]\\d|[2][0-3])(\\:[0-5]\\d){1,2})?$",
        "raw_prompt": "This is a regular expression to validate a date string in &quot;MM/DD/YYYY&quot; format, a date time string in &quot;MM/DD/YYYY HH:MM&quot; or a date time string in &quot;MM/DD/YYYY HH:MM:SS&quot; format.\nIt can validate date from 1600 to 2199.",
        "refined_prompt": "\nMatch examples:\n- \"12/30/2002\"\n- \"01/12/1998 13:30\"\n- \"01/28/2002 22:35:00\"\nNon-match examples:\n- \"13/30/2002\"\n- \"01/12/1998 24:30\"",
        "matches": [
            "12/30/2002",
            "01/12/1998 13:30",
            "01/28/2002 22:35:00"
        ],
        "non_matches": [
            "13/30/2002",
            "01/12/1998 24:30",
            "01/28/2002 22:35:64"
        ],
        "stress_tests": []
    },
    {
        "id": 207,
        "expression": "^([0]\\d|[1][0-2])\\/([0-2]\\d|[3][0-1])\\/([2][01]|[1][6-9])\\d{2}(\\s([0]\\d|[1][0-2])(\\:[0-5]\\d){1,2})*\\s*([aApP][mM]{0,2})?$",
        "raw_prompt": "This is a combination of a few regular expressions found on this site. It allows for a flexible date and time combination, but requires a 12-hour clock (am/pm). Many versions of the am/pm are supported.",
        "refined_prompt": "\nMatch examples:\n- \"12/31/2002\"\n- \"12/31/2002 08:00\"\n- \"12/31/2002 08:00 AM\"\nNon-match examples:\n- \"12/31/02\"\n- \"12/31/2002 14:00\"",
        "matches": [
            "12/31/2002",
            "12/31/2002 08:00",
            "12/31/2002 08:00 AM"
        ],
        "non_matches": [
            "12/31/02",
            "12/31/2002 14:00"
        ],
        "stress_tests": []
    },
    {
        "id": 208,
        "expression": "<blockquote>(?:\\s*([^<]+)<br>\\s*)+</blockquote>",
        "raw_prompt": "Use this regular expression pattern to get the string1, string2, string3 .... from &lt;blockquote&gt;string1&lt;br&gt;string2&lt;br&gt;string3&lt;br&gt;&lt;/blockquote&gt;",
        "refined_prompt": "\nMatch examples:\n- \"<blockquote>string1<br>string2<br>string3<br></blockquote>\"\nNon-match examples:\n- \"..\"",
        "matches": [
            "<blockquote>string1<br>string2<br>string3<br></blockquote>"
        ],
        "non_matches": [
            ".."
        ],
        "stress_tests": []
    },
    {
        "id": 209,
        "expression": "^((0?[13578]|10|12)(-|\\/)(([1-9])|(0[1-9])|([12])([0-9]?)|(3[01]?))(-|\\/)((19)([2-9])(\\d{1})|(20)([01])(\\d{1})|([8901])(\\d{1}))|(0?[2469]|11)(-|\\/)(([1-9])|(0[1-9])|([12])([0-9]?)|(3[0]?))(-|\\/)((19)([2-9])(\\d{1})|(20)([01])(\\d{1})|([8901])(\\d{1})))$",
        "raw_prompt": "improved date validation M/D/YY or M/D/YYYY or MM/DD/YYYY or MM/DD/YY: 1/1/1920 through 12/31/2019; Feb 29 and 30 always allowed, deal with it",
        "refined_prompt": "\nMatch examples:\n- \"1/2/03\"\n- \"02/30/1999\"\n- \"3/04/00\"\nNon-match examples:\n- \"3/4/2020\"\n- \"3/4/1919\"",
        "matches": [
            "1/2/03",
            "02/30/1999",
            "3/04/00"
        ],
        "non_matches": [
            "3/4/2020",
            "3/4/1919",
            "4/31/2000"
        ],
        "stress_tests": []
    },
    {
        "id": 210,
        "expression": "&lt;/?(\\w+)(\\s*\\w*\\s*=\\s*(&quot;[^&quot;]*&quot;|'[^']'|[^&gt;]*))*|/?&gt;",
        "raw_prompt": "Matches HTML of XML tags, with or without attributes (single-, double-, or non-quoted), closing tags, or self-closing singleton tags.",
        "refined_prompt": "\nMatch examples:\n- \"&lt;font color=&quot;blue&quot;&gt;\"\n- \"&lt;/font&gt;\"\n- \"&lt;br /&gt;\"\nNon-match examples:\n- \"this is a test...\"",
        "matches": [
            "&lt;font color=&quot;blue&quot;&gt;",
            "&lt;/font&gt;",
            "&lt;br /&gt;"
        ],
        "non_matches": [
            "this is a test..."
        ],
        "stress_tests": []
    },
    {
        "id": 211,
        "expression": "^(([0]?[1-9]|1[0-2])(:)([0-5][0-9]))$",
        "raw_prompt": "This time validation expression accepts an hour between 1 and 9 (with optional leading zero) and minutes between 01 and 59. This is primarily for use with an AM/PM drop down list or radio button.",
        "refined_prompt": "\nMatch examples:\n- \"09:00\"\n- \"9:00\"\n- \"11:35\"\nNon-match examples:\n- \"13:00\"\n- \"9.00\"",
        "matches": [
            "09:00",
            "9:00",
            "11:35"
        ],
        "non_matches": [
            "13:00",
            "9.00",
            "6:60"
        ],
        "stress_tests": []
    },
    {
        "id": 212,
        "expression": "^ *(1[0-2]|[1-9]):[0-5][0-9] *(a|p|A|P)(m|M) *$",
        "raw_prompt": "validate 12-hour time with am/pm after it, with optional spaces before or after, and optionally between time and am/pm.",
        "refined_prompt": "\nMatch examples:\n- \"12:00am\"\n- \"1:00 PM\"\n- \"12:59 pm\"\nNon-match examples:\n- \"0:00\"\n- \"0:01 am\"",
        "matches": [
            "12:00am",
            "1:00 PM",
            "12:59 pm"
        ],
        "non_matches": [
            "0:00",
            "0:01 am",
            "13:00 pm"
        ],
        "stress_tests": []
    },
    {
        "id": 215,
        "expression": "^(([0]?[1-9]|[1][0-2])[\\/|\\-|\\.]([0-2]\\d|[3][0-1]|[1-9])[\\/|\\-|\\.]([2][0])?\\d{2}\\s+((([0][0-9]|[1][0-2]|[0-9])[\\:|\\-|\\.]([0-5]\\d)\\s*([aApP][mM])?)|(([0-1][0-9]|[2][0-3]|[0-9])[\\:|\\-|\\.]([0-5]\\d))))$",
        "raw_prompt": "MM-DD-20YY HH:MM AP\nMM-DD-20YY H:MM AP\nMM-DD-20YY HH:MM\nMM-DD-20YY H:MM\nMM-DD-YY HH:MM AP\nMM-DD-YY H:MM AP\nMM-DD-YY HH:MM\nMM-DD-YY H:MM\nM-D-YY HH:MM AP\nM-D-YY H:MM AP\nM-D-YY HH:MM\nM-D-YY H:MM\nwhere - can be / or - or .\nwhere : can be : or - or .\nDefinition:\n^( ;Start of Line\n([0]?[1-9]|[1][0-2]) ;00-09 or 10-12 or 1-9\n[\\/|\\-|\\.] ;/ or - or .\n([0-2]\\d|[3][0-1]|[1-9]) ;00-29 or 30-31 or 1-9\n[\\/|\\-|\\.] ;/ or - or .\n([2][0])?\\d{2} ;2000-2099 or 00-99\n\\s+ ;one or more spaces\n( ;must be either 12H notation w/AM|PM\n(\n([0][0-9]|[1][0-2]|[0-9])\n[\\:|\\-|\\.] ;: or - or .\n([0-5]\\d) ;01 thru 59\n\\s* ;zero or more spaces\n([aApP][mM])? ;nothing or AM or PM (case insensitive)\n)\n| ;or 24H notation w/out AM|PM\n(\n([0-1][0-9]|[2][0-3]|[0-9]) ;00-19 or 20-23\n[\\:|\\-|\\.] ;: or - or .\n([0-5]\\d) ;00-59\n)\n)\n)$ ;End of Line",
        "refined_prompt": "\nMatch examples:\n- \"01/01/2002 04:42\"\n- \"5-12-02 04:42 AM\"\n- \"01.01/02 04-42aM\"\nNon-match examples:\n- \"01-12-1999 4:50PM\"\n- \"01-12-2002 15:10PM\"",
        "matches": [
            "01/01/2002 04:42",
            "5-12-02 04:42 AM",
            "01.01/02 04-42aM"
        ],
        "non_matches": [
            "01-12-1999 4:50PM",
            "01-12-2002 15:10PM",
            "01-12-002 8:20PM"
        ],
        "stress_tests": []
    },
    {
        "id": 216,
        "expression": "^[1-9]{1}$|^[1-4]{1}[0-9]{1}$|^50$",
        "raw_prompt": "Match any number between 1 and 50, no characters, no empty sets, and not zero. Match numbers greater than 1 and less than 51, no spaces, no characters.",
        "refined_prompt": "\nMatch examples:\n- \"1\"\n- \"23\"\n- \"50\"\nNon-match examples:\n- \"0\"\n- \"111\"",
        "matches": [
            "1",
            "23",
            "50"
        ],
        "non_matches": [
            "0",
            "111",
            "xyz"
        ],
        "stress_tests": []
    },
    {
        "id": 217,
        "expression": "^([A-Z]{1}[a-z]{1,})$|^([A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,})$|^([A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,})$|^$",
        "raw_prompt": "Matches up to three alphabet words separated by spaces with first alphabet character of each word uppercase. Also matches empty strings.",
        "refined_prompt": "\nMatch examples:\n- \"Sacramento\"\n- \"San Francisco\"\n- \"San Luis Obispo\"\nNon-match examples:\n- \"SanFrancisco\"\n- \"SanLuisObispo\"",
        "matches": [
            "Sacramento",
            "San Francisco",
            "San Luis Obispo"
        ],
        "non_matches": [
            "SanFrancisco",
            "SanLuisObispo",
            "San francisco"
        ],
        "stress_tests": []
    },
    {
        "id": 218,
        "expression": "^([1][12]|[0]?[1-9])[\\/-]([3][01]|[12]\\d|[0]?[1-9])[\\/-](\\d{4}|\\d{2})$",
        "raw_prompt": "Matches dates with the following format\nMonth - either MM (like 01) or M (like 1) - from 1 to 12\nDay - either DD (like 01) or D ( like 1) - from 1 to 31\nYear - either YYYY ( like 1998) or YY (like 98)\nSeparater - either - or /",
        "refined_prompt": "\nMatch examples:\n- \"11-02-02\"\n- \"1-25-2002\"\n- \"01/25/2002\"\nNon-match examples:\n- \"13-02-02\"\n- \"11.02.02\"",
        "matches": [
            "11-02-02",
            "1-25-2002",
            "01/25/2002"
        ],
        "non_matches": [
            "13-02-02",
            "11.02.02",
            "11/32/2002"
        ],
        "stress_tests": []
    },
    {
        "id": 221,
        "expression": "^([ \\u00c0-\\u01ffa-zA-Z'])+$",
        "raw_prompt": "Expression to match names and dis-allow any attempts to send evil characters. In particular, it tries to allow\nnon-english names by allowing unicode characters.",
        "refined_prompt": "\nMatch examples:\n- \"Jon Doe\"\n- \"J\u00f8rn\"\n- \"Mc'Neelan\"\nNon-match examples:\n- \"Henry); hacking attempt\"",
        "matches": [
            "Jon Doe",
            "J\u00f8rn",
            "Mc'Neelan"
        ],
        "non_matches": [
            "Henry); hacking attempt"
        ],
        "stress_tests": []
    },
    {
        "id": 222,
        "expression": "(([0-1][0-9])|([2][0-3])):([0-5][0-9]):([0-5][0-9])",
        "raw_prompt": "Validates time in MySQL time format. 24 hour time colon seperated hours:minutes:seconds",
        "refined_prompt": "\nMatch examples:\n- \"09:30:00\"\n- \"17:45:20\"\n- \"23:59:59\"\nNon-match examples:\n- \"24:00:00\"",
        "matches": [
            "09:30:00",
            "17:45:20",
            "23:59:59"
        ],
        "non_matches": [
            "24:00:00"
        ],
        "stress_tests": []
    },
    {
        "id": 223,
        "expression": "^((([0]?[1-9]|1[0-2])(:|\\.)(00|15|30|45)?( )?(AM|am|aM|Am|PM|pm|pM|Pm))|(([0]?[0-9]|1[0-9]|2[0-3])(:|\\.)(00|15|30|45)?))$",
        "raw_prompt": "This expression will allow a time value with 15 minute increments. It will not accept seconds. You can use either US time or Military time format.",
        "refined_prompt": "\nMatch examples:\n- \"1:00 PM\"\n- \"6:45 am\"\n- \"17:30\"\nNon-match examples:\n- \"4:32 am\"\n- \"5:30:00 am\"",
        "matches": [
            "1:00 PM",
            "6:45 am",
            "17:30"
        ],
        "non_matches": [
            "4:32 am",
            "5:30:00 am",
            "17:01"
        ],
        "stress_tests": []
    },
    {
        "id": 224,
        "expression": "^([0]?[1-9]|[1|2][0-9]|[3][0|1])[./-]([0]?[1-9]|[1][0-2])[./-]([0-9]{4}|[0-9]{2})$",
        "raw_prompt": "Validate brazilian date formats: dd/mm/yyyy or d/m/yy or d.m.yyyy\nwith separators: . - /\nValid dates only! d (1-31)/ m (1-12)/ y (0..)\n(rizzipereira.com.br)\nFor American date format: http://www.regexlib.com/REDetails.aspx?regexp_id=932",
        "refined_prompt": "\nMatch examples:\n- \"10/03/1979\"\n- \"1-1-02\"\n- \"01.1.2003\"\nNon-match examples:\n- \"10/03/197\"\n- \"09--02--2004\"",
        "matches": [
            "10/03/1979",
            "1-1-02",
            "01.1.2003"
        ],
        "non_matches": [
            "10/03/197",
            "09--02--2004",
            "01 02 03"
        ],
        "stress_tests": []
    },
    {
        "id": 225,
        "expression": "(^\\d*\\.?\\d*[1-9]+\\d*$)|(^[1-9]+\\d*\\.\\d*$)",
        "raw_prompt": "Accepts only positive decimal values. Zero and negatvie numbers are non-matching. Allows zeros after last non-zero numeric value after decimal place for significant digits.",
        "refined_prompt": "\nMatch examples:\n- \"0.050\"\n- \"5.0000\"\n- \"5000\"\nNon-match examples:\n- \"0\"\n- \"0.0\"",
        "matches": [
            "0.050",
            "5.0000",
            "5000"
        ],
        "non_matches": [
            "0",
            "0.0",
            ".0"
        ],
        "stress_tests": []
    },
    {
        "id": 226,
        "expression": "(^-\\d*\\.?\\d*[1-9]+\\d*$)|(^-[1-9]+\\d*\\.\\d*$)",
        "raw_prompt": "Accepts only negative decimal values. Zero and positive numbers are non-matching. Allows zeros after last non-zero numeric value after decimal place for significant digits.",
        "refined_prompt": "\nMatch examples:\n- \"-0.050\"\n- \"-5.000\"\n- \"-5\"\nNon-match examples:\n- \"0\"\n- \"0.0\"",
        "matches": [
            "-0.050",
            "-5.000",
            "-5"
        ],
        "non_matches": [
            "0",
            "0.0",
            ".0"
        ],
        "stress_tests": []
    },
    {
        "id": 227,
        "expression": "^([2][0]\\d{2}\\/([0]\\d|[1][0-2])\\/([0-2]\\d|[3][0-1]))$|^([2][0]\\d{2}\\/([0]\\d|[1][0-2])\\/([0-2]\\d|[3][0-1])\\s([0-1]\\d|[2][0-3])\\:[0-5]\\d\\:[0-5]\\d)$",
        "raw_prompt": "this is a regular expression that for chinese programer!\nyyyy/mm/dd hh:mm:ss",
        "refined_prompt": "\nMatch examples:\n- \"2002/02/03\"\n- \"2002/02/03 12:12:18\"\nNon-match examples:\n- \"2002/02/36\"\n- \"02/03/2002\"",
        "matches": [
            "2002/02/03",
            "2002/02/03 12:12:18"
        ],
        "non_matches": [
            "2002/02/36",
            "02/03/2002"
        ],
        "stress_tests": []
    },
    {
        "id": 228,
        "expression": "^(\\d|,)*\\.?\\d*$",
        "raw_prompt": "Matches Numeric with Commas and a single decimal point. Also matches empty string.",
        "refined_prompt": "\nMatch examples:\n- \"1,000\"\n- \"3,000.05\"\n- \"5,000,000\"\nNon-match examples:\n- \"abc\"\n- \"$100,000\"",
        "matches": [
            "1,000",
            "3,000.05",
            "5,000,000"
        ],
        "non_matches": [
            "abc",
            "$100,000",
            "Forty"
        ],
        "stress_tests": []
    },
    {
        "id": 231,
        "expression": "^[+]?\\d*$",
        "raw_prompt": "This re was used for set numbers only!\nSomente numeros s&#227;o requeridos!",
        "refined_prompt": "\nMatch examples:\n- \"0123456789\"\n- \"1234\"\n- \"1\"\nNon-match examples:\n- \"1.0?&amp;\"\n- \"a1\"",
        "matches": [
            "0123456789",
            "1234",
            "1"
        ],
        "non_matches": [
            "1.0?&amp;",
            "a1",
            "2a-"
        ],
        "stress_tests": []
    },
    {
        "id": 233,
        "expression": "^[0-9A-Za-z_ ]+(.[jJ][pP][gG]|.[gG][iI][fF])$",
        "raw_prompt": "Matches HTML image leaf filenames.",
        "refined_prompt": "\nMatch examples:\n- \"good.gif\"\n- \"go d.GIf\"\n- \"goo_d.jPg\"\nNon-match examples:\n- \"junk\"\n- \"bad.bad.gif\"",
        "matches": [
            "good.gif",
            "go d.GIf",
            "goo_d.jPg"
        ],
        "non_matches": [
            "junk",
            "bad.bad.gif",
            "slash\\gif."
        ],
        "stress_tests": []
    },
    {
        "id": 234,
        "expression": "^([A-PR-UWYZ0-9][A-HK-Y0-9][AEHMNPRTVXY0-9]?[ABEHMNPRVWXY0-9]? {1,2}[0-9][ABD-HJLN-UW-Z]{2}|GIR 0AA)$",
        "raw_prompt": "Regular expression to match valid UK postcodes.\nIn the UK postal system not all letters are used in all positions (the same with vehicle registration plates) and there are various rules to govern this. This regex takes into account those rules.\nDetails of the rules:\nFirst half of postcode\nValid formats\n[A-Z][A-Z][0-9][A-Z]\n[A-Z][A-Z][0-9][0-9]\n[A-Z][0-9][0-9]\n[A-Z][A-Z][0-9]\n[A-Z][A-Z][A-Z]\n[A-Z][0-9][A-Z]\n[A-Z][0-9]\nExceptions\nPosition - First.\nContraint - QVX not used\nPosition - Second.\nContraint - IJZ not used except in GIR 0AA\nPosition - Third.\nConstraint - AEHMNPRTVXY only used\nPosition - Forth.\nContraint - ABEHMNPRVWXY\nSecond half of postcode\nValid formats\n[0-9][A-Z][A-Z]\nExceptions\nPosition - Second and Third.\nContraint - CIKMOV not used",
        "refined_prompt": "\nMatch examples:\n- \"DN3 6GB\"\n- \"SW42 4RG\"\n- \"GIR 0AA\"\nNon-match examples:\n- \"SEW4 5TY\"\n- \"AA2C 4FG\"",
        "matches": [
            "DN3 6GB",
            "SW42 4RG",
            "GIR 0AA"
        ],
        "non_matches": [
            "SEW4 5TY",
            "AA2C 4FG",
            "AA2 4CV"
        ],
        "stress_tests": []
    },
    {
        "id": 235,
        "expression": "^([0-1]?[0-9]|[2][0-3]):([0-5][0-9])$",
        "raw_prompt": "Accepts data of time in format h:mm and hh:mm\n^([0-1]?[0-9]|[2][0-3]):([0-5][0-9])$\nin php [0-23]:[0-59]{2} (posix)",
        "refined_prompt": "\nMatch examples:\n- \"0:00\"\n- \"23:00\"\n- \"00:59\"\nNon-match examples:\n- \"0:0\"\n- \"24:00\"",
        "matches": [
            "0:00",
            "23:00",
            "00:59"
        ],
        "non_matches": [
            "0:0",
            "24:00",
            "00:60"
        ],
        "stress_tests": []
    },
    {
        "id": 236,
        "expression": "^((0[1-9])|(1[0-2]))\\/(\\d{2})$",
        "raw_prompt": "Validates MM/YY for rough checking credit card expiration dates.",
        "refined_prompt": "\nMatch examples:\n- \"11/03\"\n- \"01/04\"\nNon-match examples:\n- \"13/03\"\n- \"10/2003\"",
        "matches": [
            "11/03",
            "01/04"
        ],
        "non_matches": [
            "13/03",
            "10/2003"
        ],
        "stress_tests": []
    },
    {
        "id": 238,
        "expression": "<script[^>]*>[\\w|\\t|\\r|\\W]*</script>",
        "raw_prompt": "this pattern can find all lines of script in HTML code from open to close tag range",
        "refined_prompt": "\nMatch examples:\n- \"<script language=javascript>document.write(\"one\");</script>\"\nNon-match examples:\n- \"--\"",
        "matches": [
            "<script language=javascript>document.write(\"one\");</script>"
        ],
        "non_matches": [
            "--"
        ],
        "stress_tests": []
    },
    {
        "id": 239,
        "expression": "(^|\\s)(00[1-9]|0[1-9]0|0[1-9][1-9]|[1-6]\\d{2}|7[0-6]\\d|77[0-2])(-?|[\\. ])([1-9]0|0[1-9]|[1-9][1-9])\\3(\\d{3}[1-9]|[1-9]\\d{3}|\\d[1-9]\\d{2}|\\d{2}[1-9]\\d)($|\\s|[;:,!\\.\\?])",
        "raw_prompt": "Incorporated other people's examples; removed extraneous parenthesis on 10/7/04. Currently the SSA site says 772 is the highest AREA number generated (http://www.ssa.gov/employer/highgroup.txt). Old expression was: (^|\\s)\\d{3}(-?|[\\. ])\\d{2}\\2\\d{4}($|\\s|[;:,!\\.\\?]). Looks for either the beginning of a line or whitespace before the beginning of the social security number, then either zero or one hyphen OR one of a period or space, then uses the \\3 to reference the value returned in the parenthesis that includes the -?|[\\. ] (basically says if the first dash, period, or space is there, then the second one is required; and if the first dash, period, or space is not there, then the second one can't be either), and finally looks for the end of a line, whitespace, or punctuation characters after the social security number.",
        "refined_prompt": "\nMatch examples:\n- \"123-45-6789\"\n- \"123 45 6789\"\n- \"123456789\"\nNon-match examples:\n- \"12345-67-890123\"\n- \"1234-56-7890\"",
        "matches": [
            "123-45-6789",
            "123 45 6789",
            "123456789"
        ],
        "non_matches": [
            "12345-67-890123",
            "1234-56-7890",
            "123-45-78901"
        ],
        "stress_tests": []
    },
    {
        "id": 241,
        "expression": "^[-+]?[1-9]\\d*\\.?[0]*$",
        "raw_prompt": "This will check if a number is an integer. Positive integers are all the whole numbers greater than zero: 1, 2, 3, 4, 5, ... . Negative integers are all the opposites of whole numbers: -1, -2, -3,-4, -5, ... . Zero is not a whole number with either a positive or negative value, and is not an interger. Null or Empty values are not intergers.",
        "refined_prompt": "\nMatch examples:\n- \"10\"\n- \"-10\"\n- \"+10.00\"\nNon-match examples:\n- \"0\"\n- \"-10.50\"",
        "matches": [
            "10",
            "-10",
            "+10.00"
        ],
        "non_matches": [
            "0",
            "-10.50",
            "10.50"
        ],
        "stress_tests": []
    },
    {
        "id": 242,
        "expression": "^[\\w-]+(\\.[\\w-]+)*@([a-z0-9-]+(\\.[a-z0-9-]+)*?\\.[a-z]{2,6}|(\\d{1,3}\\.){3}\\d{1,3})(:\\d{4})?$",
        "raw_prompt": "Matches a valid email address including ip's which are rarely used. Allows for a-z0-9_.- in the username, but not ending in a full stop i.e user.@domain.com is invalid and a-z0-9- as the optional sub domain(s) with domain name and a 2-7 char (a-z) tld allowing for short tld's like ca and new ones like museum.",
        "refined_prompt": "\nMatch examples:\n- \"username@domain.com\"\n- \"u-s_e.r1@s-ub2.domain-name.museum:8080\"\n- \"user_name@123.123.123.12\"\nNon-match examples:\n- \"user@domain\"\n- \"user@domain.c\"",
        "matches": [
            "username@domain.com",
            "u-s_e.r1@s-ub2.domain-name.museum:8080",
            "user_name@123.123.123.12"
        ],
        "non_matches": [
            "user@domain",
            "user@domain.c",
            "user.@domain.com"
        ],
        "stress_tests": []
    },
    {
        "id": 244,
        "expression": "^(([0]?[0-5][0-9]|[0-9]):([0-5][0-9]))$",
        "raw_prompt": "This regex is to validate the time of a ~60 minute CD where the most time on the CD is 59:59 (minutes:seconds). It is derived from Ken Madden's time regex for a project for Erik Porter (Windows/Web guru). Written by Jason Gaylord.",
        "refined_prompt": "\nMatch examples:\n- \"30:05\"\n- \"5:05\"\n- \"02:59\"\nNon-match examples:\n- \"25:7\"\n- \"5m:16\"",
        "matches": [
            "30:05",
            "5:05",
            "02:59"
        ],
        "non_matches": [
            "25:7",
            "5m:16",
            "60:60"
        ],
        "stress_tests": []
    },
    {
        "id": 245,
        "expression": "^[0-9]{1,}(,[0-9]+){0,}$",
        "raw_prompt": "It could be use to validate html input form (checkbox, optionbox, selectbox) when you have multiple numeric value under one field name. The validation is that the user have at lease chose one or more!",
        "refined_prompt": "\nMatch examples:\n- \"1111\"\n- \"47,26,2,1,1111,12\"\n- \"25,1245,2122,23232\"\nNon-match examples:\n- \"111,\"\n- \"1a1,111,1212,23\"",
        "matches": [
            "1111",
            "47,26,2,1,1111,12",
            "25,1245,2122,23232"
        ],
        "non_matches": [
            "111,",
            "1a1,111,1212,23",
            "11aa,aaa,asas,asa"
        ],
        "stress_tests": []
    },
    {
        "id": 249,
        "expression": "^\\$?(\\d{1,3},?(\\d{3},?)*\\d{3}(\\.\\d{1,3})?|\\d{1,3}(\\.\\d{2})?)$",
        "raw_prompt": "Expression to handle US currency entry in .NET. Handy for regular expression validation controls where the user can be entering in a currancy value but you can't control explict entry values. Will accept a wide variety of values that can be easy cast to a double via the CDbl function. Expression is also compatible with default US string format for currency.",
        "refined_prompt": "\nMatch examples:\n- \"10000\"\n- \"10,000\"\n- \"$1,000.00\"\nNon-match examples:\n- \"0.002\"\n- \"x.0\"",
        "matches": [
            "10000",
            "10,000",
            "$1,000.00"
        ],
        "non_matches": [
            "0.002",
            "x.0"
        ],
        "stress_tests": []
    },
    {
        "id": 250,
        "expression": "^\\d{0,2}(\\.\\d{1,4})? *%?$",
        "raw_prompt": "An expression for .NET regular expression validation controls intended to faciliate the entry of percentage values both a whole numbers or as their decimal representations. Also compatible with the default US format for string formatting for percentages.\nRecommend that if you intended accept a value passing this express that you strip the percentage signs and take measures to ensure that any whole values are converted to percentages.",
        "refined_prompt": "\nMatch examples:\n- \"4.0%\"\n- \"0.45\"\n- \".0345\"\nNon-match examples:\n- \"123\"\n- \"%12\"",
        "matches": [
            "4.0%",
            "0.45",
            ".0345"
        ],
        "non_matches": [
            "123",
            "%12"
        ],
        "stress_tests": []
    },
    {
        "id": 251,
        "expression": "^(?![0-9]{6})[0-9a-zA-Z]{6}$",
        "raw_prompt": "matches a six character &quot;password&quot; that has to consist of numbers and letters with at least one letter in it.",
        "refined_prompt": "\nMatch examples:\n- \"123a12\"\n- \"a12345\"\n- \"aaaaaa\"\nNon-match examples:\n- \"111111\"",
        "matches": [
            "123a12",
            "a12345",
            "aaaaaa"
        ],
        "non_matches": [
            "111111"
        ],
        "stress_tests": []
    },
    {
        "id": 252,
        "expression": "((^(10|12|0?[13578])([/])(3[01]|[12][0-9]|0?[1-9])([/])((1[8-9]\\d{2})|([2-9]\\d{3}))$)|(^(11|0?[469])([/])(30|[12][0-9]|0?[1-9])([/])((1[8-9]\\d{2})|([2-9]\\d{3}))$)|(^(0?2)([/])(2[0-8]|1[0-9]|0?[1-9])([/])((1[8-9]\\d{2})|([2-9]\\d{3}))$)|(^(0?2)([/])(29)([/])([2468][048]00)$)|(^(0?2)([/])(29)([/])([3579][26]00)$)|(^(0?2)([/])(29)([/])([1][89][0][48])$)|(^(0?2)([/])(29)([/])([2-9][0-9][0][48])$)|(^(0?2)([/])(29)([/])([1][89][2468][048])$)|(^(0?2)([/])(29)([/])([2-9][0-9][2468][048])$)|(^(0?2)([/])(29)([/])([1][89][13579][26])$)|(^(0?2)([/])(29)([/])([2-9][0-9][13579][26])$))",
        "raw_prompt": "This Validator Validates any date from 1800 - 9999. It takes special care of Leap years and validates any format of type mm/dd/yyyy , m/dd/yyyy , mm/d/yyyy , m/d/yyyy.\nSince SQL Server does not accept any date before 1/1/1753, so i hope it will meet Your Requirements.(Modified Version of Jason West's Date Validator.)",
        "refined_prompt": "\nMatch examples:\n- \"2/2/2000\"\n- \"02/02/2000\"\n- \"02/2/2000\"\nNon-match examples:\n- \"2.2.2000\"\n- \"2-2-2000\"",
        "matches": [
            "2/2/2000",
            "02/02/2000",
            "02/2/2000"
        ],
        "non_matches": [
            "2.2.2000",
            "2-2-2000"
        ],
        "stress_tests": []
    },
    {
        "id": 254,
        "expression": "^\\d* \\d*\\/{1}\\d*$|^\\d*$",
        "raw_prompt": "This expression is used to validate fractions (entered as strings). It will also accept non-fractional entries. Simple, but effective.",
        "refined_prompt": "\nMatch examples:\n- \"100\"\n- \"1 1/2\"\n- \"1232 5/8\"\nNon-match examples:\n- \"a 1/2\"\n- \"abc\"",
        "matches": [
            "100",
            "1 1/2",
            "1232 5/8"
        ],
        "non_matches": [
            "a 1/2",
            "abc",
            "a b/c"
        ],
        "stress_tests": []
    },
    {
        "id": 255,
        "expression": "^\\(?[\\d]{3}\\)?[\\s-]?[\\d]{3}[\\s-]?[\\d]{4}$",
        "raw_prompt": "This regular expression matches 10 digit US Phone numbers in different formats. Some examples are\n1)area code in paranthesis.\n2)space between different parts of the phone number.\n3)no space between different parts of the number.\n4)dashes between parts.",
        "refined_prompt": "\nMatch examples:\n- \"(573)8841878\"\n- \"573-884-1234\"\n- \"573 234 1256\"\nNon-match examples:\n- \"(573)(673)2345\"\n- \"573-12-2345\"",
        "matches": [
            "(573)8841878",
            "573-884-1234",
            "573 234 1256"
        ],
        "non_matches": [
            "(573)(673)2345",
            "573-12-2345"
        ],
        "stress_tests": []
    },
    {
        "id": 257,
        "expression": "^(([A-Za-z0-9]+_+)|([A-Za-z0-9]+\\-+)|([A-Za-z0-9]+\\.+)|([A-Za-z0-9]+\\++))*[A-Za-z0-9]+@((\\w+\\-+)|(\\w+\\.))*\\w{1,63}\\.[a-zA-Z]{2,6}$",
        "raw_prompt": "It verifies that: - Only letters, numbers and email acceptable symbols (+, _, -, .) are allowed - No two different symbols may follow each other - Cannot begin with a symbol - Ending domain must be at least 2 letters - Supports subdomains - TLD must be between 2 and 6 letters (Ex: .ca, .museum) - Only (-) and (.) symbols are allowed in domain, but not consecutively.\nProblems:\nSee comments below",
        "refined_prompt": "\nMatch examples:\n- \"g_s+gav@com.com\"\n- \"gav@gav.com\"\n- \"jim@jim.c.dc.ca\"\nNon-match examples:\n- \"gs_.gs@com.com\"\n- \"gav@gav.c\"",
        "matches": [
            "g_s+gav@com.com",
            "gav@gav.com",
            "jim@jim.c.dc.ca"
        ],
        "non_matches": [
            "gs_.gs@com.com",
            "gav@gav.c",
            "jim@--c.ca"
        ],
        "stress_tests": []
    },
    {
        "id": 262,
        "expression": "(^[A-Z\u00c0-\u00dc]{1}[a-z\u00e0-\u00fc']+\\s[a-zA-Z\u00e0-\u00fc\u00c0-\u00dc]+((([\\s\\.'])|([a-z\u00e0-\u00fc']+))|[a-z\u00e0-\u00fc']+[a-zA-Z\u00e0-\u00fc\u00c0-\u00dc']+))",
        "raw_prompt": "Checks if has the first and the last name, and check the capital letters.\nUse with the RegExp.test method",
        "refined_prompt": "\nMatch examples:\n- \"Carlos Rodrigues\"\n- \"C\u00e1 de Laaa\"\n- \"Crras R. L. Rodrig\u00fces\"\nNon-match examples:\n- \"aa\u00e4A\"",
        "matches": [
            "Carlos Rodrigues",
            "C\u00e1 de Laaa",
            "Crras R. L. Rodrig\u00fces"
        ],
        "non_matches": [
            "aa\u00e4A"
        ],
        "stress_tests": []
    },
    {
        "id": 263,
        "expression": "(^((((0[1-9])|([1-2][0-9])|(3[0-1]))|([1-9]))\\x2F(((0[1-9])|(1[0-2]))|([1-9]))\\x2F(([0-9]{2})|(((19)|([2]([0]{1})))([0-9]{2}))))$)",
        "raw_prompt": "dd/mm/yy\nCheck dates between 1/1/1900 - 31/12/2099",
        "refined_prompt": "\nMatch examples:\n- \"31/12/2099\"\n- \"1/1/1900\"\n- \"10/12/2003\"\nNon-match examples:\n- \"05/11/3000\"\n- \"11/13/2003\"",
        "matches": [
            "31/12/2099",
            "1/1/1900",
            "10/12/2003"
        ],
        "non_matches": [
            "05/11/3000",
            "11/13/2003",
            "32/04/2030"
        ],
        "stress_tests": []
    },
    {
        "id": 265,
        "expression": "^(\\{|\\[|\\().+(\\}|\\]|\\)).+$",
        "raw_prompt": "Matches &quot;clan&quot; nicks/names.",
        "refined_prompt": "\nMatch examples:\n- \"{CLaN}nick\"\n- \"[Clan]Nick\"\n- \"(Clan)Nick\"\nNon-match examples:\n- \"Nick\"",
        "matches": [
            "{CLaN}nick",
            "[Clan]Nick",
            "(Clan)Nick"
        ],
        "non_matches": [
            "Nick"
        ],
        "stress_tests": []
    },
    {
        "id": 266,
        "expression": "^(([\\w][\\w\\-\\.]*)\\.)?([\\w][\\w\\-]+)(\\.([\\w][\\w\\.]*))?$",
        "raw_prompt": "Is used to evaluating domain names, none of the extras such as paths or protocols.",
        "refined_prompt": "\nMatch examples:\n- \"zigamorph.com\"\n- \"www.zigamorph.com\"\n- \"localhost\"\nNon-match examples:\n- \"http://www.zigamorph.com\"\n- \"ftp://zigamorph.com\"",
        "matches": [
            "zigamorph.com",
            "www.zigamorph.com",
            "localhost"
        ],
        "non_matches": [
            "http://www.zigamorph.com",
            "ftp://zigamorph.com",
            "localhost/default.aspx"
        ],
        "stress_tests": []
    },
    {
        "id": 269,
        "expression": "^([a-zA-Z.\\s']{1,50})$",
        "raw_prompt": "This is just a regular special char expression used to get the hax0rs off your back (hopefully). You can use this for regular open name checking if you wanted. It only fails on the insert of anything other than a-z, A-Z, and ' or whitespace. I'm open to suggestions, but try to email them to me as well as posting them to help others. Thanks.",
        "refined_prompt": "\nMatch examples:\n- \"Jon M. Doe\"\n- \"Tim L. O'Doul\"\n- \"...'''''\"\nNon-match examples:\n- \"Doe, Jon\"\n- \"&lt;&gt;,;:&quot;?/\"",
        "matches": [
            "Jon M. Doe",
            "Tim L. O'Doul",
            "...'''''"
        ],
        "non_matches": [
            "Doe, Jon",
            "&lt;&gt;,;:&quot;?/",
            "%\\$#@!"
        ],
        "stress_tests": []
    },
    {
        "id": 270,
        "expression": "^([a-zA-Z0-9!@#$%^&amp;*()-_=+;:'&quot;|~`&lt;&gt;?/{}]{1,5})$",
        "raw_prompt": "This Regular expression validates a string that contains all printable characters with a minimum length of 1 and maximum length of 5.\nObviously the min and max can be changed to meet the users needs.\n^([a-zA-Z0-9!@#$%^&amp;*()-_=+;:'&quot;|~`&lt;&gt;?/{}]{1,5})$ This is the string, I keep getting &amp;amp;lt and other characters when I save it.",
        "refined_prompt": "\nMatch examples:\n- \"ilove\"\n- \"$%*!_\"\n- \"it\"\nNon-match examples:\n- \"123456\"\n- \"This is great\"",
        "matches": [
            "ilove",
            "$%*!_",
            "it"
        ],
        "non_matches": [
            "123456",
            "This is great"
        ],
        "stress_tests": []
    },
    {
        "id": 271,
        "expression": "^[0-9]{4}\\s{0,2}[a-zA-z]{2}$",
        "raw_prompt": "Dutch postalcode expression. 4 digits followed by max. two spaces end ending on two letters.",
        "refined_prompt": "\nMatch examples:\n- \"4006 AB\"\n- \"4006ab\"\n- \"4006 AB\"\nNon-match examples:\n- \"4006.ab\"\n- \"4006_ab\"",
        "matches": [
            "4006 AB",
            "4006ab",
            "4006 AB"
        ],
        "non_matches": [
            "4006.ab",
            "4006_ab",
            "4006/ab"
        ],
        "stress_tests": []
    },
    {
        "id": 273,
        "expression": "^([\\(]{1}[0-9]{3}[\\)]{1}[ |\\-]{0,1}|^[0-9]{3}[\\-| ])?[0-9]{3}(\\-| ){1}[0-9]{4}$",
        "raw_prompt": "Validates US phone numbers. Phone number can be delimited with dashes or spaces. Area code can optionally include parentheses. To optionally validate area codes, try this expression.\n^([\\(]{1}[0-9]{3}[\\)]{1}[ |\\-]{0,1}|^[0-9]{3}[\\-| ])?[0-9]{3}(\\-| ){1}[0-9]{4}$",
        "refined_prompt": "\nMatch examples:\n- \"(111) 223-2332\"\n- \"(222)233-2332\"\n- \"232-323-3233\"\nNon-match examples:\n- \"(ddd) 223-2332\"\n- \"222-232/2333\"",
        "matches": [
            "(111) 223-2332",
            "(222)233-2332",
            "232-323-3233"
        ],
        "non_matches": [
            "(ddd) 223-2332",
            "222-232/2333",
            "322-3223-222"
        ],
        "stress_tests": []
    },
    {
        "id": 275,
        "expression": "^(?:(?:(?:0?[1-9]|1\\d|2[0-8])\\/(?:0?[1-9]|1[0-2]))\\/(?:(?:1[6-9]|[2-9]\\d)\\d{2}))$|^(?:(?:(?:31\\/0?[13578]|1[02])|(?:(?:29|30)\\/(?:0?[1,3-9]|1[0-2])))\\/(?:(?:1[6-9]|[2-9]\\d)\\d{2}))$|^(?:29\\/0?2\\/(?:(?:(?:1[6-9]|[2-9]\\d)(?:0[48]|[2468][048]|[13579][26]))))$",
        "raw_prompt": "This expression validates dates in the Brazilian d/m/y format from 1/1/1600 - 12/31/9999. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999. Days and months must be 1 or 2 digits and may have leading zeros. Years must be 4 digit years, between 1600 and 9999. Date separator must be a slash (/)",
        "refined_prompt": "\nMatch examples:\n- \"29/02/2004\"\n- \"15/3/1824\"\n- \"31/01/2001\"\nNon-match examples:\n- \"29/02/2000\"\n- \"21/10/92\"",
        "matches": [
            "29/02/2004",
            "15/3/1824",
            "31/01/2001"
        ],
        "non_matches": [
            "29/02/2000",
            "21/10/92",
            "31/02/2001"
        ],
        "stress_tests": []
    },
    {
        "id": 277,
        "expression": "^\\$?(\\d{1,3},?(\\d{3},?)*\\d{3}(\\.\\d{0,2})?|\\d{1,3}(\\.\\d{0,2})?|\\.\\d{1,2}?)$",
        "raw_prompt": "This expression will validate for US Currency with a wide range of input. Using other exps found on this site, I built this one to fix 2 main problems I was finding:\n1-a space or blank entry is non-matching\n2-use of .9 in place of .90 will match (this is for those people like me who hate to type and if I put .9 I mean .90\nHope this helps others save a little time. I feel I was pretty thorough in testing, but if you find something wrong, please post it. -Thanks",
        "refined_prompt": "\nMatch examples:\n- \"$1.99\"\n- \"1.99\"\n- \".99\"\nNon-match examples:\n- \"$10.999\"\n- \"100,00.99\"",
        "matches": [
            "$1.99",
            "1.99",
            ".99"
        ],
        "non_matches": [
            "$10.999",
            "100,00.99",
            "blank"
        ],
        "stress_tests": []
    },
    {
        "id": 278,
        "expression": "^(([1-9]|[0-2]\\d|[3][0-1])\\.([1-9]|[0]\\d|[1][0-2])\\.[2][0]\\d{2})$|^(([1-9]|[0-2]\\d|[3][0-1])\\.([1-9]|[0]\\d|[1][0-2])\\.[2][0]\\d{2}\\s([1-9]|[0-1]\\d|[2][0-3])\\:[0-5]\\d)$",
        "raw_prompt": "Correct German DateTime. Does not check leap year rules!\nPossible Formats of date part:\nD.M.YYYY or D.MM.YYYY or DD.MM.YYYY or DD.M.YYYY\nPossible formats of time part:\nh:mm or hh:mm",
        "refined_prompt": "\nMatch examples:\n- \"20.10.2003 08:10\"\n- \"24.12.2003\"\n- \"1.1.2004 8:15\"\nNon-match examples:\n- \"25.13.2004\"\n- \"20.10.2003 08:9\"",
        "matches": [
            "20.10.2003 08:10",
            "24.12.2003",
            "1.1.2004 8:15"
        ],
        "non_matches": [
            "25.13.2004",
            "20.10.2003 08:9"
        ],
        "stress_tests": []
    },
    {
        "id": 279,
        "expression": "^((((0?[1-9]|[12]\\d|3[01])[\\.\\-\\/](0?[13578]|1[02])[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}))|((0?[1-9]|[12]\\d|30)[\\.\\-\\/](0?[13456789]|1[012])[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}))|((0?[1-9]|1\\d|2[0-8])[\\.\\-\\/]0?2[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}))|(29[\\.\\-\\/]0?2[\\.\\-\\/]((1[6-9]|[2-9]\\d)?(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)|00)))|(((0[1-9]|[12]\\d|3[01])(0[13578]|1[02])((1[6-9]|[2-9]\\d)?\\d{2}))|((0[1-9]|[12]\\d|30)(0[13456789]|1[012])((1[6-9]|[2-9]\\d)?\\d{2}))|((0[1-9]|1\\d|2[0-8])02((1[6-9]|[2-9]\\d)?\\d{2}))|(2902((1[6-9]|[2-9]\\d)?(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)|00))))$",
        "raw_prompt": "Date with leap years. Accepts '.' '-' and '/' as separators\nd.m.yy to dd.mm.yyyy (or d.mm.yy, etc)\nEx: dd-mm-yyyy d.mm/yy dd/m.yyyy etc etc\nAccept 00 years also.",
        "refined_prompt": "\nMatch examples:\n- \"29.2.2004\"\n- \"31121975\"\n- \"29/2-00\"\nNon-match examples:\n- \"29.2.2005\"\n- \"32121975\"",
        "matches": [
            "29.2.2004",
            "31121975",
            "29/2-00"
        ],
        "non_matches": [
            "29.2.2005",
            "32121975",
            "29.2/01"
        ],
        "stress_tests": []
    },
    {
        "id": 281,
        "expression": "&lt;[iI][mM][gG]([^&gt;]*[^/&gt;])",
        "raw_prompt": "simple little RegExp to get the IMG tag from HTML",
        "refined_prompt": "\nMatch examples:\n- \"&lt;img src=&quot;abc.jpg&quot;&gt;\"\n- \"&lt;img src=&quot;abc.jpg&quot;/&gt;\"\n- \"&lt;ImG src=&quot;abc.j\"\nNon-match examples:\n- \"none\"",
        "matches": [
            "&lt;img src=&quot;abc.jpg&quot;&gt;",
            "&lt;img src=&quot;abc.jpg&quot;/&gt;",
            "&lt;ImG src=&quot;abc.j"
        ],
        "non_matches": [
            "none"
        ],
        "stress_tests": []
    },
    {
        "id": 282,
        "expression": "\\d{2}.?\\d{3}.?\\d{3}/?\\d{4}-?\\d{2}",
        "raw_prompt": "This regular expressions matches CNPJ number. CNPJ is a Registration Number of Brazilian Companies.",
        "refined_prompt": "\nMatch examples:\n- \"00.000.000/0000-00\"\n- \"00000000000000\"\nNon-match examples:\n- \"00-000-000-000-00\"\n- \"AA.AAA.AAA/AAAA-AA\"",
        "matches": [
            "00.000.000/0000-00",
            "00000000000000"
        ],
        "non_matches": [
            "00-000-000-000-00",
            "AA.AAA.AAA/AAAA-AA"
        ],
        "stress_tests": []
    },
    {
        "id": 283,
        "expression": "('.*$|Rem((\\t| ).*$|$)|&quot;(.|&quot;&quot;)*?&quot;)",
        "raw_prompt": "Pulls out comments (both Rem and ') and string literals from VB or VBScript. Usefull for spell checking or review.\nNotes: The VBScript for &quot;Rem&quot; documentation says that it must be followed by a space but VBScript seems to accept tab characters as well.\nThe multiline flag is assumed for this search.",
        "refined_prompt": "\nMatch examples:\n- \"' This is a comment\"\n- \"Rem This is a comment\"\n- \"&quot; This is a string with &quot;&quot; and ' &quot;\"\nNon-match examples:\n- \"&quot; This is not a string\"\n- \"RemThis is not a comment\"",
        "matches": [
            "' This is a comment",
            "Rem This is a comment",
            "&quot; This is a string with &quot;&quot; and ' &quot;"
        ],
        "non_matches": [
            "&quot; This is not a string",
            "RemThis is not a comment",
            "This is not a comment or a string"
        ],
        "stress_tests": []
    },
    {
        "id": 285,
        "expression": "^((\\d{2}((0[13578]|1[02])(0[1-9]|[12]\\d|3[01])|(0[13456789]|1[012])(0[1-9]|[12]\\d|30)|02(0[1-9]|1\\d|2[0-8])))|([02468][048]|[13579][26])0229)$",
        "raw_prompt": "Date expression validator with format YYMMDD\nValidates leap years.\nOf course, as year has only 2 digits, it's not possible to invalidate years like 2100, 2200, 2300, etc as a non-leap years !",
        "refined_prompt": "\nMatch examples:\n- \"751231\"\n- \"000229\"\n- \"040229\"\nNon-match examples:\n- \"750431\"\n- \"010229\"",
        "matches": [
            "751231",
            "000229",
            "040229"
        ],
        "non_matches": [
            "750431",
            "010229",
            "050229"
        ],
        "stress_tests": []
    },
    {
        "id": 287,
        "expression": "^((\\\"[^\\\"\\f\\n\\r\\t\\v\\b]+\\\")|([\\w\\!\\#\\$\\%\\&\\'\\*\\+\\-\\~\\/\\^\\`\\|\\{\\}]+(\\.[\\w\\!\\#\\$\\%\\&\\'\\*\\+\\-\\~\\/\\^\\`\\|\\{\\}]+)*))@((\\[(((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9])))\\])|(((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9])))|((([A-Za-z0-9\\-])+\\.)+[A-Za-z\\-]+))$",
        "raw_prompt": "Email address validator. Should cover most of RFC 822, including unusual (but still valid) addresses. Does not restrict the top level domain size, but you're better off doing an nslookup or similar if you absolutely must have a valid domain. Accepts IP Addresses instead of the domain, with or without brackets. Believe it or not, this one is valid: !#$%^&amp;amp;amp;amp;*-+~/'`|{}@xyz.com\nSorry looks like this site is mangling the quote and ampersand characters - you'll have to fix that yourself.",
        "refined_prompt": "\nMatch examples:\n- \"/A/Wacky/User@weirdos.com\"\n- \"bob.builder@[1.1.1.1]\"\n- \"\"blah b. blahburger\"@blah.com\"\nNon-match examples:\n- \"./A/Wacky/User@weirdos.com\"\n- \"bob.builder@[256.1.1.1]\"",
        "matches": [
            "/A/Wacky/User@weirdos.com",
            "bob.builder@[1.1.1.1]",
            "\"blah b. blahburger\"@blah.com"
        ],
        "non_matches": [
            "./A/Wacky/User@weirdos.com",
            "bob.builder@[256.1.1.1]",
            "-\"blah b. blahburger\"@blah.com"
        ],
        "stress_tests": []
    },
    {
        "id": 288,
        "expression": "^(\\d|-)?(\\d|,)*\\.?\\d*$",
        "raw_prompt": "Input for Numeric values. Handles negatives, and comma formatted values. Also handles a single decimal point",
        "refined_prompt": "\nMatch examples:\n- \"5,000\"\n- \"-5,000\"\n- \"100.044\"\nNon-match examples:\n- \"abc\"\n- \"Hundred\"",
        "matches": [
            "5,000",
            "-5,000",
            "100.044"
        ],
        "non_matches": [
            "abc",
            "Hundred",
            "1.3.4"
        ],
        "stress_tests": []
    },
    {
        "id": 289,
        "expression": "^[1-9]+[0-9]*$",
        "raw_prompt": "Allows only positive integers that are greater then 0. Easily modified for +/- intergers and allowing zero.",
        "refined_prompt": "\nMatch examples:\n- \"1\"\n- \"12\"\n- \"124\"\nNon-match examples:\n- \"-1\"\n- \"a\"",
        "matches": [
            "1",
            "12",
            "124"
        ],
        "non_matches": [
            "-1",
            "a",
            "1.0"
        ],
        "stress_tests": []
    },
    {
        "id": 292,
        "expression": "^[A-Za-z0-9](([_\\.\\-]?[a-zA-Z0-9]+)*)@([A-Za-z0-9]+)(([\\.\\-]?[a-zA-Z0-9]+)*)\\.([A-Za-z]{2,})$",
        "raw_prompt": "does not allow IP for domain name : hello@154.145.68.12\ndoes not allow litteral addresses &quot;hello, how are you?&quot;@world.com\nallows numeric domain names\nafter the last &quot;.&quot; minimum 2 letters",
        "refined_prompt": "\nMatch examples:\n- \"he_llo@worl.d.com\"\n- \"hel.l-o@wor-ld.museum\"\n- \"h1ello@123.com\"\nNon-match examples:\n- \"hello@worl_d.com\"\n- \"he&amp;llo@world.co1\"",
        "matches": [
            "he_llo@worl.d.com",
            "hel.l-o@wor-ld.museum",
            "h1ello@123.com"
        ],
        "non_matches": [
            "hello@worl_d.com",
            "he&amp;llo@world.co1",
            ".hello@wor#.co.uk"
        ],
        "stress_tests": []
    },
    {
        "id": 293,
        "expression": "\\b(((\\S+)?)(@|mailto\\:|(news|(ht|f)tp(s?))\\://)\\S+)\\b",
        "raw_prompt": "Whilst writing a plain-text to HTML function, I ran into the problem of links that users had written with &amp;lt;a&amp;gt; tags (as opposed to just writing the URL) were linking improperly. This regular expression returns many types of URL, and preceding characters, if any. This allows you to handle each type of match appropriately",
        "refined_prompt": "\nMatch examples:\n- \"href='http://www.deepart.org'\"\n- \"demogorgon@deepart.org\"\n- \"ftp://123.123.123.123\"\nNon-match examples:\n- \"www.deepart.org\"\n- \"deepart.org\"",
        "matches": [
            "href='http://www.deepart.org'",
            "demogorgon@deepart.org",
            "ftp://123.123.123.123"
        ],
        "non_matches": [
            "www.deepart.org",
            "deepart.org",
            "123.123.123.123"
        ],
        "stress_tests": []
    },
    {
        "id": 294,
        "expression": "^(([a-z])+.)+[A-Z]([a-z])+$",
        "raw_prompt": "This matches Java class names such as &quot;com.test.Test&quot;. It's being used within an XML Schema to validate classname as specified in XML documents.",
        "refined_prompt": "\nMatch examples:\n- \"com.test.Test\"\n- \"com.Test\"\nNon-match examples:\n- \"com.test.test\"\n- \"com.test.TEst\"",
        "matches": [
            "com.test.Test",
            "com.Test"
        ],
        "non_matches": [
            "com.test.test",
            "com.test.TEst",
            "Com.test.Test"
        ],
        "stress_tests": []
    },
    {
        "id": 295,
        "expression": "^[a-zA-Z_][a-zA-Z0-9_]*$",
        "raw_prompt": "Matches variable names/identifier from C# (and most other languages)",
        "refined_prompt": "\nMatch examples:\n- \"VariableName\"\n- \"i\"\n- \"Some_Value_3\"\nNon-match examples:\n- \"3ID\"\n- \"Hello World\"",
        "matches": [
            "VariableName",
            "i",
            "Some_Value_3"
        ],
        "non_matches": [
            "3ID",
            "Hello World"
        ],
        "stress_tests": []
    },
    {
        "id": 299,
        "expression": "^((4\\d{3})|(5[1-5]\\d{2}))(-?|\\040?)(\\d{4}(-?|\\040?)){3}|^(3[4,7]\\d{2})(-?|\\040?)\\d{6}(-?|\\040?)\\d{5}",
        "raw_prompt": "Credit card validator for AMEX, VISA, MasterCard only. Allows spaces, dashes, or no separator between digit groups according to the layout (4-6-5 for AMEX, 4-4-4-4 for Visa and Mastercard)",
        "refined_prompt": "\nMatch examples:\n- \"3711-078176-01234\"\n- \"4123 5123 6123 7123\"\n- \"5123412361237123\"\nNon-match examples:\n- \"3711-4123-5123-6112\"",
        "matches": [
            "3711-078176-01234",
            "4123 5123 6123 7123",
            "5123412361237123"
        ],
        "non_matches": [
            "3711-4123-5123-6112"
        ],
        "stress_tests": []
    },
    {
        "id": 300,
        "expression": "^((\\d?)|(([-+]?\\d+\\.?\\d*)|([-+]?\\d*\\.?\\d+))|(([-+]?\\d+\\.?\\d*\\,\\ ?)*([-+]?\\d+\\.?\\d*))|(([-+]?\\d*\\.?\\d+\\,\\ ?)*([-+]?\\d*\\.?\\d+))|(([-+]?\\d+\\.?\\d*\\,\\ ?)*([-+]?\\d*\\.?\\d+))|(([-+]?\\d*\\.?\\d+\\,\\ ?)*([-+]?\\d+\\.?\\d*)))$",
        "raw_prompt": "This allows a sequence of real numbers to be added, separated by a comma (required) and a space (optional). Based pretty heavily on an expression by Steven Smith on this site.",
        "refined_prompt": "\nMatch examples:\n- \"8.0\"\n- \"8.0,-.38,+8.9\"\n- \"8.0, +8.8, 0.09\"\nNon-match examples:\n- \"+\"\n- \".\"",
        "matches": [
            "8.0",
            "8.0,-.38,+8.9",
            "8.0, +8.8, 0.09"
        ],
        "non_matches": [
            "+",
            ".",
            "a,b, c"
        ],
        "stress_tests": []
    },
    {
        "id": 301,
        "expression": "^(\\d{5}((|-)-\\d{4})?)|([A-Za-z]\\d[A-Za-z][\\s\\.\\-]?(|-)\\d[A-Za-z]\\d)|[A-Za-z]{1,2}\\d{1,2}[A-Za-z]? \\d[A-Za-z]{2}$",
        "raw_prompt": "Allows Canadian, American and UK postal/zip codes. Allowing hyphens, periods, or spaces to separate.",
        "refined_prompt": "\nMatch examples:\n- \"N9B.1Y8\"\n- \"90210-1234\"\n- \"NE21 6EQ\"\nNon-match examples:\n- \"NN8 Y83\"",
        "matches": [
            "N9B.1Y8",
            "90210-1234",
            "NE21 6EQ"
        ],
        "non_matches": [
            "NN8 Y83"
        ],
        "stress_tests": []
    },
    {
        "id": 302,
        "expression": "(.*\\.([wW][mM][aA])|([mM][pP][3])$)",
        "raw_prompt": "Matches a file name to be either a .wma or .mp3 file. This can be used to check file uploads to make sure they are of a certain type. Substitute letters where appropriate for specific file types. To include more simply add logical 'or' (|) operator and append.",
        "refined_prompt": "\nMatch examples:\n- \"thisfile.mp3\"\n- \"tH@tfile.wma\"\nNon-match examples:\n- \"whatever.exe\"\n- \"somethingelse.mpa\"",
        "matches": [
            "thisfile.mp3",
            "tH@tfile.wma"
        ],
        "non_matches": [
            "whatever.exe",
            "somethingelse.mpa",
            "thisagain.wm3"
        ],
        "stress_tests": []
    },
    {
        "id": 305,
        "expression": "(NOT)?(\\s*\\(*)\\s*(\\w+)\\s*(=|&lt;&gt;|&lt;|&gt;|LIKE|IN)\\s*(\\(([^\\)]*)\\)|'([^']*)'|(-?\\d*\\.?\\d+))(\\s*\\)*\\s*)(AND|OR)?",
        "raw_prompt": "Heres my sql clause parser regexp for recordset filtering. Does recursive query parsing all by its self. Only problem I cant figure is how to match comma separated lists of quoted strings. Tell me if you figure out how!\nThe unicodes in the re was put in by the entry form please replace them with their ascii equivalents to use it.",
        "refined_prompt": "\nMatch examples:\n- \"Aeroplane LIKE 767\"\n- \"Movie LIKE 'Star' AND NOT Movie LIKE 'Trek'\"\n- \"Number IN (1,2,3,4,5)\"\nNon-match examples:\n- \"Hello there\"\n- \"A=EXCELLENT OR\"",
        "matches": [
            "Aeroplane LIKE 767",
            "Movie LIKE 'Star' AND NOT Movie LIKE 'Trek'",
            "Number IN (1,2,3,4,5)"
        ],
        "non_matches": [
            "Hello there",
            "A=EXCELLENT OR",
            "B!=POOR"
        ],
        "stress_tests": []
    },
    {
        "id": 306,
        "expression": "(^(\\+?\\-? *[0-9]+)([,0-9 ]*)([0-9 ])*$)|(^ *$)",
        "raw_prompt": "This is my basic phone number verification. it allows a + - , signs digits, spaces and blank entry",
        "refined_prompt": "\nMatch examples:\n- \"+0335456 545 545\"\n- \"-5465 545\"\n- \"5456465 5454,545\"\nNon-match examples:\n- \"fsd54df 54\"",
        "matches": [
            "+0335456 545 545",
            "-5465 545",
            "5456465 5454,545"
        ],
        "non_matches": [
            "fsd54df 54"
        ],
        "stress_tests": []
    },
    {
        "id": 308,
        "expression": "^(.|\\n){0,16}$",
        "raw_prompt": "Limit Length - limit the length of a text box or other area to contain any character plus new line",
        "refined_prompt": "\nMatch examples:\n- \"shorter than max\"\nNon-match examples:\n- \"string longer than max\"",
        "matches": [
            "shorter than max"
        ],
        "non_matches": [
            "string longer than max"
        ],
        "stress_tests": []
    },
    {
        "id": 310,
        "expression": "&quot;([^&quot;](?:\\\\.|[^\\\\&quot;]*)*)&quot;",
        "raw_prompt": "Matches C style strings allowing for escaped string delimiters to be included in the match.\nALTERED 13-Dec-2003\n-------------------\nPrevious pattern was :\n&quot;([^&quot;](?:\\\\.|[^\\\\&quot;]*)*)&quot;\nChanged to:\n&quot;([^&quot;]*(?:\\\\.|[^\\\\&quot;]*)*)&quot;\nMaking the first character after the opening quote optional allows the pattern to match on empty quotes: &quot;&quot;.",
        "refined_prompt": "\nMatch examples:\n- \"&quot;This is a \\&quot;string\\&quot;.&quot;\"\nNon-match examples:\n- \"&quot;This is a \\&quot;string\\&quot;.\"",
        "matches": [
            "&quot;This is a \\&quot;string\\&quot;.&quot;"
        ],
        "non_matches": [
            "&quot;This is a \\&quot;string\\&quot;."
        ],
        "stress_tests": []
    },
    {
        "id": 311,
        "expression": "(\\w[-._\\w]*\\w@\\w[-._\\w]*\\w\\.\\w{2,3})",
        "raw_prompt": "This is my all-time favourite e-mail validator. I've used it for years and it's never failed me :-)",
        "refined_prompt": "\nMatch examples:\n- \"foo@bar.com\"\n- \"foobar@foobar.com.au\"\nNon-match examples:\n- \"foo@bar\"\n- \"$$$@bar.com\"",
        "matches": [
            "foo@bar.com",
            "foobar@foobar.com.au"
        ],
        "non_matches": [
            "foo@bar",
            "$$$@bar.com"
        ],
        "stress_tests": []
    },
    {
        "id": 312,
        "expression": "^([a-zA-Z]\\:)(\\\\[^\\\\/:*?<>\"|]*(?<![ ]))*(\\.[a-zA-Z]{2,6})$",
        "raw_prompt": "Matches filenames.\nUPDATED on 1st Jan 2004.",
        "refined_prompt": "\nMatch examples:\n- \"C:\\di___r\\fi_sysle.txt\"\n- \"c:\\dir\\filename.txt\"\nNon-match examples:\n- \"c:\\dir\\file?name.txt\"",
        "matches": [
            "C:\\di___r\\fi_sysle.txt",
            "c:\\dir\\filename.txt"
        ],
        "non_matches": [
            "c:\\dir\\file?name.txt"
        ],
        "stress_tests": []
    },
    {
        "id": 313,
        "expression": "^[^#]([^ ]+ ){6}[^ ]+$",
        "raw_prompt": "We've come across the situation where we had to extract the IIS-Log entries without the header information. The data is far more complex than the sample given.\nExplanation:\n^[^#] = lines not beginnin with #\n([^ ]+ ){6} = 6 times no space until one space\n[^ ]+ = no spaces allowed...\n$ = ...until end of line\nFor further explanation don't hesitate to write E-Mail.",
        "refined_prompt": "\nMatch examples:\n- \"1111 2222 33 44444 55 6 7777\"\nNon-match examples:\n- \"#IIS Logfile header\"",
        "matches": [
            "1111 2222 33 44444 55 6 7777"
        ],
        "non_matches": [
            "#IIS Logfile header"
        ],
        "stress_tests": []
    },
    {
        "id": 315,
        "expression": "^(([0-9])|([0-1][0-9])|([2][0-3])):?([0-5][0-9])$",
        "raw_prompt": "For testing 24H based time entry. Tests if there is a colon to separate the hours from the minutes",
        "refined_prompt": "\nMatch examples:\n- \"0959\"\n- \"959\"\n- \"9:59\"\nNon-match examples:\n- \"90\"\n- \"960\"",
        "matches": [
            "0959",
            "959",
            "9:59"
        ],
        "non_matches": [
            "90",
            "960",
            "24:00"
        ],
        "stress_tests": []
    },
    {
        "id": 316,
        "expression": "^(((((0[13578])|([13578])|(1[02]))[\\-\\/\\s]?((0[1-9])|([1-9])|([1-2][0-9])|(3[01])))|((([469])|(11))[\\-\\/\\s]?((0[1-9])|([1-9])|([1-2][0-9])|(30)))|((02|2)[\\-\\/\\s]?((0[1-9])|([1-9])|([1-2][0-9]))))[\\-\\/\\s]?\\d{4})(\\s(((0[1-9])|([1-9])|(1[0-2]))\\:([0-5][0-9])((\\s)|(\\:([0-5][0-9])\\s))([AM|PM|am|pm]{2,2})))?$",
        "raw_prompt": "Following expression can be used to validate a datetime column from SQL Server. This expression is an enhanced version of Scott Watermasysk's date/time submission. It now accepts leading zeros in months, days, and hours. In addition, this expression properly handles the 11th hour. Watermasysk's would take the 10th and 12th hour but not the 11th. This regex has been tweaked to do so. Does not handle the February 29th problem on non-leap years yet. Will learn a little more about RegEx and do so in later submission.",
        "refined_prompt": "\nMatch examples:\n- \"11/30/2003 10:12:24 am\"\n- \"2/29/2003 08:14:56 pm\"\n- \"5/22/2003\"\nNon-match examples:\n- \"11/31/2003 10:12:24 am\"\n- \"2/30/2003 08:14:56 pm\"",
        "matches": [
            "11/30/2003 10:12:24 am",
            "2/29/2003 08:14:56 pm",
            "5/22/2003"
        ],
        "non_matches": [
            "11/31/2003 10:12:24 am",
            "2/30/2003 08:14:56 pm",
            "5/22/2003 14:15"
        ],
        "stress_tests": []
    },
    {
        "id": 317,
        "expression": "^0(6[045679][0469]){1}(\\-)?(1)?[^0\\D]{1}\\d{6}$",
        "raw_prompt": "Validates Austrian Cellular Phone Numbers. Works with ONE, T-Mobile, A1, Telering and new Provider &quot;Drei&quot;. WITHOUT Country Code Verification.",
        "refined_prompt": "\nMatch examples:\n- \"0664-1234567\"\n- \"06641234567\"\n- \"0699-11234567\"\nNon-match examples:\n- \"06991-1234567\"\n- \"+43650-1234567\"",
        "matches": [
            "0664-1234567",
            "06641234567",
            "0699-11234567"
        ],
        "non_matches": [
            "06991-1234567",
            "+43650-1234567",
            "07661234567"
        ],
        "stress_tests": []
    },
    {
        "id": 318,
        "expression": "^1?[1-9]$|^[1-2]0$",
        "raw_prompt": "Matches a whole number between 1 and 20 inclusively",
        "refined_prompt": "\nMatch examples:\n- \"1\"\n- \"11\"\n- \"20\"\nNon-match examples:\n- \"0\"\n- \"21\"",
        "matches": [
            "1",
            "11",
            "20"
        ],
        "non_matches": [
            "0",
            "21"
        ],
        "stress_tests": []
    },
    {
        "id": 320,
        "expression": "^[1-9][0-9]{3}\\s?[a-zA-Z]{2}$",
        "raw_prompt": "Validates Dutch Postal Codes (ZipCode). There was a previous one listed here, but it's not entirely correct. Namely that dutch postal codes can contain a zero but cannot start with one, so this one is the adjusted version.",
        "refined_prompt": "\nMatch examples:\n- \"1234AB\"\n- \"1234 AB\"\n- \"1001 AB\"\nNon-match examples:\n- \"0123AB\"\n- \"1234A B\"",
        "matches": [
            "1234AB",
            "1234 AB",
            "1001 AB"
        ],
        "non_matches": [
            "0123AB",
            "1234A B",
            "0123 AB"
        ],
        "stress_tests": []
    },
    {
        "id": 321,
        "expression": "^([0-9]*|\\d*\\.\\d{1}?\\d*)$",
        "raw_prompt": "Accept only (0-9) integer and one decimal point(decimal point is also optional).After decimal point it accepts at least one numeric .This will be usefull in money related\nfields or decimal fields.",
        "refined_prompt": "\nMatch examples:\n- \".568\"\n- \"8578\"\n- \"1234567.1234567\"\nNon-match examples:\n- \"568.\"\n- \"56.89.36\"",
        "matches": [
            ".568",
            "8578",
            "1234567.1234567"
        ],
        "non_matches": [
            "568.",
            "56.89.36",
            "5.3.6.9.6"
        ],
        "stress_tests": []
    },
    {
        "id": 322,
        "expression": "^(?=\\d)(?:(?:(?:(?:(?:0?[13578]|1[02])(\\/|-|\\.)31)\\1|(?:(?:0?[1,3-9]|1[0-2])(\\/|-|\\.)(?:29|30)\\2))(?:(?:1[6-9]|[2-9]\\d)?\\d{2})|(?:0?2(\\/|-|\\.)29\\3(?:(?:(?:1[6-9]|[2-9]\\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00))))|(?:(?:0?[1-9])|(?:1[0-2]))(\\/|-|\\.)(?:0?[1-9]|1\\d|2[0-8])\\4(?:(?:1[6-9]|[2-9]\\d)?\\d{2}))($|\\ (?=\\d)))?(((0?[1-9]|1[012])(:[0-5]\\d){0,2}(\\ [AP]M))|([01]\\d|2[0-3])(:[0-5]\\d){1,2})?$",
        "raw_prompt": "DateTime Validator.",
        "refined_prompt": "\nMatch examples:\n- \"12/25/2003\"\n- \"08:03:31\"\n- \"02/29/2004 12 AM\"\nNon-match examples:\n- \"02/29/2003 1:34 PM\"\n- \"13:23 PM\"",
        "matches": [
            "12/25/2003",
            "08:03:31",
            "02/29/2004 12 AM"
        ],
        "non_matches": [
            "02/29/2003 1:34 PM",
            "13:23 PM",
            "24:00:00"
        ],
        "stress_tests": []
    },
    {
        "id": 323,
        "expression": "^((0?[1-9]|1[012])(:[0-5]\\d){0,2}(\\ [AP]M))$|^([01]\\d|2[0-3])(:[0-5]\\d){0,2}$",
        "raw_prompt": "This RE validates times patterns.",
        "refined_prompt": "\nMatch examples:\n- \"1 AM\"\n- \"23:00:00\"\n- \"5:29:59 PM\"\nNon-match examples:\n- \"13 PM\"\n- \"13:60:00\"",
        "matches": [
            "1 AM",
            "23:00:00",
            "5:29:59 PM"
        ],
        "non_matches": [
            "13 PM",
            "13:60:00",
            "00:00:00 AM"
        ],
        "stress_tests": []
    },
    {
        "id": 325,
        "expression": "^(#){1}([a-fA-F0-9]){6}$",
        "raw_prompt": "Matches HTML Color strings. Like #FFFFFF is white and #000000 is black and #FF0000 is red and so on...",
        "refined_prompt": "\nMatch examples:\n- \"#FFFFFF\"\n- \"#FF3421\"\n- \"#00FF00\"\nNon-match examples:\n- \"232323\"\n- \"f#fddee\"",
        "matches": [
            "#FFFFFF",
            "#FF3421",
            "#00FF00"
        ],
        "non_matches": [
            "232323",
            "f#fddee",
            "#fd2"
        ],
        "stress_tests": []
    },
    {
        "id": 327,
        "expression": "(((0[1-9]|[12][0-9]|3[01])([/])(0[13578]|10|12)([/])(\\d{4}))|(([0][1-9]|[12][0-9]|30)([/])(0[469]|11)([/])(\\d{4}))|((0[1-9]|1[0-9]|2[0-8])([/])(02)([/])(\\d{4}))|((29)(\\.|-|\\/)(02)([/])([02468][048]00))|((29)([/])(02)([/])([13579][26]00))|((29)([/])(02)([/])([0-9][0-9][0][48]))|((29)([/])(02)([/])([0-9][0-9][2468][048]))|((29)([/])(02)([/])([0-9][0-9][13579][26])))",
        "raw_prompt": "Date in DD/MM/YYYY format.\nFecha en formato DD/MM/AAAA.",
        "refined_prompt": "\nMatch examples:\n- \"28/12/2003\"\n- \"28/02/2003\"\n- \"29/02/2000\"\nNon-match examples:\n- \"28-02-2003\"\n- \"30/02/2003\"",
        "matches": [
            "28/12/2003",
            "28/02/2003",
            "29/02/2000"
        ],
        "non_matches": [
            "28-02-2003",
            "30/02/2003",
            "28.02.2003"
        ],
        "stress_tests": []
    },
    {
        "id": 329,
        "expression": "^((((((0?[13578])|(1[02]))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\\-\\/\\s]?((0?[1-9])|([1-2][0-9]))))[\\-\\/\\s]?\\d{2}(([02468][048])|([13579][26])))|(((((0?[13578])|(1[02]))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\\-\\/\\s]?((0?[1-9])|(1[0-9])|(2[0-8]))))[\\-\\/\\s]?\\d{2}(([02468][1235679])|([13579][01345789]))))(\\s(((0?[1-9])|(1[0-2]))\\:([0-5][0-9])((\\s)|(\\:([0-5][0-9])\\s))([AM|PM|am|pm]{2,2})))?$",
        "raw_prompt": "This regex will match SQL Server datetime values, allowing date only, allowing zero padded digits in month, day and hour, and will match leap years from 1901 up until 2099.",
        "refined_prompt": "\nMatch examples:\n- \"2/29/2004\"\n- \"04/01/2003 10:01:23 am\"\n- \"03-20-1999\"\nNon-match examples:\n- \"2/29/2003\"\n- \"13/30/2001 10:05:00 pm\"",
        "matches": [
            "2/29/2004",
            "04/01/2003 10:01:23 am",
            "03-20-1999"
        ],
        "non_matches": [
            "2/29/2003",
            "13/30/2001 10:05:00 pm",
            "12/32/2003"
        ],
        "stress_tests": []
    },
    {
        "id": 330,
        "expression": "[0-9A-Fa-f]{2}(\\.?)[0-9A-Fa-f]{2}(\\.?)[0-9A-Fa-f]{2}(\\.?)[0-9A-Fa-f]{2}",
        "raw_prompt": "matches IP address in hex form in dotted or not dotted notation",
        "refined_prompt": "\nMatch examples:\n- \"c0.a8.01.64\"\n- \"0A0275C4\"\n- \"aC.10.1F.b1\"\nNon-match examples:\n- \"192.168.1.1\"\n- \"10.2.177.4\"",
        "matches": [
            "c0.a8.01.64",
            "0A0275C4",
            "aC.10.1F.b1"
        ],
        "non_matches": [
            "192.168.1.1",
            "10.2.177.4",
            "ah.10.1f.20"
        ],
        "stress_tests": []
    },
    {
        "id": 331,
        "expression": "[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}",
        "raw_prompt": "Very Simple Match for dotted Decimal IP address. Doesn\u2019t Validate addresses",
        "refined_prompt": "\nMatch examples:\n- \"192.168.1.1\"\n- \"10.2.234.1\"\n- \"66.129.71.122\"\nNon-match examples:\n- \"192.168.1\"\n- \"10.2.1234.1\"",
        "matches": [
            "192.168.1.1",
            "10.2.234.1",
            "66.129.71.122"
        ],
        "non_matches": [
            "192.168.1",
            "10.2.1234.1",
            "66 129 71 122"
        ],
        "stress_tests": []
    },
    {
        "id": 332,
        "expression": "(^[0-9]{1,8}|(^[0-9]{1,8}\\.{0,1}[0-9]{1,2}))$",
        "raw_prompt": "Matches number in format XX.XX Please note that this expression allows maximum of 8 digits before the dot and 2 (optional) digits after the dot.",
        "refined_prompt": "\nMatch examples:\n- \"1.00\"\n- \"2345\"\n- \"332.3\"\nNon-match examples:\n- \".00\"\n- \"23333333333.00\"",
        "matches": [
            "1.00",
            "2345",
            "332.3"
        ],
        "non_matches": [
            ".00",
            "23333333333.00",
            "j22.00"
        ],
        "stress_tests": []
    },
    {
        "id": 333,
        "expression": "^[AaWaKkNn][a-zA-Z]?[0-9][a-zA-Z]{1,3}$",
        "raw_prompt": "Simple match for U.S. Amateur Radio Call signs\nMust start with an A,K,N or W.\n1 or two prefix letters (not case sensitive),\nExactly one zone digit,\nOne to three suffix digits( not case sensitive).\n73",
        "refined_prompt": "\nMatch examples:\n- \"kd6dun\"\n- \"W9OXZ\"\n- \"kb8ae\"\nNon-match examples:\n- \"kdd90bz\"\n- \"de7bgw\"",
        "matches": [
            "kd6dun",
            "W9OXZ",
            "kb8ae"
        ],
        "non_matches": [
            "kdd90bz",
            "de7bgw",
            "WV7BXQ5"
        ],
        "stress_tests": []
    },
    {
        "id": 337,
        "expression": "^[a-zA-Z0-9&#192;&#193;&#194;&#195;&#196;&#197;&#198;&#199;&#200;&#201;&#202;&#203;&#204;&#205;&#206;&#207;&#208;&#209;&#210;&#211;&#212;&#213;&#214;&#216;&#217;&#218;&#219;&#220;&#221;&#223;&#224;&#225;&#226;&#227;&#228;&#229;&#230;&#231;&#232;&#233;&#234;&#235;&#236;&#237;&#238;&#239;&#241;&#242;&#243;&#244;&#245;&#246;&#248;&#249;&#250;&#251;&#252;&#253;&#255;\\.\\,\\-\\/\\']+[a-zA-Z0-9&#192;&#193;&#194;&#195;&#196;&#197;&#198;&#199;&#200;&#201;&#202;&#203;&#204;&#205;&#206;&#207;&#208;&#209;&#210;&#211;&#212;&#213;&#214;&#216;&#217;&#218;&#219;&#220;&#221;&#223;&#224;&#225;&#226;&#227;&#228;&#229;&#230;&#231;&#232;&#233;&#234;&#235;&#236;&#237;&#238;&#239;&#241;&#242;&#243;&#244;&#245;&#246;&#248;&#249;&#250;&#251;&#252;&#253;&#255;\\.\\,\\-\\/\\' ]+$",
        "raw_prompt": "This simple regexp should match any possible italian address entry and doesn't match NULL entries (good if address is required). Should work well for any other address (it's been verified against 250 addresses from most european countries, usa and australia. Please mail me if there's something missing",
        "refined_prompt": "\nMatch examples:\n- \"v.le dell'industria 45/a\"\n- \"via genova 45-3-d\"\n- \"p.zza Garibaldi, 48\"\nNon-match examples:\n- \"[NULL]\"",
        "matches": [
            "v.le dell'industria 45/a",
            "via genova 45-3-d",
            "p.zza Garibaldi, 48"
        ],
        "non_matches": [
            "[NULL]"
        ],
        "stress_tests": []
    },
    {
        "id": 338,
        "expression": "^(Sun|Mon|(T(ues|hurs))|Fri)(day|\\.)?$|Wed(\\.|nesday)?$|Sat(\\.|urday)?$|T((ue?)|(hu?r?))\\.?$",
        "raw_prompt": "This RE matches Days of the week or their abbreviations.",
        "refined_prompt": "\nMatch examples:\n- \"Sunday\"\n- \"Mon\"\n- \"Tu\"\nNon-match examples:\n- \"day\"\n- \"Wedday\"",
        "matches": [
            "Sunday",
            "Mon",
            "Tu"
        ],
        "non_matches": [
            "day",
            "Wedday",
            "Payday"
        ],
        "stress_tests": []
    },
    {
        "id": 340,
        "expression": "<[a-zA-Z]+(\\s+[a-zA-Z]+\\s*=\\s*(\"([^\"]*)\"|'([^']*)'))*\\s*/>",
        "raw_prompt": "Matches a valid &quot;empty&quot; tag (has trailing slash). Note, if you run it against a string such as &lt;img src=&quot;test.gif&quot; alt=&quot;&lt;hr /&gt;&quot;&gt; it will indeed return a match. But, the match is not at character 1 like you'd suspect, but rather it's matching the internal &lt;hr /&gt;. If you look at the source of this tag (http://concepts.waetech.com/unclosed_tags/) you'll find a whoe suite of regex's for matching html tags. Using them you could feasibly step though a document and avoid this mismatch as the outer tag would match *in totality* and you'd completely skip this inner match.",
        "refined_prompt": "\nMatch examples:\n- \"<img src=\"test.gif\"/>\"\nNon-match examples:\n- \"<img src=\"test.gif\">\"\n- \"<img src=\"test.gif\"a/>\"",
        "matches": [
            "<img src=\"test.gif\"/>"
        ],
        "non_matches": [
            "<img src=\"test.gif\">",
            "<img src=\"test.gif\"a/>"
        ],
        "stress_tests": []
    },
    {
        "id": 341,
        "expression": "^[a-z0-9][a-z0-9_\\.-]{0,}[a-z0-9]@[a-z0-9][a-z0-9_\\.-]{0,}[a-z0-9][\\.][a-z0-9]{2,4}$",
        "raw_prompt": "for validate a email, but with this regex it 's possible : a._-z@a_.....____---.com",
        "refined_prompt": "\nMatch examples:\n- \"az@er.tr\"\n- \"a_zer-ty@az.er.ty\"\n- \"123-456_789.0@1.2.3iuyt.azer\"\nNon-match examples:\n- \"a@a.a\"\n- \"a.@_1.com\"",
        "matches": [
            "az@er.tr",
            "a_zer-ty@az.er.ty",
            "123-456_789.0@1.2.3iuyt.azer"
        ],
        "non_matches": [
            "a@a.a",
            "a.@_1.com",
            "azerty_@domain-com"
        ],
        "stress_tests": []
    },
    {
        "id": 342,
        "expression": "^\\w+.*$",
        "raw_prompt": "Validates any line begining with an alpha-numeric. If you need a regular expression that fails only for a zero length string. Remove the \\w+. I originally attempted to post was ^.*$ but the input form would not allow it.",
        "refined_prompt": "\nMatch examples:\n- \"user name\"\n- \"o)(=-&amp;r443*/\"\nNon-match examples:\n- \"=stuff\"\n- \".username\"",
        "matches": [
            "user name",
            "o)(=-&amp;r443*/"
        ],
        "non_matches": [
            "=stuff",
            ".username"
        ],
        "stress_tests": []
    },
    {
        "id": 343,
        "expression": "^((\\d{2}(([02468][048])|([13579][26]))[\\-\\/\\s]?((((0?[13578])|(1[02]))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])))))|(\\d{2}(([02468][1235679])|([13579][01345789]))[\\-\\/\\s]?((((0?[13578])|(1[02]))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\\-\\/\\s]?((0?[1-9])|(1[0-9])|(2[0-8]))))))(\\s(((0?[1-9])|(1[0-2]))\\:([0-5][0-9])((\\s)|(\\:([0-5][0-9])\\s))([AM|PM|am|pm]{2,2})))?$",
        "raw_prompt": "Matches ANSI SQL date format YYYY-mm-dd hh:mi:ss am/pm. You can use / - or space for date delimiters, so 2004-12-31 works just as well as 2004/12/31. Checks leap year from 1901 to 2099.",
        "refined_prompt": "\nMatch examples:\n- \"2004-2-29\"\n- \"2004-02-29 10:29:39 pm\"\n- \"2004/12/31\"\nNon-match examples:\n- \"2003-2-29\"\n- \"2003-13-02\"",
        "matches": [
            "2004-2-29",
            "2004-02-29 10:29:39 pm",
            "2004/12/31"
        ],
        "non_matches": [
            "2003-2-29",
            "2003-13-02",
            "2003-2-2 10:72:30 am"
        ],
        "stress_tests": []
    },
    {
        "id": 344,
        "expression": "^([a-zA-Z0-9]([a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,6}$",
        "raw_prompt": "Checks domain names. This validates domains based on latest specifications (RFCs 952 and 1123 dealing with hostnames and RFC 1035 dealing with domain name system requirements) except that it only includes realistic fully-qualified domains: 1. requires at least one subdomain 2. allows shortest top-level domains like &quot;ca&quot;, and &quot;museum&quot; as longest.\nOther validation rules: 1. Labels/parts should be seperated by period. 2. Each label/part has maximum of 63 characters. 3. First and last character of label must be alphanumeric, other characters alphanumeric or hyphen. 4. Does not check maxlength of domain which incidentally is 253 characters of text (255 binary representation).\nFor a regular expression that matches ALL domains:\n^([a-zA-Z0-9]([a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?\\.)*[a-zA-Z0-9]([a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?$",
        "refined_prompt": "\nMatch examples:\n- \"regexlib.com\"\n- \"this.is.a.museum\"\n- \"3com.com\"\nNon-match examples:\n- \"notadomain-.com\"\n- \"helloworld.c\"",
        "matches": [
            "regexlib.com",
            "this.is.a.museum",
            "3com.com"
        ],
        "non_matches": [
            "notadomain-.com",
            "helloworld.c",
            ".oops.org"
        ],
        "stress_tests": []
    },
    {
        "id": 346,
        "expression": "^((AL)|(AK)|(AS)|(AZ)|(AR)|(CA)|(CO)|(CT)|(DE)|(DC)|(FM)|(FL)|(GA)|(GU)|(HI)|(ID)|(IL)|(IN)|(IA)|(KS)|(KY)|(LA)|(ME)|(MH)|(MD)|(MA)|(MI)|(MN)|(MS)|(MO)|(MT)|(NE)|(NV)|(NH)|(NJ)|(NM)|(NY)|(NC)|(ND)|(MP)|(OH)|(OK)|(OR)|(PW)|(PA)|(PR)|(RI)|(SC)|(SD)|(TN)|(TX)|(UT)|(VT)|(VI)|(VA)|(WA)|(WV)|(WI)|(WY))$",
        "raw_prompt": "This validates the states and territories of the United States in a 2 character uppercase format. Very poor excuse for a regular expression! ;)\nWritten by Jason Gaylord.",
        "refined_prompt": "\nMatch examples:\n- \"NY\"\n- \"PA\"\n- \"NJ\"\nNon-match examples:\n- \"Pennsylvania\"\n- \"Pa\"",
        "matches": [
            "NY",
            "PA",
            "NJ"
        ],
        "non_matches": [
            "Pennsylvania",
            "Pa",
            "pa"
        ],
        "stress_tests": []
    },
    {
        "id": 347,
        "expression": "^([\\(]{1}[0-9]{3}[\\)]{1}[ ]{1}[0-9]{3}[\\-]{1}[0-9]{4})$",
        "raw_prompt": "It is the exact phone number regular expression for '(###) ###-####'.\nWritten by Jason Gaylord.",
        "refined_prompt": "\nMatch examples:\n- \"(555) 555-1212\"\nNon-match examples:\n- \"555-1212\"\n- \"1-800-555-1212\"",
        "matches": [
            "(555) 555-1212"
        ],
        "non_matches": [
            "555-1212",
            "1-800-555-1212",
            "555-555-1212"
        ],
        "stress_tests": []
    },
    {
        "id": 348,
        "expression": "^(([0]?[1-9]|1[0-2])/([0-2]?[0-9]|3[0-1])/[1-2]\\d{3})? ?((([0-1]?\\d)|(2[0-3])):[0-5]\\d)?(:[0-5]\\d)? ?(AM|am|PM|pm)?$",
        "raw_prompt": "Matches variations on date/time/AM-PM. Must have 4 digit year, but everything else is open. Restrictions are: 4 digit year, months 1-12, hours 1-23, minutes and seconds 1-59, any case of AM and PM. If this don't woik, I wrote it, lemmy know.",
        "refined_prompt": "\nMatch examples:\n- \"12/30/2002\"\n- \"12/30/2002 9:35 pm\"\n- \"12/30/2002 19:35:02\"\nNon-match examples:\n- \"18/22/2003\"\n- \"8/12/99\"",
        "matches": [
            "12/30/2002",
            "12/30/2002 9:35 pm",
            "12/30/2002 19:35:02"
        ],
        "non_matches": [
            "18/22/2003",
            "8/12/99",
            "8/22/2003 25:00"
        ],
        "stress_tests": []
    },
    {
        "id": 349,
        "expression": "^\\d(\\d)?(\\d)?$",
        "raw_prompt": "Matches positive whole numbers from 0-999",
        "refined_prompt": "\nMatch examples:\n- \"0\"\n- \"12\"\n- \"876\"\nNon-match examples:\n- \"1000\"\n- \"1.23\"",
        "matches": [
            "0",
            "12",
            "876"
        ],
        "non_matches": [
            "1000",
            "1.23",
            "-234"
        ],
        "stress_tests": []
    },
    {
        "id": 350,
        "expression": "^(3[0-1]|2[0-9]|1[0-9]|0[1-9])[\\s{1}|\\/|-](Jan|JAN|Feb|FEB|Mar|MAR|Apr|APR|May|MAY|Jun|JUN|Jul|JUL|Aug|AUG|Sep|SEP|Oct|OCT|Nov|NOV|Dec|DEC)[\\s{1}|\\/|-]\\d{4}$",
        "raw_prompt": "More flexible date validator. Allows either spaces, / or - as dividers, also allows for fully uppercase months, year as 4 digit.",
        "refined_prompt": "\nMatch examples:\n- \"01 JAN 2003\"\n- \"31/Dec/2002\"\n- \"20-Apr-2003\"\nNon-match examples:\n- \"32 Jan 2003\"\n- \"00 Dec 2003\"",
        "matches": [
            "01 JAN 2003",
            "31/Dec/2002",
            "20-Apr-2003"
        ],
        "non_matches": [
            "32 Jan 2003",
            "00 Dec 2003",
            "10 dec 2003"
        ],
        "stress_tests": []
    },
    {
        "id": 351,
        "expression": "^[1-9]{1}[0-9]{3}\\s{0,1}?[a-zA-Z]{2}$",
        "raw_prompt": "Used for dutch postalcodes; no leading zero. 4 numbers and 2 letters.",
        "refined_prompt": "\nMatch examples:\n- \"1234AB\"\n- \"1234 AB\"\n- \"1234 ab\"\nNon-match examples:\n- \"0123AB\"\n- \"123AA\"",
        "matches": [
            "1234AB",
            "1234 AB",
            "1234 ab"
        ],
        "non_matches": [
            "0123AB",
            "123AA"
        ],
        "stress_tests": []
    },
    {
        "id": 352,
        "expression": "^\\s*(((\\d*\\.?\\d*[0-9]+\\d*)|([0-9]+\\d*\\.\\d*) )\\s*[xX]\\s*){2}((\\d*\\.?\\d*[0-9]+\\d*)|([0-9]+\\d*\\.\\d*))\\s*$",
        "raw_prompt": "This validates Length times Width times Height measurements, which consists of 3 whole or decimal numbers separated by an x.",
        "refined_prompt": "\nMatch examples:\n- \"1.1 x 4.35 x 5.0\"\n- \"1 x 2 x 3\"\n- \"4.75 x 300.25 x 0\"\nNon-match examples:\n- \"z.56 x 6 x 7\"\n- \"1 xx 2 x 3\"",
        "matches": [
            "1.1 x 4.35 x 5.0",
            "1 x 2 x 3",
            "4.75 x 300.25 x 0"
        ],
        "non_matches": [
            "z.56 x 6 x 7",
            "1 xx 2 x 3",
            "1 by 2 by 3"
        ],
        "stress_tests": []
    },
    {
        "id": 353,
        "expression": "[\\\\s+,]",
        "raw_prompt": "Simple expression for matching all commas and all whitespace characters: ASCII (13,10,44)",
        "refined_prompt": "\nMatch examples:\n- \",\"\n- \"whitespace\"\n- \"carrage returns\"\nNon-match examples:\n- \"cat\"",
        "matches": [
            ",",
            "whitespace",
            "carrage returns"
        ],
        "non_matches": [
            "cat"
        ],
        "stress_tests": []
    },
    {
        "id": 354,
        "expression": "^(?:(((Jan(uary)?|Ma(r(ch)?|y)|Jul(y)?|Aug(ust)?|Oct(ober)?|Dec(ember)?)\\ 31)|((Jan(uary)?|Ma(r(ch)?|y)|Apr(il)?|Ju((ly?)|(ne?))|Aug(ust)?|Oct(ober)?|(Sept|Nov|Dec)(ember)?)\\ (0?[1-9]|([12]\\d)|30))|(Feb(ruary)?\\ (0?[1-9]|1\\d|2[0-8]|(29(?=,\\ ((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))))\\,\\ ((1[6-9]|[2-9]\\d)\\d{2}))",
        "raw_prompt": "This RE validate Dates in the MMM dd, yyyy format from Jan 1, 1600 to Dec 31, 9999. The format is as follows: The name or 3 letter abbreivation, without a period, of the month, then a space then the day value then a comma then a space finally the year. The correct number of day are validated for each month include leap years. The name of month is case sensitive.",
        "refined_prompt": "\nMatch examples:\n- \"Jan 1, 2003\"\n- \"February 29, 2004\"\n- \"November 02, 3202\"\nNon-match examples:\n- \"Feb 29, 2003\"\n- \"Apr 31, 1978\"",
        "matches": [
            "Jan 1, 2003",
            "February 29, 2004",
            "November 02, 3202"
        ],
        "non_matches": [
            "Feb 29, 2003",
            "Apr 31, 1978",
            "jan 33,3333"
        ],
        "stress_tests": []
    },
    {
        "id": 355,
        "expression": "^((31(?!\\ (Feb(ruary)?|Apr(il)?|June?|(Sep(?=\\b|t)t?|Nov)(ember)?)))|((30|29)(?!\\ Feb(ruary)?))|(29(?=\\ Feb(ruary)?\\ (((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))|(0?[1-9])|1\\d|2[0-8])\\ (Jan(uary)?|Feb(ruary)?|Ma(r(ch)?|y)|Apr(il)?|Ju((ly?)|(ne?))|Aug(ust)?|Oct(ober)?|(Sep(?=\\b|t)t?|Nov|Dec)(ember)?)\\ ((1[6-9]|[2-9]\\d)\\d{2})$",
        "raw_prompt": "This RE validates dates in the dd MMM yyyy format. Spaces separate the values.",
        "refined_prompt": "\nMatch examples:\n- \"31 January 2003\"\n- \"29 March 2004\"\n- \"29 Feb 2008\"\nNon-match examples:\n- \"Jan 1 2003\"\n- \"31 Sept 2003\"",
        "matches": [
            "31 January 2003",
            "29 March 2004",
            "29 Feb 2008"
        ],
        "non_matches": [
            "Jan 1 2003",
            "31 Sept 2003",
            "29 February 2003"
        ],
        "stress_tests": []
    },
    {
        "id": 356,
        "expression": "^(?:J(anuary|u(ne|ly))|February|Ma(rch|y)|A(pril|ugust)|(((Sept|Nov|Dec)em)|Octo)ber)$",
        "raw_prompt": "This RE validate the full name of the months.",
        "refined_prompt": "\nMatch examples:\n- \"January\"\n- \"May\"\n- \"October\"\nNon-match examples:\n- \"Jan\"\n- \"Septem\"",
        "matches": [
            "January",
            "May",
            "October"
        ],
        "non_matches": [
            "Jan",
            "Septem",
            "Octo"
        ],
        "stress_tests": []
    },
    {
        "id": 358,
        "expression": "^1+0+$",
        "raw_prompt": "A simple regular expression to determine if a subnet mask is contiguous; that is, the submask must start with a 1 bit followed by 0 or more 1 bits, followed by 1 or more 0 bits until the end of the submask.",
        "refined_prompt": "\nMatch examples:\n- \"10\"\n- \"110\"\n- \"1100\"\nNon-match examples:\n- \"0\"\n- \"01\"",
        "matches": [
            "10",
            "110",
            "1100"
        ],
        "non_matches": [
            "0",
            "01",
            "101"
        ],
        "stress_tests": []
    },
    {
        "id": 359,
        "expression": "^(((0[1-9]|[12]\\d|3[01])\\/(0[13578]|1[02])\\/((1[6-9]|[2-9]\\d)\\d{2}))|((0[1-9]|[12]\\d|30)\\/(0[13456789]|1[012])\\/((1[6-9]|[2-9]\\d)\\d{2}))|((0[1-9]|1\\d|2[0-8])\\/02\\/((1[6-9]|[2-9]\\d)\\d{2}))|(29\\/02\\/((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))))$",
        "raw_prompt": "dd/MM/yyyy with leap years 100% integrated\nValid years : from 1600 to 9999\nAs usual, many tests have been made.\nI think this one should be fine.",
        "refined_prompt": "\nMatch examples:\n- \"29/02/2000\"\n- \"30/04/2003\"\n- \"01/01/2003\"\nNon-match examples:\n- \"29/02/2001\"\n- \"30-04-2003\"",
        "matches": [
            "29/02/2000",
            "30/04/2003",
            "01/01/2003"
        ],
        "non_matches": [
            "29/02/2001",
            "30-04-2003",
            "1/1/2003"
        ],
        "stress_tests": []
    },
    {
        "id": 360,
        "expression": "^\\d{1,5}(\\.\\d{1,2})?$",
        "raw_prompt": "validate a number 5 digits and 2 decimal places allowing zero",
        "refined_prompt": "\nMatch examples:\n- \"12345.67\"\n- \"0\"\n- \"0.1\"\nNon-match examples:\n- \"123456.78\"\n- \"123456.789\"",
        "matches": [
            "12345.67",
            "0",
            "0.1"
        ],
        "non_matches": [
            "123456.78",
            "123456.789",
            ".1"
        ],
        "stress_tests": []
    },
    {
        "id": 361,
        "expression": "(?!^0*$)(?!^0*\\.0*$)^\\d{1,5}(\\.\\d{1,2})?$",
        "raw_prompt": "validates to 5 digits and 2 decimal places but not allowing zero",
        "refined_prompt": "\nMatch examples:\n- \"12345.12\"\n- \"0.5\"\nNon-match examples:\n- \"123456.12\"\n- \"1.234\"",
        "matches": [
            "12345.12",
            "0.5"
        ],
        "non_matches": [
            "123456.12",
            "1.234",
            ".1"
        ],
        "stress_tests": []
    },
    {
        "id": 362,
        "expression": "^[^<>`~!/@\\#}$%:;)(_^{&*=|'+]+$",
        "raw_prompt": "A general string validation to insure that NO malicious code or specified characters are passed through user input. This will allow you to input any characters except those specified. The expression above does not allow user input of &lt;&gt;`~!/@\\#}$%:;)(_^{&amp;*=|'+. Input as many invalid characters you wish to deny. This really works!",
        "refined_prompt": "\nMatch examples:\n- \"This is a test\"\nNon-match examples:\n- \"<href =\"\n- \"<br>\"",
        "matches": [
            "This is a test"
        ],
        "non_matches": [
            "<href =",
            "<br>",
            "That's it"
        ],
        "stress_tests": []
    },
    {
        "id": 363,
        "expression": "^([\\(]{1}[0-9]{3}[\\)]{1}[\\.| |\\-]{0,1}|^[0-9]{3}[\\.|\\-| ]?)?[0-9]{3}(\\.|\\-| )?[0-9]{4}$",
        "raw_prompt": "More permissive than others on the site, this one allows you to let a user enter US phone numbers in the way they most commonly use, without letting them enter non-valid combinations.",
        "refined_prompt": "\nMatch examples:\n- \"5551212\"\n- \"614555-1212\"\n- \"(614)555-1212\"\nNon-match examples:\n- \"A12-5555\"\n- \"(614-555-1212\"",
        "matches": [
            "5551212",
            "614555-1212",
            "(614)555-1212"
        ],
        "non_matches": [
            "A12-5555",
            "(614-555-1212",
            "555*1212"
        ],
        "stress_tests": []
    },
    {
        "id": 364,
        "expression": "^([1-9]{1}[0-9]{3}[,]?)*([1-9]{1}[0-9]{3})$",
        "raw_prompt": "Matches a comma-seperated list of year(s).",
        "refined_prompt": "\nMatch examples:\n- \"1999,2001,1988\"\n- \"1999\"\nNon-match examples:\n- \"0199,1997\"\n- \"0199\"",
        "matches": [
            "1999,2001,1988",
            "1999"
        ],
        "non_matches": [
            "0199,1997",
            "0199",
            "1999,"
        ],
        "stress_tests": []
    },
    {
        "id": 366,
        "expression": "^(((0[13578]|10|12)([-./])(0[1-9]|[12][0-9]|3[01])([-./])(\\d{4}))|((0[469]|11)([-./])([0][1-9]|[12][0-9]|30)([-./])(\\d{4}))|((02)([-./])(0[1-9]|1[0-9]|2[0-8])([-./])(\\d{4}))|((02)(\\.|-|\\/)(29)([-./])([02468][048]00))|((02)([-./])(29)([-./])([13579][26]00))|((02)([-./])(29)([-./])([0-9][0-9][0][48]))|((02)([-./])(29)([-./])([0-9][0-9][2468][048]))|((02)([-./])(29)([-./])([0-9][0-9][13579][26])))$",
        "raw_prompt": "This works for all accept 01/01/0000 mainly 0000. can anybody suggest a solution.",
        "refined_prompt": "\nMatch examples:\n- \"01/01/2001\"\nNon-match examples:\n- \"01/01/00000\"",
        "matches": [
            "01/01/2001"
        ],
        "non_matches": [
            "01/01/00000"
        ],
        "stress_tests": []
    },
    {
        "id": 367,
        "expression": "^((\\d{5}-\\d{4})|(\\d{5})|([AaBbCcEeGgHhJjKkLlMmNnPpRrSsTtVvXxYy]\\d[A-Za-z]\\s?\\d[A-Za-z]\\d))$",
        "raw_prompt": "Regular expression for US (ZIP and ZIP+4) and Canadian postal codes. It allows 5 digits for the first US postal code and requires that the +4, if it exists, is four digits long. Canadain postal codes can contain a space and take form of A1A 1A1. The letters can be upper or lower case, but the first letter must be one of the standard Canadian zones: A,B,C,E,G,H,J,K,L,M,N,P,R,S,T,V,X,Y.",
        "refined_prompt": "\nMatch examples:\n- \"00501\"\n- \"84118-3423\"\n- \"n3a 3B7\"\nNon-match examples:\n- \"501-342\"\n- \"123324\"",
        "matches": [
            "00501",
            "84118-3423",
            "n3a 3B7"
        ],
        "non_matches": [
            "501-342",
            "123324",
            "Q4B 5C5"
        ],
        "stress_tests": []
    },
    {
        "id": 369,
        "expression": "^[a-zA-Z_]{1}[a-zA-Z0-9_]+$",
        "raw_prompt": "This expression validates for valid C# or C++ identifier",
        "refined_prompt": "\nMatch examples:\n- \"_12ffsd\"\n- \"abcd123\"\n- \"abcd_23232\"\nNon-match examples:\n- \"..//\"\n- \"..13e232\"",
        "matches": [
            "_12ffsd",
            "abcd123",
            "abcd_23232"
        ],
        "non_matches": [
            "..//",
            "..13e232",
            "abcd 3232"
        ],
        "stress_tests": []
    },
    {
        "id": 370,
        "expression": "^[1]$|^[3]$|^[4]$|^[6]$|^[1]0$",
        "raw_prompt": "This will match single numbers,the first block [1346] checks for single digits of 1, 3, 4 or 6, could easily by [1-5] as well. The second block [10] checks for 10 only.\nThis matches inclusively.",
        "refined_prompt": "\nMatch examples:\n- \"1\"\n- \"4\"\n- \"10\"\nNon-match examples:\n- \"13\"\n- \"2\"",
        "matches": [
            "1",
            "4",
            "10"
        ],
        "non_matches": [
            "13",
            "2",
            "0"
        ],
        "stress_tests": []
    },
    {
        "id": 371,
        "expression": "^[A]$|^[C]$|^[D]$|^[F]$|^[H]$|^[K]$|^[L]$|^[M]$|^[O]$|^[P]$",
        "raw_prompt": "This is for matching Single uppercase Letters inclusively",
        "refined_prompt": "\nMatch examples:\n- \"A\"\n- \"F\"\n- \"P\"\nNon-match examples:\n- \"a\"\n- \"b\"",
        "matches": [
            "A",
            "F",
            "P"
        ],
        "non_matches": [
            "a",
            "b",
            "cd"
        ],
        "stress_tests": []
    },
    {
        "id": 374,
        "expression": "^[-]?([1-9]{1}[0-9]{0,}(\\.[0-9]{0,2})?|0(\\.[0-9]{0,2})?|\\.[0-9]{1,2})$",
        "raw_prompt": "This regular expression will match on a real / decimal / floating point / numeric string with no more than 2 digits past the decimal. The negative sign (-) is allowed. No leading zeroes or commas. It is based on a currency regular expression by Tom Persing.",
        "refined_prompt": "\nMatch examples:\n- \"123\"\n- \"123.54\"\n- \"-.54\"\nNon-match examples:\n- \"123.543\"\n- \"0012\"",
        "matches": [
            "123",
            "123.54",
            "-.54"
        ],
        "non_matches": [
            "123.543",
            "0012",
            "1,000.12"
        ],
        "stress_tests": []
    },
    {
        "id": 375,
        "expression": "^([a-zA-Z]\\:|\\\\\\\\[^\\/\\\\:*?\"<>|]+\\\\[^\\/\\\\:*?\"<>|]+)(\\\\[^\\/\\\\:*?\"<>|]+)+(\\.[^\\/\\\\:*?\"<>|]+)$",
        "raw_prompt": "This regular expression match any valid file path. It checks local drives and network path. The file extension is required.",
        "refined_prompt": "\nMatch examples:\n- \"c:\\Test.txt\"\n- \"\\\\server\\shared\\Test.txt\"\n- \"\\\\server\\shared\\Test.t\"\nNon-match examples:\n- \"c:\\Test\"\n- \"\\\\server\\shared\"",
        "matches": [
            "c:\\Test.txt",
            "\\\\server\\shared\\Test.txt",
            "\\\\server\\shared\\Test.t"
        ],
        "non_matches": [
            "c:\\Test",
            "\\\\server\\shared",
            "\\\\server\\shared\\Test.?"
        ],
        "stress_tests": []
    },
    {
        "id": 381,
        "expression": "<[^>]*>",
        "raw_prompt": "HTML Pattern Matching\nPLEASE HELP\n/&lt;[^&gt;]*&gt;/ig\nThe above pattern is only successful when html tag are simple (they don't include any javascript). This mean that the pattern will fail if something like this is within the tag &lt;input type=button value=test onclick='if(n.value&gt;5)do_this();'&gt;. It will not match the entire open n close sign.\nHow do you write a pattern that will pass all these tag so that the pattern will match from the open to the close sign and not when it just see a &gt; within a '' or &quot;&quot;.\n&lt;input type=button onclick='if(n.value&gt;5)do_this();'&gt; not this &lt;br&gt;\n&lt;input type=button onclick=&quot;n&gt;5?a():b();&quot; value=test&gt; not this &lt;br&gt;\n&lt;input type=button onclick=&quot;n&gt;5?a(\\&quot;OK\\&quot;):b('Not Ok');&quot; value=test&gt; not this &lt;br&gt;\n&lt;input type=button onclick='n&gt;5' value=test onmouseover=&quot;n&lt;5&amp;&amp;n&gt;8&quot; onmouseout='if(n&gt;5)alert(\\'True\\');else alert(&quot;False&quot;)'&gt; not this &lt;br&gt;\nAny help would be greatly appreciate. Thanks a whole lot.\nLogan",
        "refined_prompt": "\nMatch examples:\n- \"<html>\"\nNon-match examples:\n- \"abc\"",
        "matches": [
            "<html>"
        ],
        "non_matches": [
            "abc"
        ],
        "stress_tests": []
    },
    {
        "id": 382,
        "expression": "^([0-9]*\\-?\\ ?\\/?[0-9]*)$",
        "raw_prompt": "Match italian telephone number with prefix followed by &quot;/&quot;, &quot;-&quot; or blank and number. Usefull with numeric keybord!",
        "refined_prompt": "\nMatch examples:\n- \"02-343536\"\n- \"02/343536\"\n- \"02 343536\"\nNon-match examples:\n- \"02a343536\"\n- \"02+343536\"",
        "matches": [
            "02-343536",
            "02/343536",
            "02 343536"
        ],
        "non_matches": [
            "02a343536",
            "02+343536"
        ],
        "stress_tests": []
    },
    {
        "id": 386,
        "expression": "^(\\d+|[a-zA-Z]+)$",
        "raw_prompt": "Tests for all numbers OR all letters (upper or lower case)\n( posted from WebService - http://regexlib.com/webservices.asmx?op=Save )\n( updated from WebService - http://regexlib.com/webservices.asmx?op=Save )",
        "refined_prompt": "\nMatch examples:\n- \"aaaaadddaaaaa\"\n- \"1166633337\"\nNon-match examples:\n- \"1n\"\n- \"ppppp99\"",
        "matches": [
            "aaaaadddaaaaa",
            "1166633337"
        ],
        "non_matches": [
            "1n",
            "ppppp99"
        ],
        "stress_tests": []
    },
    {
        "id": 392,
        "expression": "\\.com/(\\d+)$",
        "raw_prompt": "This is a regex I wrote to capture requests to AspAlliance.com with an article id as the only thing after the domain. So http://aspalliance.com/123 would go to article number 123. It maps the URL to the actual aspx file that displays the article based on the ID.",
        "refined_prompt": "\nMatch examples:\n- \"http://aspalliance.com/123\"\n- \"www.aspalliance.com/123\"\n- \"http://aspalliance.com/34\"\nNon-match examples:\n- \"http://aspalliance.com/article.aspx?id=123\"\n- \"http://aspalliance.com/\"",
        "matches": [
            "http://aspalliance.com/123",
            "www.aspalliance.com/123",
            "http://aspalliance.com/34"
        ],
        "non_matches": [
            "http://aspalliance.com/article.aspx?id=123",
            "http://aspalliance.com/",
            "http://aspalliance.com/articl"
        ],
        "stress_tests": []
    },
    {
        "id": 393,
        "expression": ".*?$(?<!\\.aspx)",
        "raw_prompt": "Matches a string to ensure that it does not end with .aspx; sure, you'd probably use string handling to do something this simple but, in the real world you'd whack a regex which validates a valid url to the front of this.\nThe pattern was created by Wayne King; you can read about it here:\nhttp://scottwater.com/blog/posts/10204.aspx",
        "refined_prompt": "\nMatch examples:\n- \"http://weblogs.asp.net/DNeimke/blah.gif\"\nNon-match examples:\n- \"http://weblogs.asp.net/DNeimke/Default.aspx\"",
        "matches": [
            "http://weblogs.asp.net/DNeimke/blah.gif"
        ],
        "non_matches": [
            "http://weblogs.asp.net/DNeimke/Default.aspx"
        ],
        "stress_tests": []
    },
    {
        "id": 394,
        "expression": "^(1\\s*[-\\/\\.]?)?(\\((\\d{3})\\)|(\\d{3}))\\s*[-\\/\\.]?\\s*(\\d{3})\\s*[-\\/\\.]?\\s*(\\d{4})\\s*(([xX]|[eE][xX][tT])\\.?\\s*(\\d+))*$",
        "raw_prompt": "This regular expressions matches phone numbers with area codes and optional US country code and optional phone extension. User have so many ways of entering phone numbers into input fields. This allows for some of the ones I've encountered. Feel free to contact me if you find ones that do not match.",
        "refined_prompt": "\nMatch examples:\n- \"2405525009\"\n- \"1(240) 652-5009\"\n- \"240/752-5009 ext.55\"\nNon-match examples:\n- \"(2405525009\"\n- \"2 (240) 652-5009\"",
        "matches": [
            "2405525009",
            "1(240) 652-5009",
            "240/752-5009 ext.55"
        ],
        "non_matches": [
            "(2405525009",
            "2 (240) 652-5009"
        ],
        "stress_tests": []
    },
    {
        "id": 395,
        "expression": "^[0-9]{5}([- /]?[0-9]{4})?$",
        "raw_prompt": "US Zip Code + 4 digit extension Postal Code",
        "refined_prompt": "\nMatch examples:\n- \"14467\"\n- \"144679554\"\n- \"14467-9554\"\nNon-match examples:\n- \"14467 955\"\n- \"14467-\"",
        "matches": [
            "14467",
            "144679554",
            "14467-9554"
        ],
        "non_matches": [
            "14467 955",
            "14467-",
            "1446-9554"
        ],
        "stress_tests": []
    },
    {
        "id": 396,
        "expression": "(.)\\1{2,}",
        "raw_prompt": "matches any string with characters repeated more than twice, sometimes used as fake input",
        "refined_prompt": "\nMatch examples:\n- \"aaaeee\"\n- \"????????\"\n- \"gooogle\"\nNon-match examples:\n- \"google\"\n- \"booboo\"",
        "matches": [
            "aaaeee",
            "????????",
            "gooogle"
        ],
        "non_matches": [
            "google",
            "booboo"
        ],
        "stress_tests": []
    },
    {
        "id": 397,
        "expression": "^p(ost)?[ |\\.]*o(ffice)?[ |\\.]*(box)?[ 0-9]*[^[a-z ]]*",
        "raw_prompt": "This expression is useful for determining if an address is a PO Box type address. This can be useful in shipping systems as well as other systems that need to make determinations based on the type of address imputed.",
        "refined_prompt": "\nMatch examples:\n- \"po box 4353\"\nNon-match examples:\n- \"pollo St.\"\n- \"P. O. Box d3f12s\"",
        "matches": [
            "po box 4353"
        ],
        "non_matches": [
            "pollo St.",
            "P. O. Box d3f12s",
            "BOX 23"
        ],
        "stress_tests": []
    },
    {
        "id": 398,
        "expression": "^\\d+\\x20*([pP][xXtT])?$",
        "raw_prompt": "It can be used to validate Font Sizes.\nThanks to Gideon Engelberth for the shorter version of my original expression.",
        "refined_prompt": "\nMatch examples:\n- \"1px\"\n- \"100 PT\"\n- \"20Px\"\nNon-match examples:\n- \"1abc\"\n- \"px\"",
        "matches": [
            "1px",
            "100 PT",
            "20Px"
        ],
        "non_matches": [
            "1abc",
            "px",
            "1 sdfs"
        ],
        "stress_tests": []
    },
    {
        "id": 399,
        "expression": "ISBN\\x20(?=.{13}$)\\d{1,5}([- ])\\d{1,7}\\1\\d{1,6}\\1(\\d|X)$",
        "raw_prompt": "This RE validates the format of an ISBN number",
        "refined_prompt": "\nMatch examples:\n- \"ISBN 0 93028 923 4\"\n- \"ISBN 1-56389-668-0\"\n- \"ISBN 1-56389-016-X\"\nNon-match examples:\n- \"123456789X\"\n- \"ISBN 9-87654321-2\"",
        "matches": [
            "ISBN 0 93028 923 4",
            "ISBN 1-56389-668-0",
            "ISBN 1-56389-016-X"
        ],
        "non_matches": [
            "123456789X",
            "ISBN 9-87654321-2",
            "ISBN 123 456-789X"
        ],
        "stress_tests": []
    },
    {
        "id": 400,
        "expression": "<([^\\s>]*)(\\s[^<]*)>",
        "raw_prompt": "grab all tags attributes...\n&lt;img src=&quot;truc&quot;&gt; returns :\n&lt;\n(1:img)\n(2: src=&quot;truc&quot;)\n&gt;\ni use it to clean html pages to grab infos...\nuse a RegEx Replace with &quot;&lt;$1&gt;&quot; to keep only tags codes...",
        "refined_prompt": "\nMatch examples:\n- \"<img src=\"truc\">\"\n- \"<body background='...'>\"\n- \"<p align='left'>\"\nNon-match examples:\n- \"<br>\"\n- \"</body>\"",
        "matches": [
            "<img src=\"truc\">",
            "<body background='...'>",
            "<p align='left'>"
        ],
        "non_matches": [
            "<br>",
            "</body>",
            "<p>"
        ],
        "stress_tests": []
    },
    {
        "id": 401,
        "expression": "<([^<>\\s]*)(\\s[^<>]*)?>",
        "raw_prompt": "All tags in first submatche\nAll attributes in second one...",
        "refined_prompt": "\nMatch examples:\n- \"<td class=\"TD2\">\"\n- \"<!-- comment -->\"\n- \"</table>\"\nNon-match examples:\n- \"19-Fev-2002 - 19h00\"\n- \"New Changes :\"",
        "matches": [
            "<td class=\"TD2\">",
            "<!-- comment -->",
            "</table>"
        ],
        "non_matches": [
            "19-Fev-2002 - 19h00",
            "New Changes :",
            "..."
        ],
        "stress_tests": []
    },
    {
        "id": 402,
        "expression": "^((Bob)|(John)|(Mary)).*$(?<!White)",
        "raw_prompt": "&quot;Starts with but does not end with.&quot;\nI needed a pattern to require certain first (and optional middle) names, but to fail for certain last names. So if Bob, John, and Mary are acceptable first names but the White's are always rejected then...",
        "refined_prompt": "\nMatch examples:\n- \"Bob Jones\"\n- \"John Smith\"\n- \"Mary Jane Smith\"\nNon-match examples:\n- \"Bob White\"\n- \"Mary Doe White\"",
        "matches": [
            "Bob Jones",
            "John Smith",
            "Mary Jane Smith"
        ],
        "non_matches": [
            "Bob White",
            "Mary Doe White",
            "Gina Smith"
        ],
        "stress_tests": []
    },
    {
        "id": 403,
        "expression": "[^!~/&gt;&lt;\\|/#%():;{}`_-]",
        "raw_prompt": "Trying to remove all these characters in the regular expression: still working on it\n!~/[&gt;&lt;*\\|]/#$%^&amp;():;{},?`_-",
        "refined_prompt": "\nMatch examples:\n- \"Soma\"\n- \"Infy\"\n- \"every\"\nNon-match examples:\n- \"&lt;\"\n- \"&gt;\"",
        "matches": [
            "Soma",
            "Infy",
            "every"
        ],
        "non_matches": [
            "&lt;",
            "&gt;",
            "!"
        ],
        "stress_tests": []
    },
    {
        "id": 404,
        "expression": "^([\\s\\S]){1,20}([\\s\\.])",
        "raw_prompt": "This pattern returns as much of the first x characters of a string as full words or sentences as a match, where x is currently 20. Change x to adjust the length supported in your database field.\nI'm currently using this within a string shortening utility to shrink large text regions to word/sentance-boundary elements and appending an ellipsis as a text continuator.",
        "refined_prompt": "\nMatch examples:\n- \"Any text of any length\"\n- \"...but will only 'match' the first 20 characters at a period or space.\"\nNon-match examples:\n- \"N/A\"",
        "matches": [
            "Any text of any length",
            "...but will only 'match' the first 20 characters at a period or space."
        ],
        "non_matches": [
            "N/A"
        ],
        "stress_tests": []
    },
    {
        "id": 405,
        "expression": "^(?-i:A[LKSZRAEP]|C[AOT]|D[EC]|F[LM]|G[AU]|HI|I[ADLN]|K[SY]|LA|M[ADEHINOPST]|N[CDEHJMVY]|O[HKR]|P[ARW]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY])$",
        "raw_prompt": "The RE match U.S. state abbreviation used by the U.S. Post Office.",
        "refined_prompt": "\nMatch examples:\n- \"AL\"\n- \"CA\"\n- \"AA\"\nNon-match examples:\n- \"New York\"\n- \"California\"",
        "matches": [
            "AL",
            "CA",
            "AA"
        ],
        "non_matches": [
            "New York",
            "California",
            "ny"
        ],
        "stress_tests": []
    },
    {
        "id": 407,
        "expression": "^[A-Za-z]{6}[0-9]{2}[A-Za-z]{1}[0-9]{2}[A-Za-z]{1}[0-9]{3}[A-Za-z]{1}$",
        "raw_prompt": "This pattern match italian fiscal code (codice fiscale).",
        "refined_prompt": "\nMatch examples:\n- \"SPGGRG73A02E625S\"\n- \"czzdll74h18f205w\"\nNon-match examples:\n- \"SP6FFFF3A02E625S\"\n- \"czzdll74h18f205\"",
        "matches": [
            "SPGGRG73A02E625S",
            "czzdll74h18f205w"
        ],
        "non_matches": [
            "SP6FFFF3A02E625S",
            "czzdll74h18f205"
        ],
        "stress_tests": []
    },
    {
        "id": 408,
        "expression": "(\\w(\\s)?)+",
        "raw_prompt": "Used to verify that the string consists of only A-z, 0 - 9 and underscore. Several words allowed, only one space between them. No spaces up front. Hey, I know it's easy, but it was not in the library! Plus, the test option here is not working well all the time.",
        "refined_prompt": "\nMatch examples:\n- \"Test\"\n- \"TesT\"\n- \"tesT9 _test9\"\nNon-match examples:\n- \"\\\\\\\"",
        "matches": [
            "Test",
            "TesT",
            "tesT9 _test9"
        ],
        "non_matches": [
            "\\\\\\"
        ],
        "stress_tests": []
    },
    {
        "id": 412,
        "expression": "^(([8]))$|^((([0-7]))$|^((([0-7])).?((25)|(50)|(5)|(75)|(0)|(00))))$",
        "raw_prompt": "Time off hours edit for quarter hour(s) less than eight.",
        "refined_prompt": "\nMatch examples:\n- \"0.25\"\n- \"7.75\"\n- \"8\"\nNon-match examples:\n- \"8.25\"\n- \"7.15\"",
        "matches": [
            "0.25",
            "7.75",
            "8"
        ],
        "non_matches": [
            "8.25",
            "7.15",
            "0.15"
        ],
        "stress_tests": []
    },
    {
        "id": 420,
        "expression": "^ISBN\\s(?=[-0-9xX ]{13}$)(?:[0-9]+[- ]){3}[0-9]*[xX0-9]$",
        "raw_prompt": "This pattern validates ISBN numbers. I've written a full description about it here: http://regexblogs.com/dneimke/posts/201.aspx",
        "refined_prompt": "\nMatch examples:\n- \"ISBN 90-70002-34-5\"\n- \"ISBN 90-70002-34-x\"\nNon-match examples:\n- \"ISBN 90-70002-34-5x\"\n- \"ISBN 90-700-02-34-5\"",
        "matches": [
            "ISBN 90-70002-34-5",
            "ISBN 90-70002-34-x"
        ],
        "non_matches": [
            "ISBN 90-70002-34-5x",
            "ISBN 90-700-02-34-5"
        ],
        "stress_tests": []
    },
    {
        "id": 421,
        "expression": "^(((0[1-9]|[12]\\d|3[01])\\/(0[13578]|1[02])\\/(\\d{2}))|((0[1-9]|[12]\\d|30)\\/(0[13456789]|1[012])\\/(\\d{2}))|((0[1-9]|1\\d|2[0-8])\\/02\\/(\\d{2}))|(29\\/02\\/((0[48]|[2468][048]|[13579][26])|(00))))$",
        "raw_prompt": "Matching : dd/MM/yy\nLeap years compatible\nItalian style, just for more fun.\nPlease, don't forget to rate it if you use it. THX",
        "refined_prompt": "\nMatch examples:\n- \"31/12/75\"\n- \"29/02/00\"\n- \"29/02/04\"\nNon-match examples:\n- \"01/13/01\"\n- \"29/02/01\"",
        "matches": [
            "31/12/75",
            "29/02/00",
            "29/02/04"
        ],
        "non_matches": [
            "01/13/01",
            "29/02/01",
            "29/02/2004"
        ],
        "stress_tests": []
    },
    {
        "id": 429,
        "expression": "^(0)$|^([1-9][0-9]*)$",
        "raw_prompt": "This regular expression matches on postive whole numbers and 0. Whole numbers that are left padded with 0's are not a match.",
        "refined_prompt": "\nMatch examples:\n- \"12\"\n- \"0\"\n- \"1200\"\nNon-match examples:\n- \"-12\"\n- \"0012\"",
        "matches": [
            "12",
            "0",
            "1200"
        ],
        "non_matches": [
            "-12",
            "0012"
        ],
        "stress_tests": []
    },
    {
        "id": 431,
        "expression": "^(0*100{1,1}\\.?((?<=\\.)0*)?%?$)|(^0*\\d{0,2}\\.?((?<=\\.)\\d*)?%?)$",
        "raw_prompt": "Percentage (From 0 to 100)",
        "refined_prompt": "\nMatch examples:\n- \"100%\"\n- \"100\"\n- \"52.65%\"\nNon-match examples:\n- \"-1\"\n- \"-1%\"",
        "matches": [
            "100%",
            "100",
            "52.65%"
        ],
        "non_matches": [
            "-1",
            "-1%",
            "100.1%"
        ],
        "stress_tests": []
    },
    {
        "id": 433,
        "expression": "((^(10|12|0?[13578])(3[01]|[12][0-9]|0?[1-9])((1[8-9]\\d{2})|([2-9]\\d{3}))$)|(^(11|0?[469])(30|[12][0-9]|0?[1-9])((1[8-9]\\d{2})|([2-9]\\d{3}))$)|(^(0?2)(2[0-8]|1[0-9]|0?[1-9])((1[8-9]\\d{2})|([2-9]\\d{3}))$)|(^(0?2)(29)([2468][048]00)$)|(^(0?2)(29)([3579][26]00)$)|(^(0?2)(29)([1][89][0][48])$)|(^(0?2)(29)([2-9][0-9][0][48])$)|(^(0?2)(29)([1][89][2468][048])$)|(^(0?2)(29)([2-9][0-9][2468][048])$)|(^(0?2)(29)([1][89][13579][26])$)|(^(0?2)(29)([2-9][0-9][13579][26])$))",
        "raw_prompt": "Matches on MMDDYYYY only, requires all 8 digits",
        "refined_prompt": "\nMatch examples:\n- \"01012003\"\n- \"02292000\"\nNon-match examples:\n- \"01/01/2003\"",
        "matches": [
            "01012003",
            "02292000"
        ],
        "non_matches": [
            "01/01/2003"
        ],
        "stress_tests": []
    },
    {
        "id": 435,
        "expression": "^\\d{1,7}$",
        "raw_prompt": "Positive Whole number matched from 0 to 9999999. Only 7 digits length is allowed.",
        "refined_prompt": "\nMatch examples:\n- \"1234567\"\n- \"9999999\"\n- \"1\"\nNon-match examples:\n- \"12345678\"\n- \"9999.99\"",
        "matches": [
            "1234567",
            "9999999",
            "1"
        ],
        "non_matches": [
            "12345678",
            "9999.99",
            "-1234"
        ],
        "stress_tests": []
    },
    {
        "id": 439,
        "expression": "^((([sS][r-tR-Tx-zX-Z])\\s*([sx-zSX-Z])?\\s*([a-zA-Z]{2,3}))?\\s*(\\d\\d)\\s*-?\\s*(\\d{6,7}))$",
        "raw_prompt": "California Resale License number validator. Validates Letters and Numbers or Number only. Letters: First 2 letters can be SR, SS, ST , SX, SY, SZ (TAT Code) Next optional letter can be S,X,Y,Z. Next letters must be a minimum of two and a maximum of 3 (District Code). Numbers: Can be 8-9 numbers. Numbers can be delimited with a hypen or spaces after the first 2 numbers. Note: I use () to extract the information I want for use in other scripts.",
        "refined_prompt": "\nMatch examples:\n- \"SR BH 97-578613\"\n- \"97578613\"\n- \"SRXBH97578613\"\nNon-match examples:\n- \"RR BH 97-578613\"\n- \"9757861\"",
        "matches": [
            "SR BH 97-578613",
            "97578613",
            "SRXBH97578613"
        ],
        "non_matches": [
            "RR BH 97-578613",
            "9757861",
            "SRAABH 97-578613"
        ],
        "stress_tests": []
    },
    {
        "id": 440,
        "expression": "^[a-zA-Z0-9_\\s-]+$",
        "raw_prompt": "This tests an input string for only a-z and A-Z and only allows underscores, hyphens and spaces. The purpose is to force users to generate legitimate, readable file names that can be streamed from the web.",
        "refined_prompt": "\nMatch examples:\n- \"123Testing\"\n- \"123_Testing\"\n- \"123-Testing This\"\nNon-match examples:\n- \"!@#Testing\"\n- \"Testing &quot;This&quot;\"",
        "matches": [
            "123Testing",
            "123_Testing",
            "123-Testing This"
        ],
        "non_matches": [
            "!@#Testing",
            "Testing &quot;This&quot;",
            "Don't Forget to Write"
        ],
        "stress_tests": []
    },
    {
        "id": 441,
        "expression": "^DOMAIN\\\\\\w+$",
        "raw_prompt": "In response to a question on the regex list at www.aspadvice.com, this expression should ensure that a login field's username includes a 'DOMAIN\\' prefix. The latter part of the expression should probably be limited so that it only allows usernames of appropriate lengths, perhaps 3 to 20 characters (by replacing + with {3,20} for instance).",
        "refined_prompt": "\nMatch examples:\n- \"DOMAIN\\ssmith\"\n- \"DOMAIN\\a\"\n- \"DOMAIN\\username\"\nNon-match examples:\n- \"ssmith\"\n- \"username\"",
        "matches": [
            "DOMAIN\\ssmith",
            "DOMAIN\\a",
            "DOMAIN\\username"
        ],
        "non_matches": [
            "ssmith",
            "username",
            "DOMAIN\\"
        ],
        "stress_tests": []
    },
    {
        "id": 442,
        "expression": "^\\W{0,5}[Rr]e:\\W[a-zA-Z0-9]{1,10},\\W[a-z]{1,10}\\W[a-z]{1,10}\\W[a-z]{1,10}",
        "raw_prompt": "Simple email subject line matching. This regex matches those really annoying emails that begin with 0-5 spaces, followed by a fake reply, contain a random string of letters (usually CAPITALIZED) from 1-10 characters long followed by a comma, and then followed by three lower-case words each from 1-10 characters long. In my experience, the 3 trailing words are always lower-case. the words make begin with, contain, or end in common punctuation marks.",
        "refined_prompt": "\nMatch examples:\n- \"re: ASDFG, hours among lifestyle\"\n- \"Re: ASD34SSDF, i can't believe\"\n- \"Re: VZWENKS, the coffin brogade\"\nNon-match examples:\n- \"re: ASDFGASFDASDF, Hours among lifestyle\"\n- \"Re: ASD34SSDF, I can't believe it's true\"",
        "matches": [
            "re: ASDFG, hours among lifestyle",
            "Re: ASD34SSDF, i can't believe",
            "Re: VZWENKS, the coffin brogade"
        ],
        "non_matches": [
            "re: ASDFGASFDASDF, Hours among lifestyle",
            "Re: ASD34SSDF, I can't believe it's true"
        ],
        "stress_tests": []
    },
    {
        "id": 444,
        "expression": "^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\,*\\s\\s*\\d{4}$|^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\\,*\\s\\d{4}$|^(January|February|March|April|May|June|July|August|September|October|November|December)\\,*\\s\\d{4}$|^(january|february|march|april|may|june|july|august|september|october|november|december)\\,*\\s\\d{4}$",
        "raw_prompt": "Best Use validation to accept a valid &quot;MonthName(,) Year&quot;.\nIt can validate an entry with or without comma (,).",
        "refined_prompt": "\nMatch examples:\n- \"January 2004\"\n- \"Jan, 2004\"\n- \"january 2003\"\nNon-match examples:\n- \"Janu 2004\"\n- \"jAn, 2004\"",
        "matches": [
            "January 2004",
            "Jan, 2004",
            "january 2003"
        ],
        "non_matches": [
            "Janu 2004",
            "jAn, 2004",
            "January,2003"
        ],
        "stress_tests": []
    },
    {
        "id": 452,
        "expression": "^[a-zA-Z]+(([\\'\\,\\.\\-][a-zA-Z])?[a-zA-Z]*)*$",
        "raw_prompt": "This allows you to validate first names and last names in seperate fields. Instead of validating a full name in one field.",
        "refined_prompt": "\nMatch examples:\n- \"Sameul\"\n- \"O'Conner\"\n- \"Mary-Kate\"\nNon-match examples:\n- \"David Bugel\"\n- \"Robert1\"",
        "matches": [
            "Sameul",
            "O'Conner",
            "Mary-Kate"
        ],
        "non_matches": [
            "David Bugel",
            "Robert1",
            "Robert M. Larry"
        ],
        "stress_tests": []
    },
    {
        "id": 454,
        "expression": "(?i:on(blur|c(hange|lick)|dblclick|focus|keypress|(key|mouse)(down|up)|(un)?load|mouse(move|o(ut|ver))|reset|s(elect|ubmit)))",
        "raw_prompt": "This regex will match all the valid on event attributes in HTML 4.01/XHTML 1.0",
        "refined_prompt": "\nMatch examples:\n- \"onclick\"\n- \"onsubmit\"\n- \"onmouseover\"\nNon-match examples:\n- \"click\"\n- \"onandon\"",
        "matches": [
            "onclick",
            "onsubmit",
            "onmouseover"
        ],
        "non_matches": [
            "click",
            "onandon",
            "mickeymouse"
        ],
        "stress_tests": []
    },
    {
        "id": 458,
        "expression": "^#?(([fFcC0369])\\2){3}$",
        "raw_prompt": "Matches the 216 web colors with or without the '#' sign.",
        "refined_prompt": "\nMatch examples:\n- \"#FFFFFF\"\n- \"FFCC00\"\n- \"003300\"\nNon-match examples:\n- \"#FFFFF\"\n- \"EFCC00\"",
        "matches": [
            "#FFFFFF",
            "FFCC00",
            "003300"
        ],
        "non_matches": [
            "#FFFFF",
            "EFCC00",
            "030303"
        ],
        "stress_tests": []
    },
    {
        "id": 459,
        "expression": "^(\\d{4}-){3}\\d{4}$|^(\\d{4} ){3}\\d{4}$|^\\d{16}$",
        "raw_prompt": "Used to validate Credit Card numbers, Checks if it contains 16 numbers in groups of 4 separated by -, ,or nothing",
        "refined_prompt": "\nMatch examples:\n- \"1111-2323-2312-3434\"\n- \"1234343425262837\"\n- \"1111 2323 2312 3434\"\nNon-match examples:\n- \"1111 2323 2312-3434\"\n- \"34323423\"",
        "matches": [
            "1111-2323-2312-3434",
            "1234343425262837",
            "1111 2323 2312 3434"
        ],
        "non_matches": [
            "1111 2323 2312-3434",
            "34323423",
            "1111-2323-23122-3434"
        ],
        "stress_tests": []
    },
    {
        "id": 460,
        "expression": "^([\\+][0-9]{1,3}[\\.][0-9]{1,12})([x]?[0-9]{1,4}?)$",
        "raw_prompt": "Validates on the following standards:\n+CCC.ZZZZZZZZZZxYYYY, where 'C' is the numeric\ncountry phone code (up to three digits), 'Z' is the phone number (up to\n12 digits) and 'Y' is the extension (up to 4 digits); max length overall is\n20 characters, including the '+', '.', and 'x' (if extension is present).\nUseful for people communicating with the OpenSRS API",
        "refined_prompt": "\nMatch examples:\n- \"+800.4453377x4444\"\n- \"+80.4453377\"\n- \"+8.123456789123x1111\"\nNon-match examples:\n- \"181823884499\"\n- \"+800.4453377x\"",
        "matches": [
            "+800.4453377x4444",
            "+80.4453377",
            "+8.123456789123x1111"
        ],
        "non_matches": [
            "181823884499",
            "+800.4453377x",
            "2486994x11"
        ],
        "stress_tests": []
    },
    {
        "id": 462,
        "expression": "&amp;(?![a-zA-Z]{2,6};|#[0-9]{3};)",
        "raw_prompt": "The goal of this regular expression is to replace all &amp; (ampersand) characters by &amp;amp; if they are not the start of HTML entities. I used\nhttp://www.w3schools.com/html/html_entitiesref.asp as a reference. You can then use RegExp Replace method to do the work. Was helpful for me, might helpful be for you...",
        "refined_prompt": "\nMatch examples:\n- \"&amp;ThisIsTooLong;\"\n- \"Lilo &amp; Stich\"\n- \"&amp;l;\"\nNon-match examples:\n- \"&amp;lt;\"\n- \"&amp;brvbar;\"",
        "matches": [
            "&amp;ThisIsTooLong;",
            "Lilo &amp; Stich",
            "&amp;l;"
        ],
        "non_matches": [
            "&amp;lt;",
            "&amp;brvbar;",
            "&amp;#166;"
        ],
        "stress_tests": []
    },
    {
        "id": 464,
        "expression": "^([0-9]{2})(00[1-9]|0[1-9][0-9]|[1-2][0-9][0-9]|3[0-5][0-9]|36[0-6])$",
        "raw_prompt": "Matches a Julian date in the format YYDDD. Two digit year followed by a number from 1 - 366 indicating the day of the year.",
        "refined_prompt": "\nMatch examples:\n- \"99366\"\n- \"00001\"\nNon-match examples:\n- \"74000\"\n- \"04367\"",
        "matches": [
            "99366",
            "00001"
        ],
        "non_matches": [
            "74000",
            "04367"
        ],
        "stress_tests": []
    },
    {
        "id": 465,
        "expression": "^(?!000)([0-6]\\d{2}|7([0-6]\\d|7[012]))([ -]?)(?!00)\\d\\d\\3(?!0000)\\d{4}$",
        "raw_prompt": "This regex validates U.S. social security numbers, within the range of numbers that have been currently allocated.",
        "refined_prompt": "\nMatch examples:\n- \"078-05-1120\"\n- \"078 05 1120\"\n- \"078051120\"\nNon-match examples:\n- \"987-65-4320\"\n- \"000-00-0000\"",
        "matches": [
            "078-05-1120",
            "078 05 1120",
            "078051120"
        ],
        "non_matches": [
            "987-65-4320",
            "000-00-0000",
            "(555) 555-5555"
        ],
        "stress_tests": []
    },
    {
        "id": 471,
        "expression": "^([0-9a-zA-Z]([-.\\w]*[0-9a-zA-Z])*@([0-9a-zA-Z][-\\w]*[0-9a-zA-Z]\\.)+[a-zA-Z]{2,9})$",
        "raw_prompt": "regex to validate email address\nnoteworthy:\n(1) It allows usernames with 1 or 2 alphanum characters, or 3+ chars can have -._ in the middle. username may NOT start/end with -._ or any other non alphanumeric character.\n(2) It allows heirarchical domain names (e.g. me@really.big.com). Similar -._ placement rules there.\n(3) It allows 2-9 character alphabetic-only TLDs (that oughta cover museum and adnauseum :&gt;).\n(4) No IP email addresses though -- I wouldn't Want to accept that kind of address.",
        "refined_prompt": "\nMatch examples:\n- \"e@eee.com\"\n- \"eee@e-e.com\"\n- \"eee@ee.eee.museum\"\nNon-match examples:\n- \".@eee.com\"\n- \"eee@e-.com\"",
        "matches": [
            "e@eee.com",
            "eee@e-e.com",
            "eee@ee.eee.museum"
        ],
        "non_matches": [
            ".@eee.com",
            "eee@e-.com",
            "eee@ee.eee.eeeeeeeeee"
        ],
        "stress_tests": []
    },
    {
        "id": 473,
        "expression": "^\\d+(?:\\.\\d{0,2})?$",
        "raw_prompt": "Matches positive whole numbers with exactly zero or two decimal points if a . is present. Useful for checking currency amounts, such 5 or 5.00 or 5.25.",
        "refined_prompt": "\nMatch examples:\n- \"1\"\n- \"1.23\"\n- \"1234.45\"\nNon-match examples:\n- \"a1.34\"\n- \"1.23a\"",
        "matches": [
            "1",
            "1.23",
            "1234.45"
        ],
        "non_matches": [
            "a1.34",
            "1.23a",
            "a"
        ],
        "stress_tests": []
    },
    {
        "id": 478,
        "expression": "[^A-Za-z0-9]",
        "raw_prompt": "To detect non-alphanumeric characters (for new username/password validation, for instance):\nmonkey(AT)greyledge.net\n14-Oct-2003 11:26",
        "refined_prompt": "\nMatch examples:\n- \"!@#$\"\n- \"%^&amp;*\"\n- \"'&gt;&lt;?.,&quot;\"\nNon-match examples:\n- \"ABC123abc\"\n- \"abc123ABC\"",
        "matches": [
            "!@#$",
            "%^&amp;*",
            "'&gt;&lt;?.,&quot;"
        ],
        "non_matches": [
            "ABC123abc",
            "abc123ABC",
            "abc0132ABC"
        ],
        "stress_tests": []
    },
    {
        "id": 482,
        "expression": "^([a-zA-Z]+(.)?[\\s]*)$",
        "raw_prompt": "This regular expression matches titles. The length of the title has not been restricted. It allows only alphabets in the title and takes zero or one . after the title. Also it allows trailing spaces.",
        "refined_prompt": "\nMatch examples:\n- \"Mr.\"\n- \"Sr\"\n- \"Mr\"\nNon-match examples:\n- \"Mr..\"\n- \"12M\"",
        "matches": [
            "Mr.",
            "Sr",
            "Mr"
        ],
        "non_matches": [
            "Mr..",
            "12M",
            ".Mr"
        ],
        "stress_tests": []
    },
    {
        "id": 488,
        "expression": "^http://([a-zA-Z0-9_\\-]+)([\\.][a-zA-Z0-9_\\-]+)+([/][a-zA-Z0-9\\~\\(\\)_\\-]*)+([\\.][a-zA-Z0-9\\(\\)_\\-]+)*$",
        "raw_prompt": "A very crude url pattern.",
        "refined_prompt": "\nMatch examples:\n- \"http://www.jonas.no/~webs(i)der/jon_as.php\"\n- \"http://www.yahoo.com/net//ore\"\nNon-match examples:\n- \"http://www./no/good\"\n- \"imap://www.com/\"",
        "matches": [
            "http://www.jonas.no/~webs(i)der/jon_as.php",
            "http://www.yahoo.com/net//ore"
        ],
        "non_matches": [
            "http://www./no/good",
            "imap://www.com/"
        ],
        "stress_tests": []
    },
    {
        "id": 489,
        "expression": "(?i:([A-D])(?!\\1)([A-D])(?!\\1|\\2)([A-D])(?!\\1|\\2|\\3)([A-D]))",
        "raw_prompt": "This regex validates a string of non-repeating characters A, B, C, D.",
        "refined_prompt": "\nMatch examples:\n- \"abcd\"\n- \"dbca\"\n- \"badc\"\nNon-match examples:\n- \"abba\"\n- \"baaa\"",
        "matches": [
            "abcd",
            "dbca",
            "badc"
        ],
        "non_matches": [
            "abba",
            "baaa",
            "cabb"
        ],
        "stress_tests": []
    },
    {
        "id": 490,
        "expression": "^((31(?! (FEB|APR|JUN|SEP|NOV)))|((30|29)(?! FEB))|(29(?= FEB (((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))|(0?[1-9])|1\\d|2[0-8]) (JAN|FEB|MAR|MAY|APR|JUL|JUN|AUG|OCT|SEP|NOV|DEC) ((1[6-9]|[2-9]\\d)\\d{2})$",
        "raw_prompt": "Validates date format by DD MMM YYYY. Validates days for each month also.\nEnsures that month is uppercase.",
        "refined_prompt": "\nMatch examples:\n- \"09 MAY 1981\"\n- \"28 JAN 2004\"\n- \"8 JUL 2006\"\nNon-match examples:\n- \"29 FEB 2003\"\n- \"28 Oct 2000\"",
        "matches": [
            "09 MAY 1981",
            "28 JAN 2004",
            "8 JUL 2006"
        ],
        "non_matches": [
            "29 FEB 2003",
            "28 Oct 2000",
            "9 APR 03"
        ],
        "stress_tests": []
    },
    {
        "id": 492,
        "expression": "^(\\d|,)*\\d*$",
        "raw_prompt": "matches 0 and all positive integers only. will accept comma formatting only.",
        "refined_prompt": "\nMatch examples:\n- \"1234\"\n- \"1,234\"\n- \"1,234,567\"\nNon-match examples:\n- \"1234.0\"\n- \"-1234\"",
        "matches": [
            "1234",
            "1,234",
            "1,234,567"
        ],
        "non_matches": [
            "1234.0",
            "-1234",
            "$1234"
        ],
        "stress_tests": []
    },
    {
        "id": 493,
        "expression": "%[\\-\\+0\\s\\#]{0,1}(\\d+){0,1}(\\.\\d+){0,1}[hlI]{0,1}[cCdiouxXeEfgGnpsS]{1}",
        "raw_prompt": "This regular expression matches &quot;c&quot; format strings for printf/scanf functions.",
        "refined_prompt": "\nMatch examples:\n- \"%s%02d\"\n- \"%s\"\n- \"%04lX\"\nNon-match examples:\n- \"%5.f\"\n- \"%++X\"",
        "matches": [
            "%s%02d",
            "%s",
            "%04lX"
        ],
        "non_matches": [
            "%5.f",
            "%++X",
            "%@d"
        ],
        "stress_tests": []
    },
    {
        "id": 495,
        "expression": ".\\{\\d\\}",
        "raw_prompt": "String formater matching.",
        "refined_prompt": "\nMatch examples:\n- \"The quick {0} fox {1} over the lazy dog.\"\nNon-match examples:\n- \"The {b} is wrong\"",
        "matches": [
            "The quick {0} fox {1} over the lazy dog."
        ],
        "non_matches": [
            "The {b} is wrong"
        ],
        "stress_tests": []
    },
    {
        "id": 496,
        "expression": "^([0-9]*\\,?[0-9]+|[0-9]+\\,?[0-9]*)?$",
        "raw_prompt": "Integer numbers with decimals. Only positives match. This expression doesn't match numbers with group separators",
        "refined_prompt": "\nMatch examples:\n- \"1234,50\"\n- \"0,70\"\n- \",03\"\nNon-match examples:\n- \"1.234,50\"\n- \"-234,50\"",
        "matches": [
            "1234,50",
            "0,70",
            ",03"
        ],
        "non_matches": [
            "1.234,50",
            "-234,50"
        ],
        "stress_tests": []
    },
    {
        "id": 497,
        "expression": "^(\\d{1,2})(\\s?(H|h)?)(:([0-5]\\d))?$",
        "raw_prompt": "Validates hours and minutes. Allows for entry in the form of hours:minutes with optional minutes and optional hours indicator (H or h).",
        "refined_prompt": "\nMatch examples:\n- \"1h\"\n- \"1:45\"\n- \"45\"\nNon-match examples:\n- \"1a\"\n- \"145\"",
        "matches": [
            "1h",
            "1:45",
            "45"
        ],
        "non_matches": [
            "1a",
            "145",
            "1:99"
        ],
        "stress_tests": []
    },
    {
        "id": 498,
        "expression": "^(((\\d{1,3})(,\\d{3})*)|(\\d+))(.\\d+)?$",
        "raw_prompt": "validates numbers, with or without decimal places, and comma 1000 separators.",
        "refined_prompt": "\nMatch examples:\n- \"9999999\"\n- \"99999.99999\"\n- \"99,999,999.9999\"\nNon-match examples:\n- \"9999.\"\n- \"9,99,99999.999\"",
        "matches": [
            "9999999",
            "99999.99999",
            "99,999,999.9999"
        ],
        "non_matches": [
            "9999.",
            "9,99,99999.999",
            "999.9999.9999"
        ],
        "stress_tests": []
    },
    {
        "id": 499,
        "expression": "^\\d{1,8}$|^\\d{1,3},\\d{3}$|^\\d{1,2},\\d{3},\\d{3}$",
        "raw_prompt": "Validates numeric input of 99,999,999 to 0 with or without commas. but no decimal places. Very simple, but not bad for a novice.",
        "refined_prompt": "\nMatch examples:\n- \"1000\"\n- \"12,345\"\n- \"12,345,678\"\nNon-match examples:\n- \"1.1\"\n- \"1,10\"",
        "matches": [
            "1000",
            "12,345",
            "12,345,678"
        ],
        "non_matches": [
            "1.1",
            "1,10",
            "123,888,888"
        ],
        "stress_tests": []
    },
    {
        "id": 500,
        "expression": "((([0][1-9]|[12][\\d])|[3][01])[-/]([0][13578]|[1][02])[-/][1-9]\\d\\d\\d)|((([0][1-9]|[12][\\d])|[3][0])[-/]([0][13456789]|[1][012])[-/][1-9]\\d\\d\\d)|(([0][1-9]|[12][\\d])[-/][0][2][-/][1-9]\\d([02468][048]|[13579][26]))|(([0][1-9]|[12][0-8])[-/][0][2][-/][1-9]\\d\\d\\d)",
        "raw_prompt": "Date validation in the dd/mm/yyyy format for years 1000+ (i.e 999 or 0999 not matching) and taking february leap years into account.",
        "refined_prompt": "\nMatch examples:\n- \"12/12/2003\"\n- \"29-02-2004\"\n- \"31-03-1980\"\nNon-match examples:\n- \"29/02/2003\"\n- \"31-04-2002\"",
        "matches": [
            "12/12/2003",
            "29-02-2004",
            "31-03-1980"
        ],
        "non_matches": [
            "29/02/2003",
            "31-04-2002",
            "10-10-0999"
        ],
        "stress_tests": []
    },
    {
        "id": 501,
        "expression": "(^\\$(\\d{1,3},?(\\d{3},?)*\\d{3}(\\.\\d{1,3})?|\\d{1,3}(\\.\\d{2})?)$|^\\d{1,2}(\\.\\d{1,2})? *%$|^100%$)",
        "raw_prompt": "Matches either an explicitly input percentage or dollar amount, variety of formats of currency borrowed from another example on this board. This is useful when you want to prompt the user to specify either dollars or percent using only one field, and want to validate the entered text is one or the other.",
        "refined_prompt": "\nMatch examples:\n- \"$1000.00\"\n- \"100%\"\n- \"50%\"\nNon-match examples:\n- \"%100\"\n- \".5%\"",
        "matches": [
            "$1000.00",
            "100%",
            "50%"
        ],
        "non_matches": [
            "%100",
            ".5%",
            "100"
        ],
        "stress_tests": []
    },
    {
        "id": 502,
        "expression": "^(?=[^\\d_].*?\\d)\\w(\\w|[!@#$%]){7,20}",
        "raw_prompt": "This regex can be used to restrict passwords to a length of 8 to 20 aplhanumeric characters and select special characters. The password also can not start with a digit, underscore or special character and must contain at least one digit.",
        "refined_prompt": "\nMatch examples:\n- \"password1\"\n- \"pa$$word2\"\n- \"pa!@#$%3\"\nNon-match examples:\n- \"password\"\n- \"1stpassword\"",
        "matches": [
            "password1",
            "pa$$word2",
            "pa!@#$%3"
        ],
        "non_matches": [
            "password",
            "1stpassword",
            "$password#"
        ],
        "stress_tests": []
    },
    {
        "id": 507,
        "expression": "^[A-Z].*$",
        "raw_prompt": "Test string to verify it begins with an upper-case letter.",
        "refined_prompt": "\nMatch examples:\n- \"Lewis\"\n- \"Edward\"\n- \"Moten\"\nNon-match examples:\n- \"lewis\"\n- \"1moten\"",
        "matches": [
            "Lewis",
            "Edward",
            "Moten"
        ],
        "non_matches": [
            "lewis",
            "1moten",
            "@home"
        ],
        "stress_tests": []
    },
    {
        "id": 510,
        "expression": "^[01]?[- .]?\\(?[2-9]\\d{2}\\)?[- .]?\\d{3}[- .]?\\d{4}$",
        "raw_prompt": "U. S. or Canadian telephone number regular expression. &lt;BR&gt;\n&lt;BR&gt;\n// # Checks phone numbers for validity &lt;BR&gt;\n// [01]? # optional '0', or '1' &lt;BR&gt;\n// [- .]? # optional separator is either a dash, a space, or a period. &lt;BR&gt;\n// \\(? # optional parentheses &lt;BR&gt;\n// [2-9] # first # of the area code must not be a '0' or '1' &lt;BR&gt;\n// \\d{2} # next 2 digits of area code can be 0-9 &lt;BR&gt;\n// \\)? # optional parentheses &lt;BR&gt;\n// [- .]? # optional separator is either a dash, a space, or a period. &lt;BR&gt;\n// \\d{3} # 3-digit prefix &lt;BR&gt;\n// [- .]? # optional separator is either a dash, a space, or a period. &lt;BR&gt;\n// \\d{4} # 4-digit station number &lt;BR&gt;",
        "refined_prompt": "\nMatch examples:\n- \"18008793262\"\n- \"800-879-3262\"\n- \"0-800.879.3262\"\nNon-match examples:\n- \"879 3262\"\n- \"077 879 3262\"",
        "matches": [
            "18008793262",
            "800-879-3262",
            "0-800.879.3262"
        ],
        "non_matches": [
            "879 3262",
            "077 879 3262",
            "879-3262"
        ],
        "stress_tests": []
    },
    {
        "id": 511,
        "expression": "^((\\(?0\\d{4}\\)?\\s?\\d{3}\\s?\\d{3})|(\\(?0\\d{3}\\)?\\s?\\d{3}\\s?\\d{4})|(\\(?0\\d{2}\\)?\\s?\\d{4}\\s?\\d{4}))(\\s?\\#(\\d{4}|\\d{3}))?$",
        "raw_prompt": "UK phone number. Allows 3, 4 or 5 digit regional prefix, with 8, 7 or 6 digit phone number respectively, plus optional 3 or 4 digit extension number prefixed with a # symbol. Also allows optional brackets surrounding the regional prefix and optional spaces between appropriate groups of numbers.",
        "refined_prompt": "\nMatch examples:\n- \"01222 555 555\"\n- \"(010) 55555555 #2222\"\n- \"0122 555 5555#222\"\nNon-match examples:\n- \"01222 555 5555\"\n- \"(010) 55555555 #22\"",
        "matches": [
            "01222 555 555",
            "(010) 55555555 #2222",
            "0122 555 5555#222"
        ],
        "non_matches": [
            "01222 555 5555",
            "(010) 55555555 #22",
            "0122 5555 5555#222"
        ],
        "stress_tests": []
    },
    {
        "id": 512,
        "expression": "(^N/A$)|(^[-]?(\\d+)(\\.\\d{0,3})?$)|(^[-]?(\\d{1,3},(\\d{3},)*\\d{3}(\\.\\d{1,3})?|\\d{1,3}(\\.\\d{1,3})?)$)",
        "raw_prompt": "This pattern matches a decimal value with up to 3 digits after the decimal. Comma is allowed as a thousands separator but not required. N/A is also allowed.",
        "refined_prompt": "\nMatch examples:\n- \"405.234\"\n- \"50\"\n- \"213123.456\"\nNon-match examples:\n- \"bathreader\"\n- \"this is N/A\"",
        "matches": [
            "405.234",
            "50",
            "213123.456",
            "-1",
            "N/A"
        ],
        "non_matches": [
            "bathreader",
            "this is N/A",
            "3.14159",
            "+10"
        ],
        "stress_tests": []
    },
    {
        "id": 517,
        "expression": "^([A-HK-PRSVWY][A-HJ-PR-Y])\\s?([0][2-9]|[1-9][0-9])\\s?[A-HJ-PR-Z]{3}$",
        "raw_prompt": "UK vehicle registration system currently in use (as defined by the DVLA and put into effect from September 2001, and therefore does not allow registrations prior to this date).",
        "refined_prompt": "\nMatch examples:\n- \"AB51DVL\"\n- \"AB 51 DVL\"\nNon-match examples:\n- \"AZ01DLQ\"\n- \"AZ 01 DLQ\"",
        "matches": [
            "AB51DVL",
            "AB 51 DVL"
        ],
        "non_matches": [
            "AZ01DLQ",
            "AZ 01 DLQ"
        ],
        "stress_tests": []
    },
    {
        "id": 518,
        "expression": "^([A-Z]{3}\\s?(\\d{3}|\\d{2}|d{1})\\s?[A-Z])|([A-Z]\\s?(\\d{3}|\\d{2}|\\d{1})\\s?[A-Z]{3})$",
        "raw_prompt": "UK vehicle registration system prior to September 2001. Allows both older suffix and the later prefix formats in simple form, with optional spaces.",
        "refined_prompt": "\nMatch examples:\n- \"ABC123A\"\n- \"A 123 ABC\"\nNon-match examples:\n- \"AB123A\"\n- \"A 123 AB\"",
        "matches": [
            "ABC123A",
            "A 123 ABC"
        ],
        "non_matches": [
            "AB123A",
            "A 123 AB"
        ],
        "stress_tests": []
    },
    {
        "id": 519,
        "expression": "^([1-9]{1}[0-9]{0,7})+((,[1-9]{1}[0-9]{0,7}){0,1})+$",
        "raw_prompt": "Validate a comma delimited string of integer between 1 and 99999999 (change {0,7} to whatever you need). No zero leading.",
        "refined_prompt": "\nMatch examples:\n- \"1,2,3455,12345678\"\n- \"23045,34678,2892\"\n- \"1,2,99999999\"\nNon-match examples:\n- \"01,234,567\"\n- \"123,0445,3434,\"",
        "matches": [
            "1,2,3455,12345678",
            "23045,34678,2892",
            "1,2,99999999"
        ],
        "non_matches": [
            "01,234,567",
            "123,0445,3434,",
            "121,,1212,,12,"
        ],
        "stress_tests": []
    },
    {
        "id": 520,
        "expression": "^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,15}$",
        "raw_prompt": "Password matching expression. Password must be at least 8 characters, no more than 15 characters, and must include at least one upper case letter, one lower case letter, and one numeric digit.",
        "refined_prompt": "\nMatch examples:\n- \"aaaa1234AAAA\"\n- \"12aaAA12\"\n- \"aaaaa12345AAAAA\"\nNon-match examples:\n- \"aaaaa123456AAAAA\"\n- \"12aaAA1\"",
        "matches": [
            "aaaa1234AAAA",
            "12aaAA12",
            "aaaaa12345AAAAA"
        ],
        "non_matches": [
            "aaaaa123456AAAAA",
            "12aaAA1",
            "12aaaa12"
        ],
        "stress_tests": []
    },
    {
        "id": 521,
        "expression": "^([0-9a-zA-Z]([-.\\w]*[0-9a-zA-Z])*@(([0-9a-zA-Z])+([-\\w]*[0-9a-zA-Z])*\\.)+[a-zA-Z]{2,9})$",
        "raw_prompt": "Email validation based on Rob Eberhardt's (Thanks, Rob!) email expression, but allows single letter subdomains...",
        "refined_prompt": "\nMatch examples:\n- \"bob@smith.com\"\n- \"bob@j.smith.museum\"\n- \"bob.smith@a-1.smith.com\"\nNon-match examples:\n- \"bob@.com\"\n- \"bob@-a.smith.com\"",
        "matches": [
            "bob@smith.com",
            "bob@j.smith.museum",
            "bob.smith@a-1.smith.com"
        ],
        "non_matches": [
            "bob@.com",
            "bob@-a.smith.com"
        ],
        "stress_tests": []
    },
    {
        "id": 523,
        "expression": "^[a-zA-Z0-9\\s]+$",
        "raw_prompt": "Alphanumeric expression with spaces",
        "refined_prompt": "\nMatch examples:\n- \"123asd\"\n- \"111 ee11e\"\n- \"223 eeddd23\"\nNon-match examples:\n- \"12' ggg\"\n- \"&lt;&gt;dfdg 444\"",
        "matches": [
            "123asd",
            "111 ee11e",
            "223 eeddd23"
        ],
        "non_matches": [
            "12' ggg",
            "&lt;&gt;dfdg 444",
            "dfgdfg/dfgd"
        ],
        "stress_tests": []
    },
    {
        "id": 524,
        "expression": "^([2-9])(\\d{2})(-?|\\040?)(\\d{4})( ?|\\040?)(\\d{1,4}?|\\040?)$",
        "raw_prompt": "A regular expression that validates the any format of fixed telephone numbers inside Lima - Peru, including an optional extension of at least one number up to four numbers.",
        "refined_prompt": "\nMatch examples:\n- \"263-8854\"\n- \"5660578 1235\"\n- \"622-4588 21\"\nNon-match examples:\n- \"1227585\"\n- \"4224586 50124\"",
        "matches": [
            "263-8854",
            "5660578 1235",
            "622-4588 21"
        ],
        "non_matches": [
            "1227585",
            "4224586 50124",
            "0554499"
        ],
        "stress_tests": []
    },
    {
        "id": 525,
        "expression": "^([8-9])([1-9])(\\d{2})(-?|\\040?)(\\d{4})$",
        "raw_prompt": "A regular expression that validates the any of the new formats of cellular phones numbers in Peru, allows an optional dash in the middle of the number.",
        "refined_prompt": "\nMatch examples:\n- \"8874-2544\"\n- \"99106800\"\n- \"84509955\"\nNon-match examples:\n- \"6540-9985\"\n- \"77329390\"",
        "matches": [
            "8874-2544",
            "99106800",
            "84509955"
        ],
        "non_matches": [
            "6540-9985",
            "77329390",
            "725-2763"
        ],
        "stress_tests": []
    },
    {
        "id": 526,
        "expression": "^(\\$)?((\\d+)|(\\d{1,3})(\\,\\d{3})*)(\\.\\d{2,})?$",
        "raw_prompt": "This pattern handles currency including the following:\noptional period with two or more digits to the right of the period\noptional commas\noptional dollar sign($)",
        "refined_prompt": "\nMatch examples:\n- \"$3,333,333,333\"\n- \"$333333\"\n- \"$3,333.33\"\nNon-match examples:\n- \"3,33\"\n- \"3333,333,333\"",
        "matches": [
            "$3,333,333,333",
            "$333333",
            "$3,333.33"
        ],
        "non_matches": [
            "3,33",
            "3333,333,333",
            "333.3"
        ],
        "stress_tests": []
    },
    {
        "id": 527,
        "expression": "^(?!\\d[1]{2}|[5]{3})([2-9]\\d{2})([. -]*)\\d{4}$",
        "raw_prompt": "Validates *usable* US telephone numbers (possibly Canadian and Caribbean Islands as well?) Numbers cannot beginning with zero, one, (any number)11, or 555. It will allow either a hyphen, space or period as a separator.\nTechnically (and contrary to popular belief) most 555- numbers ARE valid numbers [see http://www.nanpa.com/nas/public/form555MasterReport.do?method=display555MasterReport ] but they are unlikely to be used by normal folks. Therefore, excluding them with this regex is useful to prevent bogus/fraudulent telephone numbers in forms.\nFYI, the fictitious 555- numbers used in the movies and TV are only in the range of 555-0100 through 555-0199. Not very many, huh?",
        "refined_prompt": "\nMatch examples:\n- \"222-2222\"\n- \"295-5000\"\nNon-match examples:\n- \"555-1234\"\n- \"411-5555\"",
        "matches": [
            "222-2222",
            "295-5000"
        ],
        "non_matches": [
            "555-1234",
            "411-5555",
            "099-9999"
        ],
        "stress_tests": []
    },
    {
        "id": 529,
        "expression": "^(?:\\([2-9]\\d{2}\\)\\ ?|[2-9]\\d{2}(?:\\-?|\\ ?))[2-9]\\d{2}[- ]?\\d{4}$",
        "raw_prompt": "US Phone Number: This regular expression for US phone numbers conforms to NANP A-digit and D-digit requirments (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted. Format validation accepts 10-digits without delimiters, optional parens on area code, and optional spaces or dashes between area code, central office code and station code. Acceptable formats include 2225551212, 222 555 1212, 222-555-1212, (222) 555 1212, (222) 555-1212, etc. You can add/remove formatting options to meet your needs.",
        "refined_prompt": "\nMatch examples:\n- \"5305551212\"\n- \"(530) 555-1212\"\n- \"530-555-1212\"\nNon-match examples:\n- \"0010011212\"\n- \"1991991212\"",
        "matches": [
            "5305551212",
            "(530) 555-1212",
            "530-555-1212"
        ],
        "non_matches": [
            "0010011212",
            "1991991212",
            "123) not-good"
        ],
        "stress_tests": []
    },
    {
        "id": 530,
        "expression": "^((?:(?:(?:[a-zA-Z0-9][\\.\\-\\+_]?)*)[a-zA-Z0-9])+)\\@((?:(?:(?:[a-zA-Z0-9][\\.\\-_]?){0,62})[a-zA-Z0-9])+)\\.([a-zA-Z0-9]{2,6})$",
        "raw_prompt": "Captures Submatches, problem:domainname length can be longer than 64 chars, because every [a-zA-Z0-9][\\.\\-_] is only countet as one char.",
        "refined_prompt": "\nMatch examples:\n- \"abc@def.gh\"\n- \"a+b_c@d-e_f.gh\"\n- \"abc@def.ghijkl\"\nNon-match examples:\n- \"__@__.__\"\n- \"-a-@-b-.cd\"",
        "matches": [
            "abc@def.gh",
            "a+b_c@d-e_f.gh",
            "abc@def.ghijkl"
        ],
        "non_matches": [
            "__@__.__",
            "-a-@-b-.cd",
            "a--b@c__d.ef"
        ],
        "stress_tests": []
    },
    {
        "id": 531,
        "expression": "^(((\\d{4}((0[13578]|1[02])(0[1-9]|[12]\\d|3[01])|(0[13456789]|1[012])(0[1-9]|[12]\\d|30)|02(0[1-9]|1\\d|2[0-8])))|((\\d{2}[02468][048]|\\d{2}[13579][26]))0229)){0,8}$",
        "raw_prompt": "Validates a date expression (or empty value) in CCYYMMDD format, checking a leap year from 00000101 A.D. to 99991231",
        "refined_prompt": "\nMatch examples:\n- \"20041231\"\n- \"20040229\"\nNon-match examples:\n- \"20043112\"\n- \"2003/04/02\"",
        "matches": [
            "20041231",
            "20040229"
        ],
        "non_matches": [
            "20043112",
            "2003/04/02"
        ],
        "stress_tests": []
    },
    {
        "id": 532,
        "expression": "^(?=\\d)(?:(?:31(?!.(?:0?[2469]|11))|(?:30|29)(?!.0?2)|29(?=.0?2.(?:(?:(?:1[6-9]|[2-9]\\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00)))(?:\\x20|$))|(?:2[0-8]|1\\d|0?[1-9]))([-./])(?:1[012]|0?[1-9])\\1(?:1[6-9]|[2-9]\\d)?\\d\\d(?:(?=\\x20\\d)\\x20|$))?(((0?[1-9]|1[012])(:[0-5]\\d){0,2}(\\x20[AP]M))|([01]\\d|2[0-3])(:[0-5]\\d){1,2})?$",
        "raw_prompt": "DateTime Validator. This RE validates both dates and/or times patterns. Days in Feb. are also validated for Leap years. Dates: in dd/mm/yyyy or d/m/yy format between 1/1/1600 - 31/12/9999. Leading zeroes are optional. Date separators can be either matching dashes(-), slashes(/) or periods(.) Times: in the hh:MM:ss AM/PM 12 hour format (12:00 AM - 11:59:59 PM) or hh:MM:ss military time format (00:00:00 - 23:59:59). The 12 hour time format: 1) may have a leading zero for the hour. 2) Minutes and seconds are optional for the 12 hour format 3) AM or PM is required and case sensitive. Military time 1) must have a leading zero for all hours less than 10. 2) Minutes are manditory. 3) seconds are optional. Datetimes: combination of the above formats. A date first then a time separated by a space. ex) dd/mm/yyyy hh:MM:ss This RE is an variation of one of my other Datetime (mm/dd/yyyy) validator already in this library http://www.regexlib.com/REDetails.aspx?regexp_id=369, so the same rules for leap year apply. All 4 digit year and all two digit years except 00, which might not be a leap year.",
        "refined_prompt": "\nMatch examples:\n- \"31/12/2003 11:59:59 PM\"\n- \"29-2-2004\"\n- \"01:45:02\"\nNon-match examples:\n- \"12/31/2003\"\n- \"29.02.2005\"",
        "matches": [
            "31/12/2003 11:59:59 PM",
            "29-2-2004",
            "01:45:02"
        ],
        "non_matches": [
            "12/31/2003",
            "29.02.2005",
            "13:30 PM"
        ],
        "stress_tests": []
    },
    {
        "id": 535,
        "expression": "^(\\x22|\\x27)((?!\\1).|\\1{2})*\\1$",
        "raw_prompt": "The regex validate a quoted string in VBScript or Ansi SQL. The string may contain the containing quote character if it is escaped by being doubled up.\nIn VB/VBScript two double quotes within a string enclosed in double qoutes translate into one double quote within the string\nIn SQL two single quotes within a string enclosed in single qoutes translate into one single quote within the string",
        "refined_prompt": "\nMatch examples:\n- \"\"To quote Yoda (\"\"Do, or do not. There is no 'try'\"\" )\"\"\nNon-match examples:\n- \"'This won't validate'\"\n- \"\"He said \"Ok.\"\"\"",
        "matches": [
            "\"To quote Yoda (\"\"Do, or do not. There is no 'try'\"\" )\""
        ],
        "non_matches": [
            "'This won't validate'",
            "\"He said \"Ok.\"\""
        ],
        "stress_tests": []
    },
    {
        "id": 537,
        "expression": "^1000([.][0]{1,3})?$|^\\d{1,3}$|^\\d{1,3}([.]\\d{1,3})$|^([.]\\d{1,3})$",
        "raw_prompt": "allows positive none-to-3-decimal values between 0.000 and 1000.000",
        "refined_prompt": "\nMatch examples:\n- \".123\"\n- \"0.126\"\n- \"1000.000\"\nNon-match examples:\n- \".1234\"\n- \"0.1b6\"",
        "matches": [
            ".123",
            "0.126",
            "1000.000"
        ],
        "non_matches": [
            ".1234",
            "0.1b6",
            "1000.001"
        ],
        "stress_tests": []
    },
    {
        "id": 538,
        "expression": "^(\\-)?1000([.][0]{1,3})?$|^(\\-)?\\d{1,3}$|^(\\-)?\\d{1,3}([.]\\d{1,3})$|^(\\-)?([.]\\d{1,3})$",
        "raw_prompt": "allows positive and negative none-to-3-decimal values between -1000.000 and 1000.000",
        "refined_prompt": "\nMatch examples:\n- \"123.456\"\n- \"-0.125\"\n- \"-1000.000\"\nNon-match examples:\n- \"123.4567\"\n- \"-0.1b5\"",
        "matches": [
            "123.456",
            "-0.125",
            "-1000.000"
        ],
        "non_matches": [
            "123.4567",
            "-0.1b5",
            "-1000.001"
        ],
        "stress_tests": []
    },
    {
        "id": 542,
        "expression": "^(((ht|f)tp(s?))\\://)?(www.|[a-zA-Z].)[a-zA-Z0-9\\-\\.]+\\.(com|edu|gov|mil|net|org|biz|info|name|museum|us|ca|uk)(\\:[0-9]+)*(/($|[a-zA-Z0-9\\.\\,\\;\\?\\'\\\\\\+&amp;%\\$#\\=~_\\-]+))*$",
        "raw_prompt": "Version 1.3.0: I needed a regexp to validate URL's without the ht(f)tp(s):// and include North American domains (like .us and .ca) and there didn't seem to be one available...so I created one. It will also work with ASP QueryStrings and anchor URL's. If you have a problem with the expression or have any suggestions to improve, please write me and let me know. Added .uk domain and expression now allows for URLs that contain JSP session IDs. 4/14/04 - added ability to include URLs that start with server names.",
        "refined_prompt": "\nMatch examples:\n- \"www.blah.com:8103\"\n- \"www.blah.com/blah.asp?sort=ASC\"\n- \"www.blah.com/blah.htm#blah\"\nNon-match examples:\n- \"www.state.ga\"\n- \"http://www.blah.ru\"",
        "matches": [
            "www.blah.com:8103",
            "www.blah.com/blah.asp?sort=ASC",
            "www.blah.com/blah.htm#blah"
        ],
        "non_matches": [
            "www.state.ga",
            "http://www.blah.ru"
        ],
        "stress_tests": []
    },
    {
        "id": 544,
        "expression": "(^[a-zA-Z0-9]+://)",
        "raw_prompt": "Use in a .net Regex.Split() to pull the protocol out of a url into the first array entry.",
        "refined_prompt": "\nMatch examples:\n- \"myprot://server/path.asp\"\nNon-match examples:\n- \"server/path.asp\"",
        "matches": [
            "myprot://server/path.asp"
        ],
        "non_matches": [
            "server/path.asp"
        ],
        "stress_tests": []
    },
    {
        "id": 545,
        "expression": "^\\$?\\-?([1-9]{1}[0-9]{0,2}(\\,\\d{3})*(\\.\\d{0,2})?|[1-9]{1}\\d{0,}(\\.\\d{0,2})?|0(\\.\\d{0,2})?|(\\.\\d{1,2}))$|^\\-?\\$?([1-9]{1}\\d{0,2}(\\,\\d{3})*(\\.\\d{0,2})?|[1-9]{1}\\d{0,}(\\.\\d{0,2})?|0(\\.\\d{0,2})?|(\\.\\d{1,2}))$|^\\(\\$?([1-9]{1}\\d{0,2}(\\,\\d{3})*(\\.\\d{0,2})?|[1-9]{1}\\d{0,}(\\.\\d{0,2})?|0(\\.\\d{0,2})?|(\\.\\d{1,2}))\\)$",
        "raw_prompt": "currency format that allows optional $, optional &quot;-&quot;(MinusSignNegative) OR &quot;()&quot; (ParenNegative) but not both, optional cents, and optional commas separating thousands. Minus sign can be before or after $, but parens must be outside the $. UPDATED: now fails to match a &quot;$&quot; without any further numbers",
        "refined_prompt": "\nMatch examples:\n- \"($4,000.00)\"\n- \"-$4000.00\"\n- \"-$400.00\"\nNon-match examples:\n- \"4,00.000\"\n- \"abc\"",
        "matches": [
            "($4,000.00)",
            "-$4000.00",
            "-$400.00"
        ],
        "non_matches": [
            "4,00.000",
            "abc",
            "$"
        ],
        "stress_tests": []
    },
    {
        "id": 547,
        "expression": "^((\\d{1,2})?([.][\\d]{1,2})?){1}[%]{1}$",
        "raw_prompt": "for checking a value is between 99.99% and 00.00%",
        "refined_prompt": "\nMatch examples:\n- \"99.99%\"\n- \"9%\"\n- \".09%\"\nNon-match examples:\n- \"99\"\n- \"9.%\"",
        "matches": [
            "99.99%",
            "9%",
            ".09%"
        ],
        "non_matches": [
            "99",
            "9.%"
        ],
        "stress_tests": []
    },
    {
        "id": 550,
        "expression": "(^[A-Za-z])|(\\s)([A-Za-z])",
        "raw_prompt": "This expression will return the first letter of each word in a string. Best used if you need to get initials from a name.\n&quot;James Kramer&quot; = &quot;J K&quot; &amp; &quot;Sir Richard Branson&quot; = &quot;S R B&quot; &amp; &quot;33 yoYo 654 ma&quot; = &quot;y m&quot;",
        "refined_prompt": "\nMatch examples:\n- \"James Kramer\"\n- \"Sir Richard Branson\"\n- \"33 yoYo 654 ma\"\nNon-match examples:\n- \"33 66 4ju\"",
        "matches": [
            "James Kramer",
            "Sir Richard Branson",
            "33 yoYo 654 ma"
        ],
        "non_matches": [
            "33 66 4ju"
        ],
        "stress_tests": []
    },
    {
        "id": 567,
        "expression": "^(([a-zA-Z]:)|(\\\\{2}\\w+)\\$?)(\\\\(\\w[\\w ]*.*))+\\.(txt|TXT)$",
        "raw_prompt": "It matches .jpg files. It allows for a dot in the path. A dot may occur in such directories as: C:\\Documents and Settings\\roman.lukyanenko\\Desktop\\stuff\\b_card2.txt or C:\\Windows\\Microsoft.NET etc",
        "refined_prompt": "\nMatch examples:\n- \"C:\\Documents and Settings\\roman.lukyanenko\\Desktop\\stuff\\b_card2.txt\"\nNon-match examples:\n- \"C:\\file.doc\"",
        "matches": [
            "C:\\Documents and Settings\\roman.lukyanenko\\Desktop\\stuff\\b_card2.txt"
        ],
        "non_matches": [
            "C:\\file.doc"
        ],
        "stress_tests": []
    },
    {
        "id": 569,
        "expression": "^(((\\d{4})(0[13578]|10|12)(0[1-9]|[12][0-9]|3[01]))|((\\d{4})(0[469]|11)([0][1-9]|[12][0-9]|30))|((\\d{4})(02)(0[1-9]|1[0-9]|2[0-8]))|(([02468][048]00)(02)(29))|(([13579][26]00) (02)(29))|(([0-9][0-9][0][48])(02)(29))|(([0-9][0-9][2468][048])(02)(29))|(([0-9][0-9][13579][26])(02)(29))|(00000000)|(88888888)|(99999999))?$",
        "raw_prompt": "it's for date in the format: &quot;yyyymmdd&quot; and it validates the empty string and some special values (00000000,88888888,99999999) but you can delete these last values. It works with leap years.",
        "refined_prompt": "\nMatch examples:\n- \"20041212\"\n- \"20040229\"\n- \"88888888\"\nNon-match examples:\n- \"20040230\"\n- \"20041330\"",
        "matches": [
            "20041212",
            "20040229",
            "88888888"
        ],
        "non_matches": [
            "20040230",
            "20041330"
        ],
        "stress_tests": []
    },
    {
        "id": 571,
        "expression": "^(0{0,1}[1-9]|[12][0-9]|3[01])[- /.](0{0,1}[1-9]|1[012])[- /.](\\d{2}|\\d{4})$",
        "raw_prompt": "Validates dates formatted like &quot;dd.mm.yyyy&quot; or &quot;dd.mm.yy&quot;. Also the separators &quot;/&quot; and &quot;-&quot; are validated &quot;ok&quot;. This expression does not check leap years!\nI did this expression cause I could hardly find any date regex that supports those &quot;dot-formats&quot;.",
        "refined_prompt": "\nMatch examples:\n- \"1.1.2004\"\n- \"03.07.04\"\n- \"1-03-03\"\nNon-match examples:\n- \"0.13.2004\"\n- \"1.1.200\"",
        "matches": [
            "1.1.2004",
            "03.07.04",
            "1-03-03"
        ],
        "non_matches": [
            "0.13.2004",
            "1.1.200",
            "32.0.03"
        ],
        "stress_tests": []
    },
    {
        "id": 577,
        "expression": "^0[234679]{1}[\\s]{0,1}[\\-]{0,1}[\\s]{0,1}[1-9]{1}[0-9]{6}$",
        "raw_prompt": "The regex matches the UAE land phone numbers. Checks the area codes[04,02,06...etc] strictly. Force user to input phone numbers in strict manner(it take input 04 3452488, but not 04______spaces_______3452488)",
        "refined_prompt": "\nMatch examples:\n- \"04 3452488\"\n- \"04 -3452488\"\n- \"04 - 3452499\"\nNon-match examples:\n- \"01 -3452488\"\n- \"04 34524888\"",
        "matches": [
            "04 3452488",
            "04 -3452488",
            "04 - 3452499"
        ],
        "non_matches": [
            "01 -3452488",
            "04 34524888",
            "08 3452488"
        ],
        "stress_tests": []
    },
    {
        "id": 578,
        "expression": "(^[a-fA-F]+[+-]?$)",
        "raw_prompt": "Letter Grade scores A-F + and -",
        "refined_prompt": "\nMatch examples:\n- \"a+\"\n- \"A\"\n- \"F-\"\nNon-match examples:\n- \"z\"\n- \"6\"",
        "matches": [
            "a+",
            "A",
            "F-"
        ],
        "non_matches": [
            "z",
            "6",
            "D +"
        ],
        "stress_tests": []
    },
    {
        "id": 580,
        "expression": "^((\\+){0,1}91(\\s){0,1}(\\-){0,1}(\\s){0,1}){0,1}98(\\s){0,1}(\\-){0,1}(\\s){0,1}[1-9]{1}[0-9]{7}$",
        "raw_prompt": "The Regex validate the mobile numbers in India.\nGives flexibility to user to enter numbers in different format like\n+919847444225, +91-98-45017381, 9844111116, 98 44111112, 98-44111116\n###Enjoy REGEX###",
        "refined_prompt": "\nMatch examples:\n- \"+919847444225\"\n- \"+91-98-44111112\"\n- \"98 44111116\"\nNon-match examples:\n- \"+919800444225\"\n- \"+947444225\"",
        "matches": [
            "+919847444225",
            "+91-98-44111112",
            "98 44111116"
        ],
        "non_matches": [
            "+919800444225",
            "+947444225",
            "44111116"
        ],
        "stress_tests": []
    },
    {
        "id": 582,
        "expression": "^([0-5]?\\d?\\d?\\d?\\d|6[0-4]\\d\\d\\d|65[0-4]\\d\\d|655[0-2]\\d|6553[0-5])$",
        "raw_prompt": "match for 0 - 65535",
        "refined_prompt": "\nMatch examples:\n- \"0\"\n- \"65535\"\n- \"59999\"\nNon-match examples:\n- \"123456\"\n- \"69999\"",
        "matches": [
            "0",
            "65535",
            "59999"
        ],
        "non_matches": [
            "123456",
            "69999",
            "65599"
        ],
        "stress_tests": []
    },
    {
        "id": 583,
        "expression": "^(((0?[1-9]|[12]\\d|3[01])[\\.\\-\\/](0?[13578]|1[02])[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}))|((0?[1-9]|[12]\\d|30)[\\.\\-\\/](0?[13456789]|1[012])[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}))|((0?[1-9]|1\\d|2[0-8])[\\.\\-\\/]0?2[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}))|(29[\\.\\-\\/]0?2[\\.\\-\\/]((1[6-9]|[2-9]\\d)?(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)|00)))$",
        "raw_prompt": "DD.MM.YY or DD.MM.YYYY\nseparator could be on choice '.' '/' or '-'\nleap years compatible, 00 is treated as year 2000.",
        "refined_prompt": "\nMatch examples:\n- \"29.2.04\"\n- \"29/02-2004\"\n- \"3.4.05\"\nNon-match examples:\n- \"29.2.03\"\n- \"2902.2004\"",
        "matches": [
            "29.2.04",
            "29/02-2004",
            "3.4.05"
        ],
        "non_matches": [
            "29.2.03",
            "2902.2004",
            "12.31.1975"
        ],
        "stress_tests": []
    },
    {
        "id": 589,
        "expression": "((\\(\\d{3,4}\\)|\\d{3,4}-)\\d{4,9}(-\\d{1,5}|\\d{0}))|(\\d{4,12})",
        "raw_prompt": "telphone number check.",
        "refined_prompt": "\nMatch examples:\n- \"0833-1234567-8888\"\n- \"(0833)1234567-8888\"\n- \"12345678\"\nNon-match examples:\n- \"ceocio\"\n- \"!@$@#$\"",
        "matches": [
            "0833-1234567-8888",
            "(0833)1234567-8888",
            "12345678"
        ],
        "non_matches": [
            "ceocio",
            "!@$@#$"
        ],
        "stress_tests": []
    },
    {
        "id": 590,
        "expression": "^[{|\\(]?[0-9a-fA-F]{8}[-]?([0-9a-fA-F]{4}[-]?){3}[0-9a-fA-F]{12}[\\)|}]?$",
        "raw_prompt": "Specifier Format of Guid Values that this RegEx supports: 32 digits: [xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx] 32 digits separated by hyphens: [xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx] 32 digits separated by hyphens, enclosed in brackets: [{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}] 32 digits separated by hyphens, enclosed in parentheses: [(xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)]",
        "refined_prompt": "\nMatch examples:\n- \"914D226A-2F5B-4944-934D-96BBE6571977\"\n- \"{914D226A-2F5B-4944-934D-96BBE6571977}\"\nNon-match examples:\n- \"914D226A-2F5B-4944-XXXX-96BBE6571977\"\n- \"{914D226A-2F5B-4944-XXXX-96BBE6571977}\"",
        "matches": [
            "914D226A-2F5B-4944-934D-96BBE6571977",
            "{914D226A-2F5B-4944-934D-96BBE6571977}"
        ],
        "non_matches": [
            "914D226A-2F5B-4944-XXXX-96BBE6571977",
            "{914D226A-2F5B-4944-XXXX-96BBE6571977}"
        ],
        "stress_tests": []
    },
    {
        "id": 604,
        "expression": "^(([a-z][0-9])|([0-9][a-z])|([a-z0-9][a-z0-9\\-]{1,2}[a-z0-9])|([a-z0-9][a-z0-9\\-](([a-z0-9\\-][a-z0-9])|([a-z0-9][a-z0-9\\-]))[a-z0-9\\-]*[a-z0-9]))\\.(co|me|org|ltd|plc|net|sch|ac|mod|nhs|police|gov)\\.uk$",
        "raw_prompt": "UK domain names. Includes the following restrictions from Nominet as at time of posting:\n1.Only a-z, 0-9 and hyphen may be used.\n2.First or last character may not be a hyphen.\n3.Third and fourth characters may not both be hyphens.\n4.Third level domain may not be a single character.\n5.Third level domain may not be two letters or two numbers.\n6.Third level domain may be one letter and one number.\nThis does not yet include the following restrictions:\n1.Whole domain may not be longer than 64 characters in length.\n2.Third level domain may not duplicate any top/second level domain.",
        "refined_prompt": "\nMatch examples:\n- \"zeropanic.co.uk\"\n- \"z2.co.uk\"\n- \"1-1.org.uk\"\nNon-match examples:\n- \"zeropanic.com\"\n- \"z.co.uk\"",
        "matches": [
            "zeropanic.co.uk",
            "z2.co.uk",
            "1-1.org.uk"
        ],
        "non_matches": [
            "zeropanic.com",
            "z.co.uk",
            "zz.co.uk"
        ],
        "stress_tests": []
    },
    {
        "id": 605,
        "expression": "^(ht|f)tp((?<=http)s)?://((?<=http://)www|(?<=https://)www|(?<=ftp://)ftp)\\.(([a-z][0-9])|([0-9][a-z])|([a-z0-9][a-z0-9\\-]{1,2}[a-z0-9])|([a-z0-9][a-z0-9\\-](([a-z0-9\\-][a-z0-9])|([a-z0-9][a-z0-9\\-]))[a-z0-9\\-]*[a-z0-9]))\\.(co|me|org|ltd|plc|net|sch|ac|mod|nhs|police|gov)\\.uk$",
        "raw_prompt": "UK domains with protocol for http/https/ftp. Based on my previous expression, this allows the subdomain &quot;www&quot; for the http/https protocols, or &quot;ftp&quot; for the ftp protocol only.",
        "refined_prompt": "\nMatch examples:\n- \"http://www.zeropanic.co.uk\"\n- \"ftp://ftp.sunsite.ac.uk\"\n- \"https://www.z2.co.uk\"\nNon-match examples:\n- \"gopher://www.z2.co.uk\"\n- \"http://ftp.z2.co.uk\"",
        "matches": [
            "http://www.zeropanic.co.uk",
            "ftp://ftp.sunsite.ac.uk",
            "https://www.z2.co.uk"
        ],
        "non_matches": [
            "gopher://www.z2.co.uk",
            "http://ftp.z2.co.uk",
            "ftp://www.z2.co.uk"
        ],
        "stress_tests": []
    },
    {
        "id": 607,
        "expression": "^(?:\\([2-9]\\d{2}\\)\\ ?|(?:[2-9]\\d{2}\\-))[2-9]\\d{2}\\-\\d{4}$",
        "raw_prompt": "This US phone number edit with restricted format options: Accepts optional parens on area code with or without following space, and dashes between area code, central office code and station code. Formats include only (222) 555-1212 (with or without a space) and 222-555-1212. Conforms to NANP A-digit and D-digit requirements (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted.",
        "refined_prompt": "\nMatch examples:\n- \"(234) 555-1212\"\n- \"(234)555-1212\"\n- \"234-555-1212\"\nNon-match examples:\n- \"(234)5551212\"\n- \"234 555 1212\"",
        "matches": [
            "(234) 555-1212",
            "(234)555-1212",
            "234-555-1212"
        ],
        "non_matches": [
            "(234)5551212",
            "234 555 1212",
            "234) 555-1212"
        ],
        "stress_tests": []
    },
    {
        "id": 610,
        "expression": "^([0-1]?\\d|2[0-3]):([0-5]\\d)$",
        "raw_prompt": "Time in 24h format; minutes must be two digits; hours may be one or two digits",
        "refined_prompt": "\nMatch examples:\n- \"3:23\"\n- \"03:23\"\n- \"16:59\"\nNon-match examples:\n- \"12:2\"\n- \"12:76\"",
        "matches": [
            "3:23",
            "03:23",
            "16:59"
        ],
        "non_matches": [
            "12:2",
            "12:76",
            "33:12"
        ],
        "stress_tests": []
    },
    {
        "id": 619,
        "expression": "^(\\d{3}-\\d{3}-\\d{4})*$",
        "raw_prompt": "This expression is a very simplex expression that allows null values or 3 digits, dash, 3 digits, dash, 4 digits. It validates a basic US phone number. Written by Jason N. Gaylord.",
        "refined_prompt": "\nMatch examples:\n- \"555-555-1212\"\n- \"123-456-7890\"\nNon-match examples:\n- \"555.555.1212\"\n- \"(555) 555-1212\"",
        "matches": [
            "555-555-1212",
            "123-456-7890"
        ],
        "non_matches": [
            "555.555.1212",
            "(555) 555-1212",
            "5555551212"
        ],
        "stress_tests": []
    },
    {
        "id": 620,
        "expression": "^(\\d{2}-\\d{2})*$",
        "raw_prompt": "This expression is a simplex expression that checks to see if a value is a valid phone system terminal number. It allows a null value or 2 digits, dash, 2 digits. Written by Jason N. Gaylord.",
        "refined_prompt": "\nMatch examples:\n- \"00-00\"\n- \"54-68\"\nNon-match examples:\n- \"1235\"\n- \"0\"",
        "matches": [
            "00-00",
            "54-68"
        ],
        "non_matches": [
            "1235",
            "0",
            "5-789"
        ],
        "stress_tests": []
    },
    {
        "id": 621,
        "expression": "(\\s|\\n|^)(\\w+://[^\\s\\n]+)",
        "raw_prompt": "will match free floating valid protocol + urls in text ... will not touch the ones wrapped in a tag, so that you can auto-link the ones that aren't :) couple of things to know :\n1. if the url is next to a tag this won't work (eg : &lt;br&gt;http://www.acme.com), the url must either start with a \\s, \\n or any character other than &gt;.\n2. the pattern will match the preceding \\s and \\n too, so when you replace put them back in place $1 will either be \\s or \\n, $2 will be the exact match\nvb usage :\nset re = New RegExp\nre.Pattern =&quot;(\\s|\\n|^)(\\w+://[^\\s\\n]+)&quot;\nstrResult = re.Replace(strText, &quot;$1&lt;a href='$2' target='_new'&gt;$2&lt;/a&gt;&quot;)",
        "refined_prompt": "\nMatch examples:\n- \"http://www.acme.com\"\n- \"ftp://ftp.acme.com/hede\"\n- \"gopher://asdfasd.asdfasdf\"\nNon-match examples:\n- \"&lt;a href=&quot;http://acme.com&quot;&gt;http://www.acme.com&lt;/a&gt;\"\n- \"&lt;br&gt;http://www.acme.\"",
        "matches": [
            "http://www.acme.com",
            "ftp://ftp.acme.com/hede",
            "gopher://asdfasd.asdfasdf"
        ],
        "non_matches": [
            "&lt;a href=&quot;http://acme.com&quot;&gt;http://www.acme.com&lt;/a&gt;",
            "&lt;br&gt;http://www.acme."
        ],
        "stress_tests": []
    },
    {
        "id": 623,
        "expression": "[0-9]{4}[A-Z]{2}",
        "raw_prompt": "Match for dutch zipcodes.\nDutch zipcodes are always in the format of 4 digits and 2 letters.",
        "refined_prompt": "\nMatch examples:\n- \"1000AB\"\n- \"3035KA\"\n- \"9999ZZ\"\nNon-match examples:\n- \"AA1000\"\n- \"Z1000\"",
        "matches": [
            "1000AB",
            "3035KA",
            "9999ZZ"
        ],
        "non_matches": [
            "AA1000",
            "Z1000",
            "1000-CC"
        ],
        "stress_tests": []
    },
    {
        "id": 626,
        "expression": "^(((((0[1-9])|(1\\d)|(2[0-8]))/((0[1-9])|(1[0-2])))|((31/((0[13578])|(1[02])))|((29|30)/((0[1,3-9])|(1[0-2])))))/((20[0-9][0-9]))|((((0[1-9])|(1\\d)|(2[0-8]))/((0[1-9])|(1[0-2])))|((31/((0[13578])|(1[02])))|((29|30)/((0[1,3-9])|(1[0-2])))))/((19[0-9][0-9]))|(29/02/20(([02468][048])|([13579][26])))|(29/02/19(([02468][048])|([13579][26]))))$",
        "raw_prompt": "This expression is an improved version of J&#246;rg Maag. It checks a date field in the Australian DD/MM/YYYY format. Besides, it also validates leap year between 1900 and 2099.",
        "refined_prompt": "\nMatch examples:\n- \"29/02/1992\"\n- \"29/02/2000\"\n- \"29/02/2004\"\nNon-match examples:\n- \"29/02/1892\"\n- \"29/02/2100\"",
        "matches": [
            "29/02/1992",
            "29/02/2000",
            "29/02/2004"
        ],
        "non_matches": [
            "29/02/1892",
            "29/02/2100",
            "29/02/3004"
        ],
        "stress_tests": []
    },
    {
        "id": 627,
        "expression": "(((0[1-9]|[12][0-9]|3[01])([/])(0[13578]|10|12)([/])([1-2][0,9][0-9][0-9]))|(([0][1-9]|[12][0-9]|30)([/])(0[469]|11)([/])([1-2][0,9][0-9][0-9]))|((0[1-9]|1[0-9]|2[0-8])([/])(02)([/])([1-2][0,9][0-9][0-9]))|((29)(\\.|-|\\/)(02)([/])([02468][048]00))|((29)([/])(02)([/])([13579][26]00))|((29)([/])(02)([/])([0-9][0-9][0][48]))|((29)([/])(02)([/])([0-9][0-9][2468][048]))|((29)([/])(02)([/])([0-9][0-9][13579][26])))",
        "raw_prompt": "This is the Brazilian Date Format.\nDD/MM/YYYY with the right days per month.\nDates &gt;=1900 &lt;=2999.",
        "refined_prompt": "\nMatch examples:\n- \"29/02/2004\"\n- \"31/01/1900\"\n- \"31/01/2999\"\nNon-match examples:\n- \"29/02/2003\"\n- \"12042004\"",
        "matches": [
            "29/02/2004",
            "31/01/1900",
            "31/01/2999"
        ],
        "non_matches": [
            "29/02/2003",
            "12042004",
            "20/04/04"
        ],
        "stress_tests": []
    },
    {
        "id": 634,
        "expression": "^([1-9]|[1-9]\\d|100)$",
        "raw_prompt": "This pattern matches whole numbers 1-100.",
        "refined_prompt": "\nMatch examples:\n- \"1\"\n- \"50\"\n- \"100\"\nNon-match examples:\n- \"0\"\n- \".5\"",
        "matches": [
            "1",
            "50",
            "100"
        ],
        "non_matches": [
            "0",
            ".5",
            "101"
        ],
        "stress_tests": []
    },
    {
        "id": 635,
        "expression": "^(20|21|22|23|[01]\\d|\\d)(([:.][0-5]\\d){1,2})$",
        "raw_prompt": "24 hour clock as prefered by MS-SQL, allows for shorter more human methods of writing time (no preceding zero or seconds required).\nMS-SQL prefers semi-colon although this accepts full stops for users ease of use.",
        "refined_prompt": "\nMatch examples:\n- \"09:00:00\"\n- \"09.00\"\n- \"9:00\"\nNon-match examples:\n- \"9:00AM\"",
        "matches": [
            "09:00:00",
            "09.00",
            "9:00"
        ],
        "non_matches": [
            "9:00AM"
        ],
        "stress_tests": []
    },
    {
        "id": 637,
        "expression": "^[a-zA-Z]+((\\s|\\-)[a-zA-Z]+)?$",
        "raw_prompt": "This regex validates a persons first name. Acceptable names include compound names with a hyphen or a space in them.",
        "refined_prompt": "\nMatch examples:\n- \"Bobbie Sue\"\n- \"Ana-Claire\"\n- \"BobbyJoe\"\nNon-match examples:\n- \"Billy - Joe\"\n- \"Billy Jr.\"",
        "matches": [
            "Bobbie Sue",
            "Ana-Claire",
            "BobbyJoe"
        ],
        "non_matches": [
            "Billy - Joe",
            "Billy Jr.",
            "Thos."
        ],
        "stress_tests": []
    },
    {
        "id": 638,
        "expression": "^[a-zA-Z]+((((\\-)|(\\s))[a-zA-Z]+)?(,(\\s)?(((j|J)|(s|S))(r|R)(\\.)?|II|III|IV))?)?$",
        "raw_prompt": "This regex validates a persons last name. Acceptable names can include compound names seperated by a hyphen or a space.",
        "refined_prompt": "\nMatch examples:\n- \"Jones, Jr\"\n- \"Casey-Jones\"\n- \"Casey-Jones, IV\"\nNon-match examples:\n- \"Jones, IV.\"\n- \"Jones , Jr\"",
        "matches": [
            "Jones, Jr",
            "Casey-Jones",
            "Casey-Jones, IV"
        ],
        "non_matches": [
            "Jones, IV.",
            "Jones , Jr",
            "Casey-Jones-Hall"
        ],
        "stress_tests": []
    },
    {
        "id": 639,
        "expression": "(((0[123456789]|10|11|12)([/])(([1][9][0-9][0-9])|([2][0-9][0-9][0-9]))))",
        "raw_prompt": "This is an new data Validation to MM/YYYY from 1900 to 2999 this is an validation expression to Client From MOnth/Year.",
        "refined_prompt": "\nMatch examples:\n- \"01/1900\"\n- \"10/1990\"\n- \"12/2999\"\nNon-match examples:\n- \"1/1900\"\n- \"12/1899\"",
        "matches": [
            "01/1900",
            "10/1990",
            "12/2999"
        ],
        "non_matches": [
            "1/1900",
            "12/1899",
            "01/3000"
        ],
        "stress_tests": []
    },
    {
        "id": 640,
        "expression": "^(([1-9]{1})|([0-1][0-9])|([1-2][0-3])):([0-5][0-9])$",
        "raw_prompt": "Matches 24 hour time format.",
        "refined_prompt": "\nMatch examples:\n- \"00:00\"\n- \"23:59\"\n- \"10:10\"\nNon-match examples:\n- \"24:00\"\n- \"00:60\"",
        "matches": [
            "00:00",
            "23:59",
            "10:10"
        ],
        "non_matches": [
            "24:00",
            "00:60",
            "25:61"
        ],
        "stress_tests": []
    },
    {
        "id": 641,
        "expression": "^(([1-9]{1})|([0-1][1-2])|(0[1-9])|([1][0-2])):([0-5][0-9])(([aA])|([pP]))[mM]$",
        "raw_prompt": "Matches 12 hour time format",
        "refined_prompt": "\nMatch examples:\n- \"1:00Am\"\n- \"12:59pM\"\n- \"05:05pm\"\nNon-match examples:\n- \"00:00am\"\n- \"05:60pm\"",
        "matches": [
            "1:00Am",
            "12:59pM",
            "05:05pm"
        ],
        "non_matches": [
            "00:00am",
            "05:60pm",
            "1:00"
        ],
        "stress_tests": []
    },
    {
        "id": 642,
        "expression": "(^[0]{1}$|^[-]?[1-9]{1}\\d*$)",
        "raw_prompt": "This is a regular expression I used to validate negative and positive WHOLE numbers, including 0.",
        "refined_prompt": "\nMatch examples:\n- \"0\"\n- \"123\"\n- \"-123\"\nNon-match examples:\n- \"001\"\n- \"-012\"",
        "matches": [
            "0",
            "123",
            "-123"
        ],
        "non_matches": [
            "001",
            "-012",
            "-002"
        ],
        "stress_tests": []
    },
    {
        "id": 644,
        "expression": "[:]{1}[-~+o]?[)&gt;]+",
        "raw_prompt": "This ist the Expression for a happy smiley. It should find all the usual writings of the emotion icon :)",
        "refined_prompt": "\nMatch examples:\n- \":)))))\"\n- \":+&gt;\"\n- \":o)\"\nNon-match examples:\n- \";o)\"\n- \":-(\"",
        "matches": [
            ":)))))",
            ":+&gt;",
            ":o)"
        ],
        "non_matches": [
            ";o)",
            ":-("
        ],
        "stress_tests": []
    },
    {
        "id": 645,
        "expression": "^\\d?\\d'(\\d|1[01])&quot;$",
        "raw_prompt": "Height notation for feet (') and inches(&quot;)",
        "refined_prompt": "\nMatch examples:\n- \"6'3&quot;\"\n- \"5'11&quot;\"\n- \"10'0&quot;\"\nNon-match examples:\n- \"9 Feet 2 inches\"\n- \"5'12&quot;\"",
        "matches": [
            "6'3&quot;",
            "5'11&quot;",
            "10'0&quot;"
        ],
        "non_matches": [
            "9 Feet 2 inches",
            "5'12&quot;",
            "5'2 1/2&quot;"
        ],
        "stress_tests": []
    },
    {
        "id": 647,
        "expression": "^-?\\d*(\\.\\d+)?$",
        "raw_prompt": "Matches all positive &amp; negative decimal floating point numbers, to any magnitude. Allows empty string.",
        "refined_prompt": "\nMatch examples:\n- \"4.4\"\n- \".4\"\n- \"-.4\"\nNon-match examples:\n- \".\"\n- \"...\"",
        "matches": [
            "4.4",
            ".4",
            "-.4"
        ],
        "non_matches": [
            ".",
            "...",
            "zero"
        ],
        "stress_tests": []
    },
    {
        "id": 650,
        "expression": "^(ht|f)tp(s?)\\:\\/\\/[a-zA-Z0-9\\-\\._]+(\\.[a-zA-Z0-9\\-\\._]+){2,}(\\/?)([a-zA-Z0-9\\-\\.\\?\\,\\'\\/\\\\\\+&amp;%\\$#_]*)?$",
        "raw_prompt": "Cheap and cheerful URL checker. Requires a http/https/ftp at the start and will then allow anything starting with at least a &lt;something&gt;.&lt;something&gt;.&lt;something&gt; then valid characters separated by dots and slashes",
        "refined_prompt": "\nMatch examples:\n- \"http://www.thedaddy.org\"\n- \"http://forum.thedaddy.org/index.html\"\n- \"ftp://hows.it.going_buddy/checkit/o\"\nNon-match examples:\n- \"www.thedaddy.org\"\n- \"http://hello\"",
        "matches": [
            "http://www.thedaddy.org",
            "http://forum.thedaddy.org/index.html",
            "ftp://hows.it.going_buddy/checkit/o"
        ],
        "non_matches": [
            "www.thedaddy.org",
            "http://hello",
            "ftp://check.it"
        ],
        "stress_tests": []
    },
    {
        "id": 651,
        "expression": ".+\\.([^.]+)$",
        "raw_prompt": "Get any file extension...",
        "refined_prompt": "\nMatch examples:\n- \"foo.bar\"\n- \"more.foo.bar\"\nNon-match examples:\n- \".\"\n- \"bar\"",
        "matches": [
            "foo.bar",
            "more.foo.bar"
        ],
        "non_matches": [
            ".",
            "bar"
        ],
        "stress_tests": []
    },
    {
        "id": 652,
        "expression": "^[0-9]*[1-9]+$|^[1-9]+[0-9]*$",
        "raw_prompt": "This Expression checks if the value is an integer, positive, not zero and not a decimal.\nVery handy for use when people need to fill in whole numbers, like when ordering car parts on a website (you dont want your customers to order -10 tires or 0.7 mirrors..",
        "refined_prompt": "\nMatch examples:\n- \"1\"\n- \"00000428123\"\n- \"1230000\"\nNon-match examples:\n- \"0\"\n- \"00000000\"",
        "matches": [
            "1",
            "00000428123",
            "1230000"
        ],
        "non_matches": [
            "0",
            "00000000",
            "any text or +, - or any other character"
        ],
        "stress_tests": []
    },
    {
        "id": 653,
        "expression": "\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*([,;]\\s*\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*)*",
        "raw_prompt": "Validates 1 or more email addresses. Email addresses can be delimited with either comma or semicolon. White space is allowed after delimiter, but not necessary. I needed this to allow my users to specify multiple email addresses if they choose to do so.",
        "refined_prompt": "\nMatch examples:\n- \"lewis@moten.com\"\n- \"lewis@moten.com, me@lewismoten.com\"\n- \"lewis@moten.com;me@lewismoten.com\"\nNon-match examples:\n- \"lewis@@moten.com\"",
        "matches": [
            "lewis@moten.com",
            "lewis@moten.com, me@lewismoten.com",
            "lewis@moten.com;me@lewismoten.com"
        ],
        "non_matches": [
            "lewis@@moten.com"
        ],
        "stress_tests": []
    },
    {
        "id": 654,
        "expression": "^(\\(?[0-9]{3}[\\)-\\.]?\\ ?)?[0-9]{3}[-\\.]?[0-9]{4}$",
        "raw_prompt": "Simple US phone number matching, allowing area code or not. Allows spaces, dashes, dots, or none of the above. Area code, if entered, can be surrounded by parenthesis or not.",
        "refined_prompt": "\nMatch examples:\n- \"(555) 555-5555\"\n- \"555.555.5555\"\n- \"555-5555\"\nNon-match examples:\n- \"(555)-555-5555\"",
        "matches": [
            "(555) 555-5555",
            "555.555.5555",
            "555-5555"
        ],
        "non_matches": [
            "(555)-555-5555"
        ],
        "stress_tests": []
    },
    {
        "id": 655,
        "expression": "^(\\-)?\\d*(\\.\\d+)?$",
        "raw_prompt": "Matches all positive decimal floating negative/non-negative numbers. Allows empty string.",
        "refined_prompt": "\nMatch examples:\n- \"0.55\"\n- \"21232.00\"\n- \"-89.20\"\nNon-match examples:\n- \"asdf\"\n- \"+0.33\"",
        "matches": [
            "0.55",
            "21232.00",
            "-89.20"
        ],
        "non_matches": [
            "asdf",
            "+0.33"
        ],
        "stress_tests": []
    },
    {
        "id": 656,
        "expression": "^((?:.*(?!\\d))*(?:\\D*)?)(\\d+)$",
        "raw_prompt": "Matches the number at the end of the string.",
        "refined_prompt": "\nMatch examples:\n- \"123\"\n- \"aaa123\"\n- \"aaa123aaa123\"\nNon-match examples:\n- \"aaa\"\n- \"aaa123aaa\"",
        "matches": [
            "123",
            "aaa123",
            "aaa123aaa123"
        ],
        "non_matches": [
            "aaa",
            "aaa123aaa"
        ],
        "stress_tests": []
    },
    {
        "id": 657,
        "expression": "^(ht|f)tp((?<=http)s)?://((?<=http://)www|(?<=https://)www|(?<=ftp://)ftp)\\.(([a-z][0-9])|([0-9][a-z])|([a-z0-9][a-z0-9\\-]{1,2}[a-z0-9])|([a-z0-9][a-z0-9\\-](([a-z0-9\\-][a-z0-9])|([a-z0-9][a-z0-9\\-]))[a-z0-9\\-]*[a-z0-9]))\\.(co|me|org|ltd|plc|net|sch|ac|mod|nhs|police|gov)\\.uk(:\\d+)?\\/?$",
        "raw_prompt": "UK http/https/ftp URI. Based on my previous expression, this one takes an optional port number and optional trailing slash.",
        "refined_prompt": "\nMatch examples:\n- \"http://www.zeropanic.co.uk/\"\n- \"http://www.zeropanic.co.uk:81/\"\n- \"http://www.zeropanic.co.uk:81\"\nNon-match examples:\n- \"http://www.zeropanic.com:81/\"",
        "matches": [
            "http://www.zeropanic.co.uk/",
            "http://www.zeropanic.co.uk:81/",
            "http://www.zeropanic.co.uk:81"
        ],
        "non_matches": [
            "http://www.zeropanic.com:81/"
        ],
        "stress_tests": []
    },
    {
        "id": 660,
        "expression": "^([0-9a-fA-F]{1,2})(\\s[0-9a-fA-F]{1,2})*$",
        "raw_prompt": "Expression validating a series of hex codes (byte values) separated by spaces.",
        "refined_prompt": "\nMatch examples:\n- \"1b 2e\"\n- \"1B 70 00 90 F0\"\nNon-match examples:\n- \"gh 4b\"\n- \"1G 70 00 UU\"",
        "matches": [
            "1b 2e",
            "1B 70 00 90 F0"
        ],
        "non_matches": [
            "gh 4b",
            "1G 70 00 UU"
        ],
        "stress_tests": []
    },
    {
        "id": 662,
        "expression": "&lt;(?:[^&quot;']+?|.+?(?:&quot;|').*?(?:&quot;|')?.*?)*?&gt;",
        "raw_prompt": "This will match all tags in a string, it's good for stripping HTML or XML tags to get the plain text.It works with attributes that include javascript or &quot;&lt;&gt;&quot;.\nIt will match all these\n&lt;hr size=&quot;3&quot;\nnoshade\ncolor=&quot;#000000&quot;\nalign=&quot;left&quot;&gt;\n&lt;p style=&quot;margin-top:0px;margin-bottom:0px&quot;\nalign=&quot;center&quot;&gt;&lt;font face=&quot;Times New Roman&quot;\nsize=&quot;5&quot;&gt;&lt;b&gt;UNITED STATES&lt;/b&gt;&lt;/font&gt;&lt;/p&gt;\n&lt;input type=button onclick='if(n.value&gt;5)do_this();'&gt; not this &lt;br&gt; &lt;input type=button onclick=&quot;n&gt;5?a():b();&quot; value=test&gt; not this &lt;br&gt; &lt;input type=button onclick=&quot;n&gt;5?a(\\&quot;OK\\&quot;):b('Not Ok');&quot; value=test&gt; not this &lt;br&gt; &lt;input type=button onclick='n&gt;5' value=test onmouseover=&quot;n&lt;5&amp;&amp;n&gt;8&quot; onmouseout='if(n&gt;5)alert(\\'True\\');else alert(&quot;False&quot;)'&gt; not this &lt;br&gt;",
        "refined_prompt": "\nMatch examples:\n- \"&lt;input type=button onclick='n&gt;5' value=test onmouseover=&quot;n&lt;5&amp;&amp;n&gt;8&quot; onm\"\nNon-match examples:\n- \"haven't found any exceptions yet\"",
        "matches": [
            "&lt;input type=button onclick='n&gt;5' value=test onmouseover=&quot;n&lt;5&amp;&amp;n&gt;8&quot; onm"
        ],
        "non_matches": [
            "haven't found any exceptions yet"
        ],
        "stress_tests": []
    },
    {
        "id": 665,
        "expression": "^[a-zA-Z]+(([\\'\\,\\.\\- ][a-zA-Z ])?[a-zA-Z]*)*\\s+&lt;(\\w[-._\\w]*\\w@\\w[-._\\w]*\\w\\.\\w{2,3})&gt;$|^(\\w[-._\\w]*\\w@\\w[-._\\w]*\\w\\.\\w{2,3})$",
        "raw_prompt": "This Works good until we want a multiple email address validator, I am working on it to make it work with the multiple email address, If anyone can work on this part as to validate a multiple email address then that will produce a very good expression, i think the best of this kind. AIM - to Validate Mohit &lt;myadav@yahoo.com&gt;; Rohit &lt;ryadav@yahoo.com&gt;; .........(any number of times)",
        "refined_prompt": "\nMatch examples:\n- \"Mohit &lt;myadav@yahoo.com&gt;\"\n- \"Xon &lt;JON@jon.com&gt;\"\n- \"Xon@something.com\"\nNon-match examples:\n- \"mohit&lt;myadav@yahoo.com&gt;\"\n- \"Xon &lt;JON@jon.com&gt;, tom &lt;jon@jon.com&gt;\"",
        "matches": [
            "Mohit &lt;myadav@yahoo.com&gt;",
            "Xon &lt;JON@jon.com&gt;",
            "Xon@something.com"
        ],
        "non_matches": [
            "mohit&lt;myadav@yahoo.com&gt;",
            "Xon &lt;JON@jon.com&gt;, tom &lt;jon@jon.com&gt;",
            "Xon@somthing.com,"
        ],
        "stress_tests": []
    },
    {
        "id": 673,
        "expression": "^(smtp)\\.([\\w\\-]+)\\.[\\w\\-]{2,3}$",
        "raw_prompt": "Matches basic SMTP server names.",
        "refined_prompt": "\nMatch examples:\n- \"smtp.yahoo.com\"\n- \"smtp.charter.net\"\nNon-match examples:\n- \"pop.yahoo.com\"",
        "matches": [
            "smtp.yahoo.com",
            "smtp.charter.net"
        ],
        "non_matches": [
            "pop.yahoo.com"
        ],
        "stress_tests": []
    },
    {
        "id": 675,
        "expression": "(?=\\d)^(?:(?!(?:10\\D(?:0?[5-9]|1[0-4])\\D(?:1582))|(?:0?9\\D(?:0?[3-9]|1[0-3])\\D(?:1752)))((?:0?[13578]|1[02])|(?:0?[469]|11)(?!\\/31)(?!-31)(?!\\.31)|(?:0?2(?=.?(?:(?:29.(?!000[04]|(?:(?:1[^0-6]|[2468][^048]|[3579][^26])00))(?:(?:(?:\\d\\d)(?:[02468][048]|[13579][26])(?!\\x20BC))|(?:00(?:42|3[0369]|2[147]|1[258]|09)\\x20BC))))))|(?:0?2(?=.(?:(?:\\d\\D)|(?:[01]\\d)|(?:2[0-8])))))([-.\\/])(0?[1-9]|[12]\\d|3[01])\\2(?!0000)((?=(?:00(?:4[0-5]|[0-3]?\\d)\\x20BC)|(?:\\d{4}(?!\\x20BC)))\\d{4}(?:\\x20BC)?)(?:$|(?=\\x20\\d)\\x20))?((?:(?:0?[1-9]|1[012])(?::[0-5]\\d){0,2}(?:\\x20[aApP][mM]))|(?:[01]\\d|2[0-3])(?::[0-5]\\d){1,2})?$",
        "raw_prompt": "mm/dd/yyyy hh:MM:ss Datetime for all AD years, including leap years.\nJavascript safe version of http://regexlib.com/REDetails.aspx?regexp_id=644. Please see that regex for details of what is being checked",
        "refined_prompt": "\nMatch examples:\n- \"11/24/0004 11:59 PM\"\n- \"2.29.2008\"\n- \"02:50:10\"\nNon-match examples:\n- \"12/33/1020\"\n- \"2/29/2005\"",
        "matches": [
            "11/24/0004 11:59 PM",
            "2.29.2008",
            "02:50:10"
        ],
        "non_matches": [
            "12/33/1020",
            "2/29/2005",
            "13:00 AM"
        ],
        "stress_tests": []
    },
    {
        "id": 676,
        "expression": "^(?=\\d)(?:(?!(?:(?:0?[5-9]|1[0-4])(?:\\.|-|\\/)10(?:\\.|-|\\/)(?:1582))|(?:(?:0?[3-9]|1[0-3])(?:\\.|-|\\/)0?9(?:\\.|-|\\/)(?:1752)))(31(?!(?:\\.|-|\\/)(?:0?[2469]|11))|30(?!(?:\\.|-|\\/)0?2)|(?:29(?:(?!(?:\\.|-|\\/)0?2(?:\\.|-|\\/))|(?=\\D0?2\\D(?:(?!000[04]|(?:(?:1[^0-6]|[2468][^048]|[3579][^26])00))(?:(?:(?:\\d\\d)(?:[02468][048]|[13579][26])(?!\\x20BC))|(?:00(?:42|3[0369]|2[147]|1[258]|09)\\x20BC))))))|2[0-8]|1\\d|0?[1-9])([-.\\/])(1[012]|(?:0?[1-9]))\\2((?=(?:00(?:4[0-5]|[0-3]?\\d)\\x20BC)|(?:\\d{4}(?:$|(?=\\x20\\d)\\x20)))\\d{4}(?:\\x20BC)?)(?:$|(?=\\x20\\d)\\x20))?((?:(?:0?[1-9]|1[012])(?::[0-5]\\d){0,2}(?:\\x20[aApP][mM]))|(?:[01]\\d|2[0-3])(?::[0-5]\\d){1,2})?$",
        "raw_prompt": "dd/mm/yyyy hh:MM:ss Datetime for all AD years, including leap years.\nJavascript safe version of http://regexlib.com/REDetails.aspx?regexp_id=691. Please see that regex for details of what is being checked",
        "refined_prompt": "\nMatch examples:\n- \"31.12.6008\"\n- \"5:30 AM\"\n- \"30-04-1066\"\nNon-match examples:\n- \"00/00/0000\"\n- \"99:99:99\"",
        "matches": [
            "31.12.6008",
            "5:30 AM",
            "30-04-1066"
        ],
        "non_matches": [
            "00/00/0000",
            "99:99:99",
            "29/02/2005"
        ],
        "stress_tests": []
    },
    {
        "id": 677,
        "expression": "^(?=\\d)(?:(?!(?:1582(?:\\.|-|\\/)10(?:\\.|-|\\/)(?:0?[5-9]|1[0-4]))|(?:1752(?:\\.|-|\\/)0?9(?:\\.|-|\\/)(?:0?[3-9]|1[0-3])))(?=(?:(?!000[04]|(?:(?:1[^0-6]|[2468][^048]|[3579][^26])00))(?:(?:\\d\\d)(?:[02468][048]|[13579][26]))\\D0?2\\D29)|(?:\\d{4}\\D(?!(?:0?[2469]|11)\\D31)(?!0?2(?:\\.|-|\\/)(?:29|30))))(\\d{4})([-\\/.])(0?\\d|1[012])\\2((?!00)[012]?\\d|3[01])(?:$|(?=\\x20\\d)\\x20))?((?:(?:0?[1-9]|1[012])(?::[0-5]\\d){0,2}(?:\\x20[aApP][mM]))|(?:[01]\\d|2[0-3])(?::[0-5]\\d){1,2})?$",
        "raw_prompt": "yyyy/mm/dd hh:MM:ss Datetime for all AD years, including leap years.\nJavascript safe version of http://regexlib.com/REDetails.aspx?regexp_id=760. Please see that regex for details of what is being checked",
        "refined_prompt": "\nMatch examples:\n- \"0008-02-29\"\n- \"2:34:59 PM\"\n- \"9999/12/31 11:59 PM\"\nNon-match examples:\n- \"04/04/04\"\n- \"1:00\"",
        "matches": [
            "0008-02-29",
            "2:34:59 PM",
            "9999/12/31 11:59 PM"
        ],
        "non_matches": [
            "04/04/04",
            "1:00",
            "1999/1/32"
        ],
        "stress_tests": []
    },
    {
        "id": 678,
        "expression": "^((\\d[-. ]?)?((\\(\\d{3}\\))|\\d{3}))?[-. ]?\\d{3}[-. ]?\\d{4}$",
        "raw_prompt": "This is a pretty flexable phone number validator for US numbers. Allows optional country code and area code. Allows separation of numbers with &quot; &quot;, &quot;-&quot;, &quot;.&quot; or nothing to seperate. Area codes can be in parenthesis or not. Validates that you'll get 7, 10, or 11 digits in the way the most number of people option when writing them.",
        "refined_prompt": "\nMatch examples:\n- \"1(555)444-3333\"\n- \"202.555.3333\"\n- \"555-4444\"\nNon-match examples:\n- \"555-222-33334\"\n- \"1(303)5a4-5555\"",
        "matches": [
            "1(555)444-3333",
            "202.555.3333",
            "555-4444"
        ],
        "non_matches": [
            "555-222-33334",
            "1(303)5a4-5555",
            "1 202) 111-3333"
        ],
        "stress_tests": []
    },
    {
        "id": 679,
        "expression": "^((((H|h)(T|t)|(F|f))(T|t)(P|p)((S|s)?))\\://)?(www.|[a-zA-Z0-9].)[a-zA-Z0-9\\-\\.]+\\.[a-zA-Z]{2,6}(\\:[0-9]{1,5})*(/($|[a-zA-Z0-9\\.\\,\\;\\?\\'\\\\\\+&amp;%\\$#\\=~_\\-]+))*$",
        "raw_prompt": "Matches URLS that start with numbers and any TLD that is 2 to 6 characters long. Matches most URLs. Thanks to eveyone for suggesting modifications!\nUPDATES::[Nov. 11, 2005] Now it matches uppercase and lower case protocols.\nUpdates::December 3, 2005 Added restriction to ports since they will only go up to 65535. (Thanks lorello)\nKeep the suggestions coming! Thanks for the heads up!!",
        "refined_prompt": "\nMatch examples:\n- \"hTtP://3iem.net/\"\n- \"http://3iem.museum:1337/\"\n- \"plik.co.uk\"\nNon-match examples:\n- \"http://foobar\"\n- \"lameurl.toolongtld\"",
        "matches": [
            "hTtP://3iem.net/",
            "http://3iem.museum:1337/",
            "plik.co.uk"
        ],
        "non_matches": [
            "http://foobar",
            "lameurl.toolongtld"
        ],
        "stress_tests": []
    },
    {
        "id": 680,
        "expression": "^(((ht|f)tp(s?))\\://).*$",
        "raw_prompt": "Identifies http, https, ftp, and ftps",
        "refined_prompt": "\nMatch examples:\n- \"http://3iem.net/\"\n- \"https://foo.org\"\n- \"ftps://jormahma.tk/\"\nNon-match examples:\n- \"yahoo.com\"\n- \"lame://protocol.us\"",
        "matches": [
            "http://3iem.net/",
            "https://foo.org",
            "ftps://jormahma.tk/"
        ],
        "non_matches": [
            "yahoo.com",
            "lame://protocol.us"
        ],
        "stress_tests": []
    },
    {
        "id": 684,
        "expression": "^(?=.*[0-9]+.*)(?=.*[a-zA-Z]+.*)[0-9a-zA-Z]{6,}$",
        "raw_prompt": "Password must contain at least one letter, at least one number, and be longer than six charaters.",
        "refined_prompt": "\nMatch examples:\n- \"a1b2c3\"\n- \"abcdefg123\"\n- \"12345a\"\nNon-match examples:\n- \"abcdefghij\"\n- \"1234567890\"",
        "matches": [
            "a1b2c3",
            "abcdefg123",
            "12345a"
        ],
        "non_matches": [
            "abcdefghij",
            "1234567890"
        ],
        "stress_tests": []
    },
    {
        "id": 688,
        "expression": "^(((((0?[1-9])|(1\\d)|(2[0-8]))\\.((0?[1-9])|(1[0-2])))|((31\\.((0[13578])|(1[02])))|((29|30)\\.((0?[1,3-9])|(1[0-2])))))\\.((20[0-9][0-9]))|(29\\.0?2\\.20(([02468][048])|([13579][26]))))$",
        "raw_prompt": "Regular expression to evaluate a date in German date format (DD.MM.YYYY). Leading zeros for days and months are valid. Period from 1.1.2000 until 31.12.2099 is valid. Leap years are checked.",
        "refined_prompt": "\nMatch examples:\n- \"1.1.2000\"\n- \"29.02.2004\"\n- \"31.12.2099\"\nNon-match examples:\n- \"1.1.1999\"\n- \"29.02.2003\"",
        "matches": [
            "1.1.2000",
            "29.02.2004",
            "31.12.2099"
        ],
        "non_matches": [
            "1.1.1999",
            "29.02.2003",
            "01.01.2100"
        ],
        "stress_tests": []
    },
    {
        "id": 689,
        "expression": "(\\/\\*(\\s*|.*?)*\\*\\/)|(\\/\\/.*)",
        "raw_prompt": "This regexp is used to match c++,java,etc style multi-line and single line comments.",
        "refined_prompt": "\nMatch examples:\n- \"/* This is a multi-line comment */\"\n- \"// this is a single-line\"\nNon-match examples:\n- \"/sometext\"\n- \"/*/\"",
        "matches": [
            "/* This is a multi-line comment */",
            "// this is a single-line"
        ],
        "non_matches": [
            "/sometext",
            "/*/"
        ],
        "stress_tests": []
    },
    {
        "id": 693,
        "expression": "\\.txt$",
        "raw_prompt": "Matches a file extention.",
        "refined_prompt": "\nMatch examples:\n- \"testfile.txt\"\n- \".txt\"\n- \"this is a file.txt\"\nNon-match examples:\n- \"this is not a file.trt\"\n- \".tst\"",
        "matches": [
            "testfile.txt",
            ".txt",
            "this is a file.txt"
        ],
        "non_matches": [
            "this is not a file.trt",
            ".tst",
            ".text"
        ],
        "stress_tests": []
    },
    {
        "id": 697,
        "expression": "((DK|FI|HU|LU|MT|SI)(-)?\\d{8})|((BE|EE|DE|EL|LT|PT)(-)?\\d{9})|((PL|SK)(-)?\\d{10})|((IT|LV)(-)?\\d{11})|((LT|SE)(-)?\\d{12})|(AT(-)?U\\d{8})|(CY(-)?\\d{8}[A-Z])|(CZ(-)?\\d{8,10})|(FR(-)?[\\dA-HJ-NP-Z]{2}\\d{9})|(IE(-)?\\d[A-Z\\d]\\d{5}[A-Z])|(NL(-)?\\d{9}B\\d{2})|(ES(-)?[A-Z\\d]\\d{7}[A-Z\\d])",
        "raw_prompt": "Matches valid VAT identification number for all current EU's member states, in format CC-xxx or CCxxx (where CC is country code and xxx actual VAT number).",
        "refined_prompt": "\nMatch examples:\n- \"CZ-7907111883\"\n- \"ESA12345678\"\n- \"FRAB123456789\"\nNon-match examples:\n- \"CZ55912\"\n- \"XY123456\"",
        "matches": [
            "CZ-7907111883",
            "ESA12345678",
            "FRAB123456789"
        ],
        "non_matches": [
            "CZ55912",
            "XY123456",
            "FR-IB123456789"
        ],
        "stress_tests": []
    },
    {
        "id": 702,
        "expression": "^((CN=['\\w\\d\\s\\-\\&amp;]+,)+(OU=['\\w\\d\\s\\-\\&amp;]+,)*(DC=['\\w\\d\\s\\-\\&amp;]+[,]*){2,})$",
        "raw_prompt": "Matches the LDAP path of Microsoft Active Directory entry. Checks to ensure the ADsPath attribute is accurate.",
        "refined_prompt": "\nMatch examples:\n- \"CN=Joey O'Brenn,OU=Test &amp; 1,OU=Test &amp; 2,DC=support,DC=com\"\nNon-match examples:\n- \"CN=Laurie Brenn,CN=Users,DC=support\"",
        "matches": [
            "CN=Joey O'Brenn,OU=Test &amp; 1,OU=Test &amp; 2,DC=support,DC=com"
        ],
        "non_matches": [
            "CN=Laurie Brenn,CN=Users,DC=support"
        ],
        "stress_tests": []
    },
    {
        "id": 703,
        "expression": "^(((2|8|9)\\d{2})|((02|08|09)\\d{2})|([1-9]\\d{3}))$",
        "raw_prompt": "Matched Australian Postcodes, as defined by AusPost.\nMany Australian developers are unaware of the small range of 3 digit, or 0 starting postcodes.\n220 and 221 (or 0220 and 0221) are for ANU and LVR.\n800s and 900s (or 0800s and 0900s) are for NT, and parts of SA, WA.\n1000s are for big companies in Sydney, competition mailings, etc.",
        "refined_prompt": "\nMatch examples:\n- \"200\"\n- \"0820\"\n- \"2753\"\nNon-match examples:\n- \"700\"\n- \"0700\"",
        "matches": [
            "200",
            "0820",
            "2753"
        ],
        "non_matches": [
            "700",
            "0700",
            "abcd"
        ],
        "stress_tests": []
    },
    {
        "id": 704,
        "expression": "^(19[0-9]{2}|[2-9][0-9]{3})-((0(1|3|5|7|8)|10|12)-(0[1-9]|1[0-9]|2[0-9]|3[0-1])|(0(4|6|9)|11)-(0[1-9]|1[0-9]|2[0-9]|30)|(02)-(0[1-9]|1[0-9]|2[0-9]))\\x20(0[0-9]|1[0-9]|2[0-3])(:[0-5][0-9]){2}$",
        "raw_prompt": "Checks for the format yyyy-MM-dd HH:mm:ss\nalso known as SortableDateTimePattern (conforms to ISO 8601) using local time. From 1900-01-01 00:00:00 to 9999-12-31 23:59:59. No check for leap year.",
        "refined_prompt": "\nMatch examples:\n- \"2004-07-12 14:25:59\"\n- \"1900-01-01 00:00:00\"\n- \"9999-12-31 23:59:59\"\nNon-match examples:\n- \"04-07-12 14:25:59\"\n- \"20004-07-12 14:25\"",
        "matches": [
            "2004-07-12 14:25:59",
            "1900-01-01 00:00:00",
            "9999-12-31 23:59:59"
        ],
        "non_matches": [
            "04-07-12 14:25:59",
            "20004-07-12 14:25",
            "2004/07/12 14:25:59"
        ],
        "stress_tests": []
    },
    {
        "id": 705,
        "expression": "^(a-z|A-Z|0-9)*[^#$%^&*()']*$",
        "raw_prompt": "Does not allow these characters in a string #$%^&amp;*()'",
        "refined_prompt": "\nMatch examples:\n- \"Test\"\n- \"Whatever Text\"\n- \"D://folder/file.ext\"\nNon-match examples:\n- \"word's\"\n- \"test#\"",
        "matches": [
            "Test",
            "Whatever Text",
            "D://folder/file.ext"
        ],
        "non_matches": [
            "word's",
            "test#",
            "(something)"
        ],
        "stress_tests": []
    },
    {
        "id": 706,
        "expression": "^((?:[a-zA-Z]:)|(?:\\\\{2}\\w[-\\w]*)\\$?)\\\\(?!\\.)((?:(?![\\\\/:*?<>\"|])(?![.\\x20](?:\\\\|$))[\\x20-\\x7E])+\\\\(?!\\.))*((?:(?:(?![\\\\/:*?<>\"|])(?![ .]$)[\\x20-\\x7E])+)\\.((?:(?![\\\\/:*?<>\"|])(?![ .]$)[\\x20-\\x7E]){2,15}))?$",
        "raw_prompt": "Matches drives, folders and file on a Windows OS. Folder matches must end with \\\nFolder and file names can not end with a space.\nI limited the file extension length to 15 though that not a restriction of a file's extension\nThis is a mod of Darren's regex http://www.regexlib.com/REDetails.aspx?regexp_id=357\nand my own http://www.regexlib.com/REDetails.aspx?regexp_id=137\nUpdated Feb 2005",
        "refined_prompt": "\nMatch examples:\n- \"C:\\\"\n- \"\\\\Server\\share\\path\\File.txt\"\n- \"E:\\My Files\\Are\\#1\\\"\nNon-match examples:\n- \"C:\"\n- \"C:\\\\\\\"",
        "matches": [
            "C:\\",
            "\\\\Server\\share\\path\\File.txt",
            "E:\\My Files\\Are\\#1\\"
        ],
        "non_matches": [
            "C:",
            "C:\\\\\\",
            "C:\\Trailing Space \\"
        ],
        "stress_tests": []
    },
    {
        "id": 708,
        "expression": "(^\\d{1,5}$|^\\d{1,5}\\.\\d{1,2}$)",
        "raw_prompt": "This expression evaluates simple currency values... alteast 1 digit and max 5 digits and if period then atleast one digit after period and max two digits after period",
        "refined_prompt": "\nMatch examples:\n- \"0\"\n- \"00000\"\n- \"00.00\"\nNon-match examples:\n- \"asds\"\n- \"000000\"",
        "matches": [
            "0",
            "00000",
            "00.00"
        ],
        "non_matches": [
            "asds",
            "000000",
            "00000."
        ],
        "stress_tests": []
    },
    {
        "id": 709,
        "expression": "^(\\$)?(\\s)?(\\-)?((\\d+)|(\\d{1,3})(\\,\\d{3})*)(\\.\\d{2,})?$",
        "raw_prompt": "Allows either inclusion of $ symbol or not. Allows a whitespace character after the $ sysmbol or not. Allows a negative symbol in front of the starting digit or not. Allows comma separators at thousands, but nowhere else. Allows more than two decimal places.",
        "refined_prompt": "\nMatch examples:\n- \"$1,000.00\"\n- \"$-1,000.00\"\n- \"100.8766\"\nNon-match examples:\n- \"$1a\"\n- \"$#100.00\"",
        "matches": [
            "$1,000.00",
            "$-1,000.00",
            "100.8766"
        ],
        "non_matches": [
            "$1a",
            "$#100.00",
            "1,00.00"
        ],
        "stress_tests": []
    },
    {
        "id": 711,
        "expression": "^[\\w0-9&#228;&#196;&#246;&#214;&#252;&#220;&#223;\\-_]+\\.[a-zA-Z0-9]{2,6}$",
        "raw_prompt": "This RegEx can be used to varify (esp. when receiving data from forms) filenames. No Path is allowed. German Special Characters are allowed.",
        "refined_prompt": "\nMatch examples:\n- \"gut.txt\"\nNon-match examples:\n- \"&amp;quatsch\"\n- \"qua%tsch.txt\"",
        "matches": [
            "gut.txt"
        ],
        "non_matches": [
            "&amp;quatsch",
            "qua%tsch.txt",
            "auch_quatsch.test.txt"
        ],
        "stress_tests": []
    },
    {
        "id": 712,
        "expression": "^((ht|f)tp(s?))\\://([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]{2,6}(\\:[0-9]+)?(/\\S*)?$",
        "raw_prompt": "Simple URL Validator -- allows http, https, ftp, ftps, 2-6 letter TLD, ports, any path. Sorry, no IP addresses. Not too fussy, but then, it's not too long either ;-)",
        "refined_prompt": "\nMatch examples:\n- \"http://www.site.com\"\n- \"https://www.secure.com:10000\"\n- \"ftp://ftp.site.com/pub/files/\"\nNon-match examples:\n- \"www.site.com\"\n- \"https://www.site.longtld\"",
        "matches": [
            "http://www.site.com",
            "https://www.secure.com:10000",
            "ftp://ftp.site.com/pub/files/"
        ],
        "non_matches": [
            "www.site.com",
            "https://www.site.longtld",
            "ftp:/badformat.com"
        ],
        "stress_tests": []
    },
    {
        "id": 714,
        "expression": "^(?:(?:0?[13578]|1[02])|(?:0?[469]|11)(?!\\/31)|(?:0?2)(?:(?!\\/3[01]|\\/29\\/(?:(?:0[^48]|[13579][^26]|[2468][^048])00|(?:\\d{2}(?:0[^48]|[13579][^26]|[2468][^048]))))))\\/(?:0?[1-9]|[12][0-9]|3[01])\\/\\d{4}$",
        "raw_prompt": "will match all dates in mm/dd/yyyy format. takes into account leap-years and months without 31 days.",
        "refined_prompt": "\nMatch examples:\n- \"2/29/2004\"\n- \"07/16/1492\"\n- \"12/31/1999\"\nNon-match examples:\n- \"2/29/2003\"\n- \"2/29/2100\"",
        "matches": [
            "2/29/2004",
            "07/16/1492",
            "12/31/1999"
        ],
        "non_matches": [
            "2/29/2003",
            "2/29/2100",
            "11/31/2003"
        ],
        "stress_tests": []
    },
    {
        "id": 715,
        "expression": "^\\s*-?((\\d{1,3}(\\.(\\d){3})*)|\\d*)(,\\d{1,2})?\\s?(\\u20AC)?\\s*$",
        "raw_prompt": "Matches euro currency (portuguese regional options).\nUses the dot sign as the thousands separator (optional) and the comma sign as the decimal separator.\nMatches only 2 digitals after decimal.\nAlso matches negative numbers.",
        "refined_prompt": "\nMatch examples:\n- \"-123123,12 \u20ac\"\n- \"12312432134\"\n- \"-12.234.123,23\"\nNon-match examples:\n- \"1234.12,234\"",
        "matches": [
            "-123123,12 \u20ac",
            "12312432134",
            "-12.234.123,23"
        ],
        "non_matches": [
            "1234.12,234"
        ],
        "stress_tests": []
    },
    {
        "id": 722,
        "expression": "((ht|f)tp(s?))(:((\\/\\/)(?!\\/)))(((w){3}\\.)?)([a-zA-Z0-9\\-_]+(\\.(com|edu|gov|int|mil|net|org|biz|info|name|pro|museum|co\\.uk)))(\\/(?!\\/))(([a-zA-Z0-9\\-_\\/]*)?)([a-zA-Z0-9])+\\.((jpg|jpeg|gif|png)(?!(\\w|\\W)))",
        "raw_prompt": "This expression matches valid image URLs. The main use for this would be in UBBC tags.\nWritten by RyanJ and Jick for FWD (http://flexwebdev.thenamesdan.com/)",
        "refined_prompt": "\nMatch examples:\n- \"http://www.location.com/images/image1.gif\"\n- \"http://www.location.com/images/mainImgs/image1.png\"\nNon-match examples:\n- \"/images/image1.jpeg\"\n- \"http://www.location.com/images/image1.swf\"",
        "matches": [
            "http://www.location.com/images/image1.gif",
            "http://www.location.com/images/mainImgs/image1.png"
        ],
        "non_matches": [
            "/images/image1.jpeg",
            "http://www.location.com/images/image1.swf",
            "http://www.something.com/hello/..j"
        ],
        "stress_tests": []
    },
    {
        "id": 724,
        "expression": "^[a-zA-Z_]{1}[a-zA-Z0-9_@$#]*$",
        "raw_prompt": "This Regex matches valid SQL identifiers, including names for Stored Procedures and the like. Note that local variables/parameters (which begin with an &quot;@&quot;) will not match this Regex, nor will temporary objects (beginning with a &quot;#&quot;), or global temporary objects (beginning with &quot;##&quot;). All other valid identifiers/variables/table names/stored procedure names/columns etc., will match. Please let me know if you find this useful or have any complaints - trash@primalblaze.com.",
        "refined_prompt": "\nMatch examples:\n- \"upApplicationReadContacts\"\n- \"_Application_ReadContacts\"\n- \"a_45$#z\"\nNon-match examples:\n- \"upApplication ReadContacts\"\n- \"$Application_ReadContacts\"",
        "matches": [
            "upApplicationReadContacts",
            "_Application_ReadContacts",
            "a_45$#z"
        ],
        "non_matches": [
            "upApplication ReadContacts",
            "$Application_ReadContacts",
            "a_45%$#z"
        ],
        "stress_tests": []
    },
    {
        "id": 725,
        "expression": "(?=([\\W]*[\\w][\\W]*\\b))\\s(?=\\d\\.|\\d\\b)",
        "raw_prompt": "This RegExp matches a space (&quot; &quot;) character with lookahead condition if there is an ASCII text in front of it and it is followed by a single decimal number which in turn is followed by a dot or nothing. It's useful to seperate scientific notation numbers from a text, i.e. when classifying with the bow toolkit.\n[EDIT 18.09.2004] There was indeed an error in the second lookahead. Changed |\\b to |\\d\\b",
        "refined_prompt": "\nMatch examples:\n- \"ROOT 4.873624764e-34\"\n- \"`1234567 890-= 3.8765e-34543\"\n- \"~! @ # $ % ^ &amp; ( % )_+ 3.345e-2384754\"\nNon-match examples:\n- \"rstuvwxyz 754.234e-23\"\n- \"yz754.234e-23\"",
        "matches": [
            "ROOT 4.873624764e-34",
            "`1234567 890-= 3.8765e-34543",
            "~! @ # $ % ^ &amp; ( % )_+ 3.345e-2384754"
        ],
        "non_matches": [
            "rstuvwxyz 754.234e-23",
            "yz754.234e-23",
            "yz .234e-23"
        ],
        "stress_tests": []
    },
    {
        "id": 727,
        "expression": "^\\.{1}",
        "raw_prompt": "simply checks to see if the first charactor is a . (dot)",
        "refined_prompt": "\nMatch examples:\n- \".net\"\n- \".blah\"\n- \".anything\"\nNon-match examples:\n- \"net\"\n- \"net.stuff\"",
        "matches": [
            ".net",
            ".blah",
            ".anything"
        ],
        "non_matches": [
            "net",
            "net.stuff",
            "netstuff."
        ],
        "stress_tests": []
    },
    {
        "id": 729,
        "expression": "^\\d?\\d'(\\d|1[01])?.?(\\d|1[01])&quot;$",
        "raw_prompt": "This RE matches the height in feet and inches with decimals and without decimals in it",
        "refined_prompt": "\nMatch examples:\n- \"5'5.5&quot;\"\n- \"2'3&quot;\"\n- \"9'10.4&quot;\"\nNon-match examples:\n- \"5 feet 5.5 inches\"",
        "matches": [
            "5'5.5&quot;",
            "2'3&quot;",
            "9'10.4&quot;"
        ],
        "non_matches": [
            "5 feet 5.5 inches"
        ],
        "stress_tests": []
    },
    {
        "id": 730,
        "expression": "^[A-Za-z]{4}[ |\\-]{0,1}[0-9]{6}[ |\\-]{0,1}[0-9A-Za-z]{3}$",
        "raw_prompt": "Regular expression that matches Mexican RFC's (Registro Federal de Contribuyentes).",
        "refined_prompt": "\nMatch examples:\n- \"LOZG7802117B9\"\n- \"LOZG-780211-7B9\"\n- \"LOZG780211-7B9\"\nNon-match examples:\n- \"LO-ZG-78-02-11-7B9\"",
        "matches": [
            "LOZG7802117B9",
            "LOZG-780211-7B9",
            "LOZG780211-7B9"
        ],
        "non_matches": [
            "LO-ZG-78-02-11-7B9"
        ],
        "stress_tests": []
    },
    {
        "id": 731,
        "expression": "^([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4}$",
        "raw_prompt": "IPv6 text representation of addresses without compression from RFC 1884. This regular expression doesn't allow IPv6 compression (&quot;::&quot;) or mixed IPv4 addresses.",
        "refined_prompt": "\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080:0:0:0:8:800:200C:417A\"\n- \"0:0:0:0:0:0:0:1\"\nNon-match examples:\n- \"128.0.0.1\"\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210:AA31\"",
        "matches": [
            "FEDC:BA98:7654:3210:FEDC:BA98:7654:3210",
            "1080:0:0:0:8:800:200C:417A",
            "0:0:0:0:0:0:0:1"
        ],
        "non_matches": [
            "128.0.0.1",
            "FEDC:BA98:7654:3210:FEDC:BA98:7654:3210:AA31",
            "::1"
        ],
        "stress_tests": []
    },
    {
        "id": 732,
        "expression": "^([GB])*(([1-9]\\d{8})|([1-9]\\d{11}))$",
        "raw_prompt": "Simple check of valid UK VAT Registration numbers. The standard format for UK VAT number must be 9 characters long or 12 characters if a branch trader. The GB prefix has been included as optional, but technically you should include it. The UK VAT format also includes Government Departments and Health Authorities, but I have excluded them for the moment.",
        "refined_prompt": "\nMatch examples:\n- \"123456789\"\n- \"GB123456789\"\n- \"GB123456789123\"\nNon-match examples:\n- \"dfddf\"\n- \"3443443\"",
        "matches": [
            "123456789",
            "GB123456789",
            "GB123456789123"
        ],
        "non_matches": [
            "dfddf",
            "3443443",
            "34 34 3344"
        ],
        "stress_tests": []
    },
    {
        "id": 734,
        "expression": "^[^0-9]*(?:(\\d)[^0-9]*){10}$",
        "raw_prompt": "Recently I've been forced to validate phone numbers in a variety of formats, with all sorts of whitespace, dashes, parenthesis, etc. I didn't want to hassel with matching all that junk, I just wanted the 10 numbers!\nSo I wrote this expression which captures 10 digits in a string if there are exactly 10 digits. Anything else is allowed so long as there are 10 numbers.\nIn .Net, You just loop through the Captures collection of Groups[1] of your Regex.Match object and concatenate the Capture.Value strings to get a simple, pure 10 digit phone number. ( myMatch.Groups[1].Captures )",
        "refined_prompt": "\nMatch examples:\n- \"1234567890\"\n- \"585-737-8899\"\n- \"(324)blah225-foo2587\"\nNon-match examples:\n- \"1234567\"\n- \"12345678901\"",
        "matches": [
            "1234567890",
            "585-737-8899",
            "(324)blah225-foo2587"
        ],
        "non_matches": [
            "1234567",
            "12345678901"
        ],
        "stress_tests": []
    },
    {
        "id": 735,
        "expression": "^[0-9]*$",
        "raw_prompt": "Matches only numbers, in any length. No characters or punctuation will be matched.",
        "refined_prompt": "\nMatch examples:\n- \"2\"\n- \"99\"\n- \"15800\"\nNon-match examples:\n- \"1,2\"\n- \"f9\"",
        "matches": [
            "2",
            "99",
            "15800"
        ],
        "non_matches": [
            "1,2",
            "f9",
            "a9j"
        ],
        "stress_tests": []
    },
    {
        "id": 736,
        "expression": "^(((((0[1-9])|(1\\d)|(2[0-8]))[/.-]((0[1-9])|(1[0-2])))|((31[/.-]((0[13578])|(1[02])))|((29|30)[/.-]((0[1,3-9])|(1[0-2])))))[/.-]((000[^0])&amp;([0-9][0-9][0-9][0-9]))|(29[/.-]02[/.-](([0-9][0-9](([02468][48])|([2468][048])|([13579][26])))|((([02468][48])|([2468][048])|([13579][26]))00))))$",
        "raw_prompt": "Checks 0001-9999\nAlong with leap years\nintermediate symbols can be / or . or -\nthis can be modified easily",
        "refined_prompt": "\nMatch examples:\n- \"29-02/0004\"\n- \"29/02/0004\"\n- \"29.02.9996\"\nNon-match examples:\n- \"29-2-0004\"\n- \"29/02/0005\"",
        "matches": [
            "29-02/0004",
            "29/02/0004",
            "29.02.9996"
        ],
        "non_matches": [
            "29-2-0004",
            "29/02/0005",
            "29.02.0000"
        ],
        "stress_tests": []
    },
    {
        "id": 738,
        "expression": "^\\d{5}(-\\d{4})?$",
        "raw_prompt": "Zip+4 Zipcode RegEx. You may ommit the +4 digits but you must also then ommit the hyphen/dash as well. In 1983, the Postal Service\u2122 began using an expanded ZIP Code\u2122 number called called the &quot;ZIP+4&#174;&quot; Code. The nine digits of a ZIP+4 code (e.g., 12345-6789) is broken down as follows: [123]Sectional Center or Large City. [45]Post Office\u2122 facility or Delivery Area. [-]Required &quot;dash&quot; or &quot;hyphen&quot;. [67]Sector or Several Blocks. [89]Segment or One Side of a Street. Also just FYI, ZIP codes in the northeast US frequently start with '0' or '00'. [00988-Carolina, PR] [03110-Bedford, NH]. Thanks, Ryan v-",
        "refined_prompt": "\nMatch examples:\n- \"98121\"\n- \"00988\"\n- \"12345-6789\"\nNon-match examples:\n- \"98121-\"\n- \"12345-678\"",
        "matches": [
            "98121",
            "00988",
            "12345-6789"
        ],
        "non_matches": [
            "98121-",
            "12345-678",
            "1234"
        ],
        "stress_tests": []
    },
    {
        "id": 739,
        "expression": "^[1-9][0-9]{0,2}$",
        "raw_prompt": "All positive non-zero integers between 1 and 999. You can adjust the upper range of this expression by changing the second number (ie 2) in the {0,2} part of the expression.",
        "refined_prompt": "\nMatch examples:\n- \"1\"\n- \"561\"\n- \"999\"\nNon-match examples:\n- \"-1\"\n- \"0\"",
        "matches": [
            "1",
            "561",
            "999"
        ],
        "non_matches": [
            "-1",
            "0",
            "1000"
        ],
        "stress_tests": []
    },
    {
        "id": 741,
        "expression": "^([A-Z]|[a-z]|[0-9])(([A-Z])*(([a-z])*([0-9])*(%)*(&)*(')*(\\+)*(-)*(@)*(_)*(\\.)*)|(\\ )[^ ])+$",
        "raw_prompt": "will match as long as the only chars exist in the string : A-Z,a-z,0-9,'Space' chr(32),%&amp;'+-@_.\nIt's useful for check vs Account Names where you might want to forbid entering other chars then what is in the pattern. also will not allow repeated space in the string",
        "refined_prompt": "\nMatch examples:\n- \"AccountName_123\"\n- \"Account@email.com\"\n- \"James & Dana Inc.\"\nNon-match examples:\n- \"!MYACCOUNT!\"\n- \"{Superman}\"",
        "matches": [
            "AccountName_123",
            "Account@email.com",
            "James & Dana Inc."
        ],
        "non_matches": [
            "!MYACCOUNT!",
            "{Superman}",
            "$ Money Man $"
        ],
        "stress_tests": []
    },
    {
        "id": 742,
        "expression": "(((0[1-9]|[12][0-9]|3[01])([.])(0[13578]|10|12)([.])([1-2][0,9][0-9][0-9]))|(([0][1-9]|[12][0-9]|30)([.])(0[469]|11)([.])([1-2][0,9][0-9][0-9]))|((0[1-9]|1[0-9]|2[0-8])([.])(02)([.])([1-2][0,9][0-9][0-9]))|((29)(\\.|-|\\/)(02)([.])([02468][048]00))|((29)([.])(02)([.])([13579][26]00))|((29)([.])(02)([.])([0-9][0-9][0][48]))|((29)([.])(02)([.])([0-9][0-9][2468][048]))|((29)([.])(02)([.])([0-9][0-9][13579][26])))",
        "raw_prompt": "Usefull for SQL update and insert sentence..",
        "refined_prompt": "\nMatch examples:\n- \"01.01.2004\"\n- \"30.12.2005\"\nNon-match examples:\n- \"01/01/2004\"\n- \"1.1.2004\"",
        "matches": [
            "01.01.2004",
            "30.12.2005"
        ],
        "non_matches": [
            "01/01/2004",
            "1.1.2004",
            "01-01-2004"
        ],
        "stress_tests": []
    },
    {
        "id": 743,
        "expression": "^[A-Za-z]{3,4}[ |\\-]{0,1}[0-9]{6}[ |\\-]{0,1}[0-9A-Za-z]{3}$",
        "raw_prompt": "This Regex matches Mexican RFC's (Registro Federal de Contribuyentes) with 3 or 4 letters in the first section. It accepts spaces and dashes between sections.",
        "refined_prompt": "\nMatch examples:\n- \"LOZG7502123T7\"\n- \"LOZG-750212-3T7\"\n- \"LOZ 750212 3T7\"\nNon-match examples:\n- \"LOZG750212\"",
        "matches": [
            "LOZG7502123T7",
            "LOZG-750212-3T7",
            "LOZ 750212 3T7"
        ],
        "non_matches": [
            "LOZG750212"
        ],
        "stress_tests": []
    },
    {
        "id": 744,
        "expression": "^([A-Z]|[a-z]|[0-9])([A-Z]|[a-z]|[0-9]|([A-Z]|[a-z]|[0-9]|(%|&|'|\\+|\\-|@|_|\\.|\\ )[^%&'\\+\\-@_\\.\\ ]|\\.$|([%&'\\+\\-@_\\.]\\ [^\\ ]|\\ [%&'\\+\\-@_\\.][^%&'\\+\\-@_\\.])))+$",
        "raw_prompt": "This works good for account names where u don't want your users to create ugly account names. 3 rules apllied in it:\n1. an account name must start with Letter or Number\n2. the only valid signs are : ^%&amp;'+-@. and (space (chr32))\n3. a sign can't be repeated by any sign execept space which can't be repeated as well.",
        "refined_prompt": "\nMatch examples:\n- \"AccountName_123\"\n- \"ABC & DEF Inc.\"\n- \"me@myemail.com\"\nNon-match examples:\n- \"-=superman=-\"\n- \"$$ Money Man $$\"",
        "matches": [
            "AccountName_123",
            "ABC & DEF Inc.",
            "me@myemail.com"
        ],
        "non_matches": [
            "-=superman=-",
            "$$ Money Man $$",
            "Lord -- Foo"
        ],
        "stress_tests": []
    },
    {
        "id": 746,
        "expression": "^((\\d(\\x20)\\d{2}(\\x20)\\d{2}(\\x20)\\d{2}(\\x20)\\d{3}(\\x20)\\d{3}((\\x20)\\d{2}|))|(\\d\\d{2}\\d{2}\\d{2}\\d{3}\\d{3}(\\d{2}|)))$",
        "raw_prompt": "It is an expression to valide a french num&#233;ro de s&#233;curit&#233; social (social security number translate is not sure) with or without the key.",
        "refined_prompt": "\nMatch examples:\n- \"181049520156962\"\n- \"1 81 04 95 201 569 62\"\n- \"1 81 04 95 201 569\"\nNon-match examples:\n- \"1 81049520156962\"\n- \"181049520156962fds\"",
        "matches": [
            "181049520156962",
            "1 81 04 95 201 569 62",
            "1 81 04 95 201 569"
        ],
        "non_matches": [
            "1 81049520156962",
            "181049520156962fds",
            "1810495201569ds"
        ],
        "stress_tests": []
    },
    {
        "id": 747,
        "expression": "^([-]?[0-9])$|^([-]?[1][0-2])$",
        "raw_prompt": "I made this to validate offsets to GMT",
        "refined_prompt": "\nMatch examples:\n- \"1\"\n- \"-10\"\n- \"10\"\nNon-match examples:\n- \"13\"\n- \"-25\"",
        "matches": [
            "1",
            "-10",
            "10"
        ],
        "non_matches": [
            "13",
            "-25",
            "111"
        ],
        "stress_tests": []
    },
    {
        "id": 748,
        "expression": "^([-]?[0-9]?(\\.[0-9]{0,2})?)$|^([-]?([1][0-1])(\\.[0-9]{0,2})?)$|^([-]?([1][0-3](\\.[0]{0,2})))$",
        "raw_prompt": "This was made for specifying GMT offsets with 2 decimal places. It will validate any number from -12 to 13 with 2 decimal places.",
        "refined_prompt": "\nMatch examples:\n- \"5\"\n- \"-11.99\"\n- \"12.00\"\nNon-match examples:\n- \"13\"\n- \"-11.999\"",
        "matches": [
            "5",
            "-11.99",
            "12.00"
        ],
        "non_matches": [
            "13",
            "-11.999",
            "12.01"
        ],
        "stress_tests": []
    },
    {
        "id": 749,
        "expression": "^([01][012]|0[1-9])/([0-2][0-9]|[3][0-1])/([0-9][0-9][0-9][0-9])$",
        "raw_prompt": "Regular expression that only allows expression in the format: MM/DD/YYYY",
        "refined_prompt": "\nMatch examples:\n- \"01/01/2004\"\nNon-match examples:\n- \"1/1/04\"\n- \"01/01/04\"",
        "matches": [
            "01/01/2004"
        ],
        "non_matches": [
            "1/1/04",
            "01/01/04",
            "03/32/2004"
        ],
        "stress_tests": []
    },
    {
        "id": 750,
        "expression": "&lt;!--((?!--&gt;).)*--&gt;",
        "raw_prompt": "Strip (X)HTML comments",
        "refined_prompt": "\nMatch examples:\n- \"&lt;!-- any comments --&gt;\"\nNon-match examples:\n- \"&lt;!- - 111 --&gt;\"",
        "matches": [
            "&lt;!-- any comments --&gt;"
        ],
        "non_matches": [
            "&lt;!- - 111 --&gt;"
        ],
        "stress_tests": []
    },
    {
        "id": 751,
        "expression": "\\/\\*((?!\\*\\/).)*\\*\\/",
        "raw_prompt": "Strip C style block comments",
        "refined_prompt": "\nMatch examples:\n- \"/* comments */\"\n- \"/*\\n*\\n*/\"\n- \"/***********/\"\nNon-match examples:\n- \"// comments\"",
        "matches": [
            "/* comments */",
            "/*\\n*\\n*/",
            "/***********/"
        ],
        "non_matches": [
            "// comments"
        ],
        "stress_tests": []
    },
    {
        "id": 753,
        "expression": "(^[1]$)|(^[1]+\\d*\\.+\\d*[1-5]$)",
        "raw_prompt": "Simple expression that accepts only values between 1 and 1.5",
        "refined_prompt": "\nMatch examples:\n- \"1\"\n- \"1.4\"\n- \"1.5\"\nNon-match examples:\n- \"2\"\n- \"1.ZZ\"",
        "matches": [
            "1",
            "1.4",
            "1.5"
        ],
        "non_matches": [
            "2",
            "1.ZZ",
            "1.6"
        ],
        "stress_tests": []
    },
    {
        "id": 754,
        "expression": "^(((0?[1-9]|[12]\\d|3[01])\\.(0[13578]|[13578]|1[02])\\.((1[6-9]|[2-9]\\d)\\d{2}))|((0?[1-9]|[12]\\d|30)\\.(0[13456789]|[13456789]|1[012])\\.((1[6-9]|[2-9]\\d)\\d{2}))|((0?[1-9]|1\\d|2[0-8])\\.0?2\\.((1[6-9]|[2-9]\\d)\\d{2}))|(29\\.0?2\\.((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))))$",
        "raw_prompt": "I did not found a Regex for german date, so I created my own. This RE validate dates in the dd.MM.yyyy format with leap years 100% integrated valid years from 1600 to 9999. As usual, many tests have been made. I think this one should be fine.",
        "refined_prompt": "\nMatch examples:\n- \"1.1.2004\"\n- \"01.01.2004\"\n- \"29.2.2004\"\nNon-match examples:\n- \"1/1/2004\"\n- \"1-1-2004\"",
        "matches": [
            "1.1.2004",
            "01.01.2004",
            "29.2.2004"
        ],
        "non_matches": [
            "1/1/2004",
            "1-1-2004"
        ],
        "stress_tests": []
    },
    {
        "id": 755,
        "expression": "((\\d|([a-f]|[A-F])){2}:){5}(\\d|([a-f]|[A-F])){2}",
        "raw_prompt": "Deisgned to verify a MAC address with hex values seperated by a colon.",
        "refined_prompt": "\nMatch examples:\n- \"00:00:39:F9:3C:59\"\n- \"00:90:83:6A:B3:B7\"\n- \"00:00:39:59:30:5C\"\nNon-match examples:\n- \"00:0H:39:59:30:5C\"\n- \"00:39:59:30:5C\"",
        "matches": [
            "00:00:39:F9:3C:59",
            "00:90:83:6A:B3:B7",
            "00:00:39:59:30:5C"
        ],
        "non_matches": [
            "00:0H:39:59:30:5C",
            "00:39:59:30:5C",
            "00:39:59:30:5C:BZ"
        ],
        "stress_tests": []
    },
    {
        "id": 756,
        "expression": "\\b-?[1-9](?:\\.\\d+)?[Ee][-+]?\\d+\\b",
        "raw_prompt": "Matches standard scientific notation using E character\nScientific notation involves writing a number as the product of two numbers. The first one, the digit value, is always more than one and less than 10. The other, the exponential term, is expressed as a power of 10.",
        "refined_prompt": "\nMatch examples:\n- \"3.7E-11\"\n- \"-2.384E-03\"\n- \"9.4608e15\"\nNon-match examples:\n- \"3.7 X 10-11\"\n- \"-23.84E-02\"",
        "matches": [
            "3.7E-11",
            "-2.384E-03",
            "9.4608e15"
        ],
        "non_matches": [
            "3.7 X 10-11",
            "-23.84E-02",
            "9.4608 x 1015"
        ],
        "stress_tests": []
    },
    {
        "id": 757,
        "expression": "^(?:(?:((?![0-9_])[a-zA-Z0-9_]+)\\.?)+)(?<!\\.)$",
        "raw_prompt": "Matches that an input string is a valid namespace definition. It also captures each word / section in the namespace in case they are needed.\nThe rules this was created by are: 1)A series of words separated by a periods 2)does not begin or end with a period, 3)contains only letters numbers and underscores, 4) none of the words begin with a number, and 5) contains no whitespace",
        "refined_prompt": "\nMatch examples:\n- \"Lang.Toolkit.Configuration\"\n- \"word_1.wo_rd2.word3.LastWord\"\n- \"word_1.wo_rd2.wor3d\"\nNon-match examples:\n- \"Lang.1App\"\n- \"word_1.2wo_rd\"",
        "matches": [
            "Lang.Toolkit.Configuration",
            "word_1.wo_rd2.word3.LastWord",
            "word_1.wo_rd2.wor3d"
        ],
        "non_matches": [
            "Lang.1App",
            "word_1.2wo_rd",
            "part1.2part"
        ],
        "stress_tests": []
    },
    {
        "id": 758,
        "expression": "&lt;!--[\\w\\W]*?--&gt;",
        "raw_prompt": "This expression will find sigle or multilined HTML comments.",
        "refined_prompt": "\nMatch examples:\n- \"&lt;!-- comment --&gt;\"\n- \"&lt;!-- &lt;some tag&gt; --&gt;\"\nNon-match examples:\n- \"&lt;!- - comment --&gt;\"\n- \"&lt;!-- ccccc\"",
        "matches": [
            "&lt;!-- comment --&gt;",
            "&lt;!-- &lt;some tag&gt; --&gt;"
        ],
        "non_matches": [
            "&lt;!- - comment --&gt;",
            "&lt;!-- ccccc"
        ],
        "stress_tests": []
    },
    {
        "id": 759,
        "expression": "([0]{1}[6]{1}[-\\s]*([1-9]{1}[\\s]*){8})|([0]{1}[1-9]{1}[0-9]{1}[0-9]{1}[-\\s]*([1-9]{1}[\\s]*){6})|([0]{1}[1-9]{1}[0-9]{1}[-\\s]*([1-9]{1}[\\s]*){7})",
        "raw_prompt": "Matches dutch telephone numbers WITHOUT country code prefix\nTests on mobile numbers, 3 digits prefix city-codes and 4 digit prefix city codes.\n* Disallows a 0 directly after a prefix\n* Allows space or a - between prefix and telephonenumber\n* Also allows space between telephone digits to compensate the nasty habit of making telphone numbers more readable",
        "refined_prompt": "\nMatch examples:\n- \"06 539 439 99\"\n- \"023-123 1233\"\n- \"023 121 12 12\"\nNon-match examples:\n- \"06-539-439-99\"\n- \"05-75 46 30 50\"",
        "matches": [
            "06 539 439 99",
            "023-123 1233",
            "023 121 12 12"
        ],
        "non_matches": [
            "06-539-439-99",
            "05-75 46 30 50"
        ],
        "stress_tests": []
    },
    {
        "id": 760,
        "expression": "^(?!0,?\\d)([0-9]{2}[0-9]{0,}(\\.[0-9]{2}))$",
        "raw_prompt": "Validates currency, must have two leading and two digits following a decimal point. Does not accept leading zero's.",
        "refined_prompt": "\nMatch examples:\n- \"10.00\"\n- \"32.50\"\nNon-match examples:\n- \"01.00\"\n- \"12\"",
        "matches": [
            "10.00",
            "32.50"
        ],
        "non_matches": [
            "01.00",
            "12",
            "12.0"
        ],
        "stress_tests": []
    },
    {
        "id": 766,
        "expression": "^\\(0[1-9]{1}\\)[0-9]{8}$",
        "raw_prompt": "This is used to validate an Australian telephone number with no other characters than the () being used. Validates area code being between 01 - 09.",
        "refined_prompt": "\nMatch examples:\n- \"(02)12341234\"\n- \"(03)12341234\"\n- \"(05)12341234\"\nNon-match examples:\n- \"00 1234 1234\"\n- \"00-1234-1234\"",
        "matches": [
            "(02)12341234",
            "(03)12341234",
            "(05)12341234"
        ],
        "non_matches": [
            "00 1234 1234",
            "00-1234-1234",
            "(00)12341234"
        ],
        "stress_tests": []
    },
    {
        "id": 767,
        "expression": "^[a-zA-Z]:(\\\\|(\\\\[^\\\\/\\s:*\"<>|]+)+)>",
        "raw_prompt": "This pattern matches the windows console (cmd) prompt (also know as command prompt)",
        "refined_prompt": "\nMatch examples:\n- \"x:\\dir>\"\n- \"x:\\dir\\another.dir>\"\n- \"x:\\>\"\nNon-match examples:\n- \"x:\\dir\\>\"\n- \"x:\\dir\"",
        "matches": [
            "x:\\dir>",
            "x:\\dir\\another.dir>",
            "x:\\>"
        ],
        "non_matches": [
            "x:\\dir\\>",
            "x:\\dir",
            "\\dir"
        ],
        "stress_tests": []
    },
    {
        "id": 768,
        "expression": "[URL=[a-zA-Z0-9.:/_\\-]+\\][a-zA-Z0-9._/ ]+\\[/URL\\]",
        "raw_prompt": "A simple match for BBCode type strings. I had to code my own BBCode scheme for a project that I had taken up and really this is my first RegEx so I thought that I would share. You could modify this to work with any BBCode type of string that has the [TAG=VALUE]Desc[/TAG] syntax.",
        "refined_prompt": "\nMatch examples:\n- \"[URL=http://www.luvs.org]Luvs.org[/URL]\"\nNon-match examples:\n- \"http://www.luvs.org\"",
        "matches": [
            "[URL=http://www.luvs.org]Luvs.org[/URL]"
        ],
        "non_matches": [
            "http://www.luvs.org"
        ],
        "stress_tests": []
    },
    {
        "id": 772,
        "expression": "^((\\s|[0])\\.(\\d{0,2}\\s{0,2}))?$|^(\\.(\\d\\s){0,2})?$|^(\\s{0,4}[1]{0,1}\\.[0]{0,2}\\s{0,4})?$|^(\\s{0,4}[1]{0,1}\\s{0,4})?$|^(\\s{0,4}[0]{0,4}[1]{0,1}\\s{0,4})?$|^([0]{0,4}\\s{0,4})?$|^(\\s{0,3}[0]{0,3}\\.{1}\\d{0,2}\\s{0,2})?$",
        "raw_prompt": "For a maximum of 4 characters All values between 0.00 and 1.00. Allows Spaces / zeros prefixed / suffixed. Allows entering just the integer part or the decimal part as well.\nAllows 1.0, 1.00, 1, 1., .9, .90, 0.90.",
        "refined_prompt": "\nMatch examples:\n- \".99\"\n- \"1.\"\n- \"0.99\"\nNon-match examples:\n- \"10\"\n- \"0100\"",
        "matches": [
            ".99",
            "1.",
            "0.99"
        ],
        "non_matches": [
            "10",
            "0100",
            "1.01"
        ],
        "stress_tests": []
    },
    {
        "id": 775,
        "expression": "^[a-zA-Z][a-zA-Z0-9_]+$",
        "raw_prompt": "Validate that the string contains only alphanumeric characters or an underscore. The first character cannot be anything else than alphabetic character.\nWe use that to make sure the provided string can be a variable/entity name.",
        "refined_prompt": "\nMatch examples:\n- \"MyVariable\"\n- \"intWhatever\"\n- \"Blah_Blah\"\nNon-match examples:\n- \"1stVariable\"\n- \"654\"",
        "matches": [
            "MyVariable",
            "intWhatever",
            "Blah_Blah"
        ],
        "non_matches": [
            "1stVariable",
            "654",
            "_asdasd_234"
        ],
        "stress_tests": []
    },
    {
        "id": 778,
        "expression": "((([7-9])(\\d{3})([-])(\\d{4}))|(([7-9])(\\d{7})))",
        "raw_prompt": "Express&#227;o para a Valida&#231;&#227;o de Telefones Celulares sem o DDD valida celulares com inicio igual a 7,8 e 9.",
        "refined_prompt": "\nMatch examples:\n- \"9999-9595\"\n- \"88888787\"\n- \"7777-6589\"\nNon-match examples:\n- \"44445555\"\n- \"2222-9658\"",
        "matches": [
            "9999-9595",
            "88888787",
            "7777-6589"
        ],
        "non_matches": [
            "44445555",
            "2222-9658",
            "22223658"
        ],
        "stress_tests": []
    },
    {
        "id": 782,
        "expression": "^([0-9a-fA-F])*$",
        "raw_prompt": "Expression validating a hex string of any length.",
        "refined_prompt": "\nMatch examples:\n- \"1E3\"\n- \"82E5AAA4\"\n- \"01ff\"\nNon-match examples:\n- \"1g3\"\n- \"4Z\"",
        "matches": [
            "1E3",
            "82E5AAA4",
            "01ff"
        ],
        "non_matches": [
            "1g3",
            "4Z",
            "01x"
        ],
        "stress_tests": []
    },
    {
        "id": 783,
        "expression": "(?=^.{6,255}$)((?=.*\\d)(?=.*[A-Z])(?=.*[a-z])|(?=.*\\d)(?=.*[^A-Za-z0-9])(?=.*[a-z])|(?=.*[^A-Za-z0-9])(?=.*[A-Z])(?=.*[a-z])|(?=.*\\d)(?=.*[A-Z])(?=.*[^A-Za-z0-9]))^.*",
        "raw_prompt": "THE Complex Password Filter Matching 3 of 4 Character catagories:\n1.) at least 1 upper case character\n2.) at least 1 lower case character\n3.) at least 1 numerical character\n4.) at least 1 special character\nIt also enforces a min and max length and works for .Net and script Regex implimentations.",
        "refined_prompt": "\nMatch examples:\n- \"Passw0rd\"\n- \"assW@rd\"\n- \"1B2a345@#$%\"\nNon-match examples:\n- \"123123123\"\n- \"Password\"",
        "matches": [
            "Passw0rd",
            "assW@rd",
            "1B2a345@#$%"
        ],
        "non_matches": [
            "123123123",
            "Password",
            "asdf&amp;"
        ],
        "stress_tests": []
    },
    {
        "id": 787,
        "expression": "^[9]9\\d{10}|^[5]\\d{10}",
        "raw_prompt": "This will make sure that if your number starts w. a 99 it will have 10 more digits after it and if it starts w. a 5 it will also have 10 digits after that. So if you have a number starting with 99 it must be 12 digits long if it starts with a 5 it must be 11.",
        "refined_prompt": "\nMatch examples:\n- \"991234567890\"\n- \"51234567890\"\nNon-match examples:\n- \"99123456789\"\n- \"91234567890\"",
        "matches": [
            "991234567890",
            "51234567890"
        ],
        "non_matches": [
            "99123456789",
            "91234567890"
        ],
        "stress_tests": []
    },
    {
        "id": 788,
        "expression": "\\b((([&quot;'/,&amp;%\\:\\(\\)\\$\\+\\-\\*\\w\\000-\\032])|(-*\\d+\\.\\d+[%]*))+[\\s]+)+\\b[\\w&quot;',%\\(\\)]+[.!?](['&quot;\\s]|$)",
        "raw_prompt": "Focused on scraping English sentences from HTML/Java (without having to parse).\nCorrectly matches the vast majority of English sentences. There are undoubtedly a number of cases which do not match, but I felt they were oblique enough to be omitted.\n(Surely, the fellow that commented on this script had some sentences not match, but the example he describes does correctly match, and I provide it as the fourth example.)\nCheers",
        "refined_prompt": "\nMatch examples:\n- \"This is an example.\"\n- \"&quot;Matching sentence.&quot;\"\n- \"A 9.7% increase over the last 10+ years.\"\nNon-match examples:\n- \"Class.Function\"",
        "matches": [
            "This is an example.",
            "&quot;Matching sentence.&quot;",
            "A 9.7% increase over the last 10+ years.",
            "The vehicle has a 5.2 liter, four-wheel drive engine."
        ],
        "non_matches": [
            "Class.Function"
        ],
        "stress_tests": []
    },
    {
        "id": 790,
        "expression": "^([\\w-]+\\.)*?[\\w-]+@[\\w-]+\\.([\\w-]+\\.)*?[\\w]+$",
        "raw_prompt": "The following pattern checks whether the input string is a valid email address in the form &quot;name@domain.com&quot;. Actually, it does not have to be a &quot;.com&quot; address. Any combination of letters following the last period are fine. Also, the email name can have a dash or be separated by one or more periods. The Domain name can also have multiple words separated by periods. Thus, it will validate bob@hotmail.com and bill.michaels@us.office.gov.",
        "refined_prompt": "\nMatch examples:\n- \"name@domain.com\"\n- \"name.name2@domain.com\"\n- \"name.name2@sub.domain.com\"\nNon-match examples:\n- \"name.@domain.com\"\n- \"name@.domain.com\"",
        "matches": [
            "name@domain.com",
            "name.name2@domain.com",
            "name.name2@sub.domain.com"
        ],
        "non_matches": [
            "name.@domain.com",
            "name@.domain.com",
            ".name@domain.com"
        ],
        "stress_tests": []
    },
    {
        "id": 793,
        "expression": "( xmlns:.*=[&quot;,'].*[&quot;,'])|( xmlns=[&quot;,'].*[&quot;,'])",
        "raw_prompt": "Matches xml namespace (xmlns) attribtutes. Works with single and double quotes, could be extended to support unquoted attributes.",
        "refined_prompt": "\nMatch examples:\n- \"&lt;el xmlns=&quot;http://SomeCorp/Namespace1&quot;&gt;\"\n- \"&lt;el xmlns='http://SomeCorp/Namespace1'&\"\nNon-match examples:\n- \"&lt;el xmlns=http://SomeCorp/Namespace1&gt;\"",
        "matches": [
            "&lt;el xmlns=&quot;http://SomeCorp/Namespace1&quot;&gt;",
            "&lt;el xmlns='http://SomeCorp/Namespace1'&"
        ],
        "non_matches": [
            "&lt;el xmlns=http://SomeCorp/Namespace1&gt;"
        ],
        "stress_tests": []
    },
    {
        "id": 795,
        "expression": "^[1-9]\\d*\\.?[0]*$",
        "raw_prompt": "natural numbers 1, 2, 3...\n(no zeros)",
        "refined_prompt": "\nMatch examples:\n- \"1\"\n- \"2\"\n- \"3\"\nNon-match examples:\n- \"0\"\n- \"1.2\"",
        "matches": [
            "1",
            "2",
            "3"
        ],
        "non_matches": [
            "0",
            "1.2",
            "01"
        ],
        "stress_tests": []
    },
    {
        "id": 796,
        "expression": "&lt;a\\s*href=(.*?)[\\s|&gt;]",
        "raw_prompt": "Retrieves all anchor links in a html document, useful for spidering. You will need to do a replace of &quot; and ' after the regular expression, as the expression gets all links. As far as I know there is no way, even with \\1 groupings, of getting a condition on whether the link contains a &quot;,' or nothing at all (&quot; and ' is easy enough, but what happens if the link starts with &quot;, and has a javascript function call with a string in it). If there is, it's probably quicker to do it like this and do a string replace anyway.",
        "refined_prompt": "\nMatch examples:\n- \"&lt;a href=&quot;http://www.blah.com&quot;&gt;\"\n- \"&lt;a href='../blah.html' target=&quot;_top&quot;&a\"\nNon-match examples:\n- \"&lt;a href = http://www.idiothtmlprogrammers.com &gt;\"",
        "matches": [
            "&lt;a href=&quot;http://www.blah.com&quot;&gt;",
            "&lt;a href='../blah.html' target=&quot;_top&quot;&a"
        ],
        "non_matches": [
            "&lt;a href = http://www.idiothtmlprogrammers.com &gt;"
        ],
        "stress_tests": []
    },
    {
        "id": 797,
        "expression": "^([a-zA-z\\s]{4,32})$",
        "raw_prompt": "This is the simplest RegEx for validating someone's name. The name can contain only alphabets(in either case) &amp; should be of minimum length 4 &amp; maximum length 32. Only white spaces are allowed apart from alphabets.",
        "refined_prompt": "\nMatch examples:\n- \"some body\"\n- \"hey there\"\n- \"hello\"\nNon-match examples:\n- \"hi\"\n- \"hey 27\"",
        "matches": [
            "some body",
            "hey there",
            "hello"
        ],
        "non_matches": [
            "hi",
            "hey 27",
            "hell?"
        ],
        "stress_tests": []
    },
    {
        "id": 798,
        "expression": "^([Vv]+(erdade(iro)?)?|[Ff]+(als[eo])?|[Tt]+(rue)?|0|[\\+\\-]?1)$",
        "raw_prompt": "This RegEx will match boolean values, either numeric or literal. It will accept MS Access &quot;-1&quot; values for &quot;true&quot;,\nand recognizes English and Brazilian Portuguese.",
        "refined_prompt": "\nMatch examples:\n- \"False\"\n- \"verdadeiro\"\n- \"0\"\nNon-match examples:\n- \"+0\"\n- \"1-1\"",
        "matches": [
            "False",
            "verdadeiro",
            "0"
        ],
        "non_matches": [
            "+0",
            "1-1"
        ],
        "stress_tests": []
    },
    {
        "id": 799,
        "expression": "^(^(([0-9A-F]{1,4}(((:[0-9A-F]{1,4}){5}::[0-9A-F]{1,4})|((:[0-9A-F]{1,4}){4}::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,1})|((:[0-9A-F]{1,4}){3}::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,2})|((:[0-9A-F]{1,4}){2}::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,3})|(:[0-9A-F]{1,4}::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,4})|(::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,5})|(:[0-9A-F]{1,4}){7}))$|^(::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,6})$)|^::$)|^((([0-9A-F]{1,4}(((:[0-9A-F]{1,4}){3}::([0-9A-F]{1,4}){1})|((:[0-9A-F]{1,4}){2}::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,1})|((:[0-9A-F]{1,4}){1}::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,2})|(::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,3})|((:[0-9A-F]{1,4}){0,5})))|([:]{2}[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,4})):|::)((25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{0,2})\\.){3}(25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{0,2})$$",
        "raw_prompt": "Matches all IPv6 text representations as defined within RFC 2373. Fairly verbose",
        "refined_prompt": "\nMatch examples:\n- \"::0:0:0:FFFF:129.144.52.38\"\n- \"FEDC:BA98::3210:FEDC:BA98:7654:3210\"\n- \"::13.1.68.3\"\nNon-match examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210:1234\"\n- \"3210:FEDC:BA98:7654:3210:1234\"",
        "matches": [
            "::0:0:0:FFFF:129.144.52.38",
            "FEDC:BA98::3210:FEDC:BA98:7654:3210",
            "::13.1.68.3"
        ],
        "non_matches": [
            "FEDC:BA98:7654:3210:FEDC:BA98:7654:3210:1234",
            "3210:FEDC:BA98:7654:3210:1234",
            ":FEDC:BA98:7654:3210:"
        ],
        "stress_tests": []
    },
    {
        "id": 801,
        "expression": "^([0-9]{3,4})$",
        "raw_prompt": "Allows you to check the length of a number (in this case either 3 or 4 digits).\nI found it useful when validating Credit Card Identification Codes (CVV2/CVC2/CID) which are either 3 or 4 numerical digits.",
        "refined_prompt": "\nMatch examples:\n- \"123\"\n- \"1234\"\nNon-match examples:\n- \"12\"\n- \"12345\"",
        "matches": [
            "123",
            "1234"
        ],
        "non_matches": [
            "12",
            "12345"
        ],
        "stress_tests": []
    },
    {
        "id": 803,
        "expression": "^([a-zA-z\\s]{2,})$",
        "raw_prompt": "This pattern matches is for validating Names, Cities, States, Countries etc that require only alphabet inputs with white spaces. It requires atleast 2 characters &amp; there's no limit on maximum number of characters.",
        "refined_prompt": "\nMatch examples:\n- \"Amit Gupta\"\n- \"Some Body\"\nNon-match examples:\n- \"A\"\n- \"Someplace23\"",
        "matches": [
            "Amit Gupta",
            "Some Body"
        ],
        "non_matches": [
            "A",
            "Someplace23",
            "New-Jersey"
        ],
        "stress_tests": []
    },
    {
        "id": 804,
        "expression": "^\\+?972(\\-)?0?[23489]{1}(\\-)?[^0\\D]{1}\\d{6}$",
        "raw_prompt": "Matches an israely phone number with country code. With or without the plus sign. Also allows two or one digit in city code. Checks for a valid city code (02,03,04,08,09)",
        "refined_prompt": "\nMatch examples:\n- \"+972-4-8253055\"\n- \"972-4-8615466\"\n- \"972-04-8564521\"\nNon-match examples:\n- \"04-5487665\"\n- \"05-455665545\"",
        "matches": [
            "+972-4-8253055",
            "972-4-8615466",
            "972-04-8564521"
        ],
        "non_matches": [
            "04-5487665",
            "05-455665545",
            "456884624"
        ],
        "stress_tests": []
    },
    {
        "id": 805,
        "expression": "^((0?[1-9]|1[012])(:[0-5]\\d){1,2}(\\ [AaPp][Mm]))$",
        "raw_prompt": "This is a simple expression used to match a normal 12 hour clock, requires AM/PM in any or mixed case and requires a space before the AM or PM and minutes are required.",
        "refined_prompt": "\nMatch examples:\n- \"1:45 am\"\n- \"12:01 aM\"\n- \"01:23 pm\"\nNon-match examples:\n- \"13:34 am\"\n- \"1:60 am\"",
        "matches": [
            "1:45 am",
            "12:01 aM",
            "01:23 pm"
        ],
        "non_matches": [
            "13:34 am",
            "1:60 am",
            "13:45"
        ],
        "stress_tests": []
    },
    {
        "id": 808,
        "expression": "((\\s*([^,{]+)\\s*,?\\s*)*?){((\\s*([^:]+)\\s*:\\s*([^;]+?)\\s*;\\s*)*?)}",
        "raw_prompt": "will break out a valid CSS stylesheet into it's components. Groups on each style, all selectors, each selector within a comma delimited list of selectors, all properties, each property set, each property and each value. In other words, it breaks it all down for you :)\nThe only two problems I'm having with it:\nA) it is ignorant of comment blocks. so if you have styles within a /* */ block, it'll pick those up.\nB) the first style following a comment block is not parsed correctly (it incorrectly includes the comment as a selector\nbest thing to do would be to use another regexp to remove all comments before processing with this one",
        "refined_prompt": "\nMatch examples:\n- \"div#main { position:relative; width:809px; margin-left:auto; margin-right:auto; padding:0; }\"\nNon-match examples:\n- \"-----\"",
        "matches": [
            "div#main { position:relative; width:809px; margin-left:auto; margin-right:auto; padding:0; }"
        ],
        "non_matches": [
            "-----"
        ],
        "stress_tests": []
    },
    {
        "id": 814,
        "expression": "^\\d{5}((-|\\s)?\\d{4})?$",
        "raw_prompt": "Single field zip code validator, useful for Web Forms. Allows user to enter 5-digit or 5-digit plus 4 zip code, with hyphen or space or NO space between last 4 digits.",
        "refined_prompt": "\nMatch examples:\n- \"92078-4705\"\n- \"920784705\"\n- \"92078 4705\"\nNon-match examples:\n- \"9027x\"\n- \"902\"",
        "matches": [
            "92078-4705",
            "920784705",
            "92078 4705"
        ],
        "non_matches": [
            "9027x",
            "902",
            "92078.4705"
        ],
        "stress_tests": []
    },
    {
        "id": 815,
        "expression": "^\\d{5}((\\-|\\s)?\\d{4})?$",
        "raw_prompt": "Single field zip code validator useful for web forms, where user may enter 5 digit or 9 digit zip code, and may use hyphen, space, or no space between the first 5 digits and last 4 digits.",
        "refined_prompt": "\nMatch examples:\n- \"92078\"\n- \"92078-4705\"\n- \"92078 4705\"\nNon-match examples:\n- \"920781\"\n- \"920a87\"",
        "matches": [
            "92078",
            "92078-4705",
            "92078 4705"
        ],
        "non_matches": [
            "920781",
            "920a87",
            "920"
        ],
        "stress_tests": []
    },
    {
        "id": 816,
        "expression": "^(\\([2-9]|[2-9])(\\d{2}|\\d{2}\\))(-|.|\\s)?\\d{3}(-|.|\\s)?\\d{4}$",
        "raw_prompt": "Telephone validator allowing user to enter 10 digit telephone number with segments of number separated by hyphens, periods or spaces. Also braces allowed around area code.",
        "refined_prompt": "\nMatch examples:\n- \"213-123-1234\"\n- \"2131231234\"\n- \"(213) 123-1234\"\nNon-match examples:\n- \"123-123-1234\"",
        "matches": [
            "213-123-1234",
            "2131231234",
            "(213) 123-1234"
        ],
        "non_matches": [
            "123-123-1234"
        ],
        "stress_tests": []
    },
    {
        "id": 817,
        "expression": "[1-2][0|9][0-9]{2}[0-1][0-9][0-3][0-9][-][0-9]{4}",
        "raw_prompt": "Swedish person number. Don't work on persons older then 100 years, but they are so few that it shouldn't be a problem. Easy to fix, but I choose not to accept oldies...",
        "refined_prompt": "\nMatch examples:\n- \"19740609-7845\"\n- \"19811116-7845\"\n- \"20010913-7598\"\nNon-match examples:\n- \"21003612-9999\"\n- \"18790505-4545\"",
        "matches": [
            "19740609-7845",
            "19811116-7845",
            "20010913-7598"
        ],
        "non_matches": [
            "21003612-9999",
            "18790505-4545",
            "19740641-5559"
        ],
        "stress_tests": []
    },
    {
        "id": 822,
        "expression": "^([0]?[1-9]|[1][0-2])[./-]([0]?[1-9]|[1|2][0-9]|[3][0|1])[./-]([0-9]{4}|[0-9]{2})$",
        "raw_prompt": "Validate american date formats: mm/dd/yyyy or m/d/yy or m.d.yyyy with separators: . - /\nValid dates only! m (1-12)/ d (1-31)/ y (0..)\n(rizzipereira.com.br)\nFor Brazilian date format: http://www.regexlib.com/REDetails.aspx?regexp_id=250",
        "refined_prompt": "\nMatch examples:\n- \"10.03.1979\"\n- \"12/30/2004\"\n- \"01/01/2004\"\nNon-match examples:\n- \"09--02--2004\"\n- \"15-15-2004\"",
        "matches": [
            "10.03.1979",
            "12/30/2004",
            "01/01/2004"
        ],
        "non_matches": [
            "09--02--2004",
            "15-15-2004",
            "13/12/2004"
        ],
        "stress_tests": []
    },
    {
        "id": 823,
        "expression": "^[0-9]{4}-(((0[13578]|(10|12))-(0[1-9]|[1-2][0-9]|3[0-1]))|(02-(0[1-9]|[1-2][0-9]))|((0[469]|11)-(0[1-9]|[1-2][0-9]|30)))$",
        "raw_prompt": "Matches the date format &quot;YYYY-mm-dd&quot; and also validates month and number of days in a month. All leap year dates &quot;YYYY-02-29&quot; passes trough. Could easily be changed to another format.",
        "refined_prompt": "\nMatch examples:\n- \"2004-04-30\"\n- \"2004-02-29\"\nNon-match examples:\n- \"2004-04-31\"\n- \"2004-02-30\"",
        "matches": [
            "2004-04-30",
            "2004-02-29"
        ],
        "non_matches": [
            "2004-04-31",
            "2004-02-30"
        ],
        "stress_tests": []
    },
    {
        "id": 825,
        "expression": "([0]{1}[6]{1}[-\\s]*[1-9]{1}[\\s]*([0-9]{1}[\\s]*){7})|([0]{1}[1-9]{1}[0-9]{1}[0-9]{1}[-\\s]*[1-9]{1}[\\s]*([0-9]{1}[\\s]*){5})|([0]{1}[1-9]{1}[0-9]{1}[-\\s]*[1-9]{1}[\\s]*([0-9]{1}[\\s]*){6})",
        "raw_prompt": "Meets dutch phone number requirements.. One posted here before didn't allow the 0 after the first digit of the call ID (so the second number or later after the prefix), which should be allowed. I modified that one to meet full requirements now..\nEnjoy!!",
        "refined_prompt": "\nMatch examples:\n- \"06 12345678\"\n- \"010-1234560\"\n- \"0111-101234\"\nNon-match examples:\n- \"05-43021212\"\n- \"123-4567890\"",
        "matches": [
            "06 12345678",
            "010-1234560",
            "0111-101234"
        ],
        "non_matches": [
            "05-43021212",
            "123-4567890",
            "1234567890"
        ],
        "stress_tests": []
    },
    {
        "id": 827,
        "expression": "^((?:2[0-5]{2}|1\\d{2}|[1-9]\\d|[1-9])\\.(?:(?:2[0-5]{2}|1\\d{2}|[1-9]\\d|\\d)\\.){2}(?:2[0-5]{2}|1\\d{2}|[1-9]\\d|\\d)):(\\d|[1-9]\\d|[1-9]\\d{2,3}|[1-5]\\d{4}|6[0-4]\\d{3}|654\\d{2}|655[0-2]\\d|6553[0-5])$",
        "raw_prompt": "IPv4 ip:port checker, I hope it will help you. $1 - IP, $2 - port. More to come, maybe :)",
        "refined_prompt": "\nMatch examples:\n- \"127.0.0.1:80\"\n- \"255.255.255.0:21\"\n- \"1.0.0.0:1\"\nNon-match examples:\n- \"0.0.0.0:1\"\n- \"256.1.1.1:20\"",
        "matches": [
            "127.0.0.1:80",
            "255.255.255.0:21",
            "1.0.0.0:1"
        ],
        "non_matches": [
            "0.0.0.0:1",
            "256.1.1.1:20",
            "127.0.0.1:65536"
        ],
        "stress_tests": []
    },
    {
        "id": 831,
        "expression": "^(9,)*([1-9]\\d{2}-?)*[1-9]\\d{2}-?\\d{4}$",
        "raw_prompt": "Validates US or Canadian phone numbers with the use of &quot;-&quot; or numbers stuck together. No parantheses allowed as well as spaces. Area code is optional. The &quot;9,&quot; is optional as well, which on some phone systems is needed to dial out.",
        "refined_prompt": "\nMatch examples:\n- \"9,5143393044\"\n- \"9,514-339-3044\"\n- \"339-3044\"\nNon-match examples:\n- \"9,339 3044\"\n- \"514 440 2009\"",
        "matches": [
            "9,5143393044",
            "9,514-339-3044",
            "339-3044"
        ],
        "non_matches": [
            "9,339 3044",
            "514 440 2009",
            "(514) 440-2009"
        ],
        "stress_tests": []
    },
    {
        "id": 833,
        "expression": "^\\-?\\(?([0-9]{0,3}(\\,?[0-9]{3})*(\\.?[0-9]*))\\)?$",
        "raw_prompt": "Match a positive or negative decimal value with any precision and scale. Allows for left-padded zeroes, commas as group separator, negative sign (-) or parenthesis to indicate negative number.",
        "refined_prompt": "\nMatch examples:\n- \"0.123\"\n- \"(1234.123)\"\n- \"-01,200\"\nNon-match examples:\n- \"2.3.123\"\n- \"1,23.45\"",
        "matches": [
            "0.123",
            "(1234.123)",
            "-01,200"
        ],
        "non_matches": [
            "2.3.123",
            "1,23.45"
        ],
        "stress_tests": []
    },
    {
        "id": 834,
        "expression": "^[-+]?[0-9]\\d{0,2}(\\.\\d{1,2})?%?$",
        "raw_prompt": "Required and regular expression validator. For supporting\n-999.99 to +999.99 . Positive and Negative integer/ decimal validations. Percentage sign is also supported. Will not allow empty strings. Can increase/decrease the range as you need.",
        "refined_prompt": "\nMatch examples:\n- \"12.3\"\n- \"123\"\n- \"-123.45\"\nNon-match examples:\n- \"-\"\n- \"10.1234\"",
        "matches": [
            "12.3",
            "123",
            "-123.45"
        ],
        "non_matches": [
            "-",
            "10.1234",
            "-1234"
        ],
        "stress_tests": []
    },
    {
        "id": 836,
        "expression": "^([0-9]{5})([\\-]{1}[0-9]{4})?$",
        "raw_prompt": "Validates against a U.S. postal code in either a 5 digit format or a 5 dash 4 format.",
        "refined_prompt": "\nMatch examples:\n- \"18017\"\n- \"18017-1401\"\nNon-match examples:\n- \"1801A\"\n- \"18017-\"",
        "matches": [
            "18017",
            "18017-1401"
        ],
        "non_matches": [
            "1801A",
            "18017-",
            "18017-152A"
        ],
        "stress_tests": []
    },
    {
        "id": 837,
        "expression": "^([4]{1})([0-9]{12,15})$",
        "raw_prompt": "Validate against a visa card number. All visa cards start with a 4 and are followed by 12 to 15 more numbers.",
        "refined_prompt": "\nMatch examples:\n- \"4125632152365\"\n- \"418563256985214\"\n- \"4125632569856321\"\nNon-match examples:\n- \"3125652365214\"\n- \"41256321256\"",
        "matches": [
            "4125632152365",
            "418563256985214",
            "4125632569856321"
        ],
        "non_matches": [
            "3125652365214",
            "41256321256",
            "42563985632156322"
        ],
        "stress_tests": []
    },
    {
        "id": 838,
        "expression": "^([51|52|53|54|55]{2})([0-9]{14})$",
        "raw_prompt": "Validate against any mastercard number. All MC's start with a number between 51 and 55 and are followed by 14 other numbers.",
        "refined_prompt": "\nMatch examples:\n- \"5125632154125412\"\n- \"5225632154125412\"\n- \"5525632154125412\"\nNon-match examples:\n- \"5625632154125412\"\n- \"4825632154125412\"",
        "matches": [
            "5125632154125412",
            "5225632154125412",
            "5525632154125412"
        ],
        "non_matches": [
            "5625632154125412",
            "4825632154125412",
            "6011632154125412"
        ],
        "stress_tests": []
    },
    {
        "id": 839,
        "expression": "^([34|37]{2})([0-9]{13})$",
        "raw_prompt": "Validate against any american express number. All american express numbers start with either a 34 or 37, followed by 13 other numbers.",
        "refined_prompt": "\nMatch examples:\n- \"341256321524212\"\n- \"371524254523125\"\nNon-match examples:\n- \"425152365212542\"\n- \"34256321523621\"",
        "matches": [
            "341256321524212",
            "371524254523125"
        ],
        "non_matches": [
            "425152365212542",
            "34256321523621",
            "3712563212523651"
        ],
        "stress_tests": []
    },
    {
        "id": 840,
        "expression": "^([6011]{4})([0-9]{12})$",
        "raw_prompt": "Validate against any discover card number. All DC's start with 6011 and are followed by 12 other numbers.",
        "refined_prompt": "\nMatch examples:\n- \"6011212541254121\"\n- \"6011523654125685\"\nNon-match examples:\n- \"5021152365212541\"\n- \"601126523652321\"",
        "matches": [
            "6011212541254121",
            "6011523654125685"
        ],
        "non_matches": [
            "5021152365212541",
            "601126523652321",
            "60112563212563215"
        ],
        "stress_tests": []
    },
    {
        "id": 841,
        "expression": "^([30|36|38]{2})([0-9]{12})$",
        "raw_prompt": "Validate against any diner's club card. All diner club cards start with 30,36, or 38, followed by 12 other numbers.",
        "refined_prompt": "\nMatch examples:\n- \"30125212365212\"\n- \"36125212365212\"\n- \"38125212365212\"\nNon-match examples:\n- \"301252123652121\"\n- \"40256631125452\"",
        "matches": [
            "30125212365212",
            "36125212365212",
            "38125212365212"
        ],
        "non_matches": [
            "301252123652121",
            "40256631125452",
            "361251254125212"
        ],
        "stress_tests": []
    },
    {
        "id": 842,
        "expression": "([^\\.\\?\\!]*)[\\.\\?\\!]",
        "raw_prompt": "Finds sentences (assuming they end with a full stop, question mark or exclamation mark).",
        "refined_prompt": "\nMatch examples:\n- \"This is a series of sentences.\"\n- \"They end predictably!\"\n- \"Where would we be without punctuation?\"\nNon-match examples:\n- \"This sentence just trails off\"",
        "matches": [
            "This is a series of sentences.",
            "They end predictably!",
            "Where would we be without punctuation?"
        ],
        "non_matches": [
            "This sentence just trails off"
        ],
        "stress_tests": []
    },
    {
        "id": 844,
        "expression": "^(([A-Z]{1,2}[0-9]{1,2})|([A-Z]{1,2}[0-9][A-Z]))\\s?([0-9][A-Z]{2})$",
        "raw_prompt": "Matches UK postcodes of the below formats. The space is optional.\nAN NAA\nAAN NAA\nANN NAA\nANA NAA\nAANA NAA\nAANN NAA",
        "refined_prompt": "\nMatch examples:\n- \"A11AA\"\n- \"AA1A 1AA\"\n- \"AA11 1AA\"\nNon-match examples:\n- \"AAA 1AA\"\n- \"AA11A 1AA\"",
        "matches": [
            "A11AA",
            "AA1A 1AA",
            "AA11 1AA"
        ],
        "non_matches": [
            "AAA 1AA",
            "AA11A 1AA",
            "AAA1AA"
        ],
        "stress_tests": []
    },
    {
        "id": 848,
        "expression": "(\\S+)\\x20{2,}(?=\\S+)",
        "raw_prompt": "Trim Inside. This pattern can be used with a replace value of &quot;$1 &quot; to remove multiple consecutive spaces between characters and replace with a single space. Trailing and leading spaces are NOT altered.",
        "refined_prompt": "\nMatch examples:\n- \"Too  Many spaces.\"\nNon-match examples:\n- \"No extra spaces\"\n- \"No Extra spaces Inside\"",
        "matches": [
            "Too  Many spaces."
        ],
        "non_matches": [
            "No extra spaces",
            "No Extra spaces Inside"
        ],
        "stress_tests": []
    },
    {
        "id": 849,
        "expression": "^(?:[ -~]{10,25}(?:$|(?:[\\w!?.])\\s))",
        "raw_prompt": "Word Break. This regex can be used to break a long line of text on a full word. The qualifiers specify the minimum and maximum number of character allow before the break and can be changed according to your need. Blogge about this here http://regexadvice.com/blogs/mash/archive/2005/02/09/324.aspx",
        "refined_prompt": "\nMatch examples:\n- \"This is just a simple sample\"\nNon-match examples:\n- \"A sample\"",
        "matches": [
            "This is just a simple sample"
        ],
        "non_matches": [
            "A sample"
        ],
        "stress_tests": []
    },
    {
        "id": 851,
        "expression": "^[0-9]{4}((0[1-9])|(1[0-2]))$",
        "raw_prompt": "Match a string in CCYYMM/YYYYMM format.",
        "refined_prompt": "\nMatch examples:\n- \"200401\"\n- \"000001\"\n- \"200412\"\nNon-match examples:\n- \"aaa\"\n- \"20040123\"",
        "matches": [
            "200401",
            "000001",
            "200412"
        ],
        "non_matches": [
            "aaa",
            "20040123",
            "200414"
        ],
        "stress_tests": []
    },
    {
        "id": 852,
        "expression": "(^[a-zA-Z][a-zA-Z0-9_]*)|(^[_][a-zA-Z0-9_]+)",
        "raw_prompt": "This pattern can be used for validating a string as a valid element name (e.g. variable or class name) in Microsoft .NET. See also http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vbcn7/html/vbconelementnames.asp",
        "refined_prompt": "\nMatch examples:\n- \"var\"\n- \"_withunder_score99\"\n- \"TeSt\"\nNon-match examples:\n- \"_\"\n- \"123abc\"",
        "matches": [
            "var",
            "_withunder_score99",
            "TeSt"
        ],
        "non_matches": [
            "_",
            "123abc",
            "9"
        ],
        "stress_tests": []
    },
    {
        "id": 853,
        "expression": "^[^\\\\\\./:\\*\\?\\\"<>\\|]{1}[^\\\\/:\\*\\?\\\"<>\\|]{0,254}$",
        "raw_prompt": "Validates a long filename using Windows' rules. Requires one valid filename character other than &quot;.&quot; for the first character and then any number of valid filename characters up to a total length of 255 characters. Unresolved is how to prevent the last character from being a &quot;.&quot; while still meeting all the features that this regex does now.",
        "refined_prompt": "\nMatch examples:\n- \"abcd.jpg\"\n- \"a b239.abcd ef12983 298\"\n- \"a....23498\"\nNon-match examples:\n- \".abcde.jpg\"\n- \"abcde?.jpg\"",
        "matches": [
            "abcd.jpg",
            "a b239.abcd ef12983 298",
            "a....23498"
        ],
        "non_matches": [
            ".abcde.jpg",
            "abcde?.jpg",
            "c:\\abcde.jpg"
        ],
        "stress_tests": []
    },
    {
        "id": 858,
        "expression": "^\\\\([^\\\\]+\\\\)*[^\\/:*?&quot;&lt;&gt;|]?$",
        "raw_prompt": "Orginally on this site search for Path, go to next page\nyou see a reg expression for ^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)*[^\\/:*?&quot;&lt;&gt;|]+\\.htm(l)?$\nwhich I modified with this one to disallow drive specification.",
        "refined_prompt": "\nMatch examples:\n- \"\\temp\\\"\n- \"\\temp\\content\\\"\n- \"\\Program Files\\\"\nNon-match examples:\n- \"a:\\Temp\\\"\n- \"\\Temp\\Content\"",
        "matches": [
            "\\temp\\",
            "\\temp\\content\\",
            "\\Program Files\\"
        ],
        "non_matches": [
            "a:\\Temp\\",
            "\\Temp\\Content",
            "c:\\Program Files\\"
        ],
        "stress_tests": []
    },
    {
        "id": 859,
        "expression": "^-?[0-9]{0,2}(\\.[0-9]{1,2})?$|^-?(100)(\\.[0]{1,2})?$",
        "raw_prompt": "Matches a negative or positive percentage between 0 and 100 (inclusive). Accepts up to 2 decimal places.",
        "refined_prompt": "\nMatch examples:\n- \"12.34\"\n- \"100.00\"\n- \"-2.1\"\nNon-match examples:\n- \"101.1\"\n- \"10.123\"",
        "matches": [
            "12.34",
            "100.00",
            "-2.1"
        ],
        "non_matches": [
            "101.1",
            "10.123",
            "100.10"
        ],
        "stress_tests": []
    },
    {
        "id": 860,
        "expression": "href=[\\&quot;\\']?((?:[^&gt;]|[^\\s]|[^&quot;]|[^'])+)[\\&quot;\\']?",
        "raw_prompt": "This will match just about everything after href=\nIts good if you just need a list of all the href= values",
        "refined_prompt": "\nMatch examples:\n- \"href=&quot;http://www.google.com/tsunami_relief.html&quot;\"\n- \"href=/preferences?hl=en\"\n- \"href=&quot;ht\"\nNon-match examples:\n- \"src=blah blah\"",
        "matches": [
            "href=&quot;http://www.google.com/tsunami_relief.html&quot;",
            "href=/preferences?hl=en",
            "href=&quot;ht"
        ],
        "non_matches": [
            "src=blah blah"
        ],
        "stress_tests": []
    },
    {
        "id": 861,
        "expression": "\\b(?:a(?:[nst]|re|nd)?|b[ey]|f(?:or|rom)|i[nst]?|o[fnr]|t(?:o|hat|he|his)|w(?:as|h(?:at|en|ere|ich|o)|i(?:th|ll)))\\b",
        "raw_prompt": "Removes &quot;stop&quot; or &quot;delete&quot; words that google removes from search strings. Ordinarily have no search significance. I used this to remove the words in my own web search application. Take out the ?: for grouping.\nI've tested this a bit, yet this is my 1st regex that I've ever written. It's working fine for me.",
        "refined_prompt": "\nMatch examples:\n- \"by\"\n- \"when\"\n- \"or\"\nNon-match examples:\n- \"bye\"\n- \"craptastic\"",
        "matches": [
            "by",
            "when",
            "or"
        ],
        "non_matches": [
            "bye",
            "craptastic",
            "nor"
        ],
        "stress_tests": []
    },
    {
        "id": 862,
        "expression": "^([0-1])*$",
        "raw_prompt": "Expression validating a Binary string of any length",
        "refined_prompt": "\nMatch examples:\n- \"10101000\"\n- \"01010000\"\n- \"100000001\"\nNon-match examples:\n- \"01000200\"\n- \"00021000\"",
        "matches": [
            "10101000",
            "01010000",
            "100000001"
        ],
        "non_matches": [
            "01000200",
            "00021000",
            "e10000000"
        ],
        "stress_tests": []
    },
    {
        "id": 863,
        "expression": "^([0-7])*$",
        "raw_prompt": "Expression validating a octal string of any length.",
        "refined_prompt": "\nMatch examples:\n- \"1357\"\n- \"445005\"\n- \"101\"\nNon-match examples:\n- \"900508\"\n- \"7FFF\"",
        "matches": [
            "1357",
            "445005",
            "101"
        ],
        "non_matches": [
            "900508",
            "7FFF",
            "599D"
        ],
        "stress_tests": []
    },
    {
        "id": 865,
        "expression": "^([0-9a-fA-F]){8}$",
        "raw_prompt": "Hex number/string validation method for the Electronic Serial Number(ESN) used in Cellular Phone products.",
        "refined_prompt": "\nMatch examples:\n- \"8ECCA04F\"\n- \"82E5AAA4\"\n- \"82e5aaa4\"\nNon-match examples:\n- \"8ECCAOF\"\n- \"82E5AA4\"",
        "matches": [
            "8ECCA04F",
            "82E5AAA4",
            "82e5aaa4"
        ],
        "non_matches": [
            "8ECCAOF",
            "82E5AA4",
            "82e5aaa45"
        ],
        "stress_tests": []
    },
    {
        "id": 867,
        "expression": "^(?:[a-zA-Z0-9_'^&amp;/+-])+(?:\\.(?:[a-zA-Z0-9_'^&amp;/+-])+)*@(?:(?:\\[?(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))\\.){3}(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\]?)|(?:[a-zA-Z0-9-]+\\.)+(?:[a-zA-Z]){2,}\\.?)$",
        "raw_prompt": "this will validate most legal email addresses, even allows for some discouraged but perfectly legal characters in local part; allows IP domains with optional []; keeps final tld at a minmum of 2 chars; non capturing groups for efficiency",
        "refined_prompt": "\nMatch examples:\n- \"you.me.hello@somewhere.else.cc\"\n- \"joe_smith@here.com.\"\n- \"me@[24.111.232.1]\"\nNon-match examples:\n- \".me.you@here.com\"\n- \".murat@62.59.114.103.nl\"",
        "matches": [
            "you.me.hello@somewhere.else.cc",
            "joe_smith@here.com.",
            "me@[24.111.232.1]"
        ],
        "non_matches": [
            ".me.you@here.com",
            ".murat@62.59.114.103.nl",
            "test_case@here*555%there.com"
        ],
        "stress_tests": []
    },
    {
        "id": 869,
        "expression": "(02\\d\\s?\\d{4}\\s?\\d{4})|(01\\d{2}\\s?\\d{3}\\s?\\d{4})|(01\\d{3}\\s?\\d{5,6})|(01\\d{4}\\s?\\d{4,5})",
        "raw_prompt": "Validates UK domestic landline phone numbers.\nValid formats are:\n029 99999999 or 029 9999 9999; 0199 9999999 or 0199 999 9999; 01999 99999; 01999 999999; 019999 9999; 019999 99999. These formats are taken from the official guidelines from Ofcom, the organisation responsible for UK telecoms issues. Brackets are not valid and STD code must be entered.",
        "refined_prompt": "\nMatch examples:\n- \"020 1234 5678\"\n- \"0123 4567890\"\n- \"01234 456789\"\nNon-match examples:\n- \"02476 123456\"\n- \"0845 123456\"",
        "matches": [
            "020 1234 5678",
            "0123 4567890",
            "01234 456789"
        ],
        "non_matches": [
            "02476 123456",
            "0845 123456",
            "07712 345678"
        ],
        "stress_tests": []
    },
    {
        "id": 870,
        "expression": "(077|078|079)\\s?\\d{2}\\s?\\d{6}",
        "raw_prompt": "Validates UK mobile phone numbers. Valid formats are `077', `078' or `079' followed by another 8 digits, with an optional space after the dialling code and/or between the 4th and 5th characters of the remainder of the number. These formats are taken from the official guidelines from Ofcom, the organisation responsible for UK telecoms issues. Brackets are not valid and STD code must be entered.",
        "refined_prompt": "\nMatch examples:\n- \"07713 345678\"\n- \"078 12345678\"\n- \"079 12345678\"\nNon-match examples:\n- \"02344 123456\"\n- \"0121 292929\"",
        "matches": [
            "07713 345678",
            "078 12345678",
            "079 12345678"
        ],
        "non_matches": [
            "02344 123456",
            "0121 292929",
            "012345 6789"
        ],
        "stress_tests": []
    },
    {
        "id": 875,
        "expression": "^[\\.\\w&#230;&#248;&#229;-]+@([a-z&#230;&#248;&#229;0-9]+([\\.-]{0,1}[a-z&#230;&#248;&#229;0-9]+|[a-z&#230;&#248;&#229;0-9]?))+\\.[a-z]{2,6}$",
        "raw_prompt": "Well it pretty much accepts all kinds of users, about the domain i didn't write it special for any TLD so there's no length defined, ohh and it accepts some IDN stuff",
        "refined_prompt": "\nMatch examples:\n- \"afdaas-ddas----asddas____...@asd.asd.asd.asd.asd.com\"\n- \"a@a.aa\"\n- \".@microsoft.sun.apple.com\"\nNon-match examples:\n- \"aaaaaaa@.-com\"\n- \"aaaaaaa@adf.-com\"",
        "matches": [
            "afdaas-ddas----asddas____...@asd.asd.asd.asd.asd.com",
            "a@a.aa",
            ".@microsoft.sun.apple.com"
        ],
        "non_matches": [
            "aaaaaaa@.-com",
            "aaaaaaa@adf.-com",
            "aaaaaaa@"
        ],
        "stress_tests": []
    },
    {
        "id": 876,
        "expression": "^((0[1-9])|(1[0-2]))$",
        "raw_prompt": "Matches month, requires that months 1-9 have a leading 0",
        "refined_prompt": "\nMatch examples:\n- \"01\"\n- \"02\"\n- \"12\"\nNon-match examples:\n- \"1\"\n- \"2\"",
        "matches": [
            "01",
            "02",
            "12"
        ],
        "non_matches": [
            "1",
            "2",
            "13"
        ],
        "stress_tests": []
    },
    {
        "id": 877,
        "expression": "^\\s*-?(\\d*\\.)?([0-2])?[0-9]:([0-5])?[0-9]:([0-5])?[0-9](\\.[0-9]{1,7})?\\s*$",
        "raw_prompt": "This should be the pattern described in the documentation for the .NET TimeSpan.Parse method - generally parses time spans.\nFrom the .NET docs:\npublic static TimeSpan Parse(string s);\nThe s parameter contains a specification of the form:\n[ws][-][d.]hh:mm:ss[.ff][ws]\nItems in square brackets ([ and ]) are optional, colons and periods (: and .) are literal characters, and other items are as follows.\nItem Description\nws optional white space\n&quot;-&quot; optional minus sign indicating a negative time\n&quot;d&quot; optional days\n&quot;hh&quot; hours, ranging from 0 to 23\n&quot;mm&quot; minutes, ranging from 0 to 59\n&quot;ss&quot; seconds, ranging from 0 to 59\n&quot;ff&quot; optional fractional seconds, from 1 to 7 decimal digits",
        "refined_prompt": "\nMatch examples:\n- \"10:12:34\"\n- \"932323.9:00:32.3420\"\nNon-match examples:\n- \"10:20:80\"",
        "matches": [
            "10:12:34",
            "932323.9:00:32.3420"
        ],
        "non_matches": [
            "10:20:80"
        ],
        "stress_tests": []
    },
    {
        "id": 879,
        "expression": "^([1-9]{0,1})([0-9]{1})(\\.[0-9])?$",
        "raw_prompt": "Matches numbers 0 through 99.9\nAllows only one preceding zero and does not require the decimal point",
        "refined_prompt": "\nMatch examples:\n- \"1\"\n- \"1.1\"\n- \"0.1\"\nNon-match examples:\n- \"01\"\n- \"01.1\"",
        "matches": [
            "1",
            "1.1",
            "0.1"
        ],
        "non_matches": [
            "01",
            "01.1",
            "0.10"
        ],
        "stress_tests": []
    },
    {
        "id": 880,
        "expression": "^(eth[0-9]$)|(^eth[0-9]:[1-9]$)",
        "raw_prompt": "regex to validate unix device names (linux). useful for scripts using ifconfig or stuff",
        "refined_prompt": "\nMatch examples:\n- \"eth0\"\n- \"eth0:4\"\n- \"eth4:9\"\nNon-match examples:\n- \"eth0:\"\n- \"eth0:0\"",
        "matches": [
            "eth0",
            "eth0:4",
            "eth4:9"
        ],
        "non_matches": [
            "eth0:",
            "eth0:0",
            "eth0:1d"
        ],
        "stress_tests": []
    },
    {
        "id": 881,
        "expression": "^\\.([rR]([aA][rR]|\\d{2})|(\\d{3})?)$",
        "raw_prompt": "RAR file extensions.\nWorks also with '*.part01.rar' given '.rar' to be the file extension.\nDoes not support volumes exceed 101 for s## (r99, s00, s01, ...) serie.",
        "refined_prompt": "\nMatch examples:\n- \".RAr\"\n- \".r01\"\n- \".012\"\nNon-match examples:\n- \".rxr\"\n- \".a01\"",
        "matches": [
            ".RAr",
            ".r01",
            ".012"
        ],
        "non_matches": [
            ".rxr",
            ".a01",
            ".0112"
        ],
        "stress_tests": []
    },
    {
        "id": 882,
        "expression": "^(X(-|\\.)?0?\\d{7}(-|\\.)?[A-Z]|[A-Z](-|\\.)?\\d{7}(-|\\.)?[0-9A-Z]|\\d{8}(-|\\.)?[A-Z])$",
        "raw_prompt": "Matches Spanish CIF, NIF and NIE formats. Recognises separation of letters with the hyphen or period.\nFormat CIF: [1 letter][7 numbers][1 number or letter]\nFormat NIF: [8 numbers][1 letter]\nFormat NIE: X[possible 0][7 numbers][1 letter]\nNote that this expression does not check for the validity of the NIF/CIF/NIE... there are some control characters in there and I don't know how they work.\nGenerally I always strip out any non-alphanumeric characters (hyphens, periods, etc.) and convert to upper case before checking validity and before saving to data storage.\nPlease post improvements or errors if you find them!",
        "refined_prompt": "\nMatch examples:\n- \"X01343567-D\"\n- \"B-6116622G\"\n- \"43544122-R\"\nNon-match examples:\n- \"43.544.122-R\"",
        "matches": [
            "X01343567-D",
            "B-6116622G",
            "43544122-R"
        ],
        "non_matches": [
            "43.544.122-R"
        ],
        "stress_tests": []
    },
    {
        "id": 884,
        "expression": "([0-9]+\\.[0-9]*)|([0-9]*\\.[0-9]+)|([0-9]+)",
        "raw_prompt": "This is just a very simple matcher for real numbers.",
        "refined_prompt": "\nMatch examples:\n- \"123.456\"\n- \".123\"\n- \"123\"\nNon-match examples:\n- \".\"\n- \"apple\"",
        "matches": [
            "123.456",
            ".123",
            "123"
        ],
        "non_matches": [
            ".",
            "apple",
            "pear"
        ],
        "stress_tests": []
    },
    {
        "id": 885,
        "expression": "^((([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}:[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){5}:([0-9A-Fa-f]{1,4}:)?[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){4}:([0-9A-Fa-f]{1,4}:){0,2}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){3}:([0-9A-Fa-f]{1,4}:){0,3}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){2}:([0-9A-Fa-f]{1,4}:){0,4}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}((\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b)\\.){3}(\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b))|(([0-9A-Fa-f]{1,4}:){0,5}:((\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b)\\.){3}(\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b))|(::([0-9A-Fa-f]{1,4}:){0,5}((\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b)\\.){3}(\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b))|([0-9A-Fa-f]{1,4}::([0-9A-Fa-f]{1,4}:){0,5}[0-9A-Fa-f]{1,4})|(::([0-9A-Fa-f]{1,4}:){0,6}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){1,7}:))$",
        "raw_prompt": "Matches full and compressed IPv6 addresses as defined in RFC 2373 (http://www.faqs.org/rfcs/rfc2373.html). No useful captures.\nVarious implementations require different terminators. (i.e. ^-$ or \\b-\\b)",
        "refined_prompt": "\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080::8:800:200C:417A\"\n- \"::FFFF:129.144.52.38\"\nNon-match examples:\n- \"FEDC::7654:3210::BA98:7654:3210\"\n- \"FEDC:BA98:7654:3210\"",
        "matches": [
            "FEDC:BA98:7654:3210:FEDC:BA98:7654:3210",
            "1080::8:800:200C:417A",
            "::FFFF:129.144.52.38"
        ],
        "non_matches": [
            "FEDC::7654:3210::BA98:7654:3210",
            "FEDC:BA98:7654:3210",
            "::"
        ],
        "stress_tests": []
    },
    {
        "id": 888,
        "expression": "^(\\$|)([1-9]+\\d{0,2}(\\,\\d{3})*|([1-9]+\\d*))(\\.\\d{2})?$",
        "raw_prompt": "By combining the contributions from Bri Gipson and Michael Ash in this site. I have come up with this RE to exclude the zero dollar amounts such as $0.00, 0.00, 0, etc.",
        "refined_prompt": "\nMatch examples:\n- \"$1,234,567.00\"\n- \"$1234567.00\"\n- \"1234567.00\"\nNon-match examples:\n- \"$1,2345,67.00\"\n- \"$0\"",
        "matches": [
            "$1,234,567.00",
            "$1234567.00",
            "1234567.00"
        ],
        "non_matches": [
            "$1,2345,67.00",
            "$0",
            "$0.00"
        ],
        "stress_tests": []
    },
    {
        "id": 889,
        "expression": "(((ht|f)tp(s?):\\/\\/)|(www\\.[^ \\[\\]\\(\\)\\n\\r\\t]+)|(([012]?[0-9]{1,2}\\.){3}[012]?[0-9]{1,2})\\/)([^ \\[\\]\\(\\),;&quot;'&lt;&gt;\\n\\r\\t]+)([^\\. \\[\\]\\(\\),;&quot;'&lt;&gt;\\n\\r\\t])|(([012]?[0-9]{1,2}\\.){3}[012]?[0-9]{1,2})",
        "raw_prompt": "v2\nA general purpose expresion to find url's (improved).\nAdd heads to first part, example:\n((imap:|(ht|f)tp(s?):\\/\\/)|(www\\.\nto find url's like imap://www.com/, so ip's. No ipv6 (yet)",
        "refined_prompt": "\nMatch examples:\n- \"www.domain.com\"\n- \"http://www.blah.ru\"\n- \"https://192.168.0.2:80/users/~fname.lname/file.ext\"\nNon-match examples:\n- \"imap://.com\"",
        "matches": [
            "www.domain.com",
            "http://www.blah.ru",
            "https://192.168.0.2:80/users/~fname.lname/file.ext"
        ],
        "non_matches": [
            "imap://.com"
        ],
        "stress_tests": []
    },
    {
        "id": 890,
        "expression": "^(\\$|)([1-9]\\d{0,2}(\\,\\d{3})*|([1-9]\\d*))(\\.\\d{2})?$",
        "raw_prompt": "Combine Michael Ash's US Dollar amount and Bri Gipson's eliminating zero input to create this RE to accept Optional leading dollar sign, optional well-formed comma separator dollar amount with no zero amount allowed.\n*** Correction: Remove the &quot;+&quot; otherwise it will incorrectly matches 4 leading digits like 1234,345,678.00 03-03-2005",
        "refined_prompt": "\nMatch examples:\n- \"$1,234,567.89\"\n- \"1234567.89\"\n- \"$9.99\"\nNon-match examples:\n- \"$1,2345,67.89\"\n- \"$1234,345,678.0\"",
        "matches": [
            "$1,234,567.89",
            "1234567.89",
            "$9.99"
        ],
        "non_matches": [
            "$1,2345,67.89",
            "$1234,345,678.0",
            "0"
        ],
        "stress_tests": []
    },
    {
        "id": 891,
        "expression": "^((Fred|Wilma)\\s+Flintstone|(Barney|Betty)\\s+Rubble)$",
        "raw_prompt": "Match the full names of the four main characters of The Flintstones.",
        "refined_prompt": "\nMatch examples:\n- \"Fred Flintstone\"\n- \"Barney Rubble\"\n- \"Betty Rubble\"\nNon-match examples:\n- \"The Great Gazoo\"\n- \"Mr. Slate\"",
        "matches": [
            "Fred Flintstone",
            "Barney Rubble",
            "Betty Rubble"
        ],
        "non_matches": [
            "The Great Gazoo",
            "Mr. Slate",
            "Dino"
        ],
        "stress_tests": []
    },
    {
        "id": 892,
        "expression": "^(([a-zA-Z0-9_\\-\\.]+)@([a-zA-Z0-9_\\-\\.]+)\\.([a-zA-Z]{2,5}){1,25})+([;.](([a-zA-Z0-9_\\-\\.]+)@([a-zA-Z0-9_\\-\\.]+)\\.([a-zA-Z]{2,5}){1,25})+)*$",
        "raw_prompt": "this will accept multiple email ids separated only by semi-colons (anyway u can change it).",
        "refined_prompt": "\nMatch examples:\n- \"te_s-t@ts.co.in;te_s-t@ts.co.in;te_s-t@ts.co.in\"\nNon-match examples:\n- \"nospace@between.mailids.in ; only@semi.colons.com\"",
        "matches": [
            "te_s-t@ts.co.in;te_s-t@ts.co.in;te_s-t@ts.co.in"
        ],
        "non_matches": [
            "nospace@between.mailids.in ; only@semi.colons.com"
        ],
        "stress_tests": []
    },
    {
        "id": 893,
        "expression": "(\\b)(\\w+(\\b|\\n|\\s)){3}",
        "raw_prompt": "This script attempts to return phrases from a string (Example above looks for {3} word phrases) Combine this with some .Net code, you can display most popular X word phrases in a string.\n-If anyone can help me count &quot;Phrase and Phrase as 2 instances of Phrase please contact me",
        "refined_prompt": "\nMatch examples:\n- \"three blind mice\"\n- \"see how they run\"\nNon-match examples:\n- \"three blind\"\n- \"they run\"",
        "matches": [
            "three blind mice",
            "see how they run"
        ],
        "non_matches": [
            "three blind",
            "they run"
        ],
        "stress_tests": []
    },
    {
        "id": 894,
        "expression": "(^\\([0]\\d{2}\\))(\\d{6,7}$)",
        "raw_prompt": "Validator for New Zealand Mobile phone numbers. Will look for the first number being a 0 and must be a number or either 6 or 7 digits long after to initial (021) suffix",
        "refined_prompt": "\nMatch examples:\n- \"(021)1234567\"\n- \"(021)123456\"\n- \"(000)000000\"\nNon-match examples:\n- \"(123)1234567\"\n- \"025123456\"",
        "matches": [
            "(021)1234567",
            "(021)123456",
            "(000)000000"
        ],
        "non_matches": [
            "(123)1234567",
            "025123456",
            "0252345678"
        ],
        "stress_tests": []
    },
    {
        "id": 895,
        "expression": "^([1-9]|1[0-2]|0[1-9]){1}(:[0-5][0-9][aApP][mM]){1}$",
        "raw_prompt": "Very simple expression to validate time on a 12 hour clock, this expression is valid for client-side script validations (RegularExpressionValidator - ASP.NET).",
        "refined_prompt": "\nMatch examples:\n- \"08:00AM\"\n- \"10:00am\"\n- \"7:00pm\"\nNon-match examples:\n- \"13:00pm\"\n- \"12:65am\"",
        "matches": [
            "08:00AM",
            "10:00am",
            "7:00pm"
        ],
        "non_matches": [
            "13:00pm",
            "12:65am"
        ],
        "stress_tests": []
    },
    {
        "id": 896,
        "expression": "^([0-9a-zA-Z]+[-._+&amp;])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,6}$",
        "raw_prompt": "A short and sweet email address validator. Checks that the username starts and ends with an alphanumeric character, allows a few non-repeating 'special characters' (namely -, ., _, +, &amp;) and checks for a sensible domain name (2-6 character TLD required). Some unconventional, yet technically valid, addresses will not be matched, but this is only a simple expression ;-)",
        "refined_prompt": "\nMatch examples:\n- \"test@test.com\"\n- \"nerdy.one@science.museum\"\n- \"ready&amp;set@go.com.au\"\nNon-match examples:\n- \".test.@test.com\"\n- \"spammer@[203.12.145.68]\"",
        "matches": [
            "test@test.com",
            "nerdy.one@science.museum",
            "ready&amp;set@go.com.au"
        ],
        "non_matches": [
            ".test.@test.com",
            "spammer@[203.12.145.68]",
            "bla@bla"
        ],
        "stress_tests": []
    },
    {
        "id": 897,
        "expression": "^[0-9]*(\\.)?[0-9]+$",
        "raw_prompt": "it will check for the +ve decimal numbers",
        "refined_prompt": "\nMatch examples:\n- \"1\"\n- \"123\"\n- \"132.132\"\nNon-match examples:\n- \"1.2.2\"\n- \"-123\"",
        "matches": [
            "1",
            "123",
            "132.132"
        ],
        "non_matches": [
            "1.2.2",
            "-123"
        ],
        "stress_tests": []
    },
    {
        "id": 898,
        "expression": "^[a-zA-Z0-9]+$",
        "raw_prompt": "it will check for alphanumeric (Alpha Numeric) values.",
        "refined_prompt": "\nMatch examples:\n- \"adad1213\"\n- \"1231dfadfa\"\n- \"dfad123dfasdfs\"\nNon-match examples:\n- \"dfa@#12313\"\n- \"*(*sdfasdfadfd\"",
        "matches": [
            "adad1213",
            "1231dfadfa",
            "dfad123dfasdfs"
        ],
        "non_matches": [
            "dfa@#12313",
            "*(*sdfasdfadfd",
            "$fffsdg121ddd#$f1q"
        ],
        "stress_tests": []
    },
    {
        "id": 900,
        "expression": "\\{CHBLOCK\\:(.*?\\})",
        "raw_prompt": "Litle regexp for my portal engie. Only cut the {CHBLOCK:'modulename'} item",
        "refined_prompt": "\nMatch examples:\n- \"{CHBLOCK:sdgs}\"\n- \"{CHBLOCK:sdgs}sdg{CHBLOCK:sdgs}\"\nNon-match examples:\n- \"{CHBLOCK}\"\n- \"{CHBLOCK:sdgs\"",
        "matches": [
            "{CHBLOCK:sdgs}",
            "{CHBLOCK:sdgs}sdg{CHBLOCK:sdgs}"
        ],
        "non_matches": [
            "{CHBLOCK}",
            "{CHBLOCK:sdgs"
        ],
        "stress_tests": []
    },
    {
        "id": 901,
        "expression": "^(((0[1-9]|[12]\\d|3[01])\\/(0[13578]|1[02])\\/((19|[2-9]\\d)\\d{2}))|((0[1-9]|[12]\\d|30)\\/(0[13456789]|1[012])\\/((19|[2-9]\\d)\\d{2}))|((0[1-9]|1\\d|2[0-8])\\/02\\/((19|[2-9]\\d)\\d{2}))|(29\\/02\\/((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))))$",
        "raw_prompt": "dd/MM/yyyy with leap years 100% integrated Valid years : from 1900 to 9999.\nAs usual, many tests have been made.\nThis was requested by a user :\nhttp://www.regexlib.com/REDetails.aspx?regexp_id=409",
        "refined_prompt": "\nMatch examples:\n- \"29/02/2000\"\n- \"30/04/2003\"\n- \"01/01/2003\"\nNon-match examples:\n- \"29/02/2001\"\n- \"30-04-2003\"",
        "matches": [
            "29/02/2000",
            "30/04/2003",
            "01/01/2003"
        ],
        "non_matches": [
            "29/02/2001",
            "30-04-2003",
            "1/1/1899"
        ],
        "stress_tests": []
    },
    {
        "id": 902,
        "expression": "(?i)(pharmacy)|((p(.{1,3})?h(.{1,3})?a(.{1,3})?r(.{1,3)?m(.{1,3})?a(.{1,3})?c(.{1,3})?y))",
        "raw_prompt": "AntiSpam: matches variations on the word &quot;pharmacy&quot;",
        "refined_prompt": "\nMatch examples:\n- \"phaaarmacy\"\n- \"pphhaarrmmaaccyy\"\n- \"ppharmacy\"\nNon-match examples:\n- \"armacy\"",
        "matches": [
            "phaaarmacy",
            "pphhaarrmmaaccyy",
            "ppharmacy"
        ],
        "non_matches": [
            "armacy"
        ],
        "stress_tests": []
    },
    {
        "id": 903,
        "expression": "^[a-z]+([a-z0-9-]*[a-z0-9]+)?(\\.([a-z]+([a-z0-9-]*[a-z0-9]+)?)+)*$",
        "raw_prompt": "A simple regex which should validate a domain name according to RFC 1035\nupdated to match domain names with hyphens",
        "refined_prompt": "\nMatch examples:\n- \"www.domain.com\"\n- \"w123.d42omain.c43om\"\n- \"ww-w.d-omain.com\"\nNon-match examples:\n- \"1www.domain.com\"\n- \"www.1domain.com\"",
        "matches": [
            "www.domain.com",
            "w123.d42omain.c43om",
            "ww-w.d-omain.com"
        ],
        "non_matches": [
            "1www.domain.com",
            "www.1domain.com",
            "www.domain.com-"
        ],
        "stress_tests": []
    },
    {
        "id": 904,
        "expression": "\\w{5,255}",
        "raw_prompt": "This is User Name &amp; Password validation expression. It does not allow blank spaces as well as special characters like $#%@&amp;*(){}+",
        "refined_prompt": "\nMatch examples:\n- \"aa123_ter12\"\n- \"aa4587\"\n- \"784566\"\nNon-match examples:\n- \"123*-/ mksj\"",
        "matches": [
            "aa123_ter12",
            "aa4587",
            "784566"
        ],
        "non_matches": [
            "123*-/ mksj"
        ],
        "stress_tests": []
    },
    {
        "id": 907,
        "expression": "\\b((?:0[1-46-9]\\d{3})|(?:[1-357-9]\\d{4})|(?:[4][0-24-9]\\d{3})|(?:[6][013-9]\\d{3}))\\b",
        "raw_prompt": "This is my attempt to find out valid german postal codes (PLZ or Postleitzahlen).\nAfter the German Unification the numbers were changed to a five digit system. The postal codes starts with the two digit &quot;Leitzahl&quot;. This is a number between 00 and 99 excluding the not yet used numbers: 00, 05, 43 and 62! After that follows directly a three digit number, 000-999.\nComments welcome. This works for me, however I think it could be written more compact, but could not figure out how ;-)\nFor more information on german postal codes see:\nhttp://de.wikipedia.org/wiki/Liste_der_Postleitbereiche_Deutschland\nhttp://de.wikipedia.org/wiki/Postleitzahl_%28Deutschland%29\nhttp://en.wikipedia.org/wiki/List_of_postal_codes_in_Germany",
        "refined_prompt": "\nMatch examples:\n- \"12556\"\n- \"01550\"\n- \"80796\"\nNon-match examples:\n- \"05234\"\n- \"8973\"",
        "matches": [
            "12556",
            "01550",
            "80796"
        ],
        "non_matches": [
            "05234",
            "8973",
            "62980"
        ],
        "stress_tests": []
    },
    {
        "id": 909,
        "expression": "(^[+]?\\d*\\.?\\d*[1-9]+\\d*$)|(^[+]?[1-9]+\\d*\\.\\d*$)",
        "raw_prompt": "Accepts only positive decimal values. Zero and negative numbers are non-matching.Allows zeros after last non-zero numeric value after decimal place for significant digits",
        "refined_prompt": "\nMatch examples:\n- \"01.23\"\n- \"0.15\"\n- \"0.1568\"\nNon-match examples:\n- \"0\"\n- \"-0.18\"",
        "matches": [
            "01.23",
            "0.15",
            "0.1568"
        ],
        "non_matches": [
            "0",
            "-0.18",
            ".0"
        ],
        "stress_tests": []
    },
    {
        "id": 911,
        "expression": "^(((((((0?[13578])|(1[02]))[\\.\\-/]?((0?[1-9])|([12]\\d)|(3[01])))|(((0?[469])|(11))[\\.\\-/]?((0?[1-9])|([12]\\d)|(30)))|((0?2)[\\.\\-/]?((0?[1-9])|(1\\d)|(2[0-8]))))[\\.\\-/]?(((19)|(20))?([\\d][\\d]))))|((0?2)[\\.\\-/]?(29)[\\.\\-/]?(((19)|(20))?(([02468][048])|([13579][26])))))$",
        "raw_prompt": "Simple American date format mm-dd-yyyy or mm-dd-yy, no time. Date range is 1900 --&gt; 2099. Is enough for my purposes. Incorectly validates 02-29-1900. I created this to validate dates on a web form where the likely range will be 2000--&gt;2020. Seperators can be '.','/' or '-'\nAnyone know the rules for operator precedence for regex syntax?",
        "refined_prompt": "\nMatch examples:\n- \"02-29-2004\"\n- \"1/31/1997\"\n- \"1-2-03\"\nNon-match examples:\n- \"02-29-2003\"\n- \"04-31-2003\"",
        "matches": [
            "02-29-2004",
            "1/31/1997",
            "1-2-03"
        ],
        "non_matches": [
            "02-29-2003",
            "04-31-2003",
            "31-03-05"
        ],
        "stress_tests": []
    },
    {
        "id": 912,
        "expression": "^[^\\\\\\/\\?\\*\\&quot;\\'\\&gt;\\&lt;\\:\\|]*$",
        "raw_prompt": "Validation of a Folder Name. Excludes all forbidden characters",
        "refined_prompt": "\nMatch examples:\n- \"321321321 dasds\"\nNon-match examples:\n- \"/\\3fsdfsd\"",
        "matches": [
            "321321321 dasds"
        ],
        "non_matches": [
            "/\\3fsdfsd"
        ],
        "stress_tests": []
    },
    {
        "id": 913,
        "expression": "^([2-9]\\d{3}((0[1-9]|1[012])(0[1-9]|1\\d|2[0-8])|(0[13456789]|1[012])(29|30)|(0[13578]|1[02])31)|(([2-9]\\d)(0[48]|[2468][048]|[13579][26])|(([2468][048]|[3579][26])00))0229)$",
        "raw_prompt": "yyyyMMdd with leap year validation, starting from year 2000 only.\nThe length of the expression is minimized, but still validates all entries.\nIf you want it with years like 1600 or separators, just ask :)",
        "refined_prompt": "\nMatch examples:\n- \"20000101\"\n- \"20051231\"\n- \"20040229\"\nNon-match examples:\n- \"19990101\"\n- \"20053112\"",
        "matches": [
            "20000101",
            "20051231",
            "20040229"
        ],
        "non_matches": [
            "19990101",
            "20053112",
            "20050229"
        ],
        "stress_tests": []
    },
    {
        "id": 914,
        "expression": "^(\\d{2}((0[1-9]|1[012])(0[1-9]|1\\d|2[0-8])|(0[13456789]|1[012])(29|30)|(0[13578]|1[02])31)|([02468][048]|[13579][26])0229)$",
        "raw_prompt": "yyMMdd with leap years.\nMinimized expression.\nAs we have only 2 numbers for the years, dates 1600, 2000, etc are still validated.",
        "refined_prompt": "\nMatch examples:\n- \"001231\"\n- \"000229\"\n- \"040229\"\nNon-match examples:\n- \"003112\"\n- \"000431\"",
        "matches": [
            "001231",
            "000229",
            "040229"
        ],
        "non_matches": [
            "003112",
            "000431",
            "010229"
        ],
        "stress_tests": []
    },
    {
        "id": 915,
        "expression": "^([01]\\d|2[0123])([0-5]\\d){2}$",
        "raw_prompt": "HHmmss without any separators. Hours in 24h format.",
        "refined_prompt": "\nMatch examples:\n- \"235959\"\n- \"000000\"\n- \"012345\"\nNon-match examples:\n- \"240000\"\n- \"23:59:59\"",
        "matches": [
            "235959",
            "000000",
            "012345"
        ],
        "non_matches": [
            "240000",
            "23:59:59",
            "236060"
        ],
        "stress_tests": []
    },
    {
        "id": 916,
        "expression": "(^\\d*\\.?\\d*[0-9]+\\d*$)|(^[0-9]+\\d*\\.\\d*$)",
        "raw_prompt": "This matches all positive decimal values. There was one here already which claimed to but would fail on value 0.00 which is positive AFAIK...",
        "refined_prompt": "\nMatch examples:\n- \"0.00\"\n- \"1.23\"\n- \"4.56\"\nNon-match examples:\n- \"-1.03\"\n- \"-0.01\"",
        "matches": [
            "0.00",
            "1.23",
            "4.56"
        ],
        "non_matches": [
            "-1.03",
            "-0.01",
            "-0.00"
        ],
        "stress_tests": []
    },
    {
        "id": 918,
        "expression": "^(((0[1-9]|1[012])/(0[1-9]|1\\d|2[0-8])|(0[13456789]|1[012])/(29|30)|(0[13578]|1[02])/31)/[2-9]\\d{3}|02/29/(([2-9]\\d)(0[48]|[2468][048]|[13579][26])|(([2468][048]|[3579][26])00)))$",
        "raw_prompt": "MM/dd/yyyy with 100% leap year validation starting from year 2000.\nIf this one doesn't fit your needs, just tell me.\nSorry for starting &quot;only&quot; from year 2000, this is so simple to change this, please ask if needed.\nEnjoy",
        "refined_prompt": "\nMatch examples:\n- \"02/29/2000\"\n- \"02/29/2004\"\n- \"12/31/2001\"\nNon-match examples:\n- \"02/29/2100\"\n- \"02/29/2001\"",
        "matches": [
            "02/29/2000",
            "02/29/2004",
            "12/31/2001"
        ],
        "non_matches": [
            "02/29/2100",
            "02/29/2001",
            "1/1/2001"
        ],
        "stress_tests": []
    },
    {
        "id": 919,
        "expression": "^\\-?[0-9]{1,3}(\\,[0-9]{3})*(\\.[0-9]+)?$|^[0-9]+(\\.[0-9]+)?$",
        "raw_prompt": "Formatted Number with \",\" as thousand separator and \".\" as decimal separator. now accept numbers without separators of thousands.",
        "refined_prompt": "\nMatch examples:\n- \"10,000,000.123\"\n- \"3.14159265\"\nNon-match examples:\n- \"2.7,1828183\"",
        "matches": [
            "10,000,000.123",
            "3.14159265"
        ],
        "non_matches": [
            "2.7,1828183"
        ],
        "stress_tests": []
    },
    {
        "id": 923,
        "expression": "[AaEeIiOoUuYy]",
        "raw_prompt": "This simple reg-ex accepts any vowel letter.",
        "refined_prompt": "\nMatch examples:\n- \"a\"\n- \"o\"\n- \"e\"\nNon-match examples:\n- \"z\"\n- \"x\"",
        "matches": [
            "a",
            "o",
            "e"
        ],
        "non_matches": [
            "z",
            "x",
            "w"
        ],
        "stress_tests": []
    },
    {
        "id": 926,
        "expression": "^(?=.*[1-9].*$)\\d{0,7}(?:\\.\\d{0,9})?$",
        "raw_prompt": "Allows up to seven digits to the left and up to nine digits to the right of an optional decimal place.\nLeading zeros on the left of the decimal are accepted.\nOnly positive values are accepted.",
        "refined_prompt": "\nMatch examples:\n- \"1\"\n- \"0123456.123456789\"\n- \".123456789\"\nNon-match examples:\n- \".0123456789\"\n- \"0.0\"",
        "matches": [
            "1",
            "0123456.123456789",
            ".123456789"
        ],
        "non_matches": [
            ".0123456789",
            "0.0",
            "-1"
        ],
        "stress_tests": []
    },
    {
        "id": 928,
        "expression": "((http\\://|https\\://|ftp\\://)|(www.))+(([a-zA-Z0-9\\.-]+\\.[a-zA-Z]{2,4})|([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}))(/[a-zA-Z0-9%:/-_\\?\\.'~]*)?",
        "raw_prompt": "This RE matches the web links which begin http://, ftp://, https:// or www.\nYou can edit this disadvantage easy...",
        "refined_prompt": "\nMatch examples:\n- \"www.diskusneforum.sk\"\n- \"http://diskusneforum.sk\"\n- \"ftp://23.45.267.189/\"\nNon-match examples:\n- \"diskusneforum.sk\"\n- \"localhost\"",
        "matches": [
            "www.diskusneforum.sk",
            "http://diskusneforum.sk",
            "ftp://23.45.267.189/"
        ],
        "non_matches": [
            "diskusneforum.sk",
            "localhost"
        ],
        "stress_tests": []
    },
    {
        "id": 929,
        "expression": "^\\$( )*\\d*(.\\d{1,2})?$",
        "raw_prompt": "Validates US currency but allows for spaces between the dollar sign and dollar amount. If there is cents the period validates to two decimal places",
        "refined_prompt": "\nMatch examples:\n- \"$100.00\"\n- \"$100\"\n- \"$10.25\"\nNon-match examples:\n- \"100.\"\n- \"$10.233\"",
        "matches": [
            "$100.00",
            "$100",
            "$10.25"
        ],
        "non_matches": [
            "100.",
            "$10.233",
            "$10."
        ],
        "stress_tests": []
    },
    {
        "id": 930,
        "expression": "/\\*.+?\\*/",
        "raw_prompt": "Searches for SQL comments within a T-SQL statement...",
        "refined_prompt": "\nMatch examples:\n- \"/* This is a T-SQL comment! */\"\nNon-match examples:\n- \"SELECT * FROM Customers\"",
        "matches": [
            "/* This is a T-SQL comment! */"
        ],
        "non_matches": [
            "SELECT * FROM Customers"
        ],
        "stress_tests": []
    },
    {
        "id": 932,
        "expression": "^([1-9]{1}(([0-9])?){2})+(,[0-9]{1}[0-9]{2})*$",
        "raw_prompt": "Matchs comma delimited numbers. Easily changed to allow for other delimiters. (Edit &quot;,&quot;)\nDoes not allow a leading 0\nDoes not allow groups of numbers with less than 3 numbers, exculding the first group.",
        "refined_prompt": "\nMatch examples:\n- \"123,123,123,123\"\n- \"100,120,000,010,011\"\n- \"1,123,123,123\"\nNon-match examples:\n- \"012,123,123,123\"\n- \"12343,1244,4,12\"",
        "matches": [
            "123,123,123,123",
            "100,120,000,010,011",
            "1,123,123,123"
        ],
        "non_matches": [
            "012,123,123,123",
            "12343,1244,4,12",
            ",123,123,123"
        ],
        "stress_tests": []
    },
    {
        "id": 933,
        "expression": "\\{\\\\\\*\\\\bkmkstart\\s(.*?)\\}",
        "raw_prompt": "Applied to a .RTF document, returns all the names of the# bookmarks. Useful to retrieve# dinamically# the list of bookmarks from a document.",
        "refined_prompt": "\nMatch examples:\n- \"{\\*\\bkmkstart TagAmountDigits}\"\n- \"({\\*\\bkmkstart TagAmountText}\"\nNon-match examples:\n- \"{\\*\\bkmkend TagAmountText}\"",
        "matches": [
            "{\\*\\bkmkstart TagAmountDigits}",
            "({\\*\\bkmkstart TagAmountText}"
        ],
        "non_matches": [
            "{\\*\\bkmkend TagAmountText}"
        ],
        "stress_tests": []
    },
    {
        "id": 936,
        "expression": "\"[^\"\\r\\n]*\"",
        "raw_prompt": "returns string between two quotes",
        "refined_prompt": "\nMatch examples:\n- \"Return Parent.DB.GetDataReader(\"CauseImmediateGet\", MyIncidentEventTypeID)\"\nNon-match examples:\n- \"Return Parent.DB.GetDataReader(CauseImmediateGet\", MyIncidentEventTypeID)\"",
        "matches": [
            "Return Parent.DB.GetDataReader(\"CauseImmediateGet\", MyIncidentEventTypeID)"
        ],
        "non_matches": [
            "Return Parent.DB.GetDataReader(CauseImmediateGet\", MyIncidentEventTypeID)"
        ],
        "stress_tests": []
    },
    {
        "id": 937,
        "expression": "^\\d{3}-\\d{7}[0-6]{1}$",
        "raw_prompt": "Airway bill no that allows only the format 999-99999998 and does not allow the last digit to be 7,8,9.",
        "refined_prompt": "\nMatch examples:\n- \"999-99999995\"\n- \"123-47859683\"\n- \"156-78965422\"\nNon-match examples:\n- \"123-47859689\"\n- \"9999999999\"",
        "matches": [
            "999-99999995",
            "123-47859683",
            "156-78965422"
        ],
        "non_matches": [
            "123-47859689",
            "9999999999",
            "9588-58964"
        ],
        "stress_tests": []
    },
    {
        "id": 940,
        "expression": "(^[0-9]*[1-9]+[0-9]*\\.[0-9]*$)|(^[0-9]*\\.[0-9]*[1-9]+[0-9]*$)|(^[0-9]*[1-9]+[0-9]*$)",
        "raw_prompt": "Positive real number greater than zero.",
        "refined_prompt": "\nMatch examples:\n- \"0.01\"\n- \"010001.011010\"\n- \".234\"\nNon-match examples:\n- \"0.00 OR .\"\n- \"010001.011010E\"",
        "matches": [
            "0.01",
            "010001.011010",
            ".234"
        ],
        "non_matches": [
            "0.00 OR .",
            "010001.011010E",
            "1.234.5"
        ],
        "stress_tests": []
    },
    {
        "id": 943,
        "expression": "(a(?:[cdefgilmnoqrstuwxz]|ero|(?:rp|si)a)|b(?:[abdefghijmnorstvwyz]iz)|c(?:[acdfghiklmnoruvxyz]|at|o(?:m|op))|d[ejkmoz]|e(?:[ceghrstu]|du)|f[ijkmor]|g(?:[abdefghilmnpqrstuwy]|ov)|h[kmnrtu]|i(?:[delmnoqrst]|n(?:fo|t))|j(?:[emop]|obs)|k[eghimnprwyz]|l[abcikrstuvy]|m(?:[acdeghklmnopqrstuvwxyz]|il|obi|useum)|n(?:[acefgilopruz]|ame|et)|o(?:m|rg)|p(?:[aefghklmnrstwy]|ro)|qa|r[eosuw]|s[abcdeghijklmnortuvyz]|t(?:[cdfghjklmnoprtvwz]|(?:rav)?el)|u[agkmsyz]|v[aceginu]|w[fs]|y[etu]|z[amw])",
        "raw_prompt": "This regexp matches all existing TLDs (Top-Level Domains) according to IANA specifications as of 14/07/2007.",
        "refined_prompt": "\nMatch examples:\n- \"all ccTLDs (Country-Code Top-Level Domains)\"\n- \"all gTLDs (Generic Top-Level Domains)\"\n- \".arpa\"\nNon-match examples:\n- \"n.o.n - e.x.i.s.t.i.n.g T.L.D.s\"",
        "matches": [
            "all ccTLDs (Country-Code Top-Level Domains)",
            "all gTLDs (Generic Top-Level Domains)",
            ".arpa"
        ],
        "non_matches": [
            "n.o.n - e.x.i.s.t.i.n.g T.L.D.s"
        ],
        "stress_tests": []
    },
    {
        "id": 946,
        "expression": "^((\\d|\\d\\d|[0-1]\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|\\d\\d|[0-1]\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|\\d\\d|[0-1]\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|\\d\\d|[0-1]\\d\\d|2[0-4]\\d|25[0-5]))$",
        "raw_prompt": "Matches valids TCP/IP-Adresses",
        "refined_prompt": "\nMatch examples:\n- \"1.198.0.1\"\n- \"100.10.0.1\"\n- \"200.200.123.123\"\nNon-match examples:\n- \"..12.23\"\n- \"a.23.345\"",
        "matches": [
            "1.198.0.1",
            "100.10.0.1",
            "200.200.123.123"
        ],
        "non_matches": [
            "..12.23",
            "a.23.345",
            "400.500.300.300"
        ],
        "stress_tests": []
    },
    {
        "id": 947,
        "expression": "^(((0?[1-9]|1[012])/(0?[1-9]|1\\d|2[0-8])|(0?[13456789]|1[012])/(29|30)|(0?[13578]|1[02])/31)/(19|[2-9]\\d)\\d{2}|0?2/29/((19|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|(([2468][048]|[3579][26])00)))$",
        "raw_prompt": "MM/dd/yyyy with 100% leap years. Valid since year 1900.\nMM and DD could have 1 or 2 digits : M/d/yyyy or MM/d/yyyy or M/dd/yyyy\nThis was a request from a user in http://www.regexlib.com/REDetails.aspx?regexp_id=1038",
        "refined_prompt": "\nMatch examples:\n- \"01/31/1905\"\n- \"1/9/1900\"\n- \"2/29/1904\"\nNon-match examples:\n- \"31/01/2005\"\n- \"02/29/2005\"",
        "matches": [
            "01/31/1905",
            "1/9/1900",
            "2/29/1904"
        ],
        "non_matches": [
            "31/01/2005",
            "02/29/2005",
            "2/29/2005"
        ],
        "stress_tests": []
    },
    {
        "id": 948,
        "expression": "^(?=.*\\d)(?=.*[a-zA-Z])(?!.*[\\W_\\x7B-\\xFF]).{6,15}$",
        "raw_prompt": "Password validator\nRequires 6-20 characters including at least 1 upper or lower alpha, and 1 digit.\nIt should disallow just about everything else, inluding extended characters.",
        "refined_prompt": "\nMatch examples:\n- \"abc123\"\n- \"BA99342bob\"\n- \"1232z123311\"\nNon-match examples:\n- \"abcdef\"\n- \"123456\"",
        "matches": [
            "abc123",
            "BA99342bob",
            "1232z123311"
        ],
        "non_matches": [
            "abcdef",
            "123456",
            "123'ABC"
        ],
        "stress_tests": []
    },
    {
        "id": 949,
        "expression": "^([a-zA-Z].*|[1-9].*)\\.(((j|J)(p|P)(g|G))|((g|G)(i|I)(f|F)))$",
        "raw_prompt": "Regular expression to limit types of files accepted. This example matches .jpg and .gif files only.",
        "refined_prompt": "\nMatch examples:\n- \"filename.jpg\"\n- \"FileName.JPG\"\n- \"filename.gif\"\nNon-match examples:\n- \"filename.png\"\n- \"filename.xxx\"",
        "matches": [
            "filename.jpg",
            "FileName.JPG",
            "filename.gif"
        ],
        "non_matches": [
            "filename.png",
            "filename.xxx",
            "filename.bmp"
        ],
        "stress_tests": []
    },
    {
        "id": 950,
        "expression": "^[^']*?\\&lt;\\s*Assembly\\s*:\\s*AssemblyVersion\\s*\\(\\s*&quot;(\\*|[0-9]+.\\*|[0-9]+.[0-9]+.\\*|[0-9]+.[0-9]+.[0-9]+.\\*|[0-9]+.[0-9]+.[0-9]+.[0-9]+)&quot;\\s*\\)\\s*\\&gt;.*$",
        "raw_prompt": "Matches the AssemblyVersion attribute in an Assembly.vb file. The version value is captured.",
        "refined_prompt": "\nMatch examples:\n- \"&lt;Assembly: AssemblyVersion(&quot;1.0.*&quot;)&gt; (all version formats, i.e.: * to 1.0.0.0)\"\nNon-match examples:\n- \"'&lt;Assembly: AssemblyVersion(&quot;1.0.*&quot;)&gt; (commented lines)\"",
        "matches": [
            "&lt;Assembly: AssemblyVersion(&quot;1.0.*&quot;)&gt; (all version formats, i.e.: * to 1.0.0.0)"
        ],
        "non_matches": [
            "'&lt;Assembly: AssemblyVersion(&quot;1.0.*&quot;)&gt; (commented lines)"
        ],
        "stress_tests": []
    },
    {
        "id": 952,
        "expression": "^(\\$\\ |\\$)?((0|00|[1-9]\\d*|([1-9]\\d{0,2}(\\,\\d{3})*))(\\.\\d{1,4})?|(\\.\\d{1,4}))$",
        "raw_prompt": "Allows for a dollar sign with no space after, a dollar sign with a space after, and no dollar sign. Also makes sure theres no more than 4 decimal places. Takes out leading zeros if the number isn't 0, and protects against blank entries.",
        "refined_prompt": "\nMatch examples:\n- \"$ 123.4\"\n- \"$00.5\"\n- \"200,000\"\nNon-match examples:\n- \"$012,234.44\"\n- \"-39.05\"",
        "matches": [
            "$ 123.4",
            "$00.5",
            "200,000"
        ],
        "non_matches": [
            "$012,234.44",
            "-39.05",
            "$45,23,330.00"
        ],
        "stress_tests": []
    },
    {
        "id": 954,
        "expression": "^[A-Z1-9]{5}-[A-Z1-9]{5}-[A-Z1-9]{5}-[A-Z1-9]{5}-[A-Z1-9]{5}$",
        "raw_prompt": "Simple Microsoft product key check.",
        "refined_prompt": "\nMatch examples:\n- \"12345-12345-12345-12345-12345\"\n- \"ABCDE-ABCDE-ABCDE-ABCDE-ABCDE\"\n- \"AB5DE-AB5DE-AB5DE-AB5DE-AB5DE\"\nNon-match examples:\n- \"12345-123-123456-12345\"\n- \"ABC-ABCDEF-ABCDE-ABCDE\"",
        "matches": [
            "12345-12345-12345-12345-12345",
            "ABCDE-ABCDE-ABCDE-ABCDE-ABCDE",
            "AB5DE-AB5DE-AB5DE-AB5DE-AB5DE"
        ],
        "non_matches": [
            "12345-123-123456-12345",
            "ABC-ABCDEF-ABCDE-ABCDE",
            "12AB5-ABC-12AB567-12AB5"
        ],
        "stress_tests": []
    },
    {
        "id": 957,
        "expression": "&amp;\\#x0*(0|1|2|3|4|5|6|7|8|B|C|E|F|10|11|12|13|14|15|16|17|18|19|1A|1B|1C|1D|1E|1F);",
        "raw_prompt": "Can be used to match on (and strip out) low-order non-printable ASCII characters (ASCII 0-31) from string data prior to adding to an XML document. Useful when using parsers like Microsoft's MSXML3 that strictly enforce W3C specification on allowable characters. Does not match on ASCII 9 (horiz tab), 10 (carriage return), 13 (line feed).",
        "refined_prompt": "\nMatch examples:\n- \"&amp;#x2;\"\n- \"&amp;#x001F;\"\nNon-match examples:\n- \"&amp;#x0020;\"\n- \"&amp;#xDFFF;\"",
        "matches": [
            "&amp;#x2;",
            "&amp;#x001F;"
        ],
        "non_matches": [
            "&amp;#x0020;",
            "&amp;#xDFFF;"
        ],
        "stress_tests": []
    },
    {
        "id": 965,
        "expression": "(^(\\d{2}.\\d{3}.\\d{3}/\\d{4}-\\d{2})|(\\d{14})$)|(^(\\d{3}.\\d{3}.\\d{3}-\\d{2})|(\\d{11})$)",
        "raw_prompt": "Validador de CPF ou CNPJ brasileiro. Utilizado em campos que podem receber os dois valores, como um campo de busca, que pode buscar por CPF ou CNPJ, como era o meu caso.\n[00.000.000/0000-00], [123.456.789-98],[00000000000000] e [12345678998]\nEnjoy! =)",
        "refined_prompt": "\nMatch examples:\n- \"00.000.000/0000-00\"\n- \"123.456.789-98\"\n- \"12345678901234\"\nNon-match examples:\n- \"12.123.123.0001.12\"\n- \"123.456.789.89\"",
        "matches": [
            "00.000.000/0000-00",
            "123.456.789-98",
            "12345678901234"
        ],
        "non_matches": [
            "12.123.123.0001.12",
            "123.456.789.89"
        ],
        "stress_tests": []
    },
    {
        "id": 966,
        "expression": "^([1-9]{1}[\\d]{0,2}(\\.[\\d]{3})*(\\,[\\d]{0,2})?|[1-9]{1}[\\d]{0,}(\\,[\\d]{0,2})?|0(\\,[\\d]{0,2})?|(\\,[\\d]{1,2})?)$",
        "raw_prompt": "Numera&#231;&#227;o usar para valores moeda brasileira e de outras regi&#245;es. Dinheiro, money...\nEnjoy! =)",
        "refined_prompt": "\nMatch examples:\n- \"123,02\"\n- \"123.456,02\"\n- \"123.456.789,02\"\nNon-match examples:\n- \"123,003\"\n- \"123,123.02\"",
        "matches": [
            "123,02",
            "123.456,02",
            "123.456.789,02"
        ],
        "non_matches": [
            "123,003",
            "123,123.02"
        ],
        "stress_tests": []
    },
    {
        "id": 968,
        "expression": "(^[A-Z]{1,2}[0-9]{1,}:{1}[A-Z]{1,2}[0-9]{1,}$)|(^\\$(([A-Z])|([a-z])){1,2}([0-9]){1,}:{1}\\$(([A-Z])|([a-z])){1,2}([0-9]){1,}$)|(^\\$(([A-Z])|([a-z])){1,2}(\\$){1}([0-9]){1,}:{1}\\$(([A-Z])|([a-z])){1,2}(\\$){1}([0-9]){1,}$)",
        "raw_prompt": "Matching any valid MS Excel range",
        "refined_prompt": "\nMatch examples:\n- \"A1:BB10\"\n- \"$A1:$BB10\"\n- \"$A$1:$BB$10\"\nNon-match examples:\n- \"$A1:BB10\"",
        "matches": [
            "A1:BB10",
            "$A1:$BB10",
            "$A$1:$BB$10"
        ],
        "non_matches": [
            "$A1:BB10"
        ],
        "stress_tests": []
    },
    {
        "id": 969,
        "expression": "(^[A-Z]{1,2}[0-9]{1,}:{1}[A-Z]{1,2}[0-9]{1,}$)|(^\\$(([A-Z])|([a-z])){1,2}([0-9]){1,}:{1}\\$(([A-Z])|([a-z])){1,2}([0-9]){1,}$)|(^\\$(([A-Z])|([a-z])){1,2}(\\$){1}([0-9]){1,}:{1}\\$(([A-Z])|([a-z])){1,2}(\\$){1}([0-9]){1,}$)",
        "raw_prompt": "A regular expression for any valid MS Excel range",
        "refined_prompt": "\nMatch examples:\n- \"A1:BB10\"\n- \"$A1:$BB10\"\n- \"$A$1:$BB$10\"\nNon-match examples:\n- \"$A1:BB10\"",
        "matches": [
            "A1:BB10",
            "$A1:$BB10",
            "$A$1:$BB$10"
        ],
        "non_matches": [
            "$A1:BB10"
        ],
        "stress_tests": []
    },
    {
        "id": 970,
        "expression": "\\\\\\\\\\w+?(?:\\\\[\\w\\s$]+)+",
        "raw_prompt": "Detect windows share path (unc path)",
        "refined_prompt": "\nMatch examples:\n- \"\\\\server\\share\\subdir1\\subdir2;\"\n- \"&quot;\\\\server\\share$\\subdir1 with space\\subdir2&quot;\"\nNon-match examples:\n- \"\\server\\share\"",
        "matches": [
            "\\\\server\\share\\subdir1\\subdir2;",
            "&quot;\\\\server\\share$\\subdir1 with space\\subdir2&quot;"
        ],
        "non_matches": [
            "\\server\\share"
        ],
        "stress_tests": []
    },
    {
        "id": 971,
        "expression": "(^\\d*\\.\\d{2}$)",
        "raw_prompt": "If you need a textbox to allow only positive numbers with two decimal places, try this. I wanted the user to be able to enter any type of currency amount (US of course) but also have two decimal places for database field.",
        "refined_prompt": "\nMatch examples:\n- \"12.56\"\n- \"0.25\"\n- \"156.56\"\nNon-match examples:\n- \"-123.45\"\n- \"1.023\"",
        "matches": [
            "12.56",
            "0.25",
            "156.56"
        ],
        "non_matches": [
            "-123.45",
            "1.023",
            "1.2"
        ],
        "stress_tests": []
    },
    {
        "id": 972,
        "expression": "^[NS]([0-8][0-9](\\.[0-5]\\d){2}|90(\\.00){2})\\040[EW]((0\\d\\d|1[0-7]\\d)(\\.[0-5]\\d){2}|180(\\.00){2})$",
        "raw_prompt": "Validate location, latitude and longitude separated by space, where latitude is expressed as compass direction (N or S),degrees,minutes,seconds and longitude is expressed as compassdirection (E or W) ,degrees,minutes,seconds.\nRange check for minutes and seconds (0-59),\nmax.latitude 90.00.00, max longitude 180.00.00",
        "refined_prompt": "\nMatch examples:\n- \"N90.00.00 E180.00.00\"\n- \"S34.59.33 W179.59.59\"\n- \"N00.00.00 W000.00.00\"\nNon-match examples:\n- \"N91.00.00 E181.00.00\"\n- \"Z34.59.33 W179.59.59\"",
        "matches": [
            "N90.00.00 E180.00.00",
            "S34.59.33 W179.59.59",
            "N00.00.00 W000.00.00"
        ],
        "non_matches": [
            "N91.00.00 E181.00.00",
            "Z34.59.33 W179.59.59",
            "N00.00.00 W181.00.00"
        ],
        "stress_tests": []
    },
    {
        "id": 975,
        "expression": "((xmlns:.*?=[&quot;,'].*?[&quot;,'])|(xmlns=[&quot;,'].*?[&quot;,']))",
        "raw_prompt": "XML Namespace ( xmlns ) matcher. Properly matches one or more of either xmlns=&quot;blah&quot; or xmlns:blah=&quot;blooey&quot; .\n(for c#, make sure to escape the double-quotes.)",
        "refined_prompt": "\nMatch examples:\n- \"&lt;Registry xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:xsi=&quot;http://www.w3.or\"\nNon-match examples:\n- \"&lt;Registry someattrib=&quot;test&quot; /&gt;\"",
        "matches": [
            "&lt;Registry xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:xsi=&quot;http://www.w3.or"
        ],
        "non_matches": [
            "&lt;Registry someattrib=&quot;test&quot; /&gt;"
        ],
        "stress_tests": []
    },
    {
        "id": 976,
        "expression": "(?<=,)\\s*(?=,)|^(?=,)|[^\\\"]{2,}(?=\\\")|([^,\\\"]+(?=,|$))",
        "raw_prompt": "Use for parsing CSV files exported from MS Excel, This program adds or not quotes, so it's more complicated..\nUse for parsing individual lines, the Regex doesn't capture end of line (supposed to ($) but not made it in the testing so you cannot parse the whole file.\nRead a line and split it, with this regex",
        "refined_prompt": "\nMatch examples:\n- \",Casa en condominio / Traspaso,\"$270,000 \",\"mn,\",\"Toluca,\",\"67 m2\"\nNon-match examples:\n- \"\"\"\"",
        "matches": [
            ",Casa en condominio / Traspaso,\"$270,000 \",\"mn,\",\"Toluca,\",\"67 m2"
        ],
        "non_matches": [
            "\"\""
        ],
        "stress_tests": []
    },
    {
        "id": 977,
        "expression": "/\\*((?!\\*/)[\\d\\D\\s])*\\*/",
        "raw_prompt": "Matches /* style comments */.\nMatches whitespace (so can detect tabs, etc.)\nProblems with nested comments.",
        "refined_prompt": "\nMatch examples:\n- \"/* CSS comments */\"\n- \"/* multi-line SQL/CSS/Etc comments */\"\nNon-match examples:\n- \"&lt;!-- doesn't match --&gt;\"\n- \"-- won't match and //won't match\"",
        "matches": [
            "/* CSS comments */",
            "/* multi-line SQL/CSS/Etc comments */"
        ],
        "non_matches": [
            "&lt;!-- doesn't match --&gt;",
            "-- won't match and //won't match"
        ],
        "stress_tests": []
    },
    {
        "id": 979,
        "expression": "(?=^.{6,10}$)(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[!@#$%^&amp;*()_+}{&quot;:;'?/&gt;.&lt;,])(?!.*\\s).*$",
        "raw_prompt": "This regular expression match can be used for validating strong password. It expects atleast 1 small-case letter, 1 Capital letter, 1 digit, 1 special character and the length should be between 6-10 characters. The sequence of the characters is not important. This expression follows the above 4 norms specified by microsoft for a strong password.",
        "refined_prompt": "\nMatch examples:\n- \"1A2a$5\"\n- \"1234567Tt#\"\n- \"Tsd677%\"\nNon-match examples:\n- \"Tt122\"\n- \"1tdfy34564646T*\"",
        "matches": [
            "1A2a$5",
            "1234567Tt#",
            "Tsd677%"
        ],
        "non_matches": [
            "Tt122",
            "1tdfy34564646T*"
        ],
        "stress_tests": []
    },
    {
        "id": 984,
        "expression": "^(102[0-3]|10[0-1]\\d|[1-9][0-9]{0,2}|0)$",
        "raw_prompt": "Port Numbers: Well Known Ports: 0 through 1023. Matches numbers in range of 0 through 1023.",
        "refined_prompt": "\nMatch examples:\n- \"0\"\n- \"123\"\n- \"1023\"\nNon-match examples:\n- \"1024\"\n- \"9999\"",
        "matches": [
            "0",
            "123",
            "1023"
        ],
        "non_matches": [
            "1024",
            "9999",
            "99999"
        ],
        "stress_tests": []
    },
    {
        "id": 985,
        "expression": "^(4915[0-1]|491[0-4]\\d|490\\d\\d|4[0-8]\\d{3}|[1-3]\\d{4}|[2-9]\\d{3}|1[1-9]\\d{2}|10[3-9]\\d|102[4-9])$",
        "raw_prompt": "Port Numbers: Registered Ports: 1024 through 49151. Matches numbers in range of 1024 through 49151.",
        "refined_prompt": "\nMatch examples:\n- \"1024\"\n- \"49151\"\n- \"30100\"\nNon-match examples:\n- \"1023\"\n- \"49152\"",
        "matches": [
            "1024",
            "49151",
            "30100"
        ],
        "non_matches": [
            "1023",
            "49152",
            "50000"
        ],
        "stress_tests": []
    },
    {
        "id": 986,
        "expression": "^(6553[0-5]|655[0-2]\\d|65[0-4]\\d\\d|6[0-4]\\d{3}|5\\d{4}|49[2-9]\\d\\d|491[6-9]\\d|4915[2-9])$",
        "raw_prompt": "Port Numbers: Dynamic and/or Private Ports: 49152 through 65535. Matches numbers in range of 49152 through 65535.",
        "refined_prompt": "\nMatch examples:\n- \"49152\"\n- \"65535\"\n- \"50000\"\nNon-match examples:\n- \"49151\"\n- \"65536\"",
        "matches": [
            "49152",
            "65535",
            "50000"
        ],
        "non_matches": [
            "49151",
            "65536",
            "66000"
        ],
        "stress_tests": []
    },
    {
        "id": 987,
        "expression": "^(4915[0-1]|491[0-4]\\d|490\\d\\d|4[0-8]\\d{3}|[1-3]\\d{4}|[1-9]\\d{0,3}|0)$",
        "raw_prompt": "Port Numbers: Well Known Ports &amp; Registered Ports: 0 through 49151. Matches numbers in range of 0 through 49151.",
        "refined_prompt": "\nMatch examples:\n- \"0\"\n- \"1023\"\n- \"49151\"\nNon-match examples:\n- \"49152\"\n- \"50000\"",
        "matches": [
            "0",
            "1023",
            "49151"
        ],
        "non_matches": [
            "49152",
            "50000",
            "60000"
        ],
        "stress_tests": []
    },
    {
        "id": 988,
        "expression": "^(6553[0-5]|655[0-2]\\d|65[0-4]\\d\\d|6[0-4]\\d{3}|[1-5]\\d{4}|[1-9]\\d{0,3}|0)$",
        "raw_prompt": "Port Numbers: Well Known Ports, Registered Ports &amp; Dynamic and/or Private Ports: 0 through 65536. Matches numbers in range of 0 through 65536.",
        "refined_prompt": "\nMatch examples:\n- \"1023\"\n- \"49151\"\n- \"65535\"\nNon-match examples:\n- \"65536\"\n- \"66000\"",
        "matches": [
            "1023",
            "49151",
            "65535"
        ],
        "non_matches": [
            "65536",
            "66000",
            "67000"
        ],
        "stress_tests": []
    },
    {
        "id": 989,
        "expression": "^((([hH][tT][tT][pP][sS]?|[fF][tT][pP])\\:\\/\\/)?([\\w\\.\\-]+(\\:[\\w\\.\\&%\\$\\-]+)*@)?((([^\\s\\(\\)\\<\\>\\\\\\\"\\.\\[\\]\\,@;:]+)(\\.[^\\s\\(\\)\\<\\>\\\\\\\"\\.\\[\\]\\,@;:]+)*(\\.[a-zA-Z]{2,4}))|((([01]?\\d{1,2}|2[0-4]\\d|25[0-5])\\.){3}([01]?\\d{1,2}|2[0-4]\\d|25[0-5])))(\\b\\:(6553[0-5]|655[0-2]\\d|65[0-4]\\d{2}|6[0-4]\\d{3}|[1-5]\\d{4}|[1-9]\\d{0,3}|0)\\b)?((\\/[^\\/][\\w\\.\\,\\?\\'\\\\\\/\\+&%\\$#\\=~_\\-@]*)*[^\\.\\,\\?\\\"\\'\\(\\)\\[\\]!;<>{}\\s\\x7F-\\xFF])?)$",
        "raw_prompt": "Matches a URL string by: protocol,subdomain,domain,ip address,port number,path and/or filename",
        "refined_prompt": "\nMatch examples:\n- \"http://regexlib.com\"\n- \"https://regexlib.com:80\"\n- \"66.129.120.94/Search.aspx\"\nNon-match examples:\n- \"http:/regexlib.com\"\n- \"https://regexlib.com:65536\"",
        "matches": [
            "http://regexlib.com",
            "https://regexlib.com:80",
            "66.129.120.94/Search.aspx"
        ],
        "non_matches": [
            "http:/regexlib.com",
            "https://regexlib.com:65536",
            "66.129.120.256/Search.aspx."
        ],
        "stress_tests": []
    },
    {
        "id": 990,
        "expression": "^((0?[1-9]|1[012])(\\s*:\\s*([0-5]\\d))?(\\s*:\\s*([0-5]\\d))?(\\s*([AaPp])[Mm]?)$|(2[0-3]|[1]\\d|0?\\d)(\\s*:\\s*([0-5]\\d))(\\s*:\\s*([0-5]\\d))?)$",
        "raw_prompt": "Matches a time string. A loose validation for easy user entry. Saves the information needed for a correct time setting.",
        "refined_prompt": "\nMatch examples:\n- \"3:00:59\"\n- \"12pm\"\n- \"6:30 a\"\nNon-match examples:\n- \"12\"\n- \"25pm\"",
        "matches": [
            "3:00:59",
            "12pm",
            "6:30 a"
        ],
        "non_matches": [
            "12",
            "25pm",
            "6:60 a"
        ],
        "stress_tests": []
    },
    {
        "id": 991,
        "expression": "(^[0-9]{0,10}$)",
        "raw_prompt": "Good For Validating Phone numbers that are 0 to 9 in length",
        "refined_prompt": "\nMatch examples:\n- \"123456\"\n- \"12354\"\n- \"456443\"\nNon-match examples:\n- \"456abcd\"",
        "matches": [
            "123456",
            "12354",
            "456443"
        ],
        "non_matches": [
            "456abcd"
        ],
        "stress_tests": []
    },
    {
        "id": 992,
        "expression": "&lt;a[a-zA-Z0-9 =&quot;'.:;?]*(name=){1}[a-zA-Z0-9 =&quot;'.:;?]*\\s*((/&gt;)|(&gt;[a-zA-Z0-9 =&quot;'&lt;&gt;.:;?]*&lt;/a&gt;))",
        "raw_prompt": "This expression matches only valid html anchors. Those are anchors with an attribute name=. Such anchor can be closed either with &lt;/a&gt; or with /&gt;.\nIf someone can help - one thing still missing is not matching html tags with parameter href, becazse such should be considered as non valid anchors.",
        "refined_prompt": "\nMatch examples:\n- \"&lt;a name=&quot;anchorName&quot;&gt;Anchor&lt;/a&gt;\"\n- \"&lt;a name=anchorName /&gt;\"\nNon-match examples:\n- \"&lt;a href=&quot;somewhere&quot;&gt;\"\n- \"&lt;a href&gt;\"",
        "matches": [
            "&lt;a name=&quot;anchorName&quot;&gt;Anchor&lt;/a&gt;",
            "&lt;a name=anchorName /&gt;"
        ],
        "non_matches": [
            "&lt;a href=&quot;somewhere&quot;&gt;",
            "&lt;a href&gt;",
            "&lt;a name /&gt;"
        ],
        "stress_tests": []
    },
    {
        "id": 993,
        "expression": "^\\$?([1-9][0-9]{3,}(\\.\\d{2})?|(\\d{1,3}\\,\\d{3}|\\d{1,3}\\,\\d{3}(\\.\\d{2})?)|(\\d{1,3}\\,\\d{3}|\\d{1,3}\\,\\d{3}\\,\\d{3}(\\.\\d{2})?)*)?$",
        "raw_prompt": "Currency which cannot be less than $1000 and lower than a billion.",
        "refined_prompt": "\nMatch examples:\n- \"$1000\"\n- \"$1,000,000.00\"\n- \"9,999\"\nNon-match examples:\n- \"999.00\"\n- \"$1,000,000,000.00\"",
        "matches": [
            "$1000",
            "$1,000,000.00",
            "9,999"
        ],
        "non_matches": [
            "999.00",
            "$1,000,000,000.00",
            "5.00"
        ],
        "stress_tests": []
    },
    {
        "id": 995,
        "expression": "(([a-zA-Z]{3}[0-9]{3})|(\\w{2}-\\w{2}-\\w{2})|([0-9]{2}-[a-zA-Z]{3}-[0-9]{1})|([0-9]{1}-[a-zA-Z]{3}-[0-9]{2})|([a-zA-Z]{1}-[0-9]{3}-[a-zA-Z]{2}))",
        "raw_prompt": "Dutch licenceplate check also including scooters#\nABC123#\n12-AB-AB#\n12-ABC-1#\n1-ABC-12#\nA-123-AB#",
        "refined_prompt": "\nMatch examples:\n- \"ABC123\"\n- \"12-AB-AB\"\n- \"12-ABC-1\"\nNon-match examples:\n- \"12ABAB\"\n- \"12ABC1\"",
        "matches": [
            "ABC123",
            "12-AB-AB",
            "12-ABC-1"
        ],
        "non_matches": [
            "12ABAB",
            "12ABC1",
            "1ABC12"
        ],
        "stress_tests": []
    },
    {
        "id": 996,
        "expression": "(\\/\\*(\\s*|.*?)*\\*\\/)|(--.*)",
        "raw_prompt": "This pattern will match any multi-line or single line comments in TSQL (Stored Procedures or SPROC's) in MS SQL Server.",
        "refined_prompt": "\nMatch examples:\n- \"/* My Comment */\"\n- \"-- A single line comment\"\nNon-match examples:\n- \"*/ Won't work /*\"\n- \"// Not likely\"",
        "matches": [
            "/* My Comment */",
            "-- A single line comment"
        ],
        "non_matches": [
            "*/ Won't work /*",
            "// Not likely",
            "- uh uh"
        ],
        "stress_tests": []
    },
    {
        "id": 997,
        "expression": "(:[a-z]{1}[a-z1-9\\$#_]*){1,31}",
        "raw_prompt": "This matches oracle binding variables in SQL. Not sure if it is the same with other RDBMS'",
        "refined_prompt": "\nMatch examples:\n- \":x\"\n- \":x1\"\n- \":x#2$\"\nNon-match examples:\n- \":1x\"\n- \":@x\"",
        "matches": [
            ":x",
            ":x1",
            ":x#2$"
        ],
        "non_matches": [
            ":1x",
            ":@x",
            ":*ac"
        ],
        "stress_tests": []
    },
    {
        "id": 998,
        "expression": "^([A-Z\\d]{3})[A-Z]{2}\\d{2}([A-Z\\d]{1})([X\\d]{1})([A-Z\\d]{3})\\d{5}$",
        "raw_prompt": "US vehicle VIN numbers for vehicles with GVW &lt; 10k lbs",
        "refined_prompt": "\nMatch examples:\n- \"WDBCA45EXKA478654\"\nNon-match examples:\n- \"WDBCA45EXKA47865a\"",
        "matches": [
            "WDBCA45EXKA478654"
        ],
        "non_matches": [
            "WDBCA45EXKA47865a"
        ],
        "stress_tests": []
    },
    {
        "id": 999,
        "expression": "(?<!\\\\)\\[(\\\\\\[|\\\\\\]|[^\\[\\]]|(?<!\\\\)\\[.*(?<!\\\\)\\])*(?<!\\\\)\\]",
        "raw_prompt": "This regular expression will find the highest level groups within recursive tokens. For instance, if I have &quot;This is [just [an] example] of the [expression]&quot;, it'll find [just [an] example] and [expression], and nothing else. It will also not find an escaped bracket expression. If you want to replace the bracket with curly braces or parenthesis, be careful. As an example, curly braces will be: (?&lt;!\\\\)\\{(\\\\\\{|\\\\\\}|[^\\{\\}]|(?&lt;!\\\\)\\{.*(?&lt;!\\\\)\\})*(?&lt;!\\\\)\\}",
        "refined_prompt": "\nMatch examples:\n- \"[just]\"\n- \"[just [an] example]\"\nNon-match examples:\n- \"\\[just]\"",
        "matches": [
            "[just]",
            "[just [an] example]"
        ],
        "non_matches": [
            "\\[just]"
        ],
        "stress_tests": []
    },
    {
        "id": 1000,
        "expression": "^[0-9,+,(), ,]{1,}(,[0-9]+){0,}$",
        "raw_prompt": "It could be used to validate local as well as International Phone nos where the number my be preceeding by + sign for(00) and may have brackets to accept the city code like (22).It will also accept space in between like 001 116 23314",
        "refined_prompt": "\nMatch examples:\n- \"0091(22) 31544\"\n- \"+1 (116) 23314\"\n- \"+91(22)311545\"\nNon-match examples:\n- \"91 (22) abc21\"\n- \"+91 (abc) 23321\"",
        "matches": [
            "0091(22) 31544",
            "+1 (116) 23314",
            "+91(22)311545"
        ],
        "non_matches": [
            "91 (22) abc21",
            "+91 (abc) 23321",
            "00111623314abc"
        ],
        "stress_tests": []
    },
    {
        "id": 1001,
        "expression": "^(.){0,20}$",
        "raw_prompt": "This limits an HTML textarea to only be 20 characters. Built for an ASP:regularexpression tag to validate a textarea.",
        "refined_prompt": "\nMatch examples:\n- \"I match\"\n- \"I match 2\"\nNon-match examples:\n- \"hey I don't match at all\"",
        "matches": [
            "I match",
            "I match 2"
        ],
        "non_matches": [
            "hey I don't match at all"
        ],
        "stress_tests": []
    },
    {
        "id": 1003,
        "expression": "^((\\d|[1-9]\\d|2[0-4]\\d|25[0-5]|1\\d\\d)(?:\\.(\\d|[1-9]\\d|2[0-4]\\d|25[0-5]|1\\d\\d)){3})$",
        "raw_prompt": "validates a simple ip v4 address. including 0.0.0.0 or 255.255.255.255. leading 0 is and numbers above 255 are forbitten.",
        "refined_prompt": "\nMatch examples:\n- \"0.0.0.0\"\n- \"255.255.255.255\"\n- \"168.129.2.255\"\nNon-match examples:\n- \"02.234.2.1\"\n- \"168.192.0.256\"",
        "matches": [
            "0.0.0.0",
            "255.255.255.255",
            "168.129.2.255"
        ],
        "non_matches": [
            "02.234.2.1",
            "168.192.0.256",
            "1233.0.0.1"
        ],
        "stress_tests": []
    },
    {
        "id": 1006,
        "expression": "^\\+?\\(?\\d+\\)?(\\s|\\-|\\.)?\\d{1,3}(\\s|\\-|\\.)?\\d{4}$",
        "raw_prompt": "Simply matches a telephone number. Not meant to be extremly accurate but more for q uick match or extracting from a body of text. Does not support extensions",
        "refined_prompt": "\nMatch examples:\n- \"555 5555\"\n- \"(555) 555-5555\"\n- \"+555 5555555\"\nNon-match examples:\n- \"+ 55 5555\"\n- \"() 555 5555\"",
        "matches": [
            "555 5555",
            "(555) 555-5555",
            "+555 5555555"
        ],
        "non_matches": [
            "+ 55 5555",
            "() 555 5555"
        ],
        "stress_tests": []
    },
    {
        "id": 1007,
        "expression": "^\\+?\\(?\\d+\\)?(\\s|\\-|\\.)?\\d{1,3}(\\s|\\-|\\.)?\\d{4}$",
        "raw_prompt": "Simply matches a telephone number. Not meant to be extremly accurate but more for q uick match or extracting from a body of text. Does not support extensions",
        "refined_prompt": "\nMatch examples:\n- \"555 5555\"\n- \"(555) 555-5555\"\n- \"+555 5555555\"\nNon-match examples:\n- \"+ 55 5555\"\n- \"() 555 5555\"",
        "matches": [
            "555 5555",
            "(555) 555-5555",
            "+555 5555555"
        ],
        "non_matches": [
            "+ 55 5555",
            "() 555 5555"
        ],
        "stress_tests": []
    },
    {
        "id": 1008,
        "expression": "^[1-9]+[0-9]*$",
        "raw_prompt": "Allows only positive numbers, greater than zero",
        "refined_prompt": "\nMatch examples:\n- \"1\"\n- \"10\"\n- \"135\"\nNon-match examples:\n- \"0\"\n- \"-1\"",
        "matches": [
            "1",
            "10",
            "135"
        ],
        "non_matches": [
            "0",
            "-1",
            "aaa"
        ],
        "stress_tests": []
    },
    {
        "id": 1009,
        "expression": "(?=^.{6,51}$)([A-Za-z]{1})([A-Za-z0-9!@#$%_\\^\\&amp;\\*\\-\\.\\?]{5,49})$",
        "raw_prompt": "This expression was originally developed for user names. Matching text must have 6 - 50 characters, cannot contain spaces, must begin with an alpha character, can contain mixed case alpha, digits, and the following special characters:\n! @ # $ % ^ &amp; * - . _ ?",
        "refined_prompt": "\nMatch examples:\n- \"aB!@#%&amp;^$.?*-0123456789Yz\"\n- \"user@somedomain.com\"\n- \"Excla!Us_er\"\nNon-match examples:\n- \"1234567890\"\n- \"aB1()[]{};:'&quot;,&lt;&gt;/\\_=0Yz\"",
        "matches": [
            "aB!@#%&amp;^$.?*-0123456789Yz",
            "user@somedomain.com",
            "Excla!Us_er"
        ],
        "non_matches": [
            "1234567890",
            "aB1()[]{};:'&quot;,&lt;&gt;/\\_=0Yz",
            "!exclaUser"
        ],
        "stress_tests": []
    },
    {
        "id": 1010,
        "expression": "([^a-zA-Z0-9])",
        "raw_prompt": "(Corrected)\nThis pattern will match 1 instance of a NON-alphanumeric character. This is very handy to use when y\nou want to filter input only by alphanumeric characters, by using Regex.Replace.\nHowever, when used in a Regex.Replace, it will replace all instances of non-alphanumeric characters\nwith specified character.",
        "refined_prompt": "\nMatch examples:\n- \"Test!\"\n- \"This will match\"\n- \"H3llo$\"\nNon-match examples:\n- \"Test\"\n- \"Thiswillnotmatch\"",
        "matches": [
            "Test!",
            "This will match",
            "H3llo$"
        ],
        "non_matches": [
            "Test",
            "Thiswillnotmatch",
            "H3llo"
        ],
        "stress_tests": []
    },
    {
        "id": 1011,
        "expression": "^([a-zA-Z][a-zA-Z\\&amp;amp;\\-\\.\\'\\s]*|)$",
        "raw_prompt": "This expression will allow Letters, periods, apostrophe, dashes.",
        "refined_prompt": "\nMatch examples:\n- \"muk.dub'ey-j ava\"\nNon-match examples:\n- \"muk_12 dubey`.ja\"",
        "matches": [
            "muk.dub'ey-j ava"
        ],
        "non_matches": [
            "muk_12 dubey`.ja"
        ],
        "stress_tests": []
    },
    {
        "id": 1012,
        "expression": "\\b(get)\\b.*{",
        "raw_prompt": "This piece of regex catches the if the open braces are not placed the line under a get command",
        "refined_prompt": "\nMatch examples:\n- \"get {\"\nNon-match examples:\n- \"get\"",
        "matches": [
            "get {"
        ],
        "non_matches": [
            "get"
        ],
        "stress_tests": []
    },
    {
        "id": 1013,
        "expression": "\\bfor\\b.*[A-Za-z][&lt;&gt; ][\\d]",
        "raw_prompt": "This regex catches the hard-coded for blocks",
        "refined_prompt": "\nMatch examples:\n- \"for (i=1;i&lt;7;i++)\"\nNon-match examples:\n- \"for (i=1;i&lt;MyEnd;i++)\"",
        "matches": [
            "for (i=1;i&lt;7;i++)"
        ],
        "non_matches": [
            "for (i=1;i&lt;MyEnd;i++)"
        ],
        "stress_tests": []
    },
    {
        "id": 1014,
        "expression": "\\b(byte|char|short|long|float|int|double|decimal|bool|string)\\b.*\\s[a-zA-Z](?=;)",
        "raw_prompt": "This regex catches if the variable isn't initialized when it is declared",
        "refined_prompt": "\nMatch examples:\n- \"int a;\"\nNon-match examples:\n- \"int a =5;\"",
        "matches": [
            "int a;"
        ],
        "non_matches": [
            "int a =5;"
        ],
        "stress_tests": []
    },
    {
        "id": 1015,
        "expression": "(\\bprotected\\b.*(public))|(\\bprivate\\b.*(protected))|(\\bprivate\\b.*(public))",
        "raw_prompt": "This regex catches illegal precedence order of declerations of a class",
        "refined_prompt": "\nMatch examples:\n- \"class SomeClass:private BaseClass1, public BaseClass2, protected BaseClass3\"\nNon-match examples:\n- \"class SomeClass:public BaseClass1, protected BaseClass2, private BaseClass3\"",
        "matches": [
            "class SomeClass:private BaseClass1, public BaseClass2, protected BaseClass3"
        ],
        "non_matches": [
            "class SomeClass:public BaseClass1, protected BaseClass2, private BaseClass3"
        ],
        "stress_tests": []
    },
    {
        "id": 1016,
        "expression": "\\b(\\w+).\\1",
        "raw_prompt": "This regex catches the redundacy of including class names in the name of class properties.",
        "refined_prompt": "\nMatch examples:\n- \"Book.BookPage\"\nNon-match examples:\n- \"Book.Page\"",
        "matches": [
            "Book.BookPage"
        ],
        "non_matches": [
            "Book.Page"
        ],
        "stress_tests": []
    },
    {
        "id": 1017,
        "expression": "\\b(public|private|protected|internal)\\b.*(byte|char|short|long|float|int|double|decimal|bool|string)\\b.*(?=,)",
        "raw_prompt": "This regex forces the programmer to make only one decleration per line.",
        "refined_prompt": "\nMatch examples:\n- \"private int height, width;\"\nNon-match examples:\n- \"private int height;\"",
        "matches": [
            "private int height, width;"
        ],
        "non_matches": [
            "private int height;"
        ],
        "stress_tests": []
    },
    {
        "id": 1018,
        "expression": "((\\bm_[a-zA-Z\\d]*\\b)|(\\bin_[a-zA-Z\\d]*\\b)|(\\bin _[a-zA-Z\\d]*\\b))",
        "raw_prompt": "This regex limits the use of any special prefix characters to indicate that the variable is scoped to the class.",
        "refined_prompt": "\nMatch examples:\n- \"in_name\"\n- \"m_name\"\nNon-match examples:\n- \"this.name\"",
        "matches": [
            "in_name",
            "m_name"
        ],
        "non_matches": [
            "this.name"
        ],
        "stress_tests": []
    },
    {
        "id": 1019,
        "expression": "\\binterface\\b.*(\\bI[_]\\w*\\b)",
        "raw_prompt": "This regex forbids the use of underscore in the interface decleration.",
        "refined_prompt": "\nMatch examples:\n- \"interface I_Point\"\nNon-match examples:\n- \"interface IPoint\"",
        "matches": [
            "interface I_Point"
        ],
        "non_matches": [
            "interface IPoint"
        ],
        "stress_tests": []
    },
    {
        "id": 1047,
        "expression": "(<[^>]*?tag[^>]*?(?:identify_by)[^>]*>)((?:.*?(?:<[ \\r\\t]*tag[^>]*>?.*?(?:<.*?/.*?tag.*?>)?)*)*)(<[^>]*?/[^>]*?tag[^>]*?>)",
        "raw_prompt": "This Pattern matches a HTML like tag and its closing tag without any childtags, that was identified by an attribute or anything identifiable (?) mark inside the opening tag.\nLook for A as Tag and 1 ans identifier. A greedy expression woulds usualy end at the A 2 closing tag, non-greedy will probably end at the A 3 end tag.\ne.g.:\n&lt;A 1&gt;\n&lt;A 2&gt;\n&lt;A 2&gt;dfgdfg&lt;/A&gt;\n&lt;/A&gt;\n&lt;Z&gt;&lt;/Z&gt;\n&lt;/A&gt;\n&lt;A 3&gt;\n&lt;/A&gt;\nReturns:\n0 Full Match\n1 Whole starttag\n2 Content inside the tag\n3 Whole endtag\nP.S.: I use it in a parser, to find tags and add code to them, without to know the code, the content or any further infomation.",
        "refined_prompt": "\nMatch examples:\n- \"<tag name=\"identify_by\">jskdfjkfb</tag>\"\nNon-match examples:\n- \"have a look at the description.\"",
        "matches": [
            "<tag name=\"identify_by\">jskdfjkfb</tag>"
        ],
        "non_matches": [
            "have a look at the description."
        ],
        "stress_tests": []
    },
    {
        "id": 1049,
        "expression": "(?<=(?:\\\\))[a-zA-Z0-9\\-\\s_]*(?=(?:\\.\\w*$))",
        "raw_prompt": "WINDOWS ONLY\nUseful to get the filename whenever you get it from anysource, recommended for non-critical filename-dependant applications.",
        "refined_prompt": "\nMatch examples:\n- \"c:\\program files\\anyfolder\\file.xls\"\n- \"c:\\program files\\any.folder\\file with weird name_.xls\"\nNon-match examples:\n- \"c:\\program files\\anyfolder\\file*.xls\"\n- \"c:\\program files\\anyfolder\\file?.xls\"",
        "matches": [
            "c:\\program files\\anyfolder\\file.xls",
            "c:\\program files\\any.folder\\file with weird name_.xls"
        ],
        "non_matches": [
            "c:\\program files\\anyfolder\\file*.xls",
            "c:\\program files\\anyfolder\\file?.xls",
            "c:\\program files\\anyfo"
        ],
        "stress_tests": []
    },
    {
        "id": 1051,
        "expression": "&lt;!\\[CDATA\\[([^\\]]*)\\]\\]&gt;",
        "raw_prompt": "for getting cdata from and xml document.\ncdata returns in $1.\nit's not perfect as you can see from the non-matching examples. improvements needed - but this works for most scenario's.",
        "refined_prompt": "\nMatch examples:\n- \"&lt;![CDATA[ gobbledy gook ]]&gt;\"\n- \"&lt;![CDATA[ gobbledy &amp; more gook ]]&gt;\"\nNon-match examples:\n- \"&lt;![CDATA[ gobbledy ] gook ]]&gt;\"\n- \"&lt;![CDATA[ gobbledy ]] gook ]]&gt;\"",
        "matches": [
            "&lt;![CDATA[ gobbledy gook ]]&gt;",
            "&lt;![CDATA[ gobbledy &amp; more gook ]]&gt;"
        ],
        "non_matches": [
            "&lt;![CDATA[ gobbledy ] gook ]]&gt;",
            "&lt;![CDATA[ gobbledy ]] gook ]]&gt;"
        ],
        "stress_tests": []
    },
    {
        "id": 1053,
        "expression": "\\s(type|name|value)=(?:(\\w+)|(?:&quot;(.*?)&quot;)|(?:\\'(.*)\\'))",
        "raw_prompt": "Returns the three most important attributes from an HTML &lt;input&gt; tag: 'type', 'name' and 'value'. Supports attribute values that are double- or single-quoted or unquoted. Returns four references, the first being the name of the attribute, and the other three being the value, of which only one will be populated based on the way the value was quoted.",
        "refined_prompt": "\nMatch examples:\n- \"&lt;input type=&quot;text&quot; value='somevalue' name=fred&gt;\"\nNon-match examples:\n- \"Any attributes that aren't &quot;type&quot;, &quot;name&quot;, or &quot;value&quot;\"",
        "matches": [
            "&lt;input type=&quot;text&quot; value='somevalue' name=fred&gt;"
        ],
        "non_matches": [
            "Any attributes that aren't &quot;type&quot;, &quot;name&quot;, or &quot;value&quot;"
        ],
        "stress_tests": []
    },
    {
        "id": 1058,
        "expression": "&lt;select(.|\\n)*?selected(.|\\n)*?&gt;(.*?)&lt;/option&gt;(.|\\n)*?&lt;/select&gt;",
        "raw_prompt": "All useful examples are multi-line, so not displayed.\nthis will match any &lt;select&gt;&lt;/select&gt; block in an HTML document, and the return $3 will contain the displayed text (NOT the value of the displayed option)",
        "refined_prompt": "\nMatch examples:\n- \"&lt;select&gt;&lt;option selected&gt;returned text&lt;/option&gt;&lt;/select&gt;\"\nNon-match examples:\n- \"&lt;select&gt;&lt;option&gt;returned text&lt;/option&gt;&lt;/select&gt;\"",
        "matches": [
            "&lt;select&gt;&lt;option selected&gt;returned text&lt;/option&gt;&lt;/select&gt;"
        ],
        "non_matches": [
            "&lt;select&gt;&lt;option&gt;returned text&lt;/option&gt;&lt;/select&gt;"
        ],
        "stress_tests": []
    },
    {
        "id": 1059,
        "expression": "&lt;textarea(.|\\n)*?&gt;((.|\\n)*?)&lt;/textarea&gt;",
        "raw_prompt": "Matches any textarea block, and returns the text inside it.",
        "refined_prompt": "\nMatch examples:\n- \"&lt;textarea&gt;return&lt;/textarea&gt;\"\nNon-match examples:\n- \"&lt;textarea&gt;returned &lt;/improperTextareaEndTag&gt;\"",
        "matches": [
            "&lt;textarea&gt;return&lt;/textarea&gt;"
        ],
        "non_matches": [
            "&lt;textarea&gt;returned &lt;/improperTextareaEndTag&gt;"
        ],
        "stress_tests": []
    },
    {
        "id": 1062,
        "expression": "^((67\\d{2})|(4\\d{3})|(5[1-5]\\d{2})|(6011))-?\\s?\\d{4}-?\\s?\\d{4}-?\\s?\\d{4}|3[4,7]\\d{13}$",
        "raw_prompt": "Credit Card Matching - Matches Switch, Solo, Visa, MasterCard and Discover. Matches length and valid prefix. Accepts input optional spaces and dashes between number groups",
        "refined_prompt": "\nMatch examples:\n- \"5154-1234-1234-1342\"\n- \"4444333322221111\"\n- \"6767 1111 1111 1111\"\nNon-match examples:\n- \"1234123412341234\"\n- \"1111111\"",
        "matches": [
            "5154-1234-1234-1342",
            "4444333322221111",
            "6767 1111 1111 1111"
        ],
        "non_matches": [
            "1234123412341234",
            "1111111",
            "987654321"
        ],
        "stress_tests": []
    },
    {
        "id": 1063,
        "expression": "^((67\\d{2})|(4\\d{3})|(5[1-5]\\d{2})|(6011))(-?\\s?\\d{4}){3}|(3[4,7])\\d{2}-?\\s?\\d{6}-?\\s?\\d{5}$",
        "raw_prompt": "Credit Card Validation. Matches Switch/Solo, Visa, MasterCard and Discover in 4-4-4-4/4 4 4 4/4444 format and Amex in 4-6-5/4 6 5/465 format.\nIncludes checks for prefixes, (67 for switch/solo, 4 for visa, 51-55 for MasterCard, 37/34 for Amex and 6011 for Discover.\nMatches all major UK debit and credit cards with spaces dashes or as a continous number",
        "refined_prompt": "\nMatch examples:\n- \"4234 1234 1234 1234\"\n- \"5434123412341234\"\n- \"3712 123456 12345\"\nNon-match examples:\n- \"1234123412341234\"\n- \"1111111\"",
        "matches": [
            "4234 1234 1234 1234",
            "5434123412341234",
            "3712 123456 12345"
        ],
        "non_matches": [
            "1234123412341234",
            "1111111",
            "987654321"
        ],
        "stress_tests": []
    },
    {
        "id": 1064,
        "expression": "[^(\\&amp;)](\\w*)+(\\=)[\\w\\d ]*",
        "raw_prompt": "Query string parser matches and tokenizes each name/value pair for a valid query string.",
        "refined_prompt": "\nMatch examples:\n- \"name1=value1&amp;name2=value2&amp;...\"\nNon-match examples:\n- \"anyoldstring\"",
        "matches": [
            "name1=value1&amp;name2=value2&amp;..."
        ],
        "non_matches": [
            "anyoldstring"
        ],
        "stress_tests": []
    },
    {
        "id": 1066,
        "expression": "\\\\red([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\\\green([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\\\blue([01]?\\d\\d?|2[0-4]\\d|25[0-5]);",
        "raw_prompt": "This RegEx will match a RTF color taken from a color tabel in a RTF document (having the form '\\redXXX\\greenXXX\\blueXXX;', where XXX is a number between 0 and 255).",
        "refined_prompt": "\nMatch examples:\n- \"\\red76\\green157\\blue76;\"\n- \"\\red0\\green0\\blue0;\"\n- \"\\red120\\green120\\blue120;\"\nNon-match examples:\n- \"\\red0\\green\\257\\blue120;\"\n- \"\\red0\\green0\\blue0\"",
        "matches": [
            "\\red76\\green157\\blue76;",
            "\\red0\\green0\\blue0;",
            "\\red120\\green120\\blue120;"
        ],
        "non_matches": [
            "\\red0\\green\\257\\blue120;",
            "\\red0\\green0\\blue0",
            "red120\\green120\\blue120;"
        ],
        "stress_tests": []
    },
    {
        "id": 1068,
        "expression": "&lt;script[\\s\\S]*?&lt;/script([\\s\\S]*?)&gt;",
        "raw_prompt": "This pattern is intended to remove all javascript blocks from a chunk of code. EDIT: a bug is cutting off additional matches.",
        "refined_prompt": "\nMatch examples:\n- \"&lt;script language=&quot;Javascript&quot;&gt;&lt;!-- alert(); --&gt;&lt;/script&gt;\"\nNon-match examples:\n- \"&lt;script&gt;\"",
        "matches": [
            "&lt;script language=&quot;Javascript&quot;&gt;&lt;!-- alert(); --&gt;&lt;/script&gt;"
        ],
        "non_matches": [
            "&lt;script&gt;"
        ],
        "stress_tests": []
    },
    {
        "id": 1070,
        "expression": "([,!@#$%^&*()\\[\\]]+|\\\\\\.\\.|\\\\\\\\\\.|\\.\\.\\\\\\|\\.\\\\\\|\\.\\.\\/|\\.\\/|\\/\\.\\.|\\/\\.|;|(?<![A-Z]):)",
        "raw_prompt": "Checks file paths for offending characters\nA successful file path is one that does not return a match",
        "refined_prompt": "\nMatch examples:\n- \"C:\\invalid\\#path\\here,\\somewhere\"\n- \"/invalid/^path/@here/\"\n- \"C:\\..\\relative\\not\\allowed\"\nNon-match examples:\n- \"C:\\valid\\path\\file.txt\"\n- \"/home/user/valid/file.txt\"",
        "matches": [
            "C:\\invalid\\#path\\here,\\somewhere",
            "/invalid/^path/@here/",
            "C:\\..\\relative\\not\\allowed"
        ],
        "non_matches": [
            "C:\\valid\\path\\file.txt",
            "/home/user/valid/file.txt"
        ],
        "stress_tests": []
    },
    {
        "id": 1074,
        "expression": "(?i:[aeiou]+)\\B",
        "raw_prompt": "This regular expression matches all interior vowels.\nIf used as a replace, the following strings would result:\nLets meet tomorrow -&gt; Lts mt tmrrw\nPlease come to my party -&gt; Plse cme to my prty\nI like your style -&gt; I lke yr style",
        "refined_prompt": "\nMatch examples:\n- \"remove all interior vowels\"\nNon-match examples:\n- \"A\"",
        "matches": [
            "remove all interior vowels"
        ],
        "non_matches": [
            "A"
        ],
        "stress_tests": []
    },
    {
        "id": 1090,
        "expression": "^[0-9]*\\/{1}[1-9]{1}[0-9]*$",
        "raw_prompt": "This regular expression checks if the given string is a fraction. This does not allow 0 either in the numerator or the denominator.",
        "refined_prompt": "\nMatch examples:\n- \"1/2\"\n- \"12/325\"\nNon-match examples:\n- \"-1/2\"\n- \"2se/4rf\"",
        "matches": [
            "1/2",
            "12/325"
        ],
        "non_matches": [
            "-1/2",
            "2se/4rf"
        ],
        "stress_tests": []
    },
    {
        "id": 1091,
        "expression": "^\\\\\\\\[\\w-]+\\\\(([\\w()-][\\w\\s()-]*[\\w()-]+)|([\\w()-]+))\\$?(\\\\(([\\w()-][\\w\\s()-]*[\\w()-]+)|([\\w()-]+)))*\\\\?$",
        "raw_prompt": "Validation of a directory (not file) in UNC format\nChecks for \\\\server\\share\\subdir, where subdirs are optional.\nShare may have a $, but only at the end.\nShares and subdir may have embedded spaces.\nString may optionally have a trailing slash.",
        "refined_prompt": "\nMatch examples:\n- \"\\\\server\\my share\\my subdir\"\n- \"\\\\server\\my share$\\\"\n- \"\\\\server\\my share\\subdir1\\subdir2\\\"\nNon-match examples:\n- \"c:\\subdir\"\n- \"\\\\my server\\share$\"",
        "matches": [
            "\\\\server\\my share\\my subdir",
            "\\\\server\\my share$\\",
            "\\\\server\\my share\\subdir1\\subdir2\\"
        ],
        "non_matches": [
            "c:\\subdir",
            "\\\\my server\\share$",
            "\\\\myserver\\share\\subdir\\file.ext"
        ],
        "stress_tests": []
    },
    {
        "id": 1092,
        "expression": "(?:-(?!0))?\\d+(?:(?: \\d+)?/\\d+)?",
        "raw_prompt": "This regexp matches string which represents a fraction.\nThis fraction can be in these forms:<br />\n1. # or -# (not -0)<br />\n2. #/# or -#/# (not -0/#)<br />\n3. # #/# or -# #/# (not -0 #/#)",
        "refined_prompt": "\nMatch examples:\n- \"-1, 1, -1/2, 1/2, -1 2/3, 1 2/3\"\n- \"0, 0/1, 1/0, 1 0/2, 1 2/0\"\nNon-match examples:\n- \"letters\"\n- \"negative zero\"",
        "matches": [
            "-1, 1, -1/2, 1/2, -1 2/3, 1 2/3",
            "0, 0/1, 1/0, 1 0/2, 1 2/0"
        ],
        "non_matches": [
            "letters",
            "negative zero",
            "/",
            "#/",
            "/#",
            "# /",
            "# #/",
            "# /#"
        ],
        "stress_tests": []
    },
    {
        "id": 1094,
        "expression": "^(0|([1-9]\\d{0,3}|[1-5]\\d{4}|[6][0-5][0-5]([0-2]\\d|[3][0-5])))$",
        "raw_prompt": "Matches TCP port numbers from 0 to 65535. Other than '0', no leading 0's are accepted.",
        "refined_prompt": "\nMatch examples:\n- \"0\"\n- \"1000\"\n- \"65535\"\nNon-match examples:\n- \"65536\"\n- \"99999\"",
        "matches": [
            "0",
            "1000",
            "65535"
        ],
        "non_matches": [
            "65536",
            "99999",
            "0123"
        ],
        "stress_tests": []
    },
    {
        "id": 1095,
        "expression": "^((25[0-4]|(2[0-4]|1[0-9]|[1-9]?)[0-9]\\.){3}(25[0-4]|(2[0-4]|1[0-9]|[1-9]?)[0-9]))$",
        "raw_prompt": "This Regular Expression matches all valid ip-patterns.\n01.02.03.04 is not matched, as leading zeros is not valid a ip-pattern.\n255.255.255.0 is not matched, as 255 is a broadcast identifier, and as such not allowed in ip-patterns.",
        "refined_prompt": "\nMatch examples:\n- \"192.168.10.4\"\n- \"130.225.56.40\"\n- \"127.0.0.1\"\nNon-match examples:\n- \"01.02.03.04\"\n- \"255.255.255.0\"",
        "matches": [
            "192.168.10.4",
            "130.225.56.40",
            "127.0.0.1"
        ],
        "non_matches": [
            "01.02.03.04",
            "255.255.255.0",
            "abc.def.ghi.jkl"
        ],
        "stress_tests": []
    },
    {
        "id": 1096,
        "expression": "^((CN=(['\\w\\d\\s\\-\\&amp;\\.]+(\\\\/)*(\\\\,)*)+,\\s*)*(OU=(['\\w\\d\\s\\-\\&amp;\\.]+(\\\\/)*(\\\\,)*)+,\\s*)*(DC=['\\w\\d\\s\\-\\&amp;]+[,]*\\s*){1,}(DC=['\\w\\d\\s\\-\\&amp;]+\\s*){1})$",
        "raw_prompt": "Matches LDAP path (AdsPath) in Active Directory. Modified version of regex which has been found in library.\nAccepts spaces after , character. Also \\/ and \\, sequences (escapes) in CN or OU name are accepted.",
        "refined_prompt": "\nMatch examples:\n- \"CN=John Smith, OU=Acc, DC=acme, DC=com\"\n- \"CN=John\\, Smith US\\/EXT, OU=Acc, DC=acme ,DC=com\"\nNon-match examples:\n- \"CN=John Smith, OU=Acc, DC=acme\"\n- \"CN=John\\, Smith\\, OU=Acc, DC=acme, DC=com\"",
        "matches": [
            "CN=John Smith, OU=Acc, DC=acme, DC=com",
            "CN=John\\, Smith US\\/EXT, OU=Acc, DC=acme ,DC=com"
        ],
        "non_matches": [
            "CN=John Smith, OU=Acc, DC=acme",
            "CN=John\\, Smith\\, OU=Acc, DC=acme, DC=com"
        ],
        "stress_tests": []
    },
    {
        "id": 1098,
        "expression": "[ ]*=[ ]*[\\&quot;]*cid[ ]*:[ ]*([^\\&quot;&lt;&gt; ]+)",
        "raw_prompt": "This is a Microsoft .NET/Mono regular expression that can be used to find the address of an embedded image inside an HTML email body.\nThe address will be the 2nd group found in the match.",
        "refined_prompt": "\nMatch examples:\n- \"&lt;img src=&quot;cid:00a601c57cba$14028d40$ed5cc23e&quot;&gt;\"\n- \"background=cid:034701c5d97f$7c12fba\"\nNon-match examples:\n- \"&lt;img src=&quot;no.jpg&quot;&gt;\"",
        "matches": [
            "&lt;img src=&quot;cid:00a601c57cba$14028d40$ed5cc23e&quot;&gt;",
            "background=cid:034701c5d97f$7c12fba"
        ],
        "non_matches": [
            "&lt;img src=&quot;no.jpg&quot;&gt;"
        ],
        "stress_tests": []
    },
    {
        "id": 1099,
        "expression": "^(([a-zA-Z]:)|(\\\\{2}\\w+)\\$?)(\\\\(\\w[\\w ]*.*))+\\.((html|HTML)|(htm|HTM))$",
        "raw_prompt": "Path of files HTML and HTM",
        "refined_prompt": "\nMatch examples:\n- \"c:\\arquivo.html\"\n- \"\\\\home\\arquivo232.HTML\"\n- \"Z:\\teste.htm\"\nNon-match examples:\n- \"c:\\arquivo.png\"\n- \"arquivo232.HTML\"",
        "matches": [
            "c:\\arquivo.html",
            "\\\\home\\arquivo232.HTML",
            "Z:\\teste.htm"
        ],
        "non_matches": [
            "c:\\arquivo.png",
            "arquivo232.HTML",
            "Z:\\teste"
        ],
        "stress_tests": []
    },
    {
        "id": 1101,
        "expression": "\\s?\\b((?!\\b50\\b|\\b00\\b)\\w*)\\b\\s?",
        "raw_prompt": "This Expression exclude any word/code from a sentence.\nTo find out all the words except any specific codes/words use this. In this example we will exclude 50 and 00 and find all other words in the sentence.\nExample Text: &quot;Ask me 50 00 times&quot;\nMatches:Ask,me,times\nHere it ignores 50 and 00 and matches the other words. Modify according to your needs. I excluded 50 or 00.",
        "refined_prompt": "\nMatch examples:\n- \"ask me 50 times\"\n- \"ask me 00 times\"\n- \"ask me 50 00 times\"\nNon-match examples:\n- \"..\"\n- \"..\"",
        "matches": [
            "ask me 50 times",
            "ask me 00 times",
            "ask me 50 00 times"
        ],
        "non_matches": [
            "..",
            "..",
            ".."
        ],
        "stress_tests": []
    },
    {
        "id": 1103,
        "expression": "^(([+]31|0031)\\s\\(0\\)([0-9]{9})|([+]31|0031)\\s0([0-9]{9})|0([0-9]{9}))$",
        "raw_prompt": "Expression to check Dutch phone numbers. Number must start with zero and number of digits should be 10. Different area and country codes are allowed.",
        "refined_prompt": "\nMatch examples:\n- \"+31 0205315386\"\n- \"0031 (0)205315386\"\n- \"0205315386\"\nNon-match examples:\n- \"020531538\"\n- \"1205315386\"",
        "matches": [
            "+31 0205315386",
            "0031 (0)205315386",
            "0205315386"
        ],
        "non_matches": [
            "020531538",
            "1205315386",
            "020531538677"
        ],
        "stress_tests": []
    },
    {
        "id": 1104,
        "expression": "^[0-9]{10}$|^\\(0[1-9]{1}\\)[0-9]{8}$|^[0-9]{8}$|^[0-9]{4}[ ][0-9]{3}[ ][0-9]{3}$|^\\(0[1-9]{1}\\)[ ][0-9]{4}[ ][0-9]{4}$|^[0-9]{4}[ ][0-9]{4}$",
        "raw_prompt": "Australian phone numbers including Mobiles and common spacing used. This is used only to test normal contact numbers for residential purposes for example not information lines like 139999.\nOther Matching:\n9999999999, 9999 9999, (09)99999999",
        "refined_prompt": "\nMatch examples:\n- \"9999 999 999\"\n- \"(09) 9999 9999\"\n- \"99999999\"\nNon-match examples:\n- \"99999999999\"\n- \"9999999\"",
        "matches": [
            "9999 999 999",
            "(09) 9999 9999",
            "99999999"
        ],
        "non_matches": [
            "99999999999",
            "9999999",
            "(99)99999999"
        ],
        "stress_tests": []
    },
    {
        "id": 1105,
        "expression": "^(N[BLSTU]|[AMN]B|[BQ]C|ON|PE|SK)$",
        "raw_prompt": "Matches Canadian provincial codes. Similar to the one already posted but smaller, faster, and will correctly return the results in one match group rather than using several so it's much friendlier.",
        "refined_prompt": "\nMatch examples:\n- \"ON\"\n- \"PE\"\n- \"NB\"\nNon-match examples:\n- \"OB\"\n- \"NM\"",
        "matches": [
            "ON",
            "PE",
            "NB"
        ],
        "non_matches": [
            "OB",
            "NM"
        ],
        "stress_tests": []
    },
    {
        "id": 1107,
        "expression": "^(0?[1-9]|1[012])$",
        "raw_prompt": "This will match numbers between 0 and 12. The 0? at the beginning will allow &quot;01&quot; as a valid match. This is useful for validation the month only component of a date part.",
        "refined_prompt": "\nMatch examples:\n- \"05\"\n- \"5\"\n- \"12\"\nNon-match examples:\n- \"0\"\n- \"1a\"",
        "matches": [
            "05",
            "5",
            "12"
        ],
        "non_matches": [
            "0",
            "1a",
            "13"
        ],
        "stress_tests": []
    },
    {
        "id": 1108,
        "expression": "^([12]?[0-9]|3[01])$",
        "raw_prompt": "This will match numbers in the range 1-31. This is useful for matching the day component of a datetime part.",
        "refined_prompt": "\nMatch examples:\n- \"1\"\n- \"20\"\n- \"31\"\nNon-match examples:\n- \"1a\"\n- \"32\"",
        "matches": [
            "1",
            "20",
            "31"
        ],
        "non_matches": [
            "1a",
            "32",
            "01"
        ],
        "stress_tests": []
    },
    {
        "id": 1109,
        "expression": "^((18[5-9][0-9])|((19|20)[0-9]{2})|(2100))$",
        "raw_prompt": "Will check to ensure the data is between 1850 and 2100.",
        "refined_prompt": "\nMatch examples:\n- \"1850\"\n- \"1977\"\n- \"2100\"\nNon-match examples:\n- \"1800\"\n- \"a\"",
        "matches": [
            "1850",
            "1977",
            "2100"
        ],
        "non_matches": [
            "1800",
            "a",
            "2101"
        ],
        "stress_tests": []
    },
    {
        "id": 1117,
        "expression": "\\b(((?!\\d\\d\\d)\\d+|1\\d\\d|2[0-4]\\d|25[0-5])(\\b|\\.)){4}",
        "raw_prompt": "match valid ip",
        "refined_prompt": "\nMatch examples:\n- \"192.168.0.1\"\n- \"10.0.0.255\"\n- \"211.100.0.0\"\nNon-match examples:\n- \"192.256.0.1\"\n- \"10.0.0.256\"",
        "matches": [
            "192.168.0.1",
            "10.0.0.255",
            "211.100.0.0"
        ],
        "non_matches": [
            "192.256.0.1",
            "10.0.0.256",
            "211.100.0.1000"
        ],
        "stress_tests": []
    },
    {
        "id": 1121,
        "expression": "^(\\w+=[^\\s,=]+,)*(\\w+=[^\\s,=]+,?)?$",
        "raw_prompt": "validate comma separated key/value pair",
        "refined_prompt": "\nMatch examples:\n- \"foo=bar\"\n- \"foo1=bar1,foo2=bar2\"\n- \"foo1=bar1,foo2=bar2,\"\nNon-match examples:\n- \"foo=\"\n- \"foo1=bar1 foo2=bar2\"",
        "matches": [
            "foo=bar",
            "foo1=bar1,foo2=bar2",
            "foo1=bar1,foo2=bar2,"
        ],
        "non_matches": [
            "foo=",
            "foo1=bar1 foo2=bar2",
            "foo1=bar1foo2=bar2"
        ],
        "stress_tests": []
    },
    {
        "id": 1124,
        "expression": "^(((((0[1-9])|(1\\d)|(2[0-8]))\\/((0[1-9])|(1[0-2])))|((31\\/((0[13578])|(1[02])))|((29|30)\\/((0[1,3-9])|(1[0-2])))))\\/((20[0-9][0-9])|(19[0-9][0-9])))|((29\\/02\\/(19|20)(([02468][048])|([13579][26]))))$",
        "raw_prompt": "matches a date in dd/mm/yyyy format",
        "refined_prompt": "\nMatch examples:\n- \"01/01/2001\"\n- \"29/02/2004\"\nNon-match examples:\n- \"32/12/2001\"\n- \"29/02/2005\"",
        "matches": [
            "01/01/2001",
            "29/02/2004"
        ],
        "non_matches": [
            "32/12/2001",
            "29/02/2005",
            "05/13/2005"
        ],
        "stress_tests": []
    },
    {
        "id": 1125,
        "expression": "^(0|(-?(((0|[1-9]\\d*)\\.\\d+)|([1-9]\\d*))))$",
        "raw_prompt": "matches a double number",
        "refined_prompt": "\nMatch examples:\n- \"-0.5\"\n- \"0.01\"\n- \"15\"\nNon-match examples:\n- \"01\"\n- \"0.2.2\"",
        "matches": [
            "-0.5",
            "0.01",
            "15"
        ],
        "non_matches": [
            "01",
            "0.2.2",
            "+5"
        ],
        "stress_tests": []
    },
    {
        "id": 1134,
        "expression": "^(([A-Za-z]+[^0-9]*)([0-9]+[^\\W]*)([\\W]+[\\W0-9A-Za-z]*))|(([A-Za-z]+[^\\W]*)([\\W]+[^0-9]*)([0-9]+[\\W0-9A-Za-z]*))|(([\\W]+[^A-Za-z]*)([A-Za-z]+[^0-9]*)([0-9]+[\\W0-9A-Za-z]*))|(([\\W]+[^0-9]*)([0-9]+[^A-Za-z]*)([A-Za-z]+[\\W0-9A-Za-z]*))|(([0-9]+[^A-Za-z]*)([A-Za-z]+[^\\W]*)([\\W]+[\\W0-9A-Za-z]*))|(([0-9]+[^\\W]*)([\\W]+[^A-Za-z]*)([A-Za-z]+[\\W0-9A-Za-z]*))$",
        "raw_prompt": "Password with minimum 1 Letter (A-Za-z), 1 Number (0-9) and Special Character (\\W). It doesn't matter the charaters position. See the Mathching Examples.\nQuestion? Write an Email to me.",
        "refined_prompt": "\nMatch examples:\n- \"test22!!\"\n- \"!!test22\"\n- \"22!!test\"\nNon-match examples:\n- \"test22\"\n- \"!!test\"",
        "matches": [
            "test22!!",
            "!!test22",
            "22!!test"
        ],
        "non_matches": [
            "test22",
            "!!test",
            "22!!"
        ],
        "stress_tests": []
    },
    {
        "id": 1135,
        "expression": "(^(\\d+)$)|(^(\\d{1,3}[ ,\\.](\\d{3}[ ,\\.])*\\d{3}|\\d{1,3})$)",
        "raw_prompt": "Searches for number greater than 0 with thousand delimiter as space, comma or period.",
        "refined_prompt": "\nMatch examples:\n- \"1 234 567\"\n- \"1.234.567.890\"\n- \"1,234\"\nNon-match examples:\n- \"-12,990\"\n- \"100.03\"",
        "matches": [
            "1 234 567",
            "1.234.567.890",
            "1,234"
        ],
        "non_matches": [
            "-12,990",
            "100.03",
            "0,05"
        ],
        "stress_tests": []
    },
    {
        "id": 1138,
        "expression": "(\\s)*(int|void|float|char|double|string)((\\s)|(\\*))*(\\&?)(\\s)+([a-z])([a-z0-9])*(\\s)*(\\()(\\s)*((int|void|float|char|double|string)((\\s)|(\\*))*(\\&?)(\\s)+([a-z])([a-z0-9])*((\\s)*[,](\\s)*(int|void|float|char|double|string)((\\s)|(\\*))*(\\&?)(\\s)+([a-z])([a-z0-9])*)*)?(\\s)*(\\))(\\s)*;",
        "raw_prompt": "C++ prototipes.\nIt is necessary to write a \\s before a variable or function\nidentifier.",
        "refined_prompt": "\nMatch examples:\n- \"int * suma(int & x, float * p, string cad) ; )\"\n- \"char one();\"\n- \"float * poo(int o);\"\nNon-match examples:\n- \"string *p();\"",
        "matches": [
            "int * suma(int & x, float * p, string cad) ; )",
            "char one();",
            "float * poo(int o);"
        ],
        "non_matches": [
            "string *p();"
        ],
        "stress_tests": []
    },
    {
        "id": 1139,
        "expression": "(?:/\\*[\\w\\W]*?\\*/|//[^\\n]*?$|\\#[^\\n]*?$)",
        "raw_prompt": "Return all comment lines (starts with //) and regions (serounded by /* */) as well as compiler arguments (#) in C# code",
        "refined_prompt": "\nMatch examples:\n- \"// some comment\"\n- \"#region myRegion\"\n- \"/* other comment */\"\nNon-match examples:\n- \"for(int i = 0; i &lt; 10; i++)\"\n- \"[XmlAttribute(&quot;somthing_else&quot;)\"",
        "matches": [
            "// some comment",
            "#region myRegion",
            "/* other comment */"
        ],
        "non_matches": [
            "for(int i = 0; i &lt; 10; i++)",
            "[XmlAttribute(&quot;somthing_else&quot;)",
            "String name = &quot;MyNa"
        ],
        "stress_tests": []
    },
    {
        "id": 1145,
        "expression": "(0[289][0-9]{2})|([1345689][0-9]{3})|(2[0-8][0-9]{2})|(290[0-9])|(291[0-4])|(7[0-4][0-9]{2})|(7[8-9][0-9]{2})",
        "raw_prompt": "Accurate Australian postal code verification.\nAustralia has 4-digit numeric postal codes with the following state based specific ranges.\nACT: 0200-0299 and 2600-2639.\nNSW: 1000-1999, 2000-2599 and 2640-2914.\nNT: 0900-0999 and 0800-0899.\nQLD: 9000-9999 and 4000-4999.\nSA: 5000-5999.\nTAS: 7800-7999 and 7000-7499.\nVIC: 8000-8999 and 3000-3999.\nWA: 6800-6999 and 6000-6799.",
        "refined_prompt": "\nMatch examples:\n- \"0200\"\n- \"7312\"\n- \"2415\"\nNon-match examples:\n- \"0300\"\n- \"7612\"",
        "matches": [
            "0200",
            "7312",
            "2415"
        ],
        "non_matches": [
            "0300",
            "7612",
            "2915"
        ],
        "stress_tests": []
    },
    {
        "id": 1146,
        "expression": "([ABCEGHJKLMNPRSTVXY][0-9][ABCEGHJKLMNPRSTVWXYZ])\\ ?([0-9][ABCEGHJKLMNPRSTVWXYZ][0-9])",
        "raw_prompt": "Accurate Canadian postal code format verification.\nThe format of a Canadian postal code is LDL DLD where L are alpha characters and D are numeric digits. But there are some exceptions. The letters D, F, I, O, Q and U never appear in a postal code because of their visual similarity to 0, E, 1, 0, 0, and V respectively. In addition to avoiding the six &quot;forbidden&quot; letters W and Z also do not appear as the first letter of a postal code (at least not at present).",
        "refined_prompt": "\nMatch examples:\n- \"M1R 4B0\"\n- \"L0R 1B1\"\n- \"L0R1B9\"\nNon-match examples:\n- \"W1R 4B0\"\n- \"L0R 1D1\"",
        "matches": [
            "M1R 4B0",
            "L0R 1B1",
            "L0R1B9"
        ],
        "non_matches": [
            "W1R 4B0",
            "L0R 1D1",
            "LOR1B9"
        ],
        "stress_tests": []
    },
    {
        "id": 1147,
        "expression": "((0[13-7]|1[1235789]|[257][0-9]|3[0-35-9]|4[0124-9]|6[013-79]|8[0124-9]|9[0-5789])[0-9]{3}|10([2-9][0-9]{2}|1([2-9][0-9]|11[5-9]))|14([01][0-9]{2}|715))",
        "raw_prompt": "Accurate German postal code verification.\nGermany has 5-digit numeric postal codes. The expression evaluates a postal code within state based specific ranges.",
        "refined_prompt": "\nMatch examples:\n- \"01125\"\nNon-match examples:\n- \"34125\"",
        "matches": [
            "01125"
        ],
        "non_matches": [
            "34125"
        ],
        "stress_tests": []
    },
    {
        "id": 1148,
        "expression": "(([A-Z]{1,2}[0-9][0-9A-Z]?)\\ ([0-9][A-Z]{2}))|(GIR\\ 0AA)",
        "raw_prompt": "Accurate UK postal code format verification.\nUK postal codes have two parts. The right part is formatted as DLL (L:letter D:digit) and the left part has six alternative formats: LD, LDL, LDD, LLD, LLDL and LLDD. There is only one exception to these formats: GIR 0AA.",
        "refined_prompt": "\nMatch examples:\n- \"M2 5BQ\"\n- \"EC1A 1HQ\"\n- \"GIR 0AA\"\nNon-match examples:\n- \"M2 BQ5\"\n- \"E31A 1HQ\"",
        "matches": [
            "M2 5BQ",
            "EC1A 1HQ",
            "GIR 0AA"
        ],
        "non_matches": [
            "M2 BQ5",
            "E31A 1HQ",
            "GIR0AA"
        ],
        "stress_tests": []
    },
    {
        "id": 1164,
        "expression": "(NL-?)?[0-9]{9}B[0-9]{2}",
        "raw_prompt": "VAT Numbers format verification (The Netherlands) with support for optional member state definition.",
        "refined_prompt": "\nMatch examples:\n- \"NL123456789B12\"\nNon-match examples:\n- \"NL123456789012\"",
        "matches": [
            "NL123456789B12"
        ],
        "non_matches": [
            "NL123456789012"
        ],
        "stress_tests": []
    },
    {
        "id": 1165,
        "expression": "^\\s*([\\(]?)\\[?\\s*\\d{3}\\s*\\]?[\\)]?\\s*[\\-]?[\\.]?\\s*\\d{3}\\s*[\\-]?[\\.]?\\s*\\d{4}$",
        "raw_prompt": "US 10-Digit Phone number matching.\n*Requires Area Code\n*Brackets optional, supports: () and []\n*seperators optional, supports: - and .\n*whitespace optional",
        "refined_prompt": "\nMatch examples:\n- \"6105551515\"\n- \"(610) 555 - 1212\"\n- \"[610]555.1212\"\nNon-match examples:\n- \"1 (610) 555-1212\"\n- \"(610) 555-1212 ext*\"",
        "matches": [
            "6105551515",
            "(610) 555 - 1212",
            "[610]555.1212"
        ],
        "non_matches": [
            "1 (610) 555-1212",
            "(610) 555-1212 ext*"
        ],
        "stress_tests": []
    },
    {
        "id": 1167,
        "expression": "^(([a-zA-Z0-9]+([\\-])?[a-zA-Z0-9]+)+(\\.)?)+[a-zA-Z]{2,6}$",
        "raw_prompt": "Checks domain names. This will match all of the valid domains. It will accept TLD's that are from 2 to 6 characters. You can not have more then one dash or period next to each other. Also it will not let you have dashes at end of the words.",
        "refined_prompt": "\nMatch examples:\n- \"www.domain.com\"\n- \"your-domain.com\"\n- \"www.sub-domain.your-domain.museum\"\nNon-match examples:\n- \".domain.com\"\n- \"your---domain.com\"",
        "matches": [
            "www.domain.com",
            "your-domain.com",
            "www.sub-domain.your-domain.museum"
        ],
        "non_matches": [
            ".domain.com",
            "your---domain.com",
            "www.-sub-.com"
        ],
        "stress_tests": []
    },
    {
        "id": 1177,
        "expression": "^(([a-zA-Z]+\\d+)|(\\d+[a-zA-Z]+))[a-zA-Z0-9]*$",
        "raw_prompt": "Password validator that validates the password contains 1 letter (regardless of case) and 1 number",
        "refined_prompt": "\nMatch examples:\n- \"Password1\"\n- \"1Password\"\n- \"1Password1\"\nNon-match examples:\n- \"*Password1\"\n- \"*1Password*\"",
        "matches": [
            "Password1",
            "1Password",
            "1Password1"
        ],
        "non_matches": [
            "*Password1",
            "*1Password*",
            "*1Password1*"
        ],
        "stress_tests": []
    },
    {
        "id": 1179,
        "expression": "^((0?[1-9])|((1)[0-1]))?((\\.[0-9]{0,2})?|0(\\.[0-9]{0,2}))$",
        "raw_prompt": "This Regular Expression allows the user to enter a value to represent the imperial measurement of Inches.\nThe expression won't allow and value of 12 or above (otherwise it would be a foot!), and has the option of having a decimal value upto 2 decimal places.\nMy first Regular Expression so go easy on me!! :)",
        "refined_prompt": "\nMatch examples:\n- \"11.99\"\n- \"05.5\"\n- \"5\"\nNon-match examples:\n- \"12\"\n- \"12.00\"",
        "matches": [
            "11.99",
            "05.5",
            "5"
        ],
        "non_matches": [
            "12",
            "12.00",
            "2.587"
        ],
        "stress_tests": []
    },
    {
        "id": 1180,
        "expression": "(?=^.{8,30}$)(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[!@#$%^&amp;*()_+}{&quot;&quot;:;'?/&gt;.&lt;,]).*$",
        "raw_prompt": "Password filter that matches the NSA Password filter DLL ENPASFILT.DLL.\nAt least 1 small-case letter\nAt least 1 Capital letter\nAt least 1 digit\nAt least 1 special character\nLength should be between 8-30 characters.\nSpaces allowed\nThe sequence of the characters is not important.",
        "refined_prompt": "\nMatch examples:\n- \"Pa$$w0rd\"\nNon-match examples:\n- \"Pa$$word\"",
        "matches": [
            "Pa$$w0rd"
        ],
        "non_matches": [
            "Pa$$word"
        ],
        "stress_tests": []
    },
    {
        "id": 1189,
        "expression": "^(?=.*[a-zA-Z].*[a-zA-Z])(?=.*\\d.*\\d)[a-zA-Z0-9]{6,20}$",
        "raw_prompt": "Password matching expression. Password must consists of at least 6 characters and not more than 20 characters. Password must contain only letters and digits. Password must contain at least 2 digits and at least 2 letters.",
        "refined_prompt": "\nMatch examples:\n- \"a1b2c3\"\nNon-match examples:\n- \"aaaaa1\"",
        "matches": [
            "a1b2c3"
        ],
        "non_matches": [
            "aaaaa1"
        ],
        "stress_tests": []
    },
    {
        "id": 1196,
        "expression": "^([\\w]+@([\\w]+\\.)+[a-zA-Z]{2,9}(\\s*;\\s*[\\w]+@([\\w]+\\.)+[a-zA-Z]{2,9})*)$",
        "raw_prompt": "Validates a semi colon delimited list of email addresses. Appropriate for use with .NET Web.Mail.MailMessage fields (To, BCC, CC)",
        "refined_prompt": "\nMatch examples:\n- \"test1@site.sub.edu ;user@site2.com\"\nNon-match examples:\n- \"test1site.sub.edu ;@site2.com\"",
        "matches": [
            "test1@site.sub.edu ;user@site2.com"
        ],
        "non_matches": [
            "test1site.sub.edu ;@site2.com"
        ],
        "stress_tests": []
    },
    {
        "id": 1199,
        "expression": "^(?:(?:[+\\-]?\\$?)|(?:\\$?[+\\-]?))?(?:(?:\\d{1,3}(?:(?:,\\d{3})|(?:\\d))*(?:\\.(?:\\d*|\\d+[eE][+\\-]\\d+))?)|(?:\\.\\d+(?:[eE][+\\-]\\d+)?))$",
        "raw_prompt": "This regex will validate the given string is numeric",
        "refined_prompt": "\nMatch examples:\n- \"$123.1234\"\n- \".123\"\n- \".123e+01\"\nNon-match examples:\n- \"asdf\"\n- \",\"",
        "matches": [
            "$123.1234",
            ".123",
            ".123e+01"
        ],
        "non_matches": [
            "asdf",
            ",",
            "1,1",
            "."
        ],
        "stress_tests": []
    },
    {
        "id": 1209,
        "expression": "^100$|^\\d{0,2}(\\.\\d{1,2})? *%?$",
        "raw_prompt": "It matches % value from 0 - 100. The two decimal places are used.",
        "refined_prompt": "\nMatch examples:\n- \"100\"\n- \"99.99\"\n- \"00\"\nNon-match examples:\n- \"101\"\n- \"22.1111\"",
        "matches": [
            "100",
            "99.99",
            "00",
            "20.99"
        ],
        "non_matches": [
            "101",
            "22.1111"
        ],
        "stress_tests": []
    },
    {
        "id": 1212,
        "expression": "<\\?xml.*</note>",
        "raw_prompt": "This will find any XML within a string starting with the <?xml header and ending with the closing root tag. Replace </note> with your closing root tag. (use singleline and case insensitive) - I use this to pull xml written in a web document.",
        "refined_prompt": "\nMatch examples:\n- \"<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></note>\"\nNon-match examples:\n- \"<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></BADnote>\"",
        "matches": [
            "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></note>"
        ],
        "non_matches": [
            "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></BADnote>"
        ],
        "stress_tests": []
    },
    {
        "id": 1213,
        "expression": "^(([1-4][0-9])|(0[1-9])|(5[0-2]))\\/[1-2]\\d{3}$",
        "raw_prompt": "This pattern can be used to validate a numeric week (between 01 and 52) and four digit year (valid years between 1000 and 2999) separated by a slash in the form of WW/YYYY.",
        "refined_prompt": "\nMatch examples:\n- \"47/2006\"\nNon-match examples:\n- \"00/3005\"",
        "matches": [
            "47/2006"
        ],
        "non_matches": [
            "00/3005"
        ],
        "stress_tests": []
    },
    {
        "id": 1217,
        "expression": "<img[^>]* src=\\\"([^\\\"]*)\\\"[^>]*>",
        "raw_prompt": "It searches for a IMG tag and group information about source of image.",
        "refined_prompt": "\nMatch examples:\n- \"<img src=\"joka.jpg\" /> <img src=\"joka.jpg\">\"\nNon-match examples:\n- \"<img> <img src=dada>\"",
        "matches": [
            "<img src=\"joka.jpg\" /> <img src=\"joka.jpg\">"
        ],
        "non_matches": [
            "<img> <img src=dada>"
        ],
        "stress_tests": []
    },
    {
        "id": 1219,
        "expression": "^((((((0[13578])|(1[02]))[\\s\\.\\-\\/\\\\]?((0[1-9])|([12][0-9])|(3[01])))|(((0[469])|(11))[\\s\\.\\-\\/\\\\]?((0[1-9])|([12][0-9])|(30)))|((02)[\\s\\.\\-\\/\\\\]?((0[1-9])|(1[0-9])|(2[0-8]))))[\\s\\.\\-\\/\\\\]?(((([2468][^048])|([13579][^26]))00)|(\\d\\d\\d[13579])|(\\d\\d[02468][^048])|(\\d\\d[13579][^26])))|(((((0[13578])|(1[02]))[\\s\\.\\-\\/\\\\]?((0[1-9])|([12][0-9])|(3[01])))|(((0[469])|(11))[\\s\\.\\-\\/\\\\]?((0[1-9])|([12][0-9])|(30)))|((02)[\\s\\.\\-\\/\\\\]?((0[1-9])|([12][0-9]))))[\\s\\.\\-\\/\\\\]?(((([2468][048])|([13579][26]))00)|(\\d\\d[2468][048])|(\\d\\d[13579][26])|(\\d\\d0[48]))))$",
        "raw_prompt": "This was made for use in javascript to detect MMDDYYYY formatted text. It tests all valid dates, including 31 vs 30 days in a month and the 28 vs 29 leap year rules which exclude centennial years not divisible by 400 and years not divisible by 4.",
        "refined_prompt": "\nMatch examples:\n- \"02292000\"\nNon-match examples:\n- \"02291700\"",
        "matches": [
            "02292000"
        ],
        "non_matches": [
            "02291700"
        ],
        "stress_tests": []
    },
    {
        "id": 1221,
        "expression": "^(\\d{4})\\D?(0[1-9]|1[0-2])\\D?([12]\\d|0[1-9]|3[01])(\\D?([01]\\d|2[0-3])\\D?([0-5]\\d)\\D?([0-5]\\d)?)?$",
        "raw_prompt": "Regex to match the ISO Date Format. The time part is optional, including the seconds, as are all of the delimiters (although they must be non-numeric). Each part of the date will be returned as a selection e.g. \\1 will contain the Year, \\2 will contain the Month.",
        "refined_prompt": "\nMatch examples:\n- \"2006-12-31 17:58:00\"\n- \"20061231175800\"\n- \"2006-12-31\"\nNon-match examples:\n- \"2006-13-36 25:61:62\"",
        "matches": [
            "2006-12-31 17:58:00",
            "20061231175800",
            "2006-12-31"
        ],
        "non_matches": [
            "2006-13-36 25:61:62"
        ],
        "stress_tests": []
    },
    {
        "id": 1223,
        "expression": "^[$]?[0-9]*(\\.)?[0-9]?[0-9]?$",
        "raw_prompt": "Should match prices with or without a dollar sign.",
        "refined_prompt": "\nMatch examples:\n- \"4.42\"\n- \"$4.42\"\nNon-match examples:\n- \"asdf\"",
        "matches": [
            "4.42",
            "$4.42"
        ],
        "non_matches": [
            "asdf"
        ],
        "stress_tests": []
    },
    {
        "id": 1224,
        "expression": "^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-2]) ([0-1][0-9]|2[0-4]):([0-4][0-9]|5[0-9]):([0-4][0-9]|5[0-9])$",
        "raw_prompt": "it will match a valid date & time string which looks like this : 2006-12-31 23:59:59",
        "refined_prompt": "\nMatch examples:\n- \"2006-12-31 23:59:59\"\nNon-match examples:\n- \"2006-13-31 4:59:65\"",
        "matches": [
            "2006-12-31 23:59:59"
        ],
        "non_matches": [
            "2006-13-31 4:59:65"
        ],
        "stress_tests": []
    },
    {
        "id": 1227,
        "expression": "^.*(([^\\.][\\.][wW][mM][aA])|([^\\.][\\.][mM][pP][3]))$",
        "raw_prompt": "Matches a file name to be either a .wma or .mp3 file. This can be used to check file uploads to make sure they are of a certain type. Substitute letters where appropriate for specific file types. This is a better solution (I think) than #343. Works in Javascript and C#.",
        "refined_prompt": "\nMatch examples:\n- \"thisfile.mp3\"\n- \"tH@tfile.wma\"\nNon-match examples:\n- \"whatever.exe\"\n- \"somethingelse.mpa\"",
        "matches": [
            "thisfile.mp3",
            "tH@tfile.wma"
        ],
        "non_matches": [
            "whatever.exe",
            "somethingelse.mpa",
            "thisagain.wm3",
            "filenamemp3",
            "filename..mp3",
            "filename.wmap3"
        ],
        "stress_tests": []
    },
    {
        "id": 1230,
        "expression": "^\\d+(\\.\\d+)?$",
        "raw_prompt": "Matches any unsigned floating point number/numeric string.",
        "refined_prompt": "\nMatch examples:\n- \"123\"\n- \"3.14159\"\nNon-match examples:\n- \"abc\"\n- \"-3.14159\"",
        "matches": [
            "123",
            "3.14159"
        ],
        "non_matches": [
            "abc",
            "-3.14159",
            "3.4.2",
            ".234",
            "."
        ],
        "stress_tests": []
    },
    {
        "id": 1239,
        "expression": "[A-Z0-9]{5}\\d[0156]\\d([0][1-9]|[12]\\d|3[01])\\d[A-Z0-9]{3}[A-Z]{2}",
        "raw_prompt": "Matches the UK Drivers License format as laid down by the DVLA / dvla. See http://www.govtalk.gov.uk/gdsc/html/frames/default.htm Matches: 1. Must be 16 characters 2. First 5 characters are alphanumeric. 3. Next 6 characters must be numeric 4. Next 3 characters are alphanumeric 5. Last 2 characters are alpha 6. Second character of numeric section can only be 0, 1, 5 or 6. 7. Fourth and fifth characters of numeric section must be in the range 01 to 31.",
        "refined_prompt": "\nMatch examples:\n- \"JOHNS711215GG9SY\"\nNon-match examples:\n- \"JOHNS731215GG9SY\"",
        "matches": [
            "JOHNS711215GG9SY"
        ],
        "non_matches": [
            "JOHNS731215GG9SY"
        ],
        "stress_tests": []
    },
    {
        "id": 1242,
        "expression": "^(3276[0-7]|327[0-5]\\d|32[0-6]\\d{2}|3[01]\\d{3}|[12]\\d{4}|[1-9]\\d{3}|[1-9]\\d{2}|[1-9]\\d|\\d)$",
        "raw_prompt": "Checks that the input is a positive integer in the range 0-32767",
        "refined_prompt": "\nMatch examples:\n- \"32767\"\n- \"0\"\n- \"999\"\nNon-match examples:\n- \"99999\"\n- \"-1\"",
        "matches": [
            "32767",
            "0",
            "999"
        ],
        "non_matches": [
            "99999",
            "-1",
            "abc"
        ],
        "stress_tests": []
    },
    {
        "id": 1244,
        "expression": "^\\+[0-9]{1,3}\\([0-9]{3}\\)[0-9]{7}$",
        "raw_prompt": "The OAGIS standard has a format for phone and fax as +###(###)#######. For details on standard see the open applications group.",
        "refined_prompt": "\nMatch examples:\n- \"+555(555)5555555\"\n- \"+1(800)5555555\"\nNon-match examples:\n- \"555\"",
        "matches": [
            "+555(555)5555555",
            "+1(800)5555555"
        ],
        "non_matches": [
            "555"
        ],
        "stress_tests": []
    },
    {
        "id": 1246,
        "expression": "([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4}|(\\d{1,3}\\.){3}\\d{1,3}",
        "raw_prompt": "Matches all IPV6 and IPV4 addresses. Doesn't limit IPV4 to just values of 255. Doesn't allow IPV6 compression.",
        "refined_prompt": "\nMatch examples:\n- \"0:123:af00:ffff:0C67:0:0:8787\"\n- \"0:0:0:0:0:0:0:1\"\n- \"0.0.0.1\"\nNon-match examples:\n- \"::1\"",
        "matches": [
            "0:123:af00:ffff:0C67:0:0:8787",
            "0:0:0:0:0:0:0:1",
            "0.0.0.1",
            "999.999.999.999"
        ],
        "non_matches": [
            "::1"
        ],
        "stress_tests": []
    },
    {
        "id": 1251,
        "expression": "^(H(P|T|U|Y|Z)|N(A|B|C|D|F|G|H|J|K|L|M|N|O|R|S|T|U|W|X|Y|Z)|OV|S(C|D|E|G|H|J|K|M|N|O|P|R|S|T|U|W|X|Y|Z)|T(A|F|G|L|M|Q|R|V)){1}\\d{4}(NE|NW|SE|SW)?$|((H(P|T|U|Y|Z)|N(A|B|C|D|F|G|H|J|K|L|M|N|O|R|S|T|U|W|X|Y|Z)|OV|S(C|D|E|G|H|J|K|M|N|O|P|R|S|T|U|W|X|Y|Z)|T(A|F|G|L|M|Q|R|V)){1}(\\d{4}|\\d{6}|\\d{8}|\\d{10}))$",
        "raw_prompt": "This pattern validates a British Ordnance Survey Grid/Tile/Sheet Reference Number. Information on the range of possible values can be found here: http://www.ordnancesurvey.co.uk/oswebsite/gps/information/coordinatesystemsinfo/guidetonationalgrid/page17.html. Grid Ref, Tile Ref, Sheet Ref.",
        "refined_prompt": "\nMatch examples:\n- \"NA1234SE\"\nNon-match examples:\n- \"AA1234SE\"",
        "matches": [
            "NA1234SE"
        ],
        "non_matches": [
            "AA1234SE"
        ],
        "stress_tests": []
    },
    {
        "id": 1253,
        "expression": "^~/[0-9a-zA-Z_][0-9a-zA-Z/_-]*\\.[0-9a-zA-Z_-]+$",
        "raw_prompt": "Matches the app relative path of a file. This will work for relative paths of URLs. Not very complicated but will work to do basic validation.",
        "refined_prompt": "\nMatch examples:\n- \"~/myPage.htm\"\n- \"~/123._aBc2\"\n- \"~/Hello_World-Page.aspx\"\nNon-match examples:\n- \"mybadPage.htm\"\n- \"~/.Not\"",
        "matches": [
            "~/myPage.htm",
            "~/123._aBc2",
            "~/Hello_World-Page.aspx"
        ],
        "non_matches": [
            "mybadPage.htm",
            "~/.Not",
            "~/Very.",
            "~/Good"
        ],
        "stress_tests": []
    },
    {
        "id": 1254,
        "expression": "<title>+(.*?)</title>",
        "raw_prompt": "This pattern could intercept the value of the tag title in every web pages, it could be found in $1.",
        "refined_prompt": "\nMatch examples:\n- \"<title>this title</title>\"\nNon-match examples:\n- \"any other tags\"",
        "matches": [
            "<title>this title</title>"
        ],
        "non_matches": [
            "any other tags"
        ],
        "stress_tests": []
    },
    {
        "id": 1255,
        "expression": "<meta[\\s]+[^>]*?name[\\s]?=[\\s\\\"\\']+(.*?)[\\s\\\"\\']+content[\\s]?=[\\s\\\"\\']+(.*?)[\\\"\\']+.*?>",
        "raw_prompt": "This pattern intercept meta tags, the name can be found in $1 the content value in $2.",
        "refined_prompt": "\nMatch examples:\n- \"<meta name=\"Author\" content=\"xxxxxx\"> <meta name=\"description\" content=\"xxxxxxxxx\"> <meta name=\"keywords\" content=\"xxxxxxxxx\"> <meta name=\"country\" content=\"IT\">\"\nNon-match examples:\n- \"any other tags\"",
        "matches": [
            "<meta name=\"Author\" content=\"xxxxxx\"> <meta name=\"description\" content=\"xxxxxxxxx\"> <meta name=\"keywords\" content=\"xxxxxxxxx\"> <meta name=\"country\" content=\"IT\">"
        ],
        "non_matches": [
            "any other tags"
        ],
        "stress_tests": []
    },
    {
        "id": 1257,
        "expression": "<h([1-6])>([^<]*)</h([1-6])>",
        "raw_prompt": "This regex find valid <h1-6> html tags",
        "refined_prompt": "\nMatch examples:\n- \"<h2>test2</h2><h3>test3</h3>\"\nNon-match examples:\n- \"<h>test1</h>\"",
        "matches": [
            "<h2>test2</h2><h3>test3</h3>"
        ],
        "non_matches": [
            "<h>test1</h>"
        ],
        "stress_tests": []
    },
    {
        "id": 1260,
        "expression": "\\b[1-9]{1}[0-9]{1,5}-\\d{2}-\\d\\b",
        "raw_prompt": "This is a more robust regex for matching Chemical Abstract Service (CAS) Numbers. This distinguishes between CAS numbers and other identifiers (e.g. EC number).",
        "refined_prompt": "\nMatch examples:\n- \"50-00-0\"\nNon-match examples:\n- \"200-001-8\"",
        "matches": [
            "50-00-0"
        ],
        "non_matches": [
            "200-001-8"
        ],
        "stress_tests": []
    },
    {
        "id": 1263,
        "expression": "(\\A|\\s)(((>[:;=+])|[>:;=+])[,*]?[-~+o]?(\\)+|\\(+|\\}+|\\{+|\\]+|\\[+|\\|+|\\\\+|/+|>+|<+|D+|[@#!OoPpXxZS$03])|>?[xX8][-~+o]?(\\)+|\\(+|\\}+|\\{+|\\]+|\\[+|\\|+|\\\\+|/+|>+|<+|D+))(\\Z|\\s)",
        "raw_prompt": "Matches all common horizontal smileys facing from left to right in its own \"word\". To match horizontal smileys in the reverse direction (.ie D:) see horozontal smileys (reverse).",
        "refined_prompt": "\nMatch examples:\n- \">:3 +D :*-((( =P\"\nNon-match examples:\n- \":=( :)))()))\"",
        "matches": [
            ">:3 +D :*-((( =P"
        ],
        "non_matches": [
            ":=( :)))()))"
        ],
        "stress_tests": []
    },
    {
        "id": 1264,
        "expression": "(\\A|\\s)((\\)+|\\(+|\\}+|\\{+|\\]+|\\[+|\\|+|\\\\+|/+|>+|<+|D+|[@#!OoXxZS$0])[-~+o]?[,*]?((<[:;=+])|[<:;=+])|(\\)+|\\(+|\\}+|\\{+|\\]+|\\[+|\\|+|\\\\+|/+|>+|<+|D+)[-~+o]?[xX8]<?)(\\Z|\\s)",
        "raw_prompt": "Matches all common horizontal smileys from right to left in its own \"word\".",
        "refined_prompt": "\nMatch examples:\n- \"D: ]]=<\"\nNon-match examples:\n- \":D #=>\"",
        "matches": [
            "D: ]]=<"
        ],
        "non_matches": [
            ":D #=>"
        ],
        "stress_tests": []
    },
    {
        "id": 1265,
        "expression": "(\\A|\\s)[({\\[]*([\\^\\*\\-@#$%<>XxVvOo0ZzTt+'\u00ac](_+|\\.)[\\^\\*\\-@#$%<>XxVvOo0ZzTt+'\u00ac]|\\._\\.|[\\^\\*@#$%<>XxVOo0ZTt']\\-[\\^\\*@#$%<>XxVOo0ZTt']|>>|><|<<|o[O0]|[O0]o)[)}\\]]*[;.?]*['\"]?(\\Z|\\s)",
        "raw_prompt": "Matches all common vertical smileys in a \"word\".",
        "refined_prompt": "\nMatch examples:\n- \"[(-_-)];;;;;? .___. t-t T.T X_O oO *.*???? \u00ac_\u00ac >>\"\nNon-match examples:\n- \"Xx --- \u00ac-\u00ac <> -.....-\"",
        "matches": [
            "[(-_-)];;;;;? .___. t-t T.T X_O oO *.*???? \u00ac_\u00ac >>"
        ],
        "non_matches": [
            "Xx --- \u00ac-\u00ac <> -.....-"
        ],
        "stress_tests": []
    },
    {
        "id": 1267,
        "expression": "^(\\d)?[ ]*[\\(\\.\\-]?(\\d{3})[\\)\\.\\-]?[ ]*(\\d{3})[\\.\\- ]?(\\d{4})[ ]*(x|ext\\.?)?[ ]*(\\d{1,7})?$",
        "raw_prompt": "Requires area code. Allows extension. Any common US format works. If you prefer not to require area code, use this: ^(\\d)?[ ]*[\\(\\.\\-]?(\\d{3})?[\\)\\.\\-]?[ ]*(\\d{3})[\\.\\- ]?(\\d{4})[ ]*(x|ext\\.?)?[ ]*(\\d{1,7})?$",
        "refined_prompt": "\nMatch examples:\n- \"1 (123) 123-1234 ext. 1234567\"\n- \"1 (123) 123-1234\"\n- \"(123) 123-1234\"\nNon-match examples:\n- \"123/1234 L. 12345678\"",
        "matches": [
            "1 (123) 123-1234 ext. 1234567",
            "1 (123) 123-1234",
            "(123) 123-1234",
            "(123)123.1234",
            "1-123-123-1234",
            "1231231234"
        ],
        "non_matches": [
            "123/1234 L. 12345678"
        ],
        "stress_tests": []
    },
    {
        "id": 1268,
        "expression": ".*(\\.[Jj][Pp][Gg]|\\.[Gg][Ii][Ff]|\\.[Jj][Pp][Ee][Gg]|\\.[Pp][Nn][Gg])",
        "raw_prompt": "This expression should work to validate that an uploaded file's extension is either jpg, gif, or png.",
        "refined_prompt": "\nMatch examples:\n- \"foo.gif\"\n- \"foo.jpg\"\n- \"foo.png\"\nNon-match examples:\n- \"foo.txt\"\n- \"foo.zip\"",
        "matches": [
            "foo.gif",
            "foo.jpg",
            "foo.png"
        ],
        "non_matches": [
            "foo.txt",
            "foo.zip",
            "foo.exe"
        ],
        "stress_tests": []
    },
    {
        "id": 1278,
        "expression": "^[-+]?(\\d?\\d?\\d?,?)?(\\d{3}\\,?)*$",
        "raw_prompt": "This pattern matches on Integer values. Handles leading positive or negative signs. Supports commas where only the leading group can have less than three digits.",
        "refined_prompt": "\nMatch examples:\n- \"+1\"\n- \"-2\"\n- \"3,000\"\nNon-match examples:\n- \"A\"\n- \"1,23\"",
        "matches": [
            "+1",
            "-2",
            "3,000",
            "1,234,567"
        ],
        "non_matches": [
            "A",
            "1,23",
            "2,34,567",
            "1.0"
        ],
        "stress_tests": []
    },
    {
        "id": 1284,
        "expression": "^([0-1](?:\\.\\d)|[0-1](?:\\,\\d)|(2\\.0)|(2\\,0))$",
        "raw_prompt": "Had to handle both \",\" and \".\" as separator in a validationscript where values are between 0.0 and 2.0 like in results of Swedish H\u00f6gskoleprov (SAT).",
        "refined_prompt": "\nMatch examples:\n- \"0,0\"\n- \"0.0\"\n- \"1,9\"\nNon-match examples:\n- \"2,1\"\n- \"1\"",
        "matches": [
            "0,0",
            "0.0",
            "1,9",
            "2.0"
        ],
        "non_matches": [
            "2,1",
            "1",
            "3",
            "a"
        ],
        "stress_tests": []
    },
    {
        "id": 1296,
        "expression": "^[2-9]{1}[0-9]{1}((?<!1)[1]|[0]|[2-9]){1}\\b",
        "raw_prompt": "According to NANPA (North American Numbering Plan Administration): The format of an area code is NXX, where N is any digit 2 through 9 and X is any digit 0 through 9. N11 are ERCs, called service codes, and are not used as area codes. This regex checks for these conditions. However, this regex does not check for N9X which are reserved for expansion in the future nor 37X or 96X which are also reserved for potential expansion in the future.",
        "refined_prompt": "\nMatch examples:\n- \"513\"\nNon-match examples:\n- \"211\"",
        "matches": [
            "513"
        ],
        "non_matches": [
            "211"
        ],
        "stress_tests": []
    },
    {
        "id": 1300,
        "expression": "<script.*/*>|</script>|<[a-zA-Z][^>]*=['\"]+javascript:\\w+.*['\"]+>|<\\w+[^>]*\\son\\w+=.*[ /]*>",
        "raw_prompt": "Matches any opening or closing script tags, inline javascript: tags, inline on<function> (ex: onClick) tags.\nMATCHES:\n<a href=\"javascript:alert('test0');\">\n<a href='javascript:alert(\"test1\");'>\n<a href=\"#\" onClick=\"alert('test2');\" />\n<script language=\"javascript\" src=\"somewhere.js\">\n<script language=\"javascript\" src=\"somewhere.js\" />\n<script>\n</script>",
        "refined_prompt": "\nMatch examples:\n- \"<a href=\"javascript:alert('test0');\"> or <a href=\"#\" onClick=\"alert('test');\" /> etc...\"\nNon-match examples:\n- \"This should not appear because in javascript: you can use the < operator or the > operator.\"",
        "matches": [
            "<a href=\"javascript:alert('test0');\"> or <a href=\"#\" onClick=\"alert('test');\" /> etc..."
        ],
        "non_matches": [
            "This should not appear because in javascript: you can use the < operator or the > operator."
        ],
        "stress_tests": []
    },
    {
        "id": 1313,
        "expression": "^[a-zA-Z0-9\\040]+$",
        "raw_prompt": "It will allow for alphanumeric characters only, with the exception of spacing.",
        "refined_prompt": "\nMatch examples:\n- \"Website Users\"\nNon-match examples:\n- \"Website Users!\"",
        "matches": [
            "Website Users"
        ],
        "non_matches": [
            "Website Users!"
        ],
        "stress_tests": []
    },
    {
        "id": 1314,
        "expression": "^\\$([0]|([1-9]\\d{1,2})|([1-9]\\d{0,1},\\d{3,3})|([1-9]\\d{2,2},\\d{3,3})|([1-9],\\d{3,3},\\d{3,3}))([.]\\d{1,2})?$|^\\(\\$([0]|([1-9]\\d{1,2})|([1-9]\\d{0,1},\\d{3,3})|([1-9]\\d{2,2},\\d{3,3})|([1-9],\\d{3,3},\\d{3,3}))([.]\\d{1,2})?\\)$|^(\\$)?(-)?([0]|([1-9]\\d{0,6}))([.]\\d{1,2})?$",
        "raw_prompt": "Matches number with optional commas and decimal places. Allows only max 7 digits before decimal and max 2 digits after decimal. Does not allow numbers beginning with 0 e.g., $0,234,567 but allows $0.05",
        "refined_prompt": "\nMatch examples:\n- \"($1,234,567.89)\"\n- \"$1,234,567.89\"\n- \"$1234567.89\"\nNon-match examples:\n- \"$1,234,567.890\"\n- \"$12345678.90\"",
        "matches": [
            "($1,234,567.89)",
            "$1,234,567.89",
            "$1234567.89",
            "$-1234567.89"
        ],
        "non_matches": [
            "$1,234,567.890",
            "$12345678.90",
            "$023,456.78"
        ],
        "stress_tests": []
    },
    {
        "id": 1315,
        "expression": "^[a-z0-9!$'*+\\-_]+(\\.[a-z0-9!$'*+\\-_]+)*@([a-z0-9]+(-+[a-z0-9]+)*\\.)+([a-z]{2}|aero|arpa|biz|cat|com|coop|edu|gov|info|int|jobs|mil|mobi|museum|name|net|org|pro|travel)$",
        "raw_prompt": "Checks email format against RFC 3696 (http://tools.ietf.org/html/rfc3696). Allows all characters described in Sections 2 and 3 of the RFC EXCEPT those described in Section 4.3 as unsafe for mailto URLs without encoding. Allows any 2-letter TLD plus any of the current gTLDs as listed at http://www.icann.org/registries/top-level-domains.htm. Does not accept quoted strings in the local part or IP addresses in lieu of the domain name. Does not enforce length limits. Intended to be used as case-insensitive. Comments are appreciated!",
        "refined_prompt": "\nMatch examples:\n- \"bob@smith.com\"\n- \"bob.j@j.smith.museum\"\n- \"!$'*+-_@a--1.ca\"\nNon-match examples:\n- \".bob@smith.com\"\n- \"bob..j@smith.com\"",
        "matches": [
            "bob@smith.com",
            "bob.j@j.smith.museum",
            "!$'*+-_@a--1.ca"
        ],
        "non_matches": [
            ".bob@smith.com",
            "bob..j@smith.com",
            "bob@-smith.com"
        ],
        "stress_tests": []
    },
    {
        "id": 1317,
        "expression": "^(((\\(\\d{3}\\)|\\d{3})( |-|\\.))|(\\(\\d{3}\\)|\\d{3}))?\\d{3}( |-|\\.)?\\d{4}(( |-|\\.)?([Ee]xt|[Xx])[.]?( |-|\\.)?\\d{4})?$",
        "raw_prompt": "with or without area code (of various forms)(does not allow for unbalanced parens in the area code). With or without an extension (of various forms). Does not allow for leading or trailing space.",
        "refined_prompt": "\nMatch examples:\n- \"(123)-456-7890 Ext 1234\"\n- \"123-456-7890\"\n- \"(123).456.7890\"\nNon-match examples:\n- \"123)4567890\"\n- \"800callcat\"",
        "matches": [
            "(123)-456-7890 Ext 1234",
            "123-456-7890",
            "(123).456.7890",
            "123.456.7890",
            "1234567890ext1234",
            "123-456 7890 X 1234"
        ],
        "non_matches": [
            "123)4567890",
            "800callcat",
            "123456789"
        ],
        "stress_tests": []
    },
    {
        "id": 1319,
        "expression": "^[http|ftp|wap|https]{3,5}:\\//\\www\\.\\w*\\.[com|net]{2,3}$",
        "raw_prompt": "it validates a simple URL like http://www.google.com , ftp://www.soso.com",
        "refined_prompt": "\nMatch examples:\n- \"http://www.google.com\"\nNon-match examples:\n- \"httpp://wwww.go.com.in\"",
        "matches": [
            "http://www.google.com"
        ],
        "non_matches": [
            "httpp://wwww.go.com.in"
        ],
        "stress_tests": []
    },
    {
        "id": 1320,
        "expression": "(?i)^((((0[1-9])|([12][0-9])|(3[01])) ((JAN)|(MAR)|(MAY)|(JUL)|(AUG)|(OCT)|(DEC)))|((((0[1-9])|([12][0-9])|(30)) ((APR)|(JUN)|(SEP)|(NOV)))|(((0[1-9])|([12][0-9])) FEB))) \\d\\d\\d\\d ((([0-1][0-9])|(2[0-3])):[0-5][0-9]:[0-5][0-9])$",
        "raw_prompt": "Validates datetimes in an internationally resilient form that is still readable by the average person.",
        "refined_prompt": "\nMatch examples:\n- \"01 JAN 2006 13:00:00\"\nNon-match examples:\n- \"31 FEB 10 03:00:00 PM\"",
        "matches": [
            "01 JAN 2006 13:00:00"
        ],
        "non_matches": [
            "31 FEB 10 03:00:00 PM"
        ],
        "stress_tests": []
    },
    {
        "id": 1326,
        "expression": "^(\\d{4})[.](0{0,1}[1-9]|1[012])[.](0{0,1}[1-9]|[12][0-9]|3[01])[.](\\d{2})$",
        "raw_prompt": "capture labels having format yyyy.mm.dd.nn here nn is for number s from 00 to 99",
        "refined_prompt": "\nMatch examples:\n- \"2006.10.09.05\"\nNon-match examples:\n- \"06.13.32.123\"",
        "matches": [
            "2006.10.09.05"
        ],
        "non_matches": [
            "06.13.32.123"
        ],
        "stress_tests": []
    },
    {
        "id": 1332,
        "expression": "^((\\d{2}(([02468][048])|([13579][26]))[\\-\\/\\s]?((((0?[13578])|(1[02]))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])))))|(\\d{2}(([02468][1235679])|([13579][01345789]))[\\-\\/\\s]?((((0?[13578])|(1[02]))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\\-\\/\\s]?((0?[1-9])|(1[0-9])|(2[0-8]))))))(\\s(((0?[1-9])|(1[0-9])|(2[0-3]))\\:([0-5][0-9])((\\s)|(\\:([0-5][0-9])))?))?$",
        "raw_prompt": "Date YYYY-MM-DD (optional time HH:MM(optional seconds :SS)). Was borrowed from this [http://regexlib.com/REDetails.aspx?regexp_id=390] but changed to use 24 hour time and optional seconds. You can use / - or space for date delimiters, so 2004-12-31 works just as well as 2004/12/31. Checks leap year from 1901 to 2099.",
        "refined_prompt": "\nMatch examples:\n- \"2006-1-20\"\n- \"2006/01/20\"\n- \"2006-01-20 15:30\"\nNon-match examples:\n- \"2003-2-29\"\n- \"2003-13-02\"",
        "matches": [
            "2006-1-20",
            "2006/01/20",
            "2006-01-20 15:30",
            "2006-01-20 15:30:21"
        ],
        "non_matches": [
            "2003-2-29",
            "2003-13-02",
            "2003-2-2 10:72:30"
        ],
        "stress_tests": []
    },
    {
        "id": 1333,
        "expression": "^\\$?\\d{1,3}(,?\\d{3})*(\\.\\d{1,2})?$",
        "raw_prompt": "Just a small pattern to make sure commas are in the rite place (if present). Only allows one decimal to be suffixed with with 1 or 2 digits. Also optional dollar sign may proceed value.",
        "refined_prompt": "\nMatch examples:\n- \"$1,000,000.00\"\nNon-match examples:\n- \"43,3.245\"",
        "matches": [
            "$1,000,000.00"
        ],
        "non_matches": [
            "43,3.245"
        ],
        "stress_tests": []
    },
    {
        "id": 1334,
        "expression": "^[0-3][0-9][0-1]\\d{3}-\\d{4}?",
        "raw_prompt": "This regex performs a crude test on the given input string.\nThe danish cilvil registration number consists of 10 numeric characters and one special character '-'. The format is DDMMYY-XXXX.",
        "refined_prompt": "\nMatch examples:\n- \"010380-2343\"\n- \"120454-5467\"\n- \"390178-3434\"\nNon-match examples:\n- \"1223876776\"\n- \"4023100923\"",
        "matches": [
            "010380-2343",
            "120454-5467",
            "390178-3434"
        ],
        "non_matches": [
            "1223876776",
            "4023100923"
        ],
        "stress_tests": []
    },
    {
        "id": 1341,
        "expression": "^(([1-9]{1}\\d{0,2},(\\d{3},)*\\d{3})|([1-9]{1}\\d{0,}))$",
        "raw_prompt": "Matches whole numbers only, including comma separated. Does not allow leading zeros. To match comma separated numbers only, change \"\\d{0,}\" to \"\\d{0,2}\". To match 0, add \"|([0])\" before \")$\". If you want to use it with Java's regexp match(), remove \"^(\" and \")$\" since they are not needed.",
        "refined_prompt": "\nMatch examples:\n- \"10\"\n- \"1000\"\n- \"1,000\"\nNon-match examples:\n- \"01\"\n- \"001,000\"",
        "matches": [
            "10",
            "1000",
            "1,000",
            "10,000,000"
        ],
        "non_matches": [
            "01",
            "001,000",
            "1000,000"
        ],
        "stress_tests": []
    },
    {
        "id": 1349,
        "expression": "([a-zA-Z0-9_\\-\\.]+)(@[a-zA-Z0-9_\\-\\.]+)",
        "raw_prompt": "matches any email address, where a @ is contained",
        "refined_prompt": "\nMatch examples:\n- \"kis.hajnalka@gmail.com\"\nNon-match examples:\n- \"www.google.com\"",
        "matches": [
            "kis.hajnalka@gmail.com"
        ],
        "non_matches": [
            "www.google.com"
        ],
        "stress_tests": []
    },
    {
        "id": 1350,
        "expression": "(?:(?:(?:http|ftp|gopher|telnet|news)://)(?:w{3}\\.)?(?:[a-zA-Z0-9/;\\?&=:\\-_\\$\\+!\\*'\\(\\|\\\\~\\[\\]#%\\.])+)",
        "raw_prompt": "an expression to match internet addresses with one of the known protocolls (http, ftp, gopher, telnet, news)",
        "refined_prompt": "\nMatch examples:\n- \"http://ifi.lmu.de\"\n- \"ftp://leo.org\"\n- \"gopher://gopher.com\"\nNon-match examples:\n- \"www.google.com\"",
        "matches": [
            "http://ifi.lmu.de",
            "ftp://leo.org",
            "gopher://gopher.com"
        ],
        "non_matches": [
            "www.google.com"
        ],
        "stress_tests": []
    },
    {
        "id": 1351,
        "expression": "(?:(?:[a-zA-Z0-9/;\\?&=:\\-_\\$\\+!\\*'\\(\\|\\\\~\\[\\]#%\\.](?!www))+(?:\\.[Cc]om|\\.[Ee]du|\\.[gG]ov|\\.[Ii]nt|\\.[Mm]il|\\.[Nn]et|\\.[Oo]rg|\\.[Bb]iz|\\.[Ii]nfo|\\.[Nn]ame|\\.[Pp]ro|\\.[Aa]ero|\\.[cC]oop|\\.[mM]useum|\\.[Cc]at|\\.[Jj]obs|\\.[Tt]ravel|\\.[Aa]rpa|\\.[Mm]obi|\\.[Aa]c|\\.[Aa]d|\\.[aA]e|\\.[aA]f|\\.[aA]g|\\.[aA]i|\\.[aA]l|\\.[aA]m|\\.[aA]n|\\.[aA]o|\\.[aA]q|\\.[aA]r|\\.[aA]s|\\.[aA]t|\\.[aA]u|\\.[aA]w|\\.[aA]z|\\.[aA]x|\\.[bB]a|\\.[bB]b|\\.[bB]d|\\.[bB]e|\\.[bB]f|\\.[bB]g|\\.[bB]h|\\.[bB]i|\\.[bB]j|\\.[bB]m|\\.[bB]n|\\.[bB]o|\\.[bB]r|\\.[bB]s|\\.[bB]t|\\.[bB]v|\\.[bB]w|\\.[bB]y|\\.[bB]z|\\.[cC]a|\\.[cC]c|\\.[cC]d|\\.[cC]f|\\.[cC]g|\\.[cC]h|\\.[cC]i|\\.[cC]k|\\.[cC]l|\\.[cC]m|\\.[cC]n|\\.[cC]o|\\.[cC]r|\\.[cC]s|\\.[cC]u|\\.[cC]v|\\.[cC]x|\\.[cC]y|\\.[cC]z|\\.[dD]e|\\.[dD]j|\\.[dD]k|\\.[dD]m|\\.[dD]o|\\.[dD]z|\\.[eE]c|\\.[eE]e|\\.[eE]g|\\.[eE]h|\\.[eE]r|\\.[eE]s|\\.[eE]t|\\.[eE]u|\\.[fF]i|\\.[fF]j|\\.[fF]k|\\.[fF]m|\\.[fF]o|\\.[fF]r|\\.[gG]a|\\.[gG]b|\\.[gG]d|\\.[gG]e|\\.[gG]f|\\.[gG]g|\\.[gG]h|\\.[gG]i|\\.[gG]l|\\.[gG]m|\\.[gG]n|\\.[gG]p|\\.[gG]q|\\.[gG]r|\\.[gG]s|\\.[gG]t|\\.[gG]u|\\.[gG]w|\\.[gG]y|\\.[hH]k|\\.[hH]m|\\.[hH]n|\\.[hH]r|\\.[hH]t|\\.[hH]u|\\.[iI]d|\\.[iI]e|\\.[iI]l|\\.[iI]m|\\.[iI]n|\\.[iI]o|\\.[iI]q|\\.[iI]r|\\.[iI]s|\\.[iI]t|\\.[jJ]e|\\.[jJ]m|\\.[jJ]o|\\.[jJ]p|\\.[kK]e|\\.[kK]g|\\.[kK]h|\\.[kK]i|\\.[kK]m|\\.[kK]n|\\.[kK]p|\\.[kK]r|\\.[kK]w|\\.[kK]y|\\.[kK]z|\\.[lL]a|\\.[lL]b|\\.[lL]c|\\.[lL]i|\\.[lL]k|\\.[lL]r|\\.[lL]s|\\.[lL]t|\\.[lL]u|\\.[lL]v|\\.[lL]y|\\.[mM]a|\\.[mM]c|\\.[mM]d|\\.[mM]g|\\.[mM]h|\\.[mM]k|\\.[mM]l|\\.[mM]m|\\.[mM]n|\\.[mM]o|\\.[mM]p|\\.[mM]q|\\.[mM]r|\\.[mM]s|\\.[mM]t|\\.[mM]u|\\.[mM]v|\\.[mM]w|\\.[mM]x|\\.[mM]y|\\.[mM]z|\\.[nN]a|\\.[nN]c|\\.[nN]e|\\.[nN]f|\\.[nN]g|\\.[nN]i|\\.[nN]l|\\.[nN]o|\\.[nN]p|\\.[nN]r|\\.[nN]u|\\.[nN]z|\\.[oO]m|\\.[pP]a|\\.[pP]e|\\.[pP]f|\\.[pP]g|\\.[pP]h|\\.[pP]k|\\.[pP]l|\\.[pP]m|\\.[pP]n|\\.[pP]r|\\.[pP]s|\\.[pP]t|\\.[pP]w|\\.[pP]y|\\.[qP]a|\\.[rR]e|\\.[rR]o|\\.[rR]u|\\.[rR]w|\\.[sS]a|\\.[sS]b|\\.[sS]c|\\.[sS]d|\\.[sS]e|\\.[sS]g|\\.[sS]h|\\.[Ss]i|\\.[sS]j|\\.[sS]k|\\.[sS]l|\\.[sS]m|\\.[sS]n|\\.[sS]o|\\.[sS]r|\\.[sS]t|\\.[sS]v|\\.[sS]y|\\.[sS]z|\\.[tT]c|\\.[tT]d|\\.[tT]f|\\.[tT]g|\\.[tT]h|\\.[tT]j|\\.[tT]k|\\.[tT]l|\\.[tT]m|\\.[tT]n|\\.[tT]o|\\.[tT]p|\\.[tT]r|\\.[tT]t|\\.[tT]v|\\.[tT]w|\\.[tT]z|\\.[uU]a|\\.[uU]g|\\.[uU]k|\\.[uU]m|\\.[uU]s|\\.[uU]y|\\.[uU]z|\\.[vV]a|\\.[vV]c|\\.[vV]e|\\.[vV]g|\\.[vV]i|\\.[vV]n|\\.[vV]u|\\.[wW]f|\\.[wW]s|\\.[yY]e|\\.[yY]t|\\.[yY]u|\\.[zZ]a|\\.[zZ]m|\\.[zZ]w))",
        "raw_prompt": "here are specified all the top level domains. In fact, this expression gets the urls only till the TLD.",
        "refined_prompt": "\nMatch examples:\n- \"webmail.ifi.lmu.de\"\nNon-match examples:\n- \"kis.hajnalka\"",
        "matches": [
            "webmail.ifi.lmu.de"
        ],
        "non_matches": [
            "kis.hajnalka"
        ],
        "stress_tests": []
    },
    {
        "id": 1356,
        "expression": "^M{0,1}T{0,1}W{0,1}(TH){0,1}F{0,1}S{0,1}(SU){0,1}$",
        "raw_prompt": "Matches a string if it is valid in the form of MWF or TTHS. Maybe used for validating the \"days part\" of a class schedule field. The string should only accept any of the ff set of letters: 'M' 'T' 'W' 'TH' 'F' 'S' 'SU' . Only one instance of these set of letters is accepted.",
        "refined_prompt": "\nMatch examples:\n- \"MWF\"\n- \"TTHS\"\n- \"MT\"\nNon-match examples:\n- \"MM\"\n- \"WM\"",
        "matches": [
            "MWF",
            "TTHS",
            "MT",
            "WFS",
            "MFSU"
        ],
        "non_matches": [
            "MM",
            "WM",
            "FTH",
            "SM"
        ],
        "stress_tests": []
    },
    {
        "id": 1357,
        "expression": "^(([0][0-9]|[1][0-2])|[0-9]):([0-5][0-9])( *)((AM|PM)|(A|P))$",
        "raw_prompt": "Matches a string if it is a valid time in the format of \"HH:MM AM\" or \"HH:MM A\".",
        "refined_prompt": "\nMatch examples:\n- \"1:30 AM\"\n- \"01:20 AM\"\n- \"10:00A\"\nNon-match examples:\n- \"13:00 A\"\n- \"01:5 AM\"",
        "matches": [
            "1:30 AM",
            "01:20 AM",
            "10:00A",
            "11:50P"
        ],
        "non_matches": [
            "13:00 A",
            "01:5 AM"
        ],
        "stress_tests": []
    },
    {
        "id": 1358,
        "expression": "^\\$?(([1-9],)?([0-9]{3},){0,3}[0-9]{3}|[0-9]{0,16})(\\.[0-9]{0,3})?$",
        "raw_prompt": "Currency expression, accepts 4 commas and 4 groups of 3 numbers and 1 number before the first comma, this first number will have to be different from zero. It accepts a number of, two or three decimal. It accepts zero numbers after the point. You can change the number of groups and numbers accespts before and after the point.",
        "refined_prompt": "\nMatch examples:\n- \"1234.23\"\n- \"1,234.245\"\n- \"1.\"\nNon-match examples:\n- \"12,12,0.00\"\n- \"0,123.99\"",
        "matches": [
            "1234.23",
            "1,234.245",
            "1."
        ],
        "non_matches": [
            "12,12,0.00",
            "0,123.99"
        ],
        "stress_tests": []
    },
    {
        "id": 1360,
        "expression": "\\d{2,4}",
        "raw_prompt": "\\d{2,4} matches at least 2 but no more than 4 digits",
        "refined_prompt": "\nMatch examples:\n- \"123\"\n- \"12\"\n- \"1234\"\nNon-match examples:\n- \"1\"",
        "matches": [
            "123",
            "12",
            "1234"
        ],
        "non_matches": [
            "1"
        ],
        "stress_tests": []
    },
    {
        "id": 1362,
        "expression": "^-?\\d+(\\.\\d+)?$",
        "raw_prompt": "Matches any unsigned or signed floating point number/numeric string.",
        "refined_prompt": "\nMatch examples:\n- \"123\"\n- \"3.14159\"\n- \"-1.2\"\nNon-match examples:\n- \"abc\"\n- \"3.4.2\"",
        "matches": [
            "123",
            "3.14159",
            "-1.2"
        ],
        "non_matches": [
            "abc",
            "3.4.2",
            ".234",
            ""
        ],
        "stress_tests": []
    },
    {
        "id": 1366,
        "expression": "^[\"a-zA-Z0-9\\040]+$",
        "raw_prompt": "Accepts words or quoted phrases for search strings. Stops SQL injection.",
        "refined_prompt": "\nMatch examples:\n- \"2 words \"Search String\"\"\nNon-match examples:\n- \"hi' or 1=1--\"",
        "matches": [
            "2 words \"Search String\""
        ],
        "non_matches": [
            "hi' or 1=1--"
        ],
        "stress_tests": []
    },
    {
        "id": 1372,
        "expression": "^(?:(A[KLRZ]|C[AOT]|D[CE]|FL|GA|HI|I[ADLN]|K[SY]|LA|M[ADEINOST]|N[CDEHJMVY]|O[HKR]|P[AR]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY]))$",
        "raw_prompt": "Just a simple US State regex. Requires valid 2 letter abbreviations.",
        "refined_prompt": "\nMatch examples:\n- \"CO\"\n- \"GA\"\n- \"TX\"\nNon-match examples:\n- \"A\"\n- \"ZZ\"",
        "matches": [
            "CO",
            "GA",
            "TX"
        ],
        "non_matches": [
            "A",
            "ZZ",
            "Florida"
        ],
        "stress_tests": []
    },
    {
        "id": 1378,
        "expression": "(?<=>)[A-Z]{2}[\\d|\\w]{9}\\d{1}(?=(<))",
        "raw_prompt": "ISIN must be located inside a html tag eg. <td>JP3756600007</td>. Just remove the (..) at the beginning and the end if you wish to match all ISINs.",
        "refined_prompt": "\nMatch examples:\n- \">JP3756600007< without brackets\"\nNon-match examples:\n- \"JP3756600007\"",
        "matches": [
            ">JP3756600007< without brackets"
        ],
        "non_matches": [
            "JP3756600007"
        ],
        "stress_tests": []
    },
    {
        "id": 1380,
        "expression": "<(?![!/]?[ABIU][>\\s])[^>]*>",
        "raw_prompt": "Used to return all the html tags and closing tags in a section of html. Can be used to replace all the tags with nothing or itterate through them.",
        "refined_prompt": "\nMatch examples:\n- \"<u><b>hello</b></u>\"\nNon-match examples:\n- \"hello\"",
        "matches": [
            "<u><b>hello</b></u>"
        ],
        "non_matches": [
            "hello"
        ],
        "stress_tests": []
    },
    {
        "id": 1381,
        "expression": "((<body)|(<BODY))([^>]*)>",
        "raw_prompt": "find the body-tag of a html page",
        "refined_prompt": "\nMatch examples:\n- \"<body><BODY bgcolor=\"#ffffff\" text=\"#000000\" marginwidth=\"0\" marginheight=\"0\">\"\nNon-match examples:\n- \"all non body tags\"",
        "matches": [
            "<body><BODY bgcolor=\"#ffffff\" text=\"#000000\" marginwidth=\"0\" marginheight=\"0\">"
        ],
        "non_matches": [
            "all non body tags"
        ],
        "stress_tests": []
    },
    {
        "id": 1385,
        "expression": "^<a[^>]*(http://[^\"]*)[^>]*>([ 0-9a-zA-Z]+)</a>$",
        "raw_prompt": "This pattern matches link tags in html and returns the contents of the href attribute and the text of the link.",
        "refined_prompt": "\nMatch examples:\n- \"<a href=\"http://www.google.com\">Google</a>\"\nNon-match examples:\n- \"<a name=\"bookmark\">something</a>\"",
        "matches": [
            "<a href=\"http://www.google.com\">Google</a>"
        ],
        "non_matches": [
            "<a name=\"bookmark\">something</a>"
        ],
        "stress_tests": []
    },
    {
        "id": 1388,
        "expression": "(?:(?:(?:04|06|09|11)\\/(?:(?:[012][0-9])|30))|(?:(?:(?:0[135789])|(?:1[02]))\\/(?:(?:[012][0-9])|30|31))|(?:02\\/(?:[012][0-9])))\\/(?:19|20|21)[0-9][0-9]",
        "raw_prompt": "Matches dates in mm/dd/yyyy format. Matches only valid dates -except is unable to test for a leapyear. Always allows February 29th. Allows years from 1901 to 2199.",
        "refined_prompt": "\nMatch examples:\n- \"02/21/1972\"\n- \"12/31/2199\"\n- \"09/04/1901\"\nNon-match examples:\n- \"02/31/1999\"\n- \"02-21-1972\"",
        "matches": [
            "02/21/1972",
            "12/31/2199",
            "09/04/1901"
        ],
        "non_matches": [
            "02/31/1999",
            "02-21-1972",
            "06/31/2001"
        ],
        "stress_tests": []
    },
    {
        "id": 1389,
        "expression": "^\\d{1,2}\\.\\d{3}\\.\\d{3}[-][0-9kK]{1}$",
        "raw_prompt": "Verifica que un RUT tenga el formato 00.000.000-X, despues de comprobar el formato ser\u00e1 necesario validar su d\u00edgito verificador.",
        "refined_prompt": "\nMatch examples:\n- \"12.025.365-6\"\n- \"5.698.124-k\"\n- \"7.999.647-K\"\nNon-match examples:\n- \"125.326.452-1\"\n- \"15.336.054-H\"",
        "matches": [
            "12.025.365-6",
            "5.698.124-k",
            "7.999.647-K"
        ],
        "non_matches": [
            "125.326.452-1",
            "15.336.054-H",
            "15254587k"
        ],
        "stress_tests": []
    },
    {
        "id": 1394,
        "expression": "<!--\\s*\\#\\s*include\\s+(file|virtual)\\s*=\\s*([\"'])([^\"'<>\\|\\b]+/)*([^\"'<>/\\|\\b]+)\\2\\s*-->",
        "raw_prompt": "Works with virtual or file include type and double or single quotes. Breaks out include type, include file path, and include file name.",
        "refined_prompt": "\nMatch examples:\n- \"<!--#include file=\"include/js/common.js\"--> <!-- # include virtual = 'test header.inc' -->\"\nNon-match examples:\n- \"<!--#include file='header.inc\"-->\"",
        "matches": [
            "<!--#include file=\"include/js/common.js\"--> <!-- # include virtual = 'test header.inc' -->"
        ],
        "non_matches": [
            "<!--#include file='header.inc\"-->"
        ],
        "stress_tests": []
    },
    {
        "id": 1395,
        "expression": "(?<=\\d{7}_).+((?=\\x5B\\d\\x5D)|.{3})",
        "raw_prompt": "Although written specifically to strip Newzbin version 2 and 3 prefixes and the [1] IE adds in Newsbin from NZB file names, this expression can be modified to search for any prefix/suffix combination. It also provides an example of using of grouping constructs to remove matching text.",
        "refined_prompt": "\nMatch examples:\n- \"msgid_0000000_Any_Text[1]\"\n- \"0000000_Any_Text\"\nNon-match examples:\n- \"msgid 0000000\"\n- \"messageid\"",
        "matches": [
            "msgid_0000000_Any_Text[1]",
            "0000000_Any_Text"
        ],
        "non_matches": [
            "msgid 0000000",
            "messageid",
            "000000"
        ],
        "stress_tests": []
    },
    {
        "id": 1402,
        "expression": "<\\s*?[^>]+\\s*?>",
        "raw_prompt": "This simple pattern is useful for removing all HTML tags with or without atributes. It has no removing white spaces",
        "refined_prompt": "\nMatch examples:\n- \"< html >\"\n- \"< div style=\"title_1\" class='number'>\"\n- \"< div style=\"title_1\" class='number' >\"\nNon-match examples:\n- \"Plain text\"",
        "matches": [
            "< html >",
            "< div style=\"title_1\" class='number'>",
            "< div style=\"title_1\" class='number' >",
            "< img src=\"img.gif\" / >"
        ],
        "non_matches": [
            "Plain text"
        ],
        "stress_tests": []
    },
    {
        "id": 1404,
        "expression": "^(?=.*[a-z].*[a-z])(?=.*[A-Z].*[A-Z])(?=.*\\d.*\\d)(?=.*\\W.*\\W)[a-zA-Z0-9\\S]{9,}$",
        "raw_prompt": "This pattern requires at least two lowercase letters, two uppercase letters, two digits, and two special characters. There must be a minimum of 9 characters total, and no white space characters are allowed.",
        "refined_prompt": "\nMatch examples:\n- \"A1!B2@cde\"\nNon-match examples:\n- \"ABC!@#123\"",
        "matches": [
            "A1!B2@cde"
        ],
        "non_matches": [
            "ABC!@#123"
        ],
        "stress_tests": []
    },
    {
        "id": 1406,
        "expression": "(<(?:.*?)\\s)href\\s*=([\\s\"'])*/?([^\\2:#]+?)\\2((?:.*?)>)",
        "raw_prompt": "This expression matches all HREF relative paths, but not full URLs or dead # links. It can be used for selecting paths that need to be updated in HTML that has replaced from its original page onto a new one. It matches the entire containing tag with the following groups: 1 - the start of the containing tag through the space before the attribute, 2 - the delimiter between the attribute's equal sign and its value (e.g. a double quote), 3 - the attribute value, 4 - the remainder of the tag after the closing attribute value delimiter.",
        "refined_prompt": "\nMatch examples:\n- \"<a href=\"joe's test.htm\" />\"\n- \"<a href='/test2.htm'>\"\n- \"<a href = test2.htm />\"\nNon-match examples:\n- \"<a href=\"http://www.test.com/test.htm\" />\"\n- \"<a href = '#' />\"",
        "matches": [
            "<a href=\"joe's test.htm\" />",
            "<a href='/test2.htm'>",
            "<a href = test2.htm />"
        ],
        "non_matches": [
            "<a href=\"http://www.test.com/test.htm\" />",
            "<a href = '#' />"
        ],
        "stress_tests": []
    },
    {
        "id": 1408,
        "expression": "(refs|references|re|closes|closed|close|see|fixes|fixed|fix|addresses) #(\\d+)(( and |, | & | )#(\\d+))*",
        "raw_prompt": "This expression can be used to set the bugtraq:logrexep property of a subversion repository. It uses the format supported by trac and enables for example tortoisesvn to transform the issue numbers used in the commit messages into links pointing to the issue in the bugtracker.",
        "refined_prompt": "\nMatch examples:\n- \"fix #313\"\n- \"references #1024 and #1337\"\nNon-match examples:\n- \"fixed 313\"\n- \"refer #1024\"",
        "matches": [
            "fix #313",
            "references #1024 and #1337"
        ],
        "non_matches": [
            "fixed 313",
            "refer #1024"
        ],
        "stress_tests": []
    },
    {
        "id": 1410,
        "expression": "\\d{2}[.]{1}\\d{2}[.]{1}[0-9A-Za-z]{1}",
        "raw_prompt": "This pattern match the Italian Istat Ateco Code (Codice Istat) updated to Istat Declaration Ateco 2004",
        "refined_prompt": "\nMatch examples:\n- \"22.12.0\"\n- \"18.24.C\"\nNon-match examples:\n- \"22.12_D\"\n- \"12.56\"",
        "matches": [
            "22.12.0",
            "18.24.C"
        ],
        "non_matches": [
            "22.12_D",
            "12.56",
            "1A.56.1"
        ],
        "stress_tests": []
    },
    {
        "id": 1411,
        "expression": "IT\\d{2}[ ][a-zA-Z]\\d{3}[ ]\\d{4}[ ]\\d{4}[ ]\\d{4}[ ]\\d{4}[ ]\\d{3}|IT\\d{2}[a-zA-Z]\\d{22}",
        "raw_prompt": "International Bank Account Number (IBAN) Italian. Identify Bank account in Italy.",
        "refined_prompt": "\nMatch examples:\n- \"IT28 W800 0000 2921 0064 5211 151\"\n- \"IT28W8000000292100645211151\"\nNon-match examples:\n- \"IT28-W800-0000-2921-0064-5211-151\"",
        "matches": [
            "IT28 W800 0000 2921 0064 5211 151",
            "IT28W8000000292100645211151"
        ],
        "non_matches": [
            "IT28-W800-0000-2921-0064-5211-151"
        ],
        "stress_tests": []
    },
    {
        "id": 1412,
        "expression": "^\\w[a-zA-Z0-9\u00f6\u00e4\u00fc\u00d6\u00c4\u00dc\\.\\-_]+@[a-zA-Z0-9\u00f6\u00e4\u00fc\u00d6\u00c4\u00dc\\-_]+?\\.[a-zA-Z]{2,3}$",
        "raw_prompt": "allows numbers, umlauts, dots and bars",
        "refined_prompt": "\nMatch examples:\n- \"t\u00e4st.inf\u00f6@t\u00fcst-1234.de\"\nNon-match examples:\n- \"t\u00e4st.inf\u00f6@t\u00fcst-1234.123\"",
        "matches": [
            "t\u00e4st.inf\u00f6@t\u00fcst-1234.de"
        ],
        "non_matches": [
            "t\u00e4st.inf\u00f6@t\u00fcst-1234.123"
        ],
        "stress_tests": []
    },
    {
        "id": 1413,
        "expression": "^(([a-zA-Z]\\:)|(\\\\))(\\\\{1}|((\\\\{1})[^\\\\]([^/:*?<>\"|]*))+)$",
        "raw_prompt": "Checks for a valid Filepath, either located on a local drive or a UNC share on the network. Use the following string to include the regex within a XML defintion file: RegEx=\"^([a-zA-Z]\\:)|(\\\\)(\\\\{1}|((\\\\{1})[^\\\\]([^/:*?&lt;&gt;&quot;|]*(?&lt;!\\[\\])))+)$\"/> (encode the appropiate HTML characters like <,>,\" with the appropiate HTML codes < = (ampersand)lt; > = (ampersand)gt; \" = (ampersand)quote;",
        "refined_prompt": "\nMatch examples:\n- \"C:\\SomeFilePatt\"\n- \"\\\\SomeServer\\SomeShare\"\nNon-match examples:\n- \"C:\"\n- \"\\SomeServer\"",
        "matches": [
            "C:\\SomeFilePatt",
            "\\\\SomeServer\\SomeShare"
        ],
        "non_matches": [
            "C:",
            "\\SomeServer"
        ],
        "stress_tests": []
    },
    {
        "id": 1414,
        "expression": "(^4\\d{12}$)|(^4[0-8]\\d{14}$)|(^(49)[^013]\\d{13}$)|(^(49030)[0-1]\\d{10}$)|(^(49033)[0-4]\\d{10}$)|(^(49110)[^12]\\d{10}$)|(^(49117)[0-3]\\d{10}$)|(^(49118)[^0-2]\\d{10}$)|(^(493)[^6]\\d{12}$)",
        "raw_prompt": "Matches Visa CC types 13 or 16 digits starting with 4 including Visa CC, Visa ATM only, Visa Electron and Visa Delta. Safe for international and will NOT match \"^(49)\" Switch debit cards.",
        "refined_prompt": "\nMatch examples:\n- \"4111111111111111\"\nNon-match examples:\n- \"4903020000000008\"",
        "matches": [
            "4111111111111111"
        ],
        "non_matches": [
            "4903020000000008"
        ],
        "stress_tests": []
    },
    {
        "id": 1425,
        "expression": "(^(5[0678])\\d{11,18}$)|(^(6[^05])\\d{11,18}$)|(^(601)[^1]\\d{9,16}$)|(^(6011)\\d{9,11}$)|(^(6011)\\d{13,16}$)|(^(65)\\d{11,13}$)|(^(65)\\d{15,18}$)|(^(49030)[2-9](\\d{10}$|\\d{12,13}$))|(^(49033)[5-9](\\d{10}$|\\d{12,13}$))|(^(49110)[1-2](\\d{10}$|\\d{12,13}$))|(^(49117)[4-9](\\d{10}$|\\d{12,13}$))|(^(49118)[0-2](\\d{10}$|\\d{12,13}$))|(^(4936)(\\d{12}$|\\d{14,15}$))",
        "raw_prompt": "Matches any of Solo, Switch or Maestro. International safe. Will not match on Discover, Visa or Mastercard. For example; Most recommendations for matching Visa are that they start with \"4\". If outside the US, this are incomplete on will falsly ID most Switch cards as Visa.",
        "refined_prompt": "\nMatch examples:\n- \"6334500000000003\"\nNon-match examples:\n- \"6011000000000004\"",
        "matches": [
            "6334500000000003"
        ],
        "non_matches": [
            "6011000000000004"
        ],
        "stress_tests": []
    },
    {
        "id": 1426,
        "expression": "(^\\-|\\+)?([1-9]{1}[0-9]{0,2}(\\,\\d{3})*|[1-9]{1}\\d{0,})$|^0?$",
        "raw_prompt": "Allows any integer, signed (+/-) or not, with or without commas, or zero (0), or blank.",
        "refined_prompt": "\nMatch examples:\n- \"1,250\"\n- \"+235\"\n- \"-1\"\nNon-match examples:\n- \"abc\"\n- \"-0\"",
        "matches": [
            "1,250",
            "+235",
            "-1",
            "0"
        ],
        "non_matches": [
            "abc",
            "-0",
            "1,0"
        ],
        "stress_tests": []
    },
    {
        "id": 1428,
        "expression": "^(97(8|9))?\\d{9}(\\d|X)$",
        "raw_prompt": "Validates both ISBN 10 and ISBN 13 numbers, and confirms ISBN 13 numbers start with only 978 or 979.",
        "refined_prompt": "\nMatch examples:\n- \"0672317249\"\n- \"9780672317248\"\nNon-match examples:\n- \"0-672-31724-9\"\n- \"5555555555555\"",
        "matches": [
            "0672317249",
            "9780672317248"
        ],
        "non_matches": [
            "0-672-31724-9",
            "5555555555555"
        ],
        "stress_tests": []
    },
    {
        "id": 1430,
        "expression": "(\\[([^/].*?)(=(.+?))?\\](.*?)\\[/\\2\\]|\\[([^/].*?)(=(.+?))?\\])",
        "raw_prompt": "Matches BBCode, non-recursive. You must recursively run the pattern with each resulting subpattern to get all the tag.",
        "refined_prompt": "\nMatch examples:\n- \"[img]path[/img] (opened), [url=path]text[/url] (opened/args), [br] (closed), [img=path] (closed/args), [font size=50]text[/font] (opened, attribs)\"\nNon-match examples:\n- \"[/b]\"",
        "matches": [
            "[img]path[/img] (opened), [url=path]text[/url] (opened/args), [br] (closed), [img=path] (closed/args), [font size=50]text[/font] (opened, attribs)"
        ],
        "non_matches": [
            "[/b]"
        ],
        "stress_tests": []
    },
    {
        "id": 1431,
        "expression": "\"(\"\"|[^\"])*\"",
        "raw_prompt": "This will match the VB-style quoted string. That means to use \" in the quoted string you must use \"\" instead.",
        "refined_prompt": "\nMatch examples:\n- \"\"\" \"Hello\" \"\"\"Wow\"\", he said\" \"\"\"\"\"\"\"\nNon-match examples:\n- \"\"Unclosed\"",
        "matches": [
            "\"\" \"Hello\" \"\"\"Wow\"\", he said\" \"\"\"\"\"\""
        ],
        "non_matches": [
            "\"Unclosed"
        ],
        "stress_tests": []
    },
    {
        "id": 1433,
        "expression": "[^\\d^\\-^\\,^\\x20]+",
        "raw_prompt": "Just a beginner....here's something I'm using to emulate the Microsoft \"Print\" functionality, where you can enter page numbers to print seperated by commas or specify a range using the \"-\" symbol. The expression checks across a whole string looking for anything that is NOT equal to a number, a minus symbol, a comma and a space character. You can use this expression to do a quick true-false check to see if the user has entered a valid string / page numbers. Later you could then write a routine to sort and / or process the input. Nothing fancy but might help someone. Comments welcome.",
        "refined_prompt": "\nMatch examples:\n- \"abcABC ! *$%&/()\"\nNon-match examples:\n- \"123456789 ,-\"",
        "matches": [
            "abcABC ! *$%&/()"
        ],
        "non_matches": [
            "123456789 ,-"
        ],
        "stress_tests": []
    },
    {
        "id": 1434,
        "expression": "(^\\*\\.[a-zA-Z][a-zA-Z][a-zA-Z]$)|(^\\*\\.\\*$)",
        "raw_prompt": "Matching any file extension.",
        "refined_prompt": "\nMatch examples:\n- \"*.doc\"\n- \"*.DOC\"\n- \"*.*\"\nNon-match examples:\n- \"*.docDOC\"\n- \"*.*d\"",
        "matches": [
            "*.doc",
            "*.DOC",
            "*.*"
        ],
        "non_matches": [
            "*.docDOC",
            "*.*d"
        ],
        "stress_tests": []
    },
    {
        "id": 1436,
        "expression": "^([A-Za-z\\-]+)\\s+(\\w+)\\s+([A-Za-z0-9_\\-\\.]+)\\s+([A-Za-z0-9_\\-\\.]+)\\s+(\\d+)\\s+(.{3} [0-9 ]{2} ([0-9][0-9]:[0-9][0-9]| [0-9]{4}))\\s+(.+)$",
        "raw_prompt": "GLOB the output of an \"ls -l\" command to extract specific details. It takes into account issues with older files/directories having a year in place of an hour:minute entry.",
        "refined_prompt": "\nMatch examples:\n- \"drwxr-xr-x 5 user dba 1024 Sep 24 21:24 dirname\"\nNon-match examples:\n- \"drwxr-xr-x 5 user dba 1024 Sep 24_21:24 dirname\"",
        "matches": [
            "drwxr-xr-x 5 user dba 1024 Sep 24 21:24 dirname"
        ],
        "non_matches": [
            "drwxr-xr-x 5 user dba 1024 Sep 24_21:24 dirname"
        ],
        "stress_tests": []
    },
    {
        "id": 1439,
        "expression": "^[\\w]{1,}$",
        "raw_prompt": "alphanumeric - no space allowed - requires at least one character",
        "refined_prompt": "\nMatch examples:\n- \"a123b\"\nNon-match examples:\n- \"a 1\"",
        "matches": [
            "a123b"
        ],
        "non_matches": [
            "a 1"
        ],
        "stress_tests": []
    },
    {
        "id": 1446,
        "expression": "^[ISBN]{4}[ ]{0,1}[0-9]{1}[-]{1}[0-9]{3}[-]{1}[0-9]{5}[-]{1}[0-9]{0,1}$",
        "raw_prompt": "Expression to check for a valid ISBN number",
        "refined_prompt": "\nMatch examples:\n- \"ISBN 0-596-00681-0\"\nNon-match examples:\n- \"Anything that's not in the above format\"",
        "matches": [
            "ISBN 0-596-00681-0"
        ],
        "non_matches": [
            "Anything that's not in the above format"
        ],
        "stress_tests": []
    },
    {
        "id": 1449,
        "expression": "(^10\\.)|(^172\\.1[6-9]\\.)|(^172\\.2[0-9]\\.)|(^172\\.3[0-1]\\.)|(^192\\.168\\.)|(^127\\.0\\.0\\.1)",
        "raw_prompt": "It matches private IP addresses. Private IP addresses (as defined by RFC 1918) are not routable on public Internet. This would help if you want to grant some previlege only to the users from within local network. ***Importnat*** This pattern assumes that the input is a valid IP address. You many need to make sure the input is a valid IP address.",
        "refined_prompt": "\nMatch examples:\n- \"10.12.0.19\"\n- \"172.21.0.23\"\n- \"192.168.0.2\"\nNon-match examples:\n- \"222.12.3.24\"\n- \"172.12.0.12\"",
        "matches": [
            "10.12.0.19",
            "172.21.0.23",
            "192.168.0.2"
        ],
        "non_matches": [
            "222.12.3.24",
            "172.12.0.12"
        ],
        "stress_tests": []
    },
    {
        "id": 1457,
        "expression": "^(GIR|[A-Z]\\d[A-Z\\d]?|[A-Z]{2}\\d[A-Z\\d]?)[ ]??(\\d[A-Z]{0,2})??$",
        "raw_prompt": "This will validate a partial postcode beginning with the postal district on up to the whole postcode, returning the two halves in sub-expressions. The main purpose is to return a valid postal district from a partial or whole postcode. The real value in this regex lies in the fact that it will process the postcode correctly regardless of whether or not the space in present after the district. So the accepted formats are A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (and the same 6 formats without the space are also accepted). Requires postcodes to be upper-case.",
        "refined_prompt": "\nMatch examples:\n- \"W1A1AB\"\nNon-match examples:\n- \"WWW1AB\"",
        "matches": [
            "W1A1AB"
        ],
        "non_matches": [
            "WWW1AB"
        ],
        "stress_tests": []
    },
    {
        "id": 1458,
        "expression": "^(GIR|[A-Z]\\d[A-Z\\d]??|[A-Z]{2}\\d[A-Z\\d]??)[ ]??(\\d[A-Z]{2})$",
        "raw_prompt": "Validates a complete UK postcode. Returns the two halves in sub-expressions. Supports the following 7 formats: A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (** And the same 7 formats without the space are also accepted). (requires postcodes to be upper-case)",
        "refined_prompt": "\nMatch examples:\n- \"GIR0AA\"\nNon-match examples:\n- \"WWW1AB\"",
        "matches": [
            "GIR0AA"
        ],
        "non_matches": [
            "WWW1AB"
        ],
        "stress_tests": []
    },
    {
        "id": 1461,
        "expression": "((?!(This|It|He|She|[MTWFS][a-z]+day|[JF][a-z]+ary|March|April|May|June|July|August|[SOND][a-z]+ber))(?:[A-Z]+\\.\\s?)*(?:(?:[a-zA-Z]+-?)?[A-Z][a-zA-Z]+)(?:(\\b\\s?((?:[a-zA-Z]+-?)?[A-Z][a-zA-Z]+|[A-Z]+\\.|on|of|the|von|der|van|de|bin|and))*(?:\\s*(?:[a-zA-Z]+-?)?[A-Z][a-zA-Z]+))?)",
        "raw_prompt": "Tries to find the proper nouns in a text",
        "refined_prompt": "\nMatch examples:\n- \"George W. Bush, al-Qaeda, VIII. Henry, United States of America, U.S. Department of Justice\"\nNon-match examples:\n- \"other non-proper nouns\"",
        "matches": [
            "George W. Bush, al-Qaeda, VIII. Henry, United States of America, U.S. Department of Justice"
        ],
        "non_matches": [
            "other non-proper nouns"
        ],
        "stress_tests": []
    },
    {
        "id": 1466,
        "expression": "^[0-9]+[NnSs] [0-9]+[WwEe]$",
        "raw_prompt": "This tests, are entered AW coordinates in correct short format, and it has no world info",
        "refined_prompt": "\nMatch examples:\n- \"0N 0W\"\nNon-match examples:\n- \"aw 0N 0W\"",
        "matches": [
            "0N 0W"
        ],
        "non_matches": [
            "aw 0N 0W"
        ],
        "stress_tests": []
    },
    {
        "id": 1467,
        "expression": "^(([+-]?)(?=\\d|\\.\\d)\\d*(\\.\\d*)?([Ee]([+-]?([12]?\\d\\d?|30[0-8])))?)?$",
        "raw_prompt": "SqlServer seems to throw an error when using higher than e308 for e-309 it just makes the value = 0. Either way, this regexp seems to work for me. and allows for empty string as well. To negate the empty string pass through in asp.net just add a required field validator--if your already program asp.net you probably already know that though : ) .",
        "refined_prompt": "\nMatch examples:\n- \"-9.9e-308\"\n- \"9.9\"\n- \"9\"\nNon-match examples:\n- \"-9.9e-309\"",
        "matches": [
            "-9.9e-308",
            "9.9",
            "9"
        ],
        "non_matches": [
            "-9.9e-309"
        ],
        "stress_tests": []
    },
    {
        "id": 1468,
        "expression": "^([0-1]?[0-9]|[2][0-3]):([0-5][0-9])$",
        "raw_prompt": "Checks time in 24 hours notation, however this one is shorter than the ones I found on regexplib",
        "refined_prompt": "\nMatch examples:\n- \"23:00\"\n- \"12:21\"\n- \"0:00\"\nNon-match examples:\n- \"24:00\"\n- \"23:60\"",
        "matches": [
            "23:00",
            "12:21",
            "0:00"
        ],
        "non_matches": [
            "24:00",
            "23:60",
            "0:60"
        ],
        "stress_tests": []
    },
    {
        "id": 1469,
        "expression": "https?://(?!\\S*?domainname\\.tld/)\\S*?/",
        "raw_prompt": "This type of filter can be used if you're trying to get rid of results from a report or something not originating from a given domain of the format domainname.tld. Anything matching the pattern can then be excluded, deleted, etc. (Like with a Google Mini, GSA, or site auditing software)",
        "refined_prompt": "\nMatch examples:\n- \"http://www.domainname2.tld2/\"\n- \"http://sub.domainname3.tld3/\"\n- \"https://secure.domainname4.tld4/\"\nNon-match examples:\n- \"http://www.domainname.tld/\"\n- \"http://sub.domainname.tld/\"",
        "matches": [
            "http://www.domainname2.tld2/",
            "http://sub.domainname3.tld3/",
            "https://secure.domainname4.tld4/",
            "http://domainname5.tld5/"
        ],
        "non_matches": [
            "http://www.domainname.tld/",
            "http://sub.domainname.tld/",
            "https://secure.domainname.tld/",
            "http://domainname.tld/"
        ],
        "stress_tests": []
    },
    {
        "id": 1473,
        "expression": "https?://[\\w./]+\\/[\\w./]+\\.(bmp|png|jpg|gif)",
        "raw_prompt": "match web pictrue's address,must be full path,include http head.",
        "refined_prompt": "\nMatch examples:\n- \"http://image2.sina.com.cn/home/07index/sinahome_ws_035.gif\"\nNon-match examples:\n- \"img src=\"images/1.jpg\"\"",
        "matches": [
            "http://image2.sina.com.cn/home/07index/sinahome_ws_035.gif"
        ],
        "non_matches": [
            "img src=\"images/1.jpg\""
        ],
        "stress_tests": []
    },
    {
        "id": 1474,
        "expression": "^([0-9][,]?)*([0-9][0-9])$",
        "raw_prompt": "This pattern matches numbers separated by comma",
        "refined_prompt": "\nMatch examples:\n- \"100,200\"\nNon-match examples:\n- \",,100\"\n- \"100,,222\"",
        "matches": [
            "100,200"
        ],
        "non_matches": [
            ",,100",
            "100,,222",
            "100,,,"
        ],
        "stress_tests": []
    },
    {
        "id": 1476,
        "expression": "<(/)?(a|abbr|acronym|address|applet|area|b|base|basefont|bdo|big|blockquote|body|br|button|caption|center|cite|code|col|colgroup|dd|del|dir|div|dfn|dl|dt|em|fieldset|font|form|frame|frameset|h[1-6]|head|hr|html|i|iframe|img|input|ins|isindex|kbd|label|legend|li|link|map|menu|meta|noframes|noscript|object|ol|optgroup|option|p|param|pre|q|s|samp|script|select|small|span|strike|strong|style|sub|sup|table|tbody|td|textarea|tfoot|th|thead|title|tr|tt|u|ul|var|xmp){1}(\\s(\\\"[^\\\"]*\\\"*|[^>])*)*>",
        "raw_prompt": "This should match all valid HTML 4.01 tags as a browser would recognize. If you miss a 2nd \" it will continue until it finds one to pair with, so if it doesn't find one, it continues until the end. This is how most browsers work I believe. It does have a few flaws, it will match </img> and </input> which is weird, but perhaps I'll fix that eventually.",
        "refined_prompt": "\nMatch examples:\n- \"</a> <h2 > </h2 asfsdf> <a href=\"abc>>123\">\"\nNon-match examples:\n- \"< /a> </h 2 asfsdf> <ahref=\"abc123\">\"",
        "matches": [
            "</a> <h2 > </h2 asfsdf> <a href=\"abc>>123\">"
        ],
        "non_matches": [
            "< /a> </h 2 asfsdf> <ahref=\"abc123\">"
        ],
        "stress_tests": []
    },
    {
        "id": 1479,
        "expression": "^(?=(.*[a-z]){1,})(?=(.*[\\d]){1,})(?=(.*[\\W]){1,})(?!.*\\s).{7,30}$",
        "raw_prompt": "The basic expression requires at least 1 lower case, 1 upper case, 1 numeric, 1 non-word and no whitespace.\n<br /><br />\nThe format of the expression lends itself to being parameterised, thus in C# I have a method that returns a modified pattern based on passed in parameters e.g.\n<br /><br />return \"^(?=(.*[a-z]){\" + minLowerCase.ToString() + \",})\"<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ \"(?=(.*[\\d]){\" + minNumeric.ToString() + \",})\"<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ \".{\" + minLength.ToString() + \",\" + maxLength.ToString() + \"}$\");<br /><br />Its then possible to set the password strength via configuration files which require strong passwords in production environments, but allow weaker passwords in development environments.",
        "refined_prompt": "\nMatch examples:\n- \"qW1@xxx\"\nNon-match examples:\n- \"qwerty123\"",
        "matches": [
            "qW1@xxx"
        ],
        "non_matches": [
            "qwerty123"
        ],
        "stress_tests": []
    },
    {
        "id": 1483,
        "expression": "</?(a|abbr|acronym|address|applet|area|b|base|basefont|bdo|big|blockquote|body|br|button|caption|center|cite|code|col|colgroup|dd|del|dir|div|dfn|dl|dt|em|fieldset|font|form|frame|frameset|h[1-6]|head|hr|html|i|iframe|img|input|ins|isindex|kbd|label|legend|li|link|map|menu|meta|noframes|noscript|object|ol|optgroup|option|p|param|pre|q|s|samp|script|select|small|span|strike|strong|style|sub|sup|table|tbody|td|textarea|tfoot|th|thead|title|tr|tt|u|ul|var|xmp)\\b((\\\"[^\\\"]*\\\"|\\'[^\\']*\\')*|[^\\\"\\'>])*>",
        "raw_prompt": "This is very similar to my other expression, except it only matches tags that a browser would read, so if you have an extra \" in the tag, it will not count it, and move onto the next possibility.",
        "refined_prompt": "\nMatch examples:\n- \"</a> <h2 > </a asdfs> </h2 asfsdf> <a href=\"abc>>123\">\"\nNon-match examples:\n- \"< /a> </h 2 asfsdf> <ahref=\"abc\"123\">\"",
        "matches": [
            "</a> <h2 > </a asdfs> </h2 asfsdf> <a href=\"abc>>123\">"
        ],
        "non_matches": [
            "< /a> </h 2 asfsdf> <ahref=\"abc\"123\">"
        ],
        "stress_tests": []
    },
    {
        "id": 1484,
        "expression": "^([0-1]?[0-9]{1}/[0-3]?[0-9]{1}/20[0-9]{2})$",
        "raw_prompt": "This regular expression will validate most (current & future) date options. The weaknesses with this one is that it will allow the days to go up to 39 and does not account for leap year. Also, the months can go up to 19, instead of our commonly accepted 12 month year. :) I designed this expression to validate dates from the year 2000 to 2099. I do not plan on this same code being in place in 2099, so I hope this is sufficient enough...",
        "refined_prompt": "\nMatch examples:\n- \"2/14/2001\"\n- \"12/29/2099\"\n- \"19/39/2000\"\nNon-match examples:\n- \"12/29/1999\"\n- \"20/40/2100\"",
        "matches": [
            "2/14/2001",
            "12/29/2099",
            "19/39/2000"
        ],
        "non_matches": [
            "12/29/1999",
            "20/40/2100"
        ],
        "stress_tests": []
    },
    {
        "id": 1485,
        "expression": "^\\d+\\*\\d+\\*\\d+$",
        "raw_prompt": "one or more numbers, asterisk, one or more numbers, asterisk, one or more numbers, no letters or punctuation other than asterisks.",
        "refined_prompt": "\nMatch examples:\n- \"123*4578*8908650\"\nNon-match examples:\n- \"12a*9999*9096\"",
        "matches": [
            "123*4578*8908650"
        ],
        "non_matches": [
            "12a*9999*9096"
        ],
        "stress_tests": []
    },
    {
        "id": 1486,
        "expression": "^((http|https|ftp):\\/\\/)?((.*?):(.*?)@)?([a-zA-Z0-9][a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])((\\.[a-zA-Z0-9][a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])*)(:([0-9]{1,5}))?((\\/.*?)(\\?(.*?))?(\\#(.*))?)?$",
        "raw_prompt": "Validates and extracts URI components.\nProtocol is optional.\nUsername & Password is optional.\nHost regex was taken from Remi Sabourin and follows RFC1035 except that it allows hostnames greater than 253 chars.\nAlso TLD length is not restriced.\nPort number is optional.\nAbsolute Path is optional, and also extracts the optional querystring and optional anchor reference.",
        "refined_prompt": "\nMatch examples:\n- \"http://john:@www.domain.com:8080/index.html?param=value#Page1\"\nNon-match examples:\n- \"http://www.domain.com:/\"\n- \"www-.domain.com\"",
        "matches": [
            "http://john:@www.domain.com:8080/index.html?param=value#Page1"
        ],
        "non_matches": [
            "http://www.domain.com:/",
            "www-.domain.com"
        ],
        "stress_tests": []
    },
    {
        "id": 1489,
        "expression": "^100(\\.0{0,2}?)?$|^\\d{0,2}(\\.\\d{0,2})?$",
        "raw_prompt": "Matches percentages from 0-100 inclusive with two decimal places.",
        "refined_prompt": "\nMatch examples:\n- \"0\"\n- \"100\"\n- \"100.00\"\nNon-match examples:\n- \"101\"\n- \"-5\"",
        "matches": [
            "0",
            "100",
            "100.00",
            "45.45"
        ],
        "non_matches": [
            "101",
            "-5",
            "45.456"
        ],
        "stress_tests": []
    },
    {
        "id": 1490,
        "expression": "(?=^.{1,254}$)(^(?:(?!\\d+\\.|-)[a-zA-Z0-9_\\-]{1,63}(?<!-)\\.?)+(?:[a-zA-Z]{2,})$)",
        "raw_prompt": "Validates MS FQDNs. 1) Entire fqdn less than 255 chars. 2) Host and domain names may contain an underscore. 3) 1st char can be a number. 4) No part can be all numbers. 5) Allows any TLD Works in C#. Based on Remi Sabourin's regex. Based on anonymous feedback I've corrected it to no longer match domains that start or end with a hyphen.",
        "refined_prompt": "\nMatch examples:\n- \"host.domain.com\"\n- \"_host.domain.com\"\n- \"1host-2._ldap.domain.com\"\nNon-match examples:\n- \"33.domain.com\"\n- \"host..com\"",
        "matches": [
            "host.domain.com",
            "_host.domain.com",
            "1host-2._ldap.domain.com"
        ],
        "non_matches": [
            "33.domain.com",
            "host..com",
            "a-.com"
        ],
        "stress_tests": []
    },
    {
        "id": 1492,
        "expression": "^((0[1-9])|(1[0-2]))\\/((0[1-9])|(1[0-9])|(2[0-9])|(3[0-1]))\\/(\\d{4})$",
        "raw_prompt": "This regular expressions matches dates in the format MM/DD/YYYY where MM can be 01 to 12, DD can be 01 to 31 and YYYY is always 4 digits long.",
        "refined_prompt": "\nMatch examples:\n- \"12/25/2007\"\n- \"11/07/1517\"\n- \"02/25/2727\"\nNon-match examples:\n- \"1/27/1977\"\n- \"00/01/000\"",
        "matches": [
            "12/25/2007",
            "11/07/1517",
            "02/25/2727"
        ],
        "non_matches": [
            "1/27/1977",
            "00/01/000",
            "15/07/2002"
        ],
        "stress_tests": []
    },
    {
        "id": 1493,
        "expression": "(src|href|action)=\"(?!http://|#|mailto:|&)([^/#\"])",
        "raw_prompt": "If when making a website you need to find your relative paths, this regex will find them. You can use the follow to make them absolute:\n\\1=\"/\\2",
        "refined_prompt": "\nMatch examples:\n- \"src=\"images\"\"\n- \"href=\"index.html\"\"\n- \"action=\"process.php\"\"\nNon-match examples:\n- \"src=\"/images\"\"\n- \"href=\"/index.html\"\"",
        "matches": [
            "src=\"images\"",
            "href=\"index.html\"",
            "action=\"process.php\""
        ],
        "non_matches": [
            "src=\"/images\"",
            "href=\"/index.html\"",
            "action=\"/process.php\"",
            "href=\"http://www.google.com\"",
            "href=\"mailto:ceo@ceo.com\"",
            "href=\"#\"",
            "href=\"\"",
            "href=\"&name=test\""
        ],
        "stress_tests": []
    },
    {
        "id": 1494,
        "expression": "^([A-Z][a-z]+)\\s([A-Z][a-zA-Z-]+)$",
        "raw_prompt": "The pattern matches what would at least appear to be a first and last name, with an optional hyphenated last name. There is an obvious flaw that it can't distinguish between actual names and any two words that start with capital letters as noted in the matching text. Also, two part first names like \"Mary Jo\" can cause problems.",
        "refined_prompt": "\nMatch examples:\n- \"John Smith\"\n- \"Jane Smith-Doe\"\n- \"John McSmith\"\nNon-match examples:\n- \"john smith\"\n- \"J Smith\"",
        "matches": [
            "John Smith",
            "Jane Smith-Doe",
            "John McSmith",
            "Abc Xyz"
        ],
        "non_matches": [
            "john smith",
            "J Smith",
            "Mrs. Doe"
        ],
        "stress_tests": []
    },
    {
        "id": 1495,
        "expression": "[0-9]{4}-([0][0-9]|[1][0-2])-([0][0-9]|[1][0-9]|[2][0-9]|[3][0-1])",
        "raw_prompt": "This function does basic testing for the YYYY-MM-DD date format.",
        "refined_prompt": "\nMatch examples:\n- \"1981-10-16\"\nNon-match examples:\n- \"1981-13-10\"",
        "matches": [
            "1981-10-16"
        ],
        "non_matches": [
            "1981-13-10"
        ],
        "stress_tests": []
    },
    {
        "id": 1496,
        "expression": "(UPDATE\\s+)(\\w+)\\s+(SET)\\s+([\\w+\\s*=\\s*\\w+,?\\s*]+)\\s+(WHERE.+)",
        "raw_prompt": "Use with \"/i\" flag (case-insensitive) to match any valid SQL UPDATE statement, and to parse it into it's component parts. Most useful will be group $2, the table name, group $4, the field=value list, and group $5, the WHERE clause.",
        "refined_prompt": "\nMatch examples:\n- \"UPDATE table1 SET field1=value1,field2=value WHERE field4=value4\"\nNon-match examples:\n- \"UPDATE table1 SET field1=value1,field2=value\"",
        "matches": [
            "UPDATE table1 SET field1=value1,field2=value WHERE field4=value4"
        ],
        "non_matches": [
            "UPDATE table1 SET field1=value1,field2=value"
        ],
        "stress_tests": []
    },
    {
        "id": 1502,
        "expression": "ISBN(?:-13)?:?\\x20*(?=.{17}$)97(?:8|9)([ -])\\d{1,5}\\1\\d{1,7}\\1\\d{1,6}\\1\\d$",
        "raw_prompt": "This regex matches the new 13 digit ISBN. The ISBN number must be preceded by the text \"ISBN:\" or \"ISBN-13:\" , the colon is optional. The proper lengthes of the ISBN elements is checked. The is no check for the validity of the check digit.",
        "refined_prompt": "\nMatch examples:\n- \"ISBN-13: 978-1-4028-9462-6\"\nNon-match examples:\n- \"ISBN-10: 1-4028-9462-7\"",
        "matches": [
            "ISBN-13: 978-1-4028-9462-6"
        ],
        "non_matches": [
            "ISBN-10: 1-4028-9462-7"
        ],
        "stress_tests": []
    },
    {
        "id": 1503,
        "expression": "(INSERT INTO\\s+)(\\w+)(\\s+\\()([\\w+,?\\s*]+)(\\)\\s+VALUES\\s+\\()(['?\\w+'?,?\\s*]+)(\\))",
        "raw_prompt": "Use with \"/i\" flag (case-insensitive) to match a fully qualified SQL INSERT statement, and to parse it into it's component parts. Group $2 will contain the table name, $4 the field list, and $6 the value list.",
        "refined_prompt": "\nMatch examples:\n- \"INSERT INTO table (field1, field2) VALUES (value1, value2)\"\nNon-match examples:\n- \"INSERT INTO table VALUES (value1, value2)\"",
        "matches": [
            "INSERT INTO table (field1, field2) VALUES (value1, value2)"
        ],
        "non_matches": [
            "INSERT INTO table VALUES (value1, value2)"
        ],
        "stress_tests": []
    },
    {
        "id": 1504,
        "expression": "(INSERT INTO\\s+)(\\w+)(\\s+\\()([\\w+,?\\s*]+)(\\)\\s+VALUES\\s+)((\\(['?\\w+'?,?\\s*]+\\)\\,?;?\\s*)+)",
        "raw_prompt": "Use with \"/i\" flag (case-insensitive) to match a fully qualified SQL INSERT statement, and to parse it into it's component parts. Group $2 will contain the table name, $4 the field list, and $6 the all of the value lists.",
        "refined_prompt": "\nMatch examples:\n- \"INSERT INTO table (field1, field2) VALUES (value1, value2); (value3, value4) or INSERT INTO table (field1, field2) VALUES (value1, value2), (value3, value4)\"\nNon-match examples:\n- \"INSERT INTO table VALUES (value1, value2)\"",
        "matches": [
            "INSERT INTO table (field1, field2) VALUES (value1, value2); (value3, value4) or INSERT INTO table (field1, field2) VALUES (value1, value2), (value3, value4)"
        ],
        "non_matches": [
            "INSERT INTO table VALUES (value1, value2)"
        ],
        "stress_tests": []
    },
    {
        "id": 1512,
        "expression": "^(((19|20)(([0][48])|([2468][048])|([13579][26]))|2000)[\\-](([0][13578]|[1][02])[\\-]([012][0-9]|[3][01])|([0][469]|11)[\\-]([012][0-9]|30)|02[\\-]([012][0-9]))|((19|20)(([02468][1235679])|([13579][01345789]))|1900)[\\-](([0][13578]|[1][02])[\\-]([012][0-9]|[3][01])|([0][469]|11)[\\-]([012][0-9]|30)|02[\\-]([012][0-8])))$",
        "raw_prompt": "This regex match dates in the international standard date notation by ISO (IS0 8601). It can validate any dates between 1900-01-01 and 2099-12-31 ant take account of leap years. The format is mandatory and the hyphen is needed. You could easily change it to accept other separators. It has been tested with Regex Coach and PHP.",
        "refined_prompt": "\nMatch examples:\n- \"1900-01-01\"\n- \"2099-12-31\"\n- \"2004-02-29\"\nNon-match examples:\n- \"20060526\"\n- \"1900-02-29\"",
        "matches": [
            "1900-01-01",
            "2099-12-31",
            "2004-02-29"
        ],
        "non_matches": [
            "20060526",
            "1900-02-29",
            "2100-01-01"
        ],
        "stress_tests": []
    },
    {
        "id": 1515,
        "expression": "^(-?)(((\\d{1,3})(,\\d{3})*)|(\\d+))(\\.\\d{1,2})?$",
        "raw_prompt": "This RegEx checks whether the input is a number or not. Number may contain commas a seperators, can contain one or two decimal places and can be positive or negative.",
        "refined_prompt": "\nMatch examples:\n- \"100,000,000.00\"\n- \"-100,000,000.00\"\n- \"100,000,000\"\nNon-match examples:\n- \"100,000,00.00\"\n- \"1000.000\"",
        "matches": [
            "100,000,000.00",
            "-100,000,000.00",
            "100,000,000",
            "-100,000,000",
            "100000000.00",
            "-100000000.00",
            "100000000",
            "-100000000"
        ],
        "non_matches": [
            "100,000,00.00",
            "1000.000",
            "1000."
        ],
        "stress_tests": []
    },
    {
        "id": 1520,
        "expression": "^1?[1-2]$|^[1-9]$|^[1]0$",
        "raw_prompt": "Get one and two numeric digits between 1 and 12 inclusive, positive numbers only (Zeros are excluded and so is values higher than 12).",
        "refined_prompt": "\nMatch examples:\n- \"1\"\n- \"6\"\n- \"12\"\nNon-match examples:\n- \"-1\"\n- \"0\"",
        "matches": [
            "1",
            "6",
            "12"
        ],
        "non_matches": [
            "-1",
            "0",
            "13"
        ],
        "stress_tests": []
    },
    {
        "id": 1522,
        "expression": "&(?![a-z]+;|#\\d+;)",
        "raw_prompt": "Single & character is not valid in HTML or XHTML code. In this case you can replace this character with its entity (if & character is not member of other entity [&amp;#353;]). example: preg_replace('/&(?!amp;)/', '&amp;amp;', $str).\n(thanks to mr. Mrva)",
        "refined_prompt": "\nMatch examples:\n- \"&\"\nNon-match examples:\n- \"&amp;amp;\"\n- \"&amp;quot;\"",
        "matches": [
            "&"
        ],
        "non_matches": [
            "&amp;amp;",
            "&amp;quot;",
            "&amp;#353;",
            "&blah;",
            "&amp;copy;"
        ],
        "stress_tests": []
    },
    {
        "id": 1523,
        "expression": "^((http|https|ftp)\\://|www\\.)[a-zA-Z0-9\\-\\.]+\\.[a-zA-Z]{2,4}(/[a-zA-Z0-9\\-\\._\\?=\\,\\'\\+%\\$#~]*[^\\.\\,\\)\\(\\s])*$",
        "raw_prompt": "Matches any valid URLs which can activate links in a text.",
        "refined_prompt": "\nMatch examples:\n- \"www.something.com\"\n- \"http://something.com/something?action=delete\"\n- \"http://www.something.com/~etc\"\nNon-match examples:\n- \"http://www.something.com/,\"\n- \"wwww.something.com\"",
        "matches": [
            "www.something.com",
            "http://something.com/something?action=delete",
            "http://www.something.com/~etc"
        ],
        "non_matches": [
            "http://www.something.com/,",
            "wwww.something.com",
            ""
        ],
        "stress_tests": []
    },
    {
        "id": 1524,
        "expression": "[({]?(0x)?[0-9a-fA-F]{8}([-,]?(0x)?[0-9a-fA-F]{4}){2}((-?[0-9a-fA-F]{4}-?[0-9a-fA-F]{12})|(,\\{0x[0-9a-fA-F]{2}(,0x[0-9a-fA-F]{2}){7}\\}))[)}]?",
        "raw_prompt": "It matches all strings that the .NET Framework API \"new Guid(string guid)\" can recognize. A String that contains a GUID in one of the following formats ('d' represents a hexadecimal digit whose case is ignored):",
        "refined_prompt": "\nMatch examples:\n- \"ca761232ed4211cebacd00aa0057b223\"\n- \"CA761232-ED42-11CE-BACD-00AA0057B223\"\n- \"{CA761232-ED42-11CE-BACD-00AA0057B223}\"\nNon-match examples:\n- \"Invalid guids\"",
        "matches": [
            "ca761232ed4211cebacd00aa0057b223",
            "CA761232-ED42-11CE-BACD-00AA0057B223",
            "{CA761232-ED42-11CE-BACD-00AA0057B223}",
            "(CA761232-ED42-11CE-BACD-00AA0057B223)",
            "{0xCA761232,0xED42,0x11CE,{0xBA,0xCD,0x00,0xAA,0x00,0x57,0xB2,0x23}}"
        ],
        "non_matches": [
            "Invalid guids"
        ],
        "stress_tests": []
    },
    {
        "id": 1530,
        "expression": "^(([1-9][0-9]*)|((([0])|([1-9][0-9]*))\\.[0-9]+)|((([1-9][0-9]*)|((([0])|([1-9][0-9]*))\\.[0-9]+))\\:)*(([1-9][0-9]*)|((([0])|([1-9][0-9]*))\\.[0-9]+)))$",
        "raw_prompt": "Accepts a colon-delimited string of positive integers and/or decimal numbers in any combination. Spaces are not permitted. Decimal numbers of less than 1 must be prefixed with a zero (e.g. accepts 0.1, but not .1), and numbers with a trailing decimal point are not accepted (e.g. accepts 3.0, but not 3.). A lone zero is not accpeted (e.g. accepts 1.02:3:4.5, but not 1.02:0:4.5). Developed from a similar expression by Steven Smith on this site.",
        "refined_prompt": "\nMatch examples:\n- \"1.2\"\n- \"0.1:0.5:56:6.70\"\n- \"3:6.78954:1:2:3\"\nNon-match examples:\n- \"0.1:.5:56\"\n- \"-6.70:3.\"",
        "matches": [
            "1.2",
            "0.1:0.5:56:6.70",
            "3:6.78954:1:2:3"
        ],
        "non_matches": [
            "0.1:.5:56",
            "-6.70:3.",
            "5: 0.1:0"
        ],
        "stress_tests": []
    },
    {
        "id": 1536,
        "expression": "^(( )*\\\u00a3{0,1}( )*)\\d*(.\\d{1,2})?$",
        "raw_prompt": "This expression is for matching the currency input. The \u00a3 is optional. e.g. \u00a312.12, \u00a3 12.12, 12.12, 12.",
        "refined_prompt": "\nMatch examples:\n- \"\u00a3123.00\"\nNon-match examples:\n- \"$123.00\"",
        "matches": [
            "\u00a3123.00"
        ],
        "non_matches": [
            "$123.00"
        ],
        "stress_tests": []
    },
    {
        "id": 1537,
        "expression": "^\\({0,1}((0|\\+61)(2|4|3|7|8)){0,1}\\){0,1}(\\ |-){0,1}[0-9]{2}(\\ |-){0,1}[0-9]{2}(\\ |-){0,1}[0-9]{1}(\\ |-){0,1}[0-9]{3}$",
        "raw_prompt": "Australian phone number validator. Accepts all forms of Australian phone numbers in different formats (area code in brackets, no area code, spaces between 2-3 and 6-7th digits, +61 international dialing code). Checks that area codes are valid (when entered).",
        "refined_prompt": "\nMatch examples:\n- \"0403111111\"\n- \"(03) 1111 1111\"\n- \"+61403111111\"\nNon-match examples:\n- \"9111 11111\"\n- \"99 1111 1111\"",
        "matches": [
            "0403111111",
            "(03) 1111 1111",
            "+61403111111",
            "02 9111 1111",
            "0403 111 111",
            "91111111"
        ],
        "non_matches": [
            "9111 11111",
            "99 1111 1111"
        ],
        "stress_tests": []
    },
    {
        "id": 1538,
        "expression": "(http(s?)://|[a-zA-Z0-9\\-]+\\.)[a-zA-Z0-9/~\\-]+\\.[a-zA-Z0-9/~\\-_,&\\?\\.;]+[^\\.,\\s<]",
        "raw_prompt": "This regex avoids matching typical mistakes where a sentence ends but there is no space after the full stop (period). Other regexes will think any two words with a dot in between is a URL! My regex does not require http:// and if there isn't http:// it will need to find AT LEAST two dots to guarantee its likely to be a URL and not a sentence that's missing a space like this.It will match www.test.com, http://test.com, test.com/index.htm but it will NOT match test.com. It will not match a dot or a comma at the very end which some people may type when including a URL in a sentence like this www.test.com, or this www.test.com.",
        "refined_prompt": "\nMatch examples:\n- \"sub.test.com\"\nNon-match examples:\n- \"test.com\"",
        "matches": [
            "sub.test.com"
        ],
        "non_matches": [
            "test.com"
        ],
        "stress_tests": []
    },
    {
        "id": 1539,
        "expression": "^N[1-9][0-9]{0,4}$|^N[1-9][0-9]{0,3}[A-Z]$|^N[1-9][0-9]{0,2}[A-Z]{2}$",
        "raw_prompt": "FAA Tail Numbers as described here: http://www.faa.gov/licenses_certificates/aircraft_certification/aircraft_registry/special_nnumbers/",
        "refined_prompt": "\nMatch examples:\n- \"N12345\"\nNon-match examples:\n- \"N123456\"",
        "matches": [
            "N12345"
        ],
        "non_matches": [
            "N123456"
        ],
        "stress_tests": []
    },
    {
        "id": 1540,
        "expression": "^((\\(?\\+45\\)?)?)(\\s?\\d{2}\\s?\\d{2}\\s?\\d{2}\\s?\\d{2})$",
        "raw_prompt": "This should help in finding european style phone numbers (without hyphens), particularly danish numbers with consist of 8 digits, and can be separated by a whitespace.",
        "refined_prompt": "\nMatch examples:\n- \"(+45) 35 35 35 35\"\n- \"+45 35 35 35 35\"\n- \"35 35 35 35\"\nNon-match examples:\n- \"(45)35353535\"\n- \"4535353535\"",
        "matches": [
            "(+45) 35 35 35 35",
            "+45 35 35 35 35",
            "35 35 35 35",
            "35353535"
        ],
        "non_matches": [
            "(45)35353535",
            "4535353535"
        ],
        "stress_tests": []
    },
    {
        "id": 1542,
        "expression": "^[^\\s]+@[^\\.][^\\s]{1,}\\.[A-Za-z]{2,10}$",
        "raw_prompt": "Simple email regex following some liberal email address validation. Requires non-whitespace name (but allows any other character), an @ symbol, then a non-period character, then some non-whitespace text (but allows just about everything else), and finishes with a tld that is 2 to 10 chars long. Two-characters is the universal minimum, 10 seemed like a good upper limit for now and allows room to grow. You can use this for a quick sanity check. Yes, the user can still enter invalid email addys, but then they won't get their emails, will they?",
        "refined_prompt": "\nMatch examples:\n- \"foo-bar@foo.the.20.bars.com\"\nNon-match examples:\n- \"foo bar@foo.com\"\n- \"foobar@.com\"",
        "matches": [
            "foo-bar@foo.the.20.bars.com"
        ],
        "non_matches": [
            "foo bar@foo.com",
            "foobar@.com",
            "foo@bar.c"
        ],
        "stress_tests": []
    },
    {
        "id": 1549,
        "expression": "\\d\\d?\\d?\\.\\d\\d?\\d?\\.\\d\\d?\\d?\\.\\d\\d?\\d?",
        "raw_prompt": "Quick and simple way of matching a well-formed IPV4 (dotted quad) ip address.",
        "refined_prompt": "\nMatch examples:\n- \"192.168.1.19\"\nNon-match examples:\n- \"19x.168.1.19\"",
        "matches": [
            "192.168.1.19"
        ],
        "non_matches": [
            "19x.168.1.19"
        ],
        "stress_tests": []
    },
    {
        "id": 1553,
        "expression": "^((0|[1-9]+[0-9]*)-(0|[1-9]+[0-9]*);|(0|[1-9]+[0-9]*);)*?((0|[1-9]+[0-9]*)-(0|[1-9]+[0-9]*)|(0|[1-9]+[0-9]*)){1}$",
        "raw_prompt": "Matches any range of numbers according to the format x;x-xx where \"x\" is a number between 0 and 9, however 0 may not be a the starting digit of a multi-digit number (i.e. 001). The format specifies that a range is denoted by x-x (numbers are seperated by a hyphen) and multiple range specification or single numbers may be seperated by a semi-colon \";\".",
        "refined_prompt": "\nMatch examples:\n- \"0\"\n- \"0-3\"\n- \"1;2\"\nNon-match examples:\n- \"1;\"\n- \"2-3;\"",
        "matches": [
            "0",
            "0-3",
            "1;2",
            "1;2-3",
            "2-3;10",
            "1-2;3-40"
        ],
        "non_matches": [
            "1;",
            "2-3;",
            "a;1",
            "2-3;a",
            "001-3",
            "1-003"
        ],
        "stress_tests": []
    },
    {
        "id": 1566,
        "expression": "^\\d*[0-9](\\.\\d?[0-9])?$",
        "raw_prompt": "Allow Decimal values as [decimal](*, 2), scale length between 0 and 2",
        "refined_prompt": "\nMatch examples:\n- \"87645.09\"\n- \"87645.9\"\n- \"87645.10\"\nNon-match examples:\n- \"87645.091\"\n- \"87645.\"",
        "matches": [
            "87645.09",
            "87645.9",
            "87645.10",
            "87645"
        ],
        "non_matches": [
            "87645.091",
            "87645."
        ],
        "stress_tests": []
    },
    {
        "id": 1567,
        "expression": "^((\\d{0,1}[0-9](\\.\\d{0,1}[0-9])?)|(100))$",
        "raw_prompt": "Allow Percentage with optional scale (max length of 2) between (00.00 and 100)",
        "refined_prompt": "\nMatch examples:\n- \"00.00\"\n- \"00\"\n- \"99.99\"\nNon-match examples:\n- \"99.\"\n- \"100.1\"",
        "matches": [
            "00.00",
            "00",
            "99.99",
            "99.5",
            "100"
        ],
        "non_matches": [
            "99.",
            "100.1"
        ],
        "stress_tests": []
    },
    {
        "id": 1570,
        "expression": "^([0-9]{4})-([0-1][0-9])-([0-3][0-9])\\s([0-1][0-9]|[2][0-3]):([0-5][0-9]):([0-5][0-9])$",
        "raw_prompt": "SQL datetime format tester YYYY-MM-DD HH:MM:SS",
        "refined_prompt": "\nMatch examples:\n- \"2007-07-01 01:01:01\"\n- \"2007-08-04 18:01:01\"\nNon-match examples:\n- \"2007-07-01\"\n- \"2007/07/01\"",
        "matches": [
            "2007-07-01 01:01:01",
            "2007-08-04 18:01:01"
        ],
        "non_matches": [
            "2007-07-01",
            "2007/07/01",
            "2007-08-04 24:00:00",
            "2007/07/01 12:12"
        ],
        "stress_tests": []
    },
    {
        "id": 1579,
        "expression": "(^[0][.]{1}[0-9]{0,}[1-9]+[0-9]{0,}$)|(^[1-9]+[0-9]{0,}[.]?[0-9]{0,}$)",
        "raw_prompt": "This pattern will match any positive number(Real or Integer). It will not match ZERO or any variation of zero (ie 0.00)",
        "refined_prompt": "\nMatch examples:\n- \"0.003\"\n- \"34\"\n- \"6.000\"\nNon-match examples:\n- \"0.0\"\n- \"-34\"",
        "matches": [
            "0.003",
            "34",
            "6.000",
            "7.3"
        ],
        "non_matches": [
            "0.0",
            "-34",
            "-23.00",
            "0",
            "-0.30"
        ],
        "stress_tests": []
    },
    {
        "id": 1582,
        "expression": "(<(tag1|tag2)[^>]*\\/?>)[\\w\\S\\s]*?(<\\/(?:\\2)>)",
        "raw_prompt": "This will remove the InnerHTML of a tag. For instance, if you wanted to clear all paragraphs and h1 tags on a page, you would simply put in \"p\" and \"h1\" into those tags, and they would end up looking like <h1></h1> <p></p> <p></p>. It's useful when you're doing work based off a template and you need to get back to the original template.",
        "refined_prompt": "\nMatch examples:\n- \"<tag1>Lorem ipsum dolor sit amet</tag1>\"\nNon-match examples:\n- \"<tag1>Lorem ipsum doler</othertag>\"",
        "matches": [
            "<tag1>Lorem ipsum dolor sit amet</tag1>"
        ],
        "non_matches": [
            "<tag1>Lorem ipsum doler</othertag>"
        ],
        "stress_tests": []
    },
    {
        "id": 1585,
        "expression": "([0-9a-zA-Z]([-.\\w]*[0-9a-zA-Z])*@([0-9a-zA-Z][-\\w]*[0-9a-zA-Z]\\.)+[a-zA-Z]{2,9})$",
        "raw_prompt": "This pattern validates email address. it allows (1)numeric characters and underscore(_) in an address.(2)numeric characters in domain name. it doesn't match user names with a dot(.). doesn;t allow username starting or ending with @ underscore.",
        "refined_prompt": "\nMatch examples:\n- \"san_z@asg.com\"\n- \"xy_z@123g.co.in\"\n- \"san@ss.com.in\"\nNon-match examples:\n- \"ssaa_s@asg.c\"\n- \"a@a.com\"",
        "matches": [
            "san_z@asg.com",
            "xy_z@123g.co.in",
            "san@ss.com.in"
        ],
        "non_matches": [
            "ssaa_s@asg.c",
            "a@a.com",
            "san@s.co.in",
            "san@apr.com.in.i"
        ],
        "stress_tests": []
    },
    {
        "id": 1586,
        "expression": "^(5[1-5]\\d{2})\\d{12}|(4\\d{3})(\\d{12}|\\d{9})$",
        "raw_prompt": "A simple regex to check for only Visa and MasterCard with no dashes or spaces. Visa starts with a 4 and is 13 or 16 digits long, MasterCard starts with a 51 through 55 and is 16 digits long. I noticed that some of the other formulas don't account for Visa being valid with only 13 digits. I used this for a PayPal processor (which doesn't allow dashes or spaces) and modified it from others on this site. Enjoy.",
        "refined_prompt": "\nMatch examples:\n- \"5555555555554444\"\n- \"5105105105105100\"\n- \"4012888888881881\"\nNon-match examples:\n- \"123412341234\"\n- \"4222-2222-2222-2222\"",
        "matches": [
            "5555555555554444",
            "5105105105105100",
            "4012888888881881",
            "4222222222222"
        ],
        "non_matches": [
            "123412341234",
            "4222-2222-2222-2222",
            "visa",
            "41231234123412345"
        ],
        "stress_tests": []
    },
    {
        "id": 1587,
        "expression": "\"[^\"]+\"",
        "raw_prompt": "Finds strings enclosed in double quotations",
        "refined_prompt": "Finds strings of characters enclosed in double quotations\nMatch examples:\n- \"\"MatchingText\"\"\n- \"\"enclosed\"\"\n- \"\"2023\"\"\nNon-match examples:\n- \"NonMatchingText\"\n- \"NoQuotes\"",
        "matches": [
            "\"MatchingText\"",
            "\"enclosed\"",
            "\"2023\"",
            "\"@gmail.com\"",
            "\" \"",
            "\" 1234\"",
            "\"\\n\"",
            "\"1234 E. Apple St.\"",
            "\"~\"",
            "\"[ ]\"",
            "\" @ \"",
            "\"HELLO!\"",
            "\"https://www.amazon.com/\""
        ],
        "non_matches": [
            "NonMatchingText",
            "NoQuotes",
            "\"NoEnding",
            "NoBeginning\"",
            "\"\"DoubleBeginning",
            "DoubleEnding\"\"",
            "'Apostrophe'",
            "'BeginningApostrophe",
            "EndingApostrophe'",
            "\"SwitchedBack'",
            "'SwitchedFront\"",
            "''DoubleApostrophe''"
        ],
        "stress_tests": []
    },
    {
        "id": 1588,
        "expression": "(15(8[48]|9[26]))|((1[6-9]|[2-9]\\d)(0[48]|[13579][26]|[2468][048]))|(([2468][048]|16|3579[26])00)",
        "raw_prompt": "Validates four-digit leap years after 1582 (when Pope Gregory XIII switched to the Gregorian calendar). The last recognized leap year is 9996, so no worries with the y3k bug.",
        "refined_prompt": "\nMatch examples:\n- \"1584\"\n- \"2000\"\n- \"2048\"\nNon-match examples:\n- \"1200\"\n- \"1580\"",
        "matches": [
            "1584",
            "2000",
            "2048"
        ],
        "non_matches": [
            "1200",
            "1580",
            "1941",
            "1800"
        ],
        "stress_tests": []
    },
    {
        "id": 1589,
        "expression": "^\\d{4}(\\/|-)([0][1-9]|[1][0-2])(\\/|-)([0][1-9]|[1-2][0-9]|[3][0-1])$",
        "raw_prompt": "This regular expressions matches dates of the form YYYY/XX/ZZ ,where YYYY is always 4 digits long, XX can be 01 to 12 and ZZ can be 01 to 31",
        "refined_prompt": "\nMatch examples:\n- \"2007/01/20\"\n- \"0001/02/31\"\n- \"9999-12-31\"\nNon-match examples:\n- \"01/1/01\"\n- \"99-9-9\"",
        "matches": [
            "2007/01/20",
            "0001/02/31",
            "9999-12-31"
        ],
        "non_matches": [
            "01/1/01",
            "99-9-9",
            "2008-00-00"
        ],
        "stress_tests": []
    },
    {
        "id": 1592,
        "expression": "^[-+]?\\d+(\\.\\d{2})?$",
        "raw_prompt": "It accepts only two integer after a decimal point. The number may be in Positive or negative.",
        "refined_prompt": "Accepts positive or negative integer values. If there is a decimal point, there must be exactly two decimal places given.\nMatch examples:\n- \"+1212.14\"\n- \"-12.13\"\n- \"122.45\"\nNon-match examples:\n- \"1212.4564\"\n- \"-11.5858\"",
        "matches": [
            "+1212.14",
            "-12.13",
            "122.45",
            "-0.44",
            "+0000444444.44",
            "-726.00",
            "555",
            "99999999999.99",
            "0.00",
            "1234.12",
            "05.05",
            "-00.00",
            "+9.99"
        ],
        "non_matches": [
            "1212.4564",
            "-11.5858",
            "12.000",
            "0.",
            "1234.1234",
            "+.",
            "00-",
            "0.9",
            "0.999999999999999999",
            "+3.14159265359",
            "-+0.99",
            "-.00"
        ],
        "stress_tests": []
    },
    {
        "id": 1593,
        "expression": "^((((19[0-9][0-9])|(2[0-9][0-9][0-9]))([-])(0[13578]|10|12)([-])(0[1-9]|[12][0-9]|3[01]))|(((19[0-9][0-9])|(2[0-9][0-9][0-9]))([-])(0[469]|11)([-])([0][1-9]|[12][0-9]|30))|(((19[0-9][0-9])|(2[0-9][0-9][0-9]))([-])(02)([-])(0[1-9]|1[0-9]|2[0-8]))|(([02468][048]00)([-])(02)([-])(29))|(([13579][26]00)([-])(02)([-])(29))|(([0-9][0-9][0][48])([-])(02)([-])(29))|(([0-9][0-9][2468][048])([-])(02)([-])(29))|(([0-9][0-9][13579][26])([-])(02)([-])(29)))$",
        "raw_prompt": "This regex checks if a date is in ISO-format (yyyy-mm-dd). Leap year should be checked too. Date has to be between 1900-01-01 and 2999-12-31.",
        "refined_prompt": "\nMatch examples:\n- \"1900-01-01\"\n- \"2025-03-15\"\n- \"2999-12-31\"\nNon-match examples:\n- \"1890-01-01\"\n- \"2008-19-45\"",
        "matches": [
            "1900-01-01",
            "2025-03-15",
            "2999-12-31"
        ],
        "non_matches": [
            "1890-01-01",
            "2008-19-45",
            "3000-01-01"
        ],
        "stress_tests": []
    },
    {
        "id": 1594,
        "expression": "^(((0[1-9]|[12][0-9]|3[01])([\\.])(0[13578]|10|12)([\\.])((19[0-9][0-9])|(2[0-9][0-9][0-9])))|(([0][1-9]|[12][0-9]|30)([\\.])(0[469]|11)([\\.])((19[0-9][0-9])|(2[0-9][0-9][0-9])))|((0[1-9]|1[0-9]|2[0-8])([\\.])(02)([\\.])((19[0-9][0-9])|(2[0-9][0-9][0-9])))|((29)([\\.])(02)([\\.])([02468][048]00))|((29)([\\.])(02)([\\.])([13579][26]00))|((29)([\\.])(02)([\\.])([0-9][0-9][0][48]))|((29)([\\.])(02)([\\.])([0-9][0-9][2468][048]))|((29)([\\.])(02)([\\.])([0-9][0-9][13579][26])))$",
        "raw_prompt": "This regex checks if a date is in german date format (dd.mm.yyyy). Leap year should be checked too. Date has to be between 01.01.1900 and 31.12.2999.",
        "refined_prompt": "\nMatch examples:\n- \"01.01.1900\"\n- \"20.11.2009\"\n- \"31.12.2999\"\nNon-match examples:\n- \"01.01.1890\"\n- \"11.20.2009\"",
        "matches": [
            "01.01.1900",
            "20.11.2009",
            "31.12.2999"
        ],
        "non_matches": [
            "01.01.1890",
            "11.20.2009",
            "01.01.3000"
        ],
        "stress_tests": []
    },
    {
        "id": 1597,
        "expression": "^(http(?:s)?\\:\\/\\/[a-zA-Z0-9]+(?:(?:\\.|\\-)[a-zA-Z0-9]+)+(?:\\:\\d+)?(?:\\/[\\w\\-]+)*(?:\\/?|\\/\\w+\\.[a-zA-Z]{2,4}(?:\\?[\\w]+\\=[\\w\\-]+)?)?(?:\\&[\\w]+\\=[\\w\\-]+)*)$",
        "raw_prompt": "A simple but powerful URL validating regex. Accepts multiple sub-domains and sub-directories. Even accept query strings.\nNow accept ports! Accepts HTTP or HTTPS.\nAlso accepts optional \"/\" on end of address.",
        "refined_prompt": "\nMatch examples:\n- \"http://website.com\"\n- \"http://subdomain.web-site.com/cgi-bin/perl.cgi?key1=value1&key2=value2\"\nNon-match examples:\n- \"http://website.com/perl.cgi?key=\"\n- \"http://web-site.com/cgi-bin/perl.cgi?key1=value1&key2\"",
        "matches": [
            "http://website.com",
            "http://subdomain.web-site.com/cgi-bin/perl.cgi?key1=value1&key2=value2"
        ],
        "non_matches": [
            "http://website.com/perl.cgi?key=",
            "http://web-site.com/cgi-bin/perl.cgi?key1=value1&key2"
        ],
        "stress_tests": []
    },
    {
        "id": 1599,
        "expression": "^(http\\:\\/\\/[a-zA-Z0-9\\-\\.]+\\.[a-zA-Z]{2,3}(?:\\/\\S*)?(?:[a-zA-Z0-9_])+\\.(?:jpg|jpeg|gif|png))$",
        "raw_prompt": "A nice little regex to verify a URL pointing towards an image. Can be useful.",
        "refined_prompt": "\nMatch examples:\n- \"http://website.com/directory/image.gif\"\nNon-match examples:\n- \"www.website.com/image.php\"",
        "matches": [
            "http://website.com/directory/image.gif"
        ],
        "non_matches": [
            "www.website.com/image.php"
        ],
        "stress_tests": []
    },
    {
        "id": 1601,
        "expression": "[0-9][0-9][0-9][0-9]-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])\\s{1}(0[0-9]|1[0-9]|2[0-3]):([0-5][0-9])",
        "raw_prompt": "Validation of date (YYYY-MM-DD format) and time (HH:MM format) with one space between both blocks. I'm not able (with this) to validate the correct last day of each month. Anyway, it helps :-)",
        "refined_prompt": "\nMatch examples:\n- \"2007-01-01 00:00\"\nNon-match examples:\n- \"2007-1-1 0:0\"",
        "matches": [
            "2007-01-01 00:00"
        ],
        "non_matches": [
            "2007-1-1 0:0"
        ],
        "stress_tests": []
    },
    {
        "id": 1606,
        "expression": "(?:\\([2-9][0-8]\\d\\)\\ ?|[2-9][0-8]\\d[\\-\\ \\.\\/]?)[2-9]\\d{2}[- \\.\\/]?\\d{4}\\b",
        "raw_prompt": "Matches NANP requirements for valid telephone numbers in the USA, its territories, Canada, Bermuda, and 16 Caribbean nations.<br>\nArea code: [2-9][0-8][0-9]<br>\nExchange code: [2-9][0-9][0-9]<br>\nStation code: [0-9][0-9][0-9][0-9]<br>\nAccepts common phone number separators like parentheses, dash/hyphen, slash, period, and space. Stops matching at any word boundary, including end of line. Adapted from Don Johnston's pattern.",
        "refined_prompt": "\nMatch examples:\n- \"8296399623\"\n- \"741 556-4630\"\n- \"319.380.3232\"\nNon-match examples:\n- \"(195)979-5873\"\n- \"763 027 5552\"",
        "matches": [
            "8296399623",
            "741 556-4630",
            "319.380.3232",
            "(859)673.5793",
            "660/471.5749"
        ],
        "non_matches": [
            "(195)979-5873",
            "763 027 5552",
            "596 270.0326",
            "8915551212"
        ],
        "stress_tests": []
    },
    {
        "id": 1611,
        "expression": "^(.{0,}(([a-zA-Z][^a-zA-Z])|([^a-zA-Z][a-zA-Z])).{4,})|(.{1,}(([a-zA-Z][^a-zA-Z])|([^a-zA-Z][a-zA-Z])).{3,})|(.{2,}(([a-zA-Z][^a-zA-Z])|([^a-zA-Z][a-zA-Z])).{2,})|(.{3,}(([a-zA-Z][^a-zA-Z])|([^a-zA-Z][a-zA-Z])).{1,})|(.{4,}(([a-zA-Z][^a-zA-Z])|([^a-zA-Z][a-zA-Z])).{0,})$",
        "raw_prompt": "Passwords with at least 1 letter, at least 1 non-letter, and at least 6 characters in length. It is lenthy with a repeating pattern so that I could validate all three conditions in one expression without using a lookahead, \"?=\", which are not handled correctly in Internet Explorer.",
        "refined_prompt": "\nMatch examples:\n- \"12345a\"\n- \"abcde*\"\n- \"ABC123\"\nNon-match examples:\n- \"12ab\"\n- \"abcdef\"",
        "matches": [
            "12345a",
            "abcde*",
            "ABC123"
        ],
        "non_matches": [
            "12ab",
            "abcdef",
            "123456"
        ],
        "stress_tests": []
    },
    {
        "id": 1618,
        "expression": "^([0-9]{0,5}|[0-9]{0,5}\\.[0-9]{0,3})$",
        "raw_prompt": "This regular expression is intended to limit numeric entries by allowed places before and after the decimal point. It also recognizes whole numbers. In this example the value cannot exceed 99999.999. To change the range, simply edit the numbers in curly braces. For example, to allow 7 digits (millions) before the decimal point, change both instances of {0,5} to {0,7}. Likewise, to change the decimals from allowing thousandths (3 digits) to just hundreths, change the {0,3} to {0,2}. This can be useful for numeric fields in SQL. This example was made to accommodate a numeric(8,3) field definition.",
        "refined_prompt": "\nMatch examples:\n- \"0\"\n- \"1\"\n- \"1.55\"\nNon-match examples:\n- \"abc\"\n- \"654321\"",
        "matches": [
            "0",
            "1",
            "1.55",
            "54321.123",
            ".12"
        ],
        "non_matches": [
            "abc",
            "654321",
            "12..34",
            ".1234"
        ],
        "stress_tests": []
    },
    {
        "id": 1621,
        "expression": "^((?:\\?[a-zA-Z0-9_]+\\=[a-zA-Z0-9_]+)?(?:\\&[a-zA-Z0-9_]+\\=[a-zA-Z0-9_]+)*)$",
        "raw_prompt": "This is a very simple regex that check the query part of a string. That is to say anything after the \"?\" at the end of an URL.",
        "refined_prompt": "\nMatch examples:\n- \"?key=value\"\n- \"?key1=value1&key2=value2\"\nNon-match examples:\n- \"key=value\"\n- \"?key=value&\"",
        "matches": [
            "?key=value",
            "?key1=value1&key2=value2"
        ],
        "non_matches": [
            "key=value",
            "?key=value&"
        ],
        "stress_tests": []
    },
    {
        "id": 1625,
        "expression": "^[^\\x00-\\x1f\\x21-\\x26\\x28-\\x2d\\x2f-\\x40\\x5b-\\x60\\x7b-\\xff]+$",
        "raw_prompt": "Matches common ASCII names without special characters.",
        "refined_prompt": "\nMatch examples:\n- \"Sir. Isaac Newton\"\n- \"Tom O'Leary\"\nNon-match examples:\n- \"Mar!y Ann\"\n- \"Bob_1\"",
        "matches": [
            "Sir. Isaac Newton",
            "Tom O'Leary"
        ],
        "non_matches": [
            "Mar!y Ann",
            "Bob_1",
            "~!@#$%^&*()_+=-0987654321`{}[]",
            "\\;:\"<>?,/"
        ],
        "stress_tests": []
    },
    {
        "id": 1632,
        "expression": "(?=[-_a-zA-Z0-9]*?[A-Z])(?=[-_a-zA-Z0-9]*?[a-z])(?=[-_a-zA-Z0-9]*?[0-9])[-_a-zA-Z0-9]{6,}",
        "raw_prompt": "Tests if the input consists of 6 or more letters, digits, underscores and hyphens. The input must contain at least one upper case ltter, one lower case letter and one digit.",
        "refined_prompt": "\nMatch examples:\n- \"M0_k3y\"\n- \"Pa-sW0rd\"\n- \"S1mPl3\"\nNon-match examples:\n- \"MonKey\"\n- \"PassWord\"",
        "matches": [
            "M0_k3y",
            "Pa-sW0rd",
            "S1mPl3"
        ],
        "non_matches": [
            "MonKey",
            "PassWord",
            "simple"
        ],
        "stress_tests": []
    },
    {
        "id": 1633,
        "expression": "(?<!^)(?=[A-Z])",
        "raw_prompt": "Used with the Regex.Split() function in .NET, this will easily split a camelCase word on the upper case letters, while not dropping any characters. (That makes it different from most split() functions -- it does not drop any characters.) More details in my blog - http://blogs.lotterypost.com/speednet/2007/08/simple-function-to-split-camelcase-words.htm",
        "refined_prompt": "\nMatch examples:\n- \"camelCase\"\nNon-match examples:\n- \"<empty string>\"",
        "matches": [
            "camelCase"
        ],
        "non_matches": [
            "<empty string>"
        ],
        "stress_tests": []
    },
    {
        "id": 1636,
        "expression": "^((192\\.168\\.0\\.)(1[7-9]|2[0-9]|3[0-2]))$",
        "raw_prompt": "This expression matches IP Addresses between 192.168.0.17 - 192.168.0.32 which is a block range of 16 addresses. I created this expression for Google Analytics to filter out hits from our companies office.",
        "refined_prompt": "\nMatch examples:\n- \"192.168.0.17\"\n- \"192.168.0.24\"\n- \"192.168.0.32\"\nNon-match examples:\n- \"192.168.0.16\"\n- \"192.168.0.33\"",
        "matches": [
            "192.168.0.17",
            "192.168.0.24",
            "192.168.0.32"
        ],
        "non_matches": [
            "192.168.0.16",
            "192.168.0.33"
        ],
        "stress_tests": []
    },
    {
        "id": 1638,
        "expression": "^(\\$)?((\\d{1,5})|(\\d{1,3})(\\,\\d{3})*)(\\.\\d{1,2})?$",
        "raw_prompt": "This regular expression is used for validating five digit numeric value which can be an amount $ separated with , sign.",
        "refined_prompt": "\nMatch examples:\n- \"80,000.00\"\n- \"80,000\"\n- \"80000\"\nNon-match examples:\n- \"800,00.00\"\n- \"80.000\"",
        "matches": [
            "80,000.00",
            "80,000",
            "80000",
            "80.00",
            "$80000.00"
        ],
        "non_matches": [
            "800,00.00",
            "80.000",
            "$8,0000.00"
        ],
        "stress_tests": []
    },
    {
        "id": 1642,
        "expression": "^(([0-9])|([0-2][0-9])|([3][0-1]))\\/(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\/\\d{4}$",
        "raw_prompt": "This regular expressions matches dates of the form dd/MMM/yyyy where dd can be 1 or 2 digits long, MMM is a month abbreviation, and yyyy is always 4 digits long.",
        "refined_prompt": "\nMatch examples:\n- \"1/Feb/2007\"\n- \"03/Jun/2007\"\n- \"31/Dec/2007\"\nNon-match examples:\n- \"1/2/2007\"\n- \"03/Jun/07\"",
        "matches": [
            "1/Feb/2007",
            "03/Jun/2007",
            "31/Dec/2007"
        ],
        "non_matches": [
            "1/2/2007",
            "03/Jun/07",
            "31-Dec-2007"
        ],
        "stress_tests": []
    },
    {
        "id": 1643,
        "expression": "^((4(\\d{12}|\\d{15}))|(5\\d{15})|(6011\\d{12})|(3(4|7)\\d{13}))$",
        "raw_prompt": "Matches Visa, American Express, Discover, and Mastercard only.",
        "refined_prompt": "\nMatch examples:\n- \"4111111111111\"\n- \"4111111111111111\"\n- \"5111111111111111\"\nNon-match examples:\n- \"411111111111\"\n- \"51111111111111111\"",
        "matches": [
            "4111111111111",
            "4111111111111111",
            "5111111111111111",
            "6011111111111111",
            "341111111111111",
            "371111111111111"
        ],
        "non_matches": [
            "411111111111",
            "51111111111111111",
            "6111111111111111",
            "321111111111111",
            "381111111111111"
        ],
        "stress_tests": []
    },
    {
        "id": 1644,
        "expression": "^\\{?[a-fA-F\\d]{32}\\}?$",
        "raw_prompt": "Matches only a 32 character hex string (Eg. MD5). Based off Chris Craft's expression:-)",
        "refined_prompt": "\nMatch examples:\n- \"09f8814c757a00f14efdb70e45f851d1\"\nNon-match examples:\n- \"46345678901234567890aaaabbbbbbzj\"",
        "matches": [
            "09f8814c757a00f14efdb70e45f851d1"
        ],
        "non_matches": [
            "46345678901234567890aaaabbbbbbzj"
        ],
        "stress_tests": []
    },
    {
        "id": 1653,
        "expression": "^(9\\d{2})([ \\-]?)([7]\\d|8[0-8])([ \\-]?)(\\d{4})$",
        "raw_prompt": "U.S. Individual Taxpayer Identification Number (ITIN) as defined in December 2006. The valid range is 900-70-0000 through 999-88-9999, all numeric values. This regular expression will accept anything in this range with space, dash or no separators.",
        "refined_prompt": "\nMatch examples:\n- \"900700000\"\n- \"900 70 0000\"\n- \"900-70-0000\"\nNon-match examples:\n- \"899700000\"\n- \"\"",
        "matches": [
            "900700000",
            "900 70 0000",
            "900-70-0000"
        ],
        "non_matches": [
            "899700000",
            "",
            "900-89-0000",
            "900-69-0000"
        ],
        "stress_tests": []
    },
    {
        "id": 1654,
        "expression": "^(?:((31\\/(Jan|Mar|May|Jul|Aug|Oct|Dec))|((([0-2]\\d)|30)\\/(Jan|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec))|(([01]\\d|2[0-8])\\/Feb))|(29\\/Feb(?=\\/((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))\\/((1[6-9]|[2-9]\\d)\\d{2})$",
        "raw_prompt": "Matches dates in the form of DD/MMM/YYYY. It also handles leap years. Days are 2 digits; months are case sensitive with first character upper-case and next 2 characters lower-case; year is 4 digits.",
        "refined_prompt": "\nMatch examples:\n- \"01/Mar/2007\"\n- \"16/Dec/2007\"\n- \"29/Feb/2008\"\nNon-match examples:\n- \"1/Mar/2007\"\n- \"16/Dec/07\"",
        "matches": [
            "01/Mar/2007",
            "16/Dec/2007",
            "29/Feb/2008"
        ],
        "non_matches": [
            "1/Mar/2007",
            "16/Dec/07",
            "29/Feb/2007"
        ],
        "stress_tests": []
    },
    {
        "id": 1656,
        "expression": "^((\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*)\\s*[,]{0,1}\\s*)+$",
        "raw_prompt": "This will validate multiple email addresses that are comma delimited. You can change it to use commas or semilcolons. If you have to worry about a lot of special characters, you may have to edit it a little bit. It allows white space before and after the comma.",
        "refined_prompt": "\nMatch examples:\n- \"Test@host.com\"\n- \"email1@host.com,email2@host.com,email3@host.com\"\n- \"email1@host.com, email2@host.com , email3@host.com\"\nNon-match examples:\n- \"test@test\"\n- \"test@host.com,test@\"",
        "matches": [
            "Test@host.com",
            "email1@host.com,email2@host.com,email3@host.com",
            "email1@host.com, email2@host.com , email3@host.com"
        ],
        "non_matches": [
            "test@test",
            "test@host.com,test@",
            "test@ host.com"
        ],
        "stress_tests": []
    },
    {
        "id": 1657,
        "expression": "(?=^.{8,}$)(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?!.*\\s)[0-9a-zA-Z!@#$%^&*()]*$",
        "raw_prompt": "This regular expression can be used for validating a strong password. It expects at least 1 lowercase letter, 1 uppercase letter, and 1 digit. It will also allow for some special characters. The length should be greater than 8 characters. The sequence of the characters is not important.",
        "refined_prompt": "\nMatch examples:\n- \"Password1\"\n- \"1Passwor\"\n- \"passworD1\"\nNon-match examples:\n- \"q3w4e5er\"\n- \"asdfg\"",
        "matches": [
            "Password1",
            "1Passwor",
            "passworD1",
            "2passWord",
            "Pass2Word",
            "pa1SS2word",
            "!1qAzxsw2"
        ],
        "non_matches": [
            "q3w4e5er",
            "asdfg",
            "asdfghjkl;",
            "ag asg ag",
            "d36234724",
            "mko)+OKM1"
        ],
        "stress_tests": []
    },
    {
        "id": 1658,
        "expression": "<body[\\d\\sa-z\\W\\S\\s]*>",
        "raw_prompt": "This will find the open body tag regardless of any properties or Event Handlers associated with it. This is great for global implementations of analytics or anything that needs to be placed after the body tag.",
        "refined_prompt": "\nMatch examples:\n- \"<body>\"\nNon-match examples:\n- \"<br>\"",
        "matches": [
            "<body>"
        ],
        "non_matches": [
            "<br>"
        ],
        "stress_tests": []
    },
    {
        "id": 1660,
        "expression": "^((\\.)?([a-zA-Z0-9_-]?)(\\.)?([a-zA-Z0-9_-]?)(\\.)?)+$",
        "raw_prompt": "Allows letters,numbers,hyphens,periods and underscores. Such as : Aa.Aa.Aa, .Aa.Aa. , -Aa-Aa- , _Aa_Aa_ , Aa_Aa_Aa , Aa-Aa-Aa , . , - , _\nI was asked by my client for this scenario to allow letters,numbers,hyphens,periods and underscores in User ID field in web application.",
        "refined_prompt": "\nMatch examples:\n- \"_-.aAa._-.aAa_-.\"\nNon-match examples:\n- \"special charachters\"",
        "matches": [
            "_-.aAa._-.aAa_-."
        ],
        "non_matches": [
            "special charachters"
        ],
        "stress_tests": []
    },
    {
        "id": 1662,
        "expression": "(\\s{1,})",
        "raw_prompt": "Matches all chars that are made up of one or more spaces. I found this useful when people were trying to make string length bypasses using consecutive spaces.",
        "refined_prompt": "\nMatch examples:\n- \"(one or more spaces)\"\nNon-match examples:\n- \"non-space\"",
        "matches": [
            "(one or more spaces)"
        ],
        "non_matches": [
            "non-space"
        ],
        "stress_tests": []
    },
    {
        "id": 1663,
        "expression": "[-]?[1-9]\\d{0,16}\\.?\\d{0,2}|[-]?[0]?\\.[1-9]{1,2}|[-]?[0]?\\.[0-9][1-9]",
        "raw_prompt": "Needed to be able to validate positive and numeric values that equate to SQL Server data type decimal(18, 2) but the value could not be 0. This regex does that. If you need to change the precision or scale have at it.",
        "refined_prompt": "\nMatch examples:\n- \"-9999999999999999.99\"\n- \"9999999999999999.99\"\n- \"1\"\nNon-match examples:\n- \"0\"\n- \"0.0\"",
        "matches": [
            "-9999999999999999.99",
            "9999999999999999.99",
            "1",
            "1.00",
            "0.52",
            "0.02"
        ],
        "non_matches": [
            "0",
            "0.0",
            "0.00"
        ],
        "stress_tests": []
    },
    {
        "id": 1664,
        "expression": "([0-9a-z_-]+[\\.][0-9a-z_-]{1,3})$",
        "raw_prompt": "Will match a Windows filename containing alphanumerics, hyphens (-) and underscores (_). There is no length limit on the first part of the filename, but the extension must be between 1 and 3 characters.",
        "refined_prompt": "\nMatch examples:\n- \"open_01.pdf, 00153._-, _abc_.--1\"\nNon-match examples:\n- \"readme.e$e, save6^.doc, open_01., .txt, leisure.docx\"",
        "matches": [
            "open_01.pdf, 00153._-, _abc_.--1"
        ],
        "non_matches": [
            "readme.e$e, save6^.doc, open_01., .txt, leisure.docx"
        ],
        "stress_tests": []
    },
    {
        "id": 1665,
        "expression": "^[A-Z\u00c4\u00d6\u00dc]{1,3}\\-[ ]{0,1}[A-Z]{0,2}[0-9]{1,4}[H]{0,1}",
        "raw_prompt": "This one checks if the value is a possible german License Plate. The trailing H stands for Historical cars.",
        "refined_prompt": "\nMatch examples:\n- \"F-RM373, W\u00dc-Z1, K- 07333,HN-WK11H\"\nNon-match examples:\n- \"MOS-AS\"",
        "matches": [
            "F-RM373, W\u00dc-Z1, K- 07333,HN-WK11H"
        ],
        "non_matches": [
            "MOS-AS"
        ],
        "stress_tests": []
    },
    {
        "id": 1668,
        "expression": "(a|A)",
        "raw_prompt": "Big or small A letter",
        "refined_prompt": "Capital (A) or lowercase (a)\nMatch examples:\n- \"aaa\"\n- \"aA\"\n- \"Aa\"\nNon-match examples:\n- \"bbb\"\n- \"\u00e0\"",
        "matches": [
            "aaa",
            "aA",
            "Aa",
            "AAA",
            "AaA",
            "aAa",
            "a",
            "A",
            "AAAaaa",
            "aaaAAA",
            "aAaAaA",
            "AaAaAa",
            "aaAaaA"
        ],
        "non_matches": [
            "bbb",
            "\u00e0",
            "\u00e1",
            "\u00e2",
            "\u00e4",
            "\u00e6",
            "\u00e3",
            "\u00e5",
            "\u0101",
            "65",
            "97",
            "\u00c6"
        ],
        "stress_tests": []
    },
    {
        "id": 1683,
        "expression": "^([A-Z]+[a-zA-Z]*)(\\s|\\-)?([A-Z]+[a-zA-Z]*)?(\\s|\\-)?([A-Z]+[a-zA-Z]*)?$",
        "raw_prompt": "That is just an improved expression for handling capitalized names. Improvement #1 - Allowed using names consisting of 3 parts. Improvement #2 - Introduced restriction that the name must start from capital character.",
        "refined_prompt": "\nMatch examples:\n- \"Rana Mohsin Ali\"\nNon-match examples:\n- \"rana Mohsin Ali\"",
        "matches": [
            "Rana Mohsin Ali"
        ],
        "non_matches": [
            "rana Mohsin Ali"
        ],
        "stress_tests": []
    },
    {
        "id": 1690,
        "expression": "^([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])([Z]|\\.[0-9]{4}|[-|\\+]([0-1][0-9]|2[0-3]):([0-5][0-9]))?$",
        "raw_prompt": "This is a pattern that matches the time format as recomended by the w3c for XML formats",
        "refined_prompt": "\nMatch examples:\n- \"12:00:12\"\n- \"01:12:19Z\"\n- \"23:59:00-06:00\"\nNon-match examples:\n- \"1:20:13\"\n- \"12:03\"",
        "matches": [
            "12:00:12",
            "01:12:19Z",
            "23:59:00-06:00",
            "18:30:13+01:00",
            "16:06:02.1234"
        ],
        "non_matches": [
            "1:20:13",
            "12:03",
            "24:00:00"
        ],
        "stress_tests": []
    },
    {
        "id": 1693,
        "expression": "^[-]?((1[6789]|[2-9][0-9])[0-9]{2}-(0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01]))T([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])([Z]|\\.[0-9]{4}|[-|\\+]([0-1][0-9]|2[0-3]):([0-5][0-9]))?$|^[-]?((1[6789]|[2-9][0-9])[0-9]{2}-(0[469]|11)-(0[1-9]|[12][0-9]|30))T([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])([Z]|\\.[0-9]{4}|[-|\\+]([0-1][0-9]|2[0-3]):([0-5][0-9]))?$|^[-]?((16|[248][048]|[3579][26])00)|(1[6789]|[2-9][0-9])(0[48]|[13579][26]|[2468][048])-02-(0[1-9]|1[0-9]|2[0-9])T([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])([Z]|\\.[0-9]{4}|[-|\\+]([0-1][0-9]|2[0-3]):([0-5][0-9]))?$|^[-]?(1[6789]|[2-9][0-9])[0-9]{2}-02-(0[1-9]|1[0-9]|2[0-8])T([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])([Z]|\\.[0-9]{4}|[-|\\+]([0-1][0-9]|2[0-3]):([0-5][0-9]))?$",
        "raw_prompt": "This pattern matches valid w3c compatible datetime values from 1600 to 9999 in the form of [-]YYYY-MM-DDTHH:MM:SS[.ssss|[[+|-][HH:MM]][Z] also takes into account leap years.",
        "refined_prompt": "\nMatch examples:\n- \"2007-11-02T18:00:00.1234\"\n- \"2000-02-29T12:00:12+03:00\"\nNon-match examples:\n- \"2005-01-20\"\n- \"23:00:00\"",
        "matches": [
            "2007-11-02T18:00:00.1234",
            "2000-02-29T12:00:12+03:00"
        ],
        "non_matches": [
            "2005-01-20",
            "23:00:00"
        ],
        "stress_tests": []
    },
    {
        "id": 1696,
        "expression": "^(([0-9]|1[0-9]|2[0-4])(\\.[0-9][0-9]?)?)$|([2][5](\\.[0][0]?)?)$",
        "raw_prompt": "this is reg expression for 0.00 to 25.00",
        "refined_prompt": "\nMatch examples:\n- \"12\"\n- \"13.1\"\n- \"23.99\"\nNon-match examples:\n- \"26\"\n- \"25.01\"",
        "matches": [
            "12",
            "13.1",
            "23.99",
            "8.99",
            "25.00"
        ],
        "non_matches": [
            "26",
            "25.01",
            "-2",
            "8.",
            ""
        ],
        "stress_tests": []
    },
    {
        "id": 1697,
        "expression": "^[\\w0-9]+( [\\w0-9]+)*$",
        "raw_prompt": "Allows \"words\" with alphanumeric characters, including the underscore _ character. Disallows leading or trailing spaces, also doubled-up spaces within the text. If you want to disallow the underscore character, you can replace the two occurrences of \\w with a-zA-Z",
        "refined_prompt": "\nMatch examples:\n- \"Test 000\"\nNon-match examples:\n- \"Punctuation! Or doubled up, leading or trailing spaces\"",
        "matches": [
            "Test 000"
        ],
        "non_matches": [
            "Punctuation! Or doubled up, leading or trailing spaces"
        ],
        "stress_tests": []
    },
    {
        "id": 1698,
        "expression": "^((([\\(]?[2-9]{1}[0-9]{2}[\\)]?)|([2-9]{1}[0-9]{2}\\.?)){1}[ ]?[2-9]{1}[0-9]{2}[\\-\\.]{1}[0-9]{4})([ ]?[xX]{1}[ ]?[0-9]{3,4})?$",
        "raw_prompt": "This regex matches US and CAN phone numbers with area code and optional 3 or 4 digit PBX extention. It does not check for validity of area code or exchange number, other than for starting with a 0 or 1.",
        "refined_prompt": "\nMatch examples:\n- \"(555) 687-6076 X 1234\"\n- \"(555) 687-6076\"\n- \"555.687.5511x1234\"\nNon-match examples:\n- \"555.687.6076 ext 1234\"",
        "matches": [
            "(555) 687-6076 X 1234",
            "(555) 687-6076",
            "555.687.5511x1234"
        ],
        "non_matches": [
            "555.687.6076 ext 1234"
        ],
        "stress_tests": []
    },
    {
        "id": 1704,
        "expression": "^[1-9]{1}[0-9]{0,2}([\\.\\,]?[0-9]{3})*$",
        "raw_prompt": "Matches whole numbers with the two most common thousands-separators (comma and period). Will not handle decimals.",
        "refined_prompt": "\nMatch examples:\n- \"1,000\"\n- \"1.000\"\n- \"1\"\nNon-match examples:\n- \"1,00\"\n- \"1,0\"",
        "matches": [
            "1,000",
            "1.000",
            "1",
            "10",
            "100",
            "1000"
        ],
        "non_matches": [
            "1,00",
            "1,0",
            "1,,000",
            ".1",
            "10."
        ],
        "stress_tests": []
    },
    {
        "id": 1706,
        "expression": "([A-HJ-PR-Y]{2}([0][1-9]|[1-9][0-9])|[A-HJ-PR-Y]{1}([1-9]|[1-2][0-9]|30|31|33|40|44|55|50|60|66|70|77|80|88|90|99|111|121|123|222|321|333|444|555|666|777|888|999|100|200|300|400|500|600|700|800|900))[ ][A-HJ-PR-Z]{3}$",
        "raw_prompt": "UK Vehicle Registration Plate / Number Plate format as specified by the DVLA. Accepts both \"Prefix\" and \"New\" style. Allows only valid DVLA number combinations as not all are supported. Registration number must be exactly as is displayed on car, hence all letters must be in uppercase and a space seperating the two sets of characters.",
        "refined_prompt": "\nMatch examples:\n- \"AB12 RCY\"\n- \"CD07 TES\"\n- \"S33 GTT\"\nNon-match examples:\n- \"ab12 rcy\"\n- \"CD07 TIS\"",
        "matches": [
            "AB12 RCY",
            "CD07 TES",
            "S33 GTT",
            "Y999 FVB"
        ],
        "non_matches": [
            "ab12 rcy",
            "CD07 TIS",
            "S34 GTT",
            "Z999 FVB"
        ],
        "stress_tests": []
    },
    {
        "id": 1709,
        "expression": "^\\$YYYY\\$\\$MM\\$\\$DD\\$$",
        "raw_prompt": "Date Format notations. Mostly used in DB applications where rigorous pattern matching for DATE is required.",
        "refined_prompt": "\nMatch examples:\n- \"$YYYY$$MM$$DD$\"\nNon-match examples:\n- \"$YY$$MM$$DD$\"",
        "matches": [
            "$YYYY$$MM$$DD$"
        ],
        "non_matches": [
            "$YY$$MM$$DD$"
        ],
        "stress_tests": []
    },
    {
        "id": 1715,
        "expression": "^[1-9]\\d?-\\d{7}$",
        "raw_prompt": "Accepts valid EIN numbers. It could use a bit of tweaking because these are the current valid prefixes allowed. 1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 65, 66, 67, 68, 71, 72, 73, 74, 75, 76, 77, 80, 81, 82, 83, 84, 85, 87, 88, 90, 91, 92, 93, 94, 95, 98, 99",
        "refined_prompt": "\nMatch examples:\n- \"55-5555555\"\n- \"1-2345678\"\n- \"99-9999999\"\nNon-match examples:\n- \"00-1111111\"\n- \"my-einnumb\"",
        "matches": [
            "55-5555555",
            "1-2345678",
            "99-9999999"
        ],
        "non_matches": [
            "00-1111111",
            "my-einnumb",
            "5-55555"
        ],
        "stress_tests": []
    },
    {
        "id": 1716,
        "expression": "^[a-zA-Z0-9\\-\\.]+\\.([a-zA-Z]{2,3})$",
        "raw_prompt": "validates after dot operator. matches atleast 2 char and max 3 char.www dot is rejected.",
        "refined_prompt": "\nMatch examples:\n- \"yahoo.com\"\n- \"ABC.COM\"\n- \"abc.au\"\nNon-match examples:\n- \"yahoo.c\"\n- \"ABC.argv\"",
        "matches": [
            "yahoo.com",
            "ABC.COM",
            "abc.au"
        ],
        "non_matches": [
            "yahoo.c",
            "ABC.argv"
        ],
        "stress_tests": []
    },
    {
        "id": 1723,
        "expression": "(\\[a url=\\\"[^\\[\\]\\\"]*\\\"\\])([^\\[\\]]+)(\\[/a\\])",
        "raw_prompt": "Matches well-formed tags.",
        "refined_prompt": "\nMatch examples:\n- \"[a url=\"http://www.example-domain.com\"]link text[/a]; [a url=\"\"]link text[/a]\"\nNon-match examples:\n- \"[a]link text[/a]; [a url= \"\"]link text[/a]\"",
        "matches": [
            "[a url=\"http://www.example-domain.com\"]link text[/a]; [a url=\"\"]link text[/a]"
        ],
        "non_matches": [
            "[a]link text[/a]; [a url= \"\"]link text[/a]"
        ],
        "stress_tests": []
    },
    {
        "id": 1726,
        "expression": "(<b>)([^<>]+)(</b>)",
        "raw_prompt": "Gets simple tags without parameters",
        "refined_prompt": "\nMatch examples:\n- \"<b>important</b>; <b>anything that should be in bold</b>\"\nNon-match examples:\n- \"<b >important</b>; <b>important<b>\"",
        "matches": [
            "<b>important</b>; <b>anything that should be in bold</b>"
        ],
        "non_matches": [
            "<b >important</b>; <b>important<b>"
        ],
        "stress_tests": []
    },
    {
        "id": 1730,
        "expression": "(?!.*([abcde]).*\\1)^[abcde]{5}$",
        "raw_prompt": "Let's say that you have a series of characters \"abcde\" and you want to match all strings that could be comprised of those characters with each character used exactly once. This could loosely be termed an anagram matcher, although if the string contains duplicate letters it would require modification of this pattern. In the example case we have a string \"abcde\" and we want to match any permutation of \"abcde\". Note that the \"5\" used in the pattern indicates the number of characters specified in the character set \"abcde\", \"5\" would still be used if \"abcde\" would be replaced with \"a-e\" since there would still be 5 characters in the series. If you are curious about how to require duplicates in the pattern (to match all permutations of \"apple\" for example) I would use (?=^.*p.*p$)(?!.*([ale]).*\\1)^[aple]{5}$",
        "refined_prompt": "\nMatch examples:\n- \"abcde\"\n- \"dbcae\"\n- \"edcba\"\nNon-match examples:\n- \"abcbe\"",
        "matches": [
            "abcde",
            "dbcae",
            "edcba"
        ],
        "non_matches": [
            "abcbe"
        ],
        "stress_tests": []
    },
    {
        "id": 1736,
        "expression": "^[-+]?([0-9]{1,3}[,]?)?([0-9]{3}[,]?)*[.]?[0-9]*$",
        "raw_prompt": "matches numeric value with optional +/- , optional decimal point, and optional commas",
        "refined_prompt": "\nMatch examples:\n- \"-12,345,678,012.98765\"\nNon-match examples:\n- \"1,45.098\"",
        "matches": [
            "-12,345,678,012.98765"
        ],
        "non_matches": [
            "1,45.098"
        ],
        "stress_tests": []
    },
    {
        "id": 1739,
        "expression": "([\\r\\n ]*//[^\\r\\n]*)+",
        "raw_prompt": "Matches groups of single-line code comments. Comment sections will be returned as a single match.",
        "refined_prompt": "\nMatch examples:\n- \"// code comments\"\nNon-match examples:\n- \"Code\"",
        "matches": [
            "// code comments"
        ],
        "non_matches": [
            "Code"
        ],
        "stress_tests": []
    },
    {
        "id": 1740,
        "expression": "(@\\s*\".*?\")|(\"([^\"\\\\]|\\\\.)*?\")",
        "raw_prompt": "Matches C# string literals; verbatin and or normal.",
        "refined_prompt": "\nMatch examples:\n- \"\"text\" \"te\\\"xt\" @\"text\"\"\nNon-match examples:\n- \"text\"",
        "matches": [
            "\"text\" \"te\\\"xt\" @\"text\""
        ],
        "non_matches": [
            "text"
        ],
        "stress_tests": []
    },
    {
        "id": 1742,
        "expression": "^[A-Z]$",
        "raw_prompt": "Matches one Upper-case US ASCII Letter.",
        "refined_prompt": "\nMatch examples:\n- \"A\"\n- \"B\"\n- \"Z\"\nNon-match examples:\n- \"a\"\n- \"1\"",
        "matches": [
            "A",
            "B",
            "Z"
        ],
        "non_matches": [
            "a",
            "1",
            "AA"
        ],
        "stress_tests": []
    },
    {
        "id": 1744,
        "expression": "^\\d+\\.\\d\\.\\d[01]\\d[0-3]\\d\\.[1-9]\\d*$",
        "raw_prompt": "4 part version numbers",
        "refined_prompt": "\nMatch examples:\n- \"0.0.60829.1\"\n- \"100.3.60931.5\"\n- \"5.1.11219.7\"\nNon-match examples:\n- \"1.1.60849.1\"\n- \"0.20.10.60810\"",
        "matches": [
            "0.0.60829.1",
            "100.3.60931.5",
            "5.1.11219.7"
        ],
        "non_matches": [
            "1.1.60849.1",
            "0.20.10.60810",
            "1.1.11219.0"
        ],
        "stress_tests": []
    },
    {
        "id": 1751,
        "expression": "^(((0[1-9]{1})|(1[0-2]{1}))\\/?(([0-2]{1}[1-9]{1})|(3[0-1]{1}))\\/?(([12]{1}[0-9]{1})?[0-9]{2}) ?(([01]{1}[0-9]{1})|(2[0-4]{1}))\\:?([0-5]{1}[0-9]{1}))$",
        "raw_prompt": "This will validate any date (does not check for number of days in month, just 31 days or less) in almost any format as long as the order follows month, day, year, hour, minute, and each part has at least 2 digits.",
        "refined_prompt": "\nMatch examples:\n- \"01/15/07 1745\"\n- \"011507 1745\"\n- \"01/15/2007 17:45\"\nNon-match examples:\n- \"13/15/07 1745\"\n- \"013207 1745\"",
        "matches": [
            "01/15/07 1745",
            "011507 1745",
            "01/15/2007 17:45",
            "0115071745"
        ],
        "non_matches": [
            "13/15/07 1745",
            "013207 1745",
            "01/15/2007 25:45",
            "0115071762"
        ],
        "stress_tests": []
    },
    {
        "id": 1756,
        "expression": "^(([A-Z])([a-zA-Z0-9]+)?)(\\:)(\\d+)$",
        "raw_prompt": "Validate if server and port is valid.",
        "refined_prompt": "\nMatch examples:\n- \"MyServer:8080\"\nNon-match examples:\n- \"1Server:A1\"\n- \"Server:AAA\"",
        "matches": [
            "MyServer:8080"
        ],
        "non_matches": [
            "1Server:A1",
            "Server:AAA"
        ],
        "stress_tests": []
    },
    {
        "id": 1762,
        "expression": "(^([0-9]*[.][0-9]*[1-9]+[0-9]*)$)|(^([0-9]*[1-9]+[0-9]*[.][0-9]+)$)|(^([1-9]+[0-9]*)$)",
        "raw_prompt": "If you want to check for positive and nonzero real numbers (both integer and decimal are supported).",
        "refined_prompt": "\nMatch examples:\n- \"1.234\"\n- \"1234\"\n- \"0.123\"\nNon-match examples:\n- \"0\"\n- \"0.0\"",
        "matches": [
            "1.234",
            "1234",
            "0.123",
            "01.2345"
        ],
        "non_matches": [
            "0",
            "0.0",
            "-123.45",
            "-12345",
            "abc123",
            "12..34"
        ],
        "stress_tests": []
    },
    {
        "id": 1763,
        "expression": "^[1-9]\\d*\\.?[0]*$",
        "raw_prompt": "It just omit 0 as the single number when it accepts all other Numbers",
        "refined_prompt": "\nMatch examples:\n- \"2\"\n- \"23\"\n- \"340\"\nNon-match examples:\n- \"0\"",
        "matches": [
            "2",
            "23",
            "340"
        ],
        "non_matches": [
            "0"
        ],
        "stress_tests": []
    },
    {
        "id": 1776,
        "expression": "^(((0[1-9]|[12]\\d|3[01])[\\s\\.\\-\\/](0[13578]|1[02])[\\s\\.\\-\\/]((19|[2-9]\\d)\\d{2}))|((0[1-9]|[12]\\d|30)[\\s\\.\\-\\/](0[13456789]|1[012])[\\s\\.\\-\\/]((19|[2-9]\\d)\\d{2}))|((0[1-9]|1\\d|2[0-8])[\\s\\.\\-\\/]02[\\s\\.\\-\\/]((19|[2-9]\\d)\\d{2}))|(29[\\s\\.\\-\\/]02[\\s\\.\\-\\/]((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))))$",
        "raw_prompt": "Checks date in format dd-mm-yyyy. Seperation characters can be -/. and space.\ndd and mm HAVE to be two characters. Year has to be four characters and minimum 1900.\nExpression handles leap year as well",
        "refined_prompt": "\nMatch examples:\n- \"20-02-1975\"\n- \"20.02.1975\"\n- \"20/02/1975\"\nNon-match examples:\n- \"20-12-1899\"\n- \"29-02-2002\"",
        "matches": [
            "20-02-1975",
            "20.02.1975",
            "20/02/1975",
            "20 02 1975",
            "20-12/1975"
        ],
        "non_matches": [
            "20-12-1899",
            "29-02-2002",
            "28-2-2008"
        ],
        "stress_tests": []
    },
    {
        "id": 1777,
        "expression": "^(0[1-9]|[12][0-9]|3[01])-(0[1-9]|11|12|10)-(19[0-9]{2})$",
        "raw_prompt": "This is regular expression that check for a particular date match in the following format respectively: DD-MM-YYYY and is only valid for the years between 1900 - 1999\nHint: good for validating age above 9-years old",
        "refined_prompt": "\nMatch examples:\n- \"31-01-1923\"\n- \"12-05-1987\"\n- \"26-10-1901\"\nNon-match examples:\n- \"07/10/1998\"\n- \"04-07-98\"",
        "matches": [
            "31-01-1923",
            "12-05-1987",
            "26-10-1901"
        ],
        "non_matches": [
            "07/10/1998",
            "04-07-98",
            "1-3-1806",
            "1985-01-07"
        ],
        "stress_tests": []
    },
    {
        "id": 1778,
        "expression": "^[a-zA-Z0-9\\.\\s]{3,}$",
        "raw_prompt": "This expression check the input of simple text string from a-z,A-Z and number from 0 to 9 and the dot(.).\nBut the minimum insert is of 3 character.",
        "refined_prompt": "\nMatch examples:\n- \"abc.123\"\n- \".abc\"\n- \"123.\"\nNon-match examples:\n- \"12\"\n- \"a1\"",
        "matches": [
            "abc.123",
            ".abc",
            "123."
        ],
        "non_matches": [
            "12",
            "a1",
            "@#%&\u00a3\"^"
        ],
        "stress_tests": []
    },
    {
        "id": 1780,
        "expression": "^(((?!\\(800\\))(?!\\(888\\))(?!\\(877\\))(?!\\(866\\))(?!\\(900\\))\\(\\d{3}\\) ?)|(?!800)(?!888)(?!877)(?!866)(?!900)(\\d{3}-))?\\d{3}-\\d{4}",
        "raw_prompt": "This pattern matches US phone numbers but excludes numbers that are 800 or 900 numbers. It excludes the following area codes 800, 888,877,866, and 900.",
        "refined_prompt": "\nMatch examples:\n- \"123-554-1247, (455)521-5482\"\nNon-match examples:\n- \"800-585-1234, (866)958-4221\"",
        "matches": [
            "123-554-1247, (455)521-5482"
        ],
        "non_matches": [
            "800-585-1234, (866)958-4221"
        ],
        "stress_tests": []
    },
    {
        "id": 1785,
        "expression": "^((?:\\/[a-zA-Z0-9]+(?:_[a-zA-Z0-9]+)*(?:\\-[a-zA-Z0-9]+)*)+)$",
        "raw_prompt": "An overly simple UNIX based path regex. The path must begin with a forward slash. The path segments may not lead or end with an underscore or dash which is a good thing. They also can not be doubled (__ or --). Another good thing. I've omitted all the punctuation that RFC allows until further notice.",
        "refined_prompt": "\nMatch examples:\n- \"/users/web/mysite/web/cgi-bin\"\nNon-match examples:\n- \"/users/web/my site/web/cgi-bin\"\n- \"users/web/mysite/web/cgi-bin/\"",
        "matches": [
            "/users/web/mysite/web/cgi-bin"
        ],
        "non_matches": [
            "/users/web/my site/web/cgi-bin",
            "users/web/mysite/web/cgi-bin/"
        ],
        "stress_tests": []
    },
    {
        "id": 1786,
        "expression": "^([a-zA-Z0-9]+(?: [a-zA-Z0-9]+)*)$",
        "raw_prompt": "This is a very basic regex for a simple subject or title. It must begin and end with a word character and may contain spaces. No punctuation :(",
        "refined_prompt": "\nMatch examples:\n- \"My Category\"\nNon-match examples:\n- \"any nonword character and leading/trailing spaces\"",
        "matches": [
            "My Category"
        ],
        "non_matches": [
            "any nonword character and leading/trailing spaces"
        ],
        "stress_tests": []
    },
    {
        "id": 1787,
        "expression": "^((31(?!([-])(Feb|Apr|June?|Sep|Nov)))|((30|29)(?!([-])Feb))|(29(?=([-])Feb([-])(((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))|(0?[1-9])|1\\d|2[0-8])([-])(Jan|Feb|Ma(r|y)|Apr|Ju(l|n)|Aug|Oct|(Sep|Nov|Dec))([-])((1[6-9]|[2-9]\\d)\\d{2}\\s(([0-1]?[0-9])|([2][0-3])):([0-5]?[0-9])(:([0-5]?[0-9]))?)$",
        "raw_prompt": "This expression matches date and time (24 hour) both in format dd-MMM-yyyy HH:mm:ss. Only the short form of month is allowed i.e. Jan not January. The month names are also case sensitive. The second part of the time is optional. Also the leading zeros for day, hour, minute and seconds are optional.",
        "refined_prompt": "\nMatch examples:\n- \"31-Jan-2008 1:30:00\"\n- \"29-Feb-2008 01:45:45\"\n- \"30-Sep-2007 23:59\"\nNon-match examples:\n- \"31-Jan-2008 24:30:00\"\n- \"29-Feb-2007 01:45:45\"",
        "matches": [
            "31-Jan-2008 1:30:00",
            "29-Feb-2008 01:45:45",
            "30-Sep-2007 23:59"
        ],
        "non_matches": [
            "31-Jan-2008 24:30:00",
            "29-Feb-2007 01:45:45",
            "3-Sep-2007 23:60:60"
        ],
        "stress_tests": []
    },
    {
        "id": 1793,
        "expression": "^\\s*-?(\\d{0,7}|10[0-5]\\d{0,5}|106[0-6]\\d{0,4}|1067[0-4]\\d{0,3}|10675[0-1]\\d{0,2}|((\\d{0,7}|10[0-5]\\d{0,5}|106[0-6]\\d{0,4}|1067[0-4]\\d{0,3}|10675[0-1]\\d{0,2})\\.)?([0-1]?[0-9]|2[0-3]):[0-5]?[0-9](:[0-5]?[0-9](\\.\\d{1,7})?)?)\\s*$",
        "raw_prompt": "Can be used to pre-validate strings before calling the TimeSpan.Parse() method in the .Net framework, to ensure that the string can be parsed without throwing an exception. The regex uses capturing groups instead of non-capturing groups so that it can easily be used as a pattern in XML Schema by simply removing the ^$ from the beginning/end.\nThis expression fully checks or enforces the [ws][-]{d|[d.]hh:mm[:ss[.ff]] }[ws] format as described in the MSDN help. It even checks the upper/lower boundaries on day values (10675199 days.)",
        "refined_prompt": "\nMatch examples:\n- \"00:00:15\"\n- \"23:59:59\"\n- \"23:59:59.9999999\"\nNon-match examples:\n- \"1.23:59:60\"\n- \"24:00\"",
        "matches": [
            "00:00:15",
            "23:59:59",
            "23:59:59.9999999",
            "-00:00:00",
            "365",
            "-365",
            "7.00:00:00.0000000",
            "5:5:5",
            "10:10",
            "21:15",
            "19:1",
            "00:10",
            "0",
            "10675199.23:59:59.9999999",
            "-10675199.23:59:59.9999999",
            "10599999",
            "10669999",
            "10674999",
            "10675099"
        ],
        "non_matches": [
            "1.23:59:60",
            "24:00",
            "23:59:59.00000000",
            "00:00:60",
            "24:00:00",
            "25:00:00",
            "10675200",
            "10676000",
            "10680000",
            "10700000",
            "11000000"
        ],
        "stress_tests": []
    },
    {
        "id": 1795,
        "expression": "\\x26(?!((amp\\x3B)|(nbsp\\x3B)|(lt\\x3B)|(gt\\x3B)|(copy\\x3B)|(reg\\x3B)|(cent\\x3B)|(deg\\x3B)|(deg\\x3B)|(micro\\x3B)|(middot\\x3B)|(not\\x3B)|(para\\x3B)|(plusmn\\x3B)|(pound\\x3B)|(raquo\\x3B)|(sect\\x3B)|(yen\\x3B)|([\\x23][0-9]{1,3}\\x3B)|(lsquo\\x3B)|(rsquo\\x3B)|(sbquo\\x3B)|(ldquo\\x3B)|(rdquo\\x3B)|(bdquo\\x3B)|(dagger\\x3B)|(Dagger\\x3B)|(permil\\x3B)|(lsaquo\\x3B)|(rsaquo\\x3B)|(spades\\x3B)|(clubs\\x3B)|(hearts\\x3B)|(diams\\x3B)|(oline\\x3B)|(larr\\x3B)|(uarr\\x3B)|(rarr\\x3B)|(darr\\x3B)|(trade\\x3B)|([\\x23]x2122\\x3B)|(quot\\x3B)|(frasl\\x3B)|(ndash\\x3B)|(mdash\\x3B)|(iexcl\\x3B)|(cent\\x3B)|(curren\\x3B)|(brvbar\\x3B)|(brvbar\\x3B)|(uml\\x3B)|(die\\x3B)|(ordf\\x3B)|(laquo\\x3B)|(not\\x3B)|(shy\\x3B)|(macr\\x3B)|(hibar\\x3B)|(sup2\\x3B)|(sup3\\x3B)|(acute\\x3B)|(micro\\x3B)|(cedil\\x3B)|(sup1\\x3B)|(ordm\\x3B)|(raquo\\x3B)|(frac14\\x3B)|(frac12\\x3B)|(frac34\\x3B)|(iquest\\x3B)|(Agrave\\x3B)|(Aacute\\x3B)|(Acirc\\x3B)|(Atilde\\x3B)|(Auml\\x3B)|(Aring\\x3B)|(AElig\\x3B)|(Ccedil\\x3B)|(Egrave\\x3B)|(Eacute\\x3B)|(Ecirc\\x3B)|(Euml\\x3B)|(Igrave\\x3B)|(Iacute\\x3B)|(Icirc\\x3B)|(Iuml\\x3B)|(ETH\\x3B)|(Ntilde\\x3B)|(Ograve\\x3B)|(Oacute\\x3B)|(Ocirc\\x3B)|(Otilde\\x3B)|(Ouml\\x3B)|(times\\x3B)|(Oslash\\x3B)|(Ugrave\\x3B)|(Uacute\\x3B)|(Ucirc\\x3B)|(Uuml\\x3B)|(Yacute\\x3B)|(THORN\\x3B)|(szlig\\x3B)|(agrave\\x3B)|(aacute\\x3B)|(acirc\\x3B)|(atilde\\x3B)|(auml\\x3B)|(aring\\x3B)|(aelig\\x3B)|(ccedil\\x3B)|(egrave\\x3B)|(eacute\\x3B)|(ecirc\\x3B)|(euml\\x3B)|(igrave\\x3B)|(iacute\\x3B)|(icirc\\x3B)|(iuml\\x3B)|(eth\\x3B)|(ntilde\\x3B)|(ograve\\x3B)|(oacute\\x3B)|(ocirc\\x3B)|(otilde\\x3B)|(ouml\\x3B)|(divide\\x3B)|(oslash\\x3B)|(ugrave\\x3B)|(uacute\\x3B)|(ucirc\\x3B)|(uuml\\x3B)|(yacute\\x3B)|(thorn\\x3B)|(yuml\\x3B)|(Alpha\\x3B)|(Alpha\\x3B)|(Beta\\x3B)|(beta\\x3B)|(Gamma\\x3B)|(gamma\\x3B)|(Delta\\x3B)|(delta\\x3B)|(Epsilon\\x3B)|(epsilon\\x3B)|(Zeta\\x3B)|(zeta\\x3B)|(Eta\\x3B)|(eta\\x3B)|(Iota\\x3B)|(iota\\x3B)|(Kappa\\x3B)|(kappa\\x3B)|(Lambda\\x3B)|(lambda\\x3B)|(Mu\\x3B)|(mu\\x3B)|(Nu\\x3B)|(nu\\x3B)|(Xi\\x3B)|(xi\\x3B)|(Omicron\\x3B)|(omicron\\x3B)|(Pi\\x3B)|(pi\\x3B)|(Rho\\x3B)|(rho\\x3B)|(Sigma\\x3B)|(sigma\\x3B)|(Tau\\x3B)|(tau\\x3B)|(Upsilon\\x3B)|(upsilon\\x3B)|(Phi\\x3B)|(phi\\x3B)|(Chi\\x3B)|(chi\\x3B)|(Psi\\x3B)|(psi\\x3B)|(Omega\\x3B)|(omega\\x3B)))",
        "raw_prompt": "This expression will match ampersands('&') that are not part an HTML Special Character string.",
        "refined_prompt": "\nMatch examples:\n- \"&\"\nNon-match examples:\n- \"&amp; &psi; &#24;\"",
        "matches": [
            "&"
        ],
        "non_matches": [
            "&amp; &psi; &#24;"
        ],
        "stress_tests": []
    },
    {
        "id": 1799,
        "expression": "^(1?(?: |\\-|\\.)?(?:\\(\\d{3}\\)|\\d{3})(?: |\\-|\\.)?\\d{3}(?: |\\-|\\.)?\\d{4})$",
        "raw_prompt": "This is my simple phone number regex. There are many like it but this is mine. It accepts the most common United States phone number formats that normal people use. The number 1 at the beginning is optional and so is the separators. The separators can be a dash (-), a period (.) or a space. Putting the area code in parenthesis is also an option. That's about it.",
        "refined_prompt": "\nMatch examples:\n- \"1-234-567-8910\"\n- \"(123) 456-7891\"\n- \"123.456.7891\"\nNon-match examples:\n- \"12-345-678-9101\"\n- \"123-45678\"",
        "matches": [
            "1-234-567-8910",
            "(123) 456-7891",
            "123.456.7891",
            "12345678910"
        ],
        "non_matches": [
            "12-345-678-9101",
            "123-45678",
            "123456789101"
        ],
        "stress_tests": []
    },
    {
        "id": 1800,
        "expression": "^(\\d{5}(?:\\-\\d{4})?)$",
        "raw_prompt": "Just for US zip codes. Very simple but effective regex for verifying a number that resembles a zip code. The post office number is optional.",
        "refined_prompt": "\nMatch examples:\n- \"12345\"\n- \"12345-6789\"\nNon-match examples:\n- \"1234\"\n- \"123456\"",
        "matches": [
            "12345",
            "12345-6789"
        ],
        "non_matches": [
            "1234",
            "123456",
            "12345-123",
            "12345-12345"
        ],
        "stress_tests": []
    },
    {
        "id": 1801,
        "expression": "^(?!000)(?!666)(?!9)\\d{3}([- ]?)(?!00)\\d{2}\\1(?!0000)\\d{4}$",
        "raw_prompt": "Updated SSN regex. A very simple one for verifying a properly formatted US social security number. First three digits must be 001 - 899 and not 666. Disallows all zeros in a group.",
        "refined_prompt": "\nMatch examples:\n- \"123-45-6789\"\nNon-match examples:\n- \"123-45 6789\"\n- \"1234-56-7890\"",
        "matches": [
            "123-45-6789"
        ],
        "non_matches": [
            "123-45 6789",
            "1234-56-7890",
            "123-00-7890"
        ],
        "stress_tests": []
    },
    {
        "id": 1803,
        "expression": "^([0-2][0-4](?:(?:(?::)?[0-5][0-9])?|(?:(?::)?[0-5][0-9](?::)?[0-5][0-9](?:\\.[0-9]+)?)?)?)$",
        "raw_prompt": "This is a regular expression to check for a properly formatted time according to the international date and time notation ISO 8601. See ISO 8601 specification for more information.",
        "refined_prompt": "\nMatch examples:\n- \"24\"\n- \"24:00\"\n- \"23:59:59\"\nNon-match examples:\n- \"25\"\n- \"24:60\"",
        "matches": [
            "24",
            "24:00",
            "23:59:59",
            "235959"
        ],
        "non_matches": [
            "25",
            "24:60"
        ],
        "stress_tests": []
    },
    {
        "id": 1804,
        "expression": "^[a-zA-Z]:\\\\(([\\w]|[\\u0621-\\u064A\\s])+\\\\)+([\\w]|[\\u0621-\\u064A\\s])+(.jpg|.JPG|.gif|.GIF|.BNG|.bng)$",
        "raw_prompt": "Select File Accept Arabic and Englesh File name or Folder name",
        "refined_prompt": "\nMatch examples:\n- \"C:\\Documents and Settings\\mohamedantar\\\u0645\u0644\u0641\\My Pictures\\\u0635\u0648\u0631\u0629.gif\"\nNon-match examples:\n- \":\\Documents and Settings\\mohamedantar\\\u0645\u0644\u0641\\My Pictures\\\u0635\u0648\u0631\u0629.gif\"",
        "matches": [
            "C:\\Documents and Settings\\mohamedantar\\\u0645\u0644\u0641\\My Pictures\\\u0635\u0648\u0631\u0629.gif"
        ],
        "non_matches": [
            ":\\Documents and Settings\\mohamedantar\\\u0645\u0644\u0641\\My Pictures\\\u0635\u0648\u0631\u0629.gif"
        ],
        "stress_tests": []
    },
    {
        "id": 1808,
        "expression": "^0?[0-9]?[0-9]$|^(100)$",
        "raw_prompt": "Accepts all integers between 0-100",
        "refined_prompt": "\nMatch examples:\n- \"0\"\n- \"00\"\n- \"01\"\nNon-match examples:\n- \"-1\"\n- \".23\"",
        "matches": [
            "0",
            "00",
            "01",
            "45",
            "99",
            "100"
        ],
        "non_matches": [
            "-1",
            ".23",
            "101"
        ],
        "stress_tests": []
    },
    {
        "id": 1810,
        "expression": "^[-]?([1-9]{1}[0-9]{0,}(\\.[0-9]{0,2})?|0(\\.[0-9]{0,2})?|\\.[0-9]{1,2})$",
        "raw_prompt": "This regular expression will match on a real / decimal / floating point / numeric string with no more than 2 digits past the decimal. The negative sign (-) is allowed. No leading zeroes or commas. It is based on a currency regular expression by Tom Persing.",
        "refined_prompt": "\nMatch examples:\n- \"123\"\n- \"123.54\"\n- \"-.54\"\nNon-match examples:\n- \"123.543\"\n- \"0012\"",
        "matches": [
            "123",
            "123.54",
            "-.54"
        ],
        "non_matches": [
            "123.543",
            "0012",
            "1,000.12"
        ],
        "stress_tests": []
    },
    {
        "id": 1811,
        "expression": "(\\+)?([-\\._\\(\\) ]?[\\d]{3,20}[-\\._\\(\\) ]?){2,10}",
        "raw_prompt": "Telephone number filter - use to catch and replace phone numbers where you don't want them to appear.",
        "refined_prompt": "\nMatch examples:\n- \"(604) 789-0136\"\n- \"+123-45678-908\"\nNon-match examples:\n- \"01.12.23\"",
        "matches": [
            "(604) 789-0136",
            "+123-45678-908"
        ],
        "non_matches": [
            "01.12.23"
        ],
        "stress_tests": []
    },
    {
        "id": 1813,
        "expression": "^((\\'|\\\")?[a-zA-Z]+(?:\\-[a-zA-Z]+)?(?:s\\'|\\'[a-zA-Z]{1,2})?(?:(?:(?:\\,|\\.|\\!|\\?)?(?:\\2)?)|(?:(?:\\2)?(?:\\,|\\.|\\!|\\?)?))(?: (\\'|\\\")?[a-zA-Z]+(?:\\-[a-zA-Z]+)?(?:s\\'|\\'[a-zA-Z]{1,2})?(?:(?:(?:\\,|\\.|\\!|\\?)?(?:\\2|\\3)?)|(?:(?:\\2|\\3)?(?:\\,|\\.|\\!|\\?)?)))*)$",
        "raw_prompt": "This is a little goofy regex to allow punctuation. I was reluctant to post it but what the heck. If it puts a smile on somebody's face then it was worth it. It works in most cases. :)",
        "refined_prompt": "\nMatch examples:\n- \"\"hello!\"\"\n- \"\"hello again\"!\"\n- \"I'm back\"\nNon-match examples:\n- \"hello\"\"\n- \"\"hello again!\"!\"",
        "matches": [
            "\"hello!\"",
            "\"hello again\"!",
            "I'm back"
        ],
        "non_matches": [
            "hello\"",
            "\"hello again!\"!",
            "I'mnot back"
        ],
        "stress_tests": []
    },
    {
        "id": 1814,
        "expression": "^[_a-zA-Z0-9-]+(\\.[_a-zA-Z0-9-]+)?@[a-zA-Z0-9-]+(((\\.[0-9]{1,3}){0,3})|((\\.(co|com|net|org|edu|gov|mil|aero|coop|info|museum|name|ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cx|cy|cz|de|dj|dk|dm|do|dz|ec|ee|eg|eh|er|es|et|fi|fj|fk|fm|fo|fr|fx|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nt|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|pt|pw|py|qa|re|ro|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|st|su|sv|sy|sz|tc|td|tf|tg|th|tj|tk|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|um|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|yu|za|zm|zr|zw)){1,2}))$",
        "raw_prompt": "This filter is able to filter a full of address. It uses extension definition",
        "refined_prompt": "\nMatch examples:\n- \"qsdf.dfqsf@14.21.20.10\"\n- \"sfdgfg@fds.co.uk\"\n- \"fgsdg.zz@free.fr\"\nNon-match examples:\n- \"sfdgf.sfdg.sdfg@sfdgsfdG.fr\"\n- \"dfgs.sdf@fdg.02.01.sdf\"",
        "matches": [
            "qsdf.dfqsf@14.21.20.10",
            "sfdgfg@fds.co.uk",
            "fgsdg.zz@free.fr"
        ],
        "non_matches": [
            "sfdgf.sfdg.sdfg@sfdgsfdG.fr",
            "dfgs.sdf@fdg.02.01.sdf",
            "sqf.bcv@xb.nbb"
        ],
        "stress_tests": []
    },
    {
        "id": 1815,
        "expression": "^(\\d{4},?)+$",
        "raw_prompt": "Accepts a list of 4 digits separated by commas. Used to validate a list of years. Can be easily customized to change the number of digits.",
        "refined_prompt": "\nMatch examples:\n- \"2001,2002,2003\"\n- \"1999\"\n- \"1999,2000,\"\nNon-match examples:\n- \"123\"\n- \"1234,e,1234\"",
        "matches": [
            "2001,2002,2003",
            "1999",
            "1999,2000,"
        ],
        "non_matches": [
            "123",
            "1234,e,1234",
            "1234, 1234,1234"
        ],
        "stress_tests": []
    },
    {
        "id": 1816,
        "expression": "(?i)^(((\\\\\\\\(\\?\\\\(UNC\\\\)?)?)([A-Z]:\\\\|([^\\\\\\/\\:\\*\\?\\\"\\<\\>\\|\\.\\s][^\\\\\\/\\:\\*\\?\\\"\\<\\>\\|]+[^\\\\\\/\\:\\*\\?\\\"\\<\\>\\|\\.\\s]\\\\){2}))|[A-Z]:\\\\)([^\\\\\\/\\:\\*\\?\\\"\\<\\>\\|\\s][^\\\\\\/\\:\\*\\?\\\"\\<\\>\\|]+[^\\\\\\/\\:\\*\\?\\\"\\<\\>\\|\\s]\\\\)*([^\\\\\\/\\:\\*\\?\\\"\\<\\>\\|\\.\\s][^\\\\\\/\\:\\*\\?\\\"\\<\\>\\|\\.]+[^\\\\\\/\\:\\*\\?\\\"\\<\\>\\|\\.\\s])(\\.[^\\\\\\/\\:\\*\\?\\\"\\<\\>\\|\\.\\s]+)*?$",
        "raw_prompt": "Matches valid Windows filenames using local, network and UNC formats.",
        "refined_prompt": "\nMatch examples:\n- \"C:\\Program Files\\RegEx\\RegEx.exe.manifest\"\nNon-match examples:\n- \"C:\\Filename.*\"",
        "matches": [
            "C:\\Program Files\\RegEx\\RegEx.exe.manifest"
        ],
        "non_matches": [
            "C:\\Filename.*"
        ],
        "stress_tests": []
    },
    {
        "id": 1819,
        "expression": "\\b(0?[1-9]|1[0-2])(\\/)(0?[1-9]|1[0-9]|2[0-9]|3[0-1])(\\/)(200[0-8])\\b",
        "raw_prompt": "Matches the valid date format MM/DD/CCYY\nYear from 2000 to 2008 and the month will accept till 12 and the day will accept till 31",
        "refined_prompt": "\nMatch examples:\n- \"01/02/2006\"\n- \"12/31/2007\"\n- \"1/1/2008\"\nNon-match examples:\n- \"01/02/1999\"\n- \"13/32/2008\"",
        "matches": [
            "01/02/2006",
            "12/31/2007",
            "1/1/2008"
        ],
        "non_matches": [
            "01/02/1999",
            "13/32/2008",
            "01-31-2008"
        ],
        "stress_tests": []
    },
    {
        "id": 1820,
        "expression": "\\b(0?[1-9]|1[0-2])(\\-)(0?[1-9]|1[0-9]|2[0-9]|3[0-1])(\\-)(200[0-8])\\b",
        "raw_prompt": "Matches the valid date format MM-DD-CCYY\nYear from 2000 to 2008 and the month will accept till 12 and the day will accept till 31",
        "refined_prompt": "\nMatch examples:\n- \"01-02-2006\"\n- \"12-31-2007\"\n- \"1-1-2008\"\nNon-match examples:\n- \"01-02-1999\"\n- \"13-32-2008\"",
        "matches": [
            "01-02-2006",
            "12-31-2007",
            "1-1-2008"
        ],
        "non_matches": [
            "01-02-1999",
            "13-32-2008",
            "01/31/2008"
        ],
        "stress_tests": []
    },
    {
        "id": 1827,
        "expression": "^(http\\:\\/\\/(?:www\\.)?[a-zA-Z0-9]+(?:(?:\\-|_)[a-zA-Z0-9]+)*(?:\\.[a-zA-Z0-9]+(?:(?:\\-|_)[a-zA-Z0-9]+)*)*\\.[a-zA-Z]{2,7}(?:\\/)?)$",
        "raw_prompt": "A URL to a domain name. Only for HTTP but that can be easily changed to accept more. The dashes and underscores can only be used between text and/or digits. The slash on the end is optional. Unlike my other URL checkers this one does not allow query strings.",
        "refined_prompt": "\nMatch examples:\n- \"http://www.website.com/\"\n- \"http://my-website.net\"\n- \"http://another_site.org\"\nNon-match examples:\n- \"www.website.com\"\n- \"http://_website.com\"",
        "matches": [
            "http://www.website.com/",
            "http://my-website.net",
            "http://another_site.org"
        ],
        "non_matches": [
            "www.website.com",
            "http://_website.com",
            "http://www. web--site.com"
        ],
        "stress_tests": []
    },
    {
        "id": 1829,
        "expression": "^([a-zA-Z0-9]+([\\.+_-][a-zA-Z0-9]+)*)@(([a-zA-Z0-9]+((\\.|[-]{1,2})[a-zA-Z0-9]+)*)\\.[a-zA-Z]{2,6})$",
        "raw_prompt": "This pattern was based on this reference: http://www.remote.org/jochen/mail/info/chars.html\nThis expression allows only these symbols (+, -, _, or .) in the local part of the address, but no two consecutive symbols are allowed. The symbols behave like separators for alphanumeric atoms. The local part must begin and end with an atom. Therefore, local part cannot begin or end with a symbol.\nFor the domain name, I tested what was allowed at various domain registrars. While hyphens are allowed, domain names must abide by the following rules:\n-can't begin or end with hyphen\n-no more than two hyphens can appear consecutively",
        "refined_prompt": "\nMatch examples:\n- \"abc@test.com\"\n- \"abc@test-test.info\"\n- \"abc.d-e_f+g@a.b-c.d--e.museum\"\nNon-match examples:\n- \"a+@test.com\"\n- \"+a@test.com\"",
        "matches": [
            "abc@test.com",
            "abc@test-test.info",
            "abc.d-e_f+g@a.b-c.d--e.museum"
        ],
        "non_matches": [
            "a+@test.com",
            "+a@test.com",
            "a++a@test.com",
            "abc@a---b.com",
            "abc@a---b.test.com"
        ],
        "stress_tests": []
    },
    {
        "id": 1830,
        "expression": "^([a-zA-Z]+)://([a-zA-Z0-9_\\-]+)((\\.[a-zA-Z0-9_\\-]+|[0-9]{1,3})+)\\.([a-zA-Z]{2,6}|[0-9]{1,3})((:[0-9]+)?)((/[a-zA-Z0-9_\\-,.;=%]*)*)((\\?[a-zA-Z0-9_\\-,.;=&%]*)?)$",
        "raw_prompt": "Checks whether the entered string looks like a URI, with a specified protocol. Optionally, you can add the port number, and some GET variables.\nThe control is quite loose, but it's a choice of mine.\nComments and corrections are welcome.",
        "refined_prompt": "\nMatch examples:\n- \"this://is.accepted.com/?and=it&sO=K\"\n- \"this://is.accept.ed?too=\"\n- \"and://also.this.one:12/?is=right\"\nNon-match examples:\n- \"this.is.NOT.accepted\"\n- \"neither://this.is&one\"",
        "matches": [
            "this://is.accepted.com/?and=it&sO=K",
            "this://is.accept.ed?too=",
            "and://also.this.one:12/?is=right"
        ],
        "non_matches": [
            "this.is.NOT.accepted",
            "neither://this.is&one",
            "abs://olut.ely.no:way"
        ],
        "stress_tests": []
    },
    {
        "id": 1832,
        "expression": "(\\$\\s*[\\d,]+\\.\\d{2})\\b",
        "raw_prompt": "Validate American Dollar Amount Format",
        "refined_prompt": "\nMatch examples:\n- \"$ 417,000.00\"\n- \"$ 280.00\"\n- \"$ 10.00\"\nNon-match examples:\n- \"$ 12234566\"\n- \"$ 540,453.000\"",
        "matches": [
            "$ 417,000.00",
            "$ 280.00",
            "$ 10.00"
        ],
        "non_matches": [
            "$ 12234566",
            "$ 540,453.000",
            "$ 123,000",
            "$ 200,000.0"
        ],
        "stress_tests": []
    },
    {
        "id": 1833,
        "expression": "\\b[1-9]\\b",
        "raw_prompt": "Validate the numbers 1 to 9",
        "refined_prompt": "\nMatch examples:\n- \"1\"\n- \"5\"\n- \"9\"\nNon-match examples:\n- \"0\"\n- \"15\"",
        "matches": [
            "1",
            "5",
            "9"
        ],
        "non_matches": [
            "0",
            "15",
            "19"
        ],
        "stress_tests": []
    },
    {
        "id": 1834,
        "expression": "\\b4[0-9]\\b",
        "raw_prompt": "Validate the numbers in between 39 to 50 (i.e 40 to 49)",
        "refined_prompt": "\nMatch examples:\n- \"40\"\n- \"46\"\n- \"49\"\nNon-match examples:\n- \"4\"\n- \"50\"",
        "matches": [
            "40",
            "46",
            "49"
        ],
        "non_matches": [
            "4",
            "50",
            "39"
        ],
        "stress_tests": []
    },
    {
        "id": 1835,
        "expression": "[^<>/?&{};#]+",
        "raw_prompt": "This expression stops the characters <>/?&{};# from a string of any length passing the regular expression validator in Visual Studio thereby stopping the HttpRequestValidationException (if client side validation and javascript is on)",
        "refined_prompt": "\nMatch examples:\n- \"any word\"\n- \"a\"\n- \"a number 4382\"\nNon-match examples:\n- \"<\"\n- \">\"",
        "matches": [
            "any word",
            "a",
            "a number 4382"
        ],
        "non_matches": [
            "<",
            ">",
            "/",
            "?",
            "&",
            "#",
            "{",
            "}",
            ";"
        ],
        "stress_tests": []
    },
    {
        "id": 1842,
        "expression": "^(100(?:\\.0{1,2})?|0*?\\.\\d{1,2}|\\d{1,2}(?:\\.\\d{1,2})?)$",
        "raw_prompt": "generate percentage with 2 values after point",
        "refined_prompt": "\nMatch examples:\n- \"3.00\"\n- \"100.00\"\n- \"45\"\nNon-match examples:\n- \"101\"\n- \"4.678\"",
        "matches": [
            "3.00",
            "100.00",
            "45"
        ],
        "non_matches": [
            "101",
            "4.678",
            "425.876"
        ],
        "stress_tests": []
    },
    {
        "id": 1846,
        "expression": "^(([1-9]{1}(\\d+)?)(\\.\\d+)?)|([0]\\.(\\d+)?([1-9]{1})(\\d+)?)$",
        "raw_prompt": "Regular expression that accepts positive numbers with or with decimal places, but will not allow zero or 0.000",
        "refined_prompt": "\nMatch examples:\n- \"1\"\n- \"25\"\n- \"25.0\"\nNon-match examples:\n- \"0\"\n- \"0.0\"",
        "matches": [
            "1",
            "25",
            "25.0",
            "25.001",
            "0.001",
            "0.234"
        ],
        "non_matches": [
            "0",
            "0.0",
            "-12"
        ],
        "stress_tests": []
    },
    {
        "id": 1848,
        "expression": "^(ftp|https?):\\/\\/([^:]+:[^@]*@)?([a-zA-Z0-9][-_a-zA-Z0-9]*\\.)*([a-zA-Z0-9][-_a-zA-Z0-9]*){1}(:[0-9]+)?\\/?(((\\/|\\[|\\]|-|~|_|\\.|:|[a-zA-Z0-9]|%[0-9a-fA-F]{2})*)\\?((\\/|\\[|\\]|-|~|_|\\.|,|:|=||\\{|\\}|[a-zA-Z0-9]|%[0-9a-fA-F]{2})*\\&?)*)?(#([-_.a-zA-Z0-9]|%[a-fA-F0-9]{2})*)?$",
        "raw_prompt": "This pattern can be used to validate URLs starting with ftp, http or https",
        "refined_prompt": "\nMatch examples:\n- \"https://user:password@subdomain.domain.tld:80/~user/a_1/b.2//c%203/file.extension?query=string&with=various&param_eters&and=param,eters&with[]=brackets&and:colons&uniqid={21EC2020-3AEA-1069-A2DD-08002B30309D}\"\nNon-match examples:\n- \"http://domain.....tld\"",
        "matches": [
            "https://user:password@subdomain.domain.tld:80/~user/a_1/b.2//c%203/file.extension?query=string&with=various&param_eters&and=param,eters&with[]=brackets&and:colons&uniqid={21EC2020-3AEA-1069-A2DD-08002B30309D}"
        ],
        "non_matches": [
            "http://domain.....tld"
        ],
        "stress_tests": []
    },
    {
        "id": 1850,
        "expression": "^(AT){0,1}[U]{0,1}[0-9]{8}$",
        "raw_prompt": "Vat number for Austria.\nFormat is\nATU12345678",
        "refined_prompt": "\nMatch examples:\n- \"ATU12345678\"\n- \"ATU98752658\"\n- \"ATU98765432\"\nNon-match examples:\n- \"ATb12345678\"\n- \"ATu12345678\"",
        "matches": [
            "ATU12345678",
            "ATU98752658",
            "ATU98765432"
        ],
        "non_matches": [
            "ATb12345678",
            "ATu12345678",
            "ATU 1234567"
        ],
        "stress_tests": []
    },
    {
        "id": 1851,
        "expression": "^(BG){0,1}([0-9]{9}|[0-9]{10})$",
        "raw_prompt": "Vat number for Bulgaria. Formats are\nBG123456789\nBG1234567890",
        "refined_prompt": "\nMatch examples:\n- \"BG123456789\"\n- \"BG1234567890\"\n- \"BG1587963587\"\nNon-match examples:\n- \"BG12349\"\n- \"Bg1234567890\"",
        "matches": [
            "BG123456789",
            "BG1234567890",
            "BG1587963587"
        ],
        "non_matches": [
            "BG12349",
            "Bg1234567890",
            "BG1587963587989"
        ],
        "stress_tests": []
    },
    {
        "id": 1852,
        "expression": "(/\\*[\\d\\D]*?\\*/)|(\\/\\*(\\s*|.*?)*\\*\\/)|(\\/\\/.*)|(/\\\\*[\\\\d\\\\D]*?\\\\*/)|([\\r\\n ]*//[^\\r\\n]*)+",
        "raw_prompt": "This regex searches multi-line, single-line, and XML comments present in C# file.",
        "refined_prompt": "\nMatch examples:\n- \"/* multi-line */\"\n- \"// comment\"\n- \"/// XML Comment\"\nNon-match examples:\n- \"/* multi-line /*\"",
        "matches": [
            "/* multi-line */",
            "// comment",
            "/// XML Comment"
        ],
        "non_matches": [
            "/* multi-line /*"
        ],
        "stress_tests": []
    },
    {
        "id": 1855,
        "expression": "(^0?[1-9]|^1[0-2])\\/(0?[1-9]|[1-2][0-9]|3[0-1])\\/(19|20)?[0-9][0-9](\\s(((0?[0-9]|1[0-9]|2[0-3]):[0-5][0-9](:[0-5][0-9])?)|((0?[0-9]|1[0-2]):[0-5][0-9](:[0-5][0-9])?\\s(AM|PM))))?$",
        "raw_prompt": "Expression to validate a date with or without time in standard or 24 hour format with optional milliseconds (01/12/08 23:31:05 or 5/12/1974 11:59 PM).",
        "refined_prompt": "\nMatch examples:\n- \"01/28/08 22:34:12\"\n- \"10/23/1952 5:23:01 PM\"\n- \"6/2/02 22:59\"\nNon-match examples:\n- \"1/32/08\"\n- \"12/29/005\"",
        "matches": [
            "01/28/08 22:34:12",
            "10/23/1952 5:23:01 PM",
            "6/2/02 22:59",
            "5/13/04"
        ],
        "non_matches": [
            "1/32/08",
            "12/29/005",
            "6/14/05 23:00:02 PM",
            "10/2/02 13:00 AM"
        ],
        "stress_tests": []
    },
    {
        "id": 1856,
        "expression": "^([a-zA-Z0-9])+\\\\{1}([a-zA-Z0-9])+$",
        "raw_prompt": "Checks for the format alphanumeric\\alphanumeric",
        "refined_prompt": "\nMatch examples:\n- \"Admin\\user1\"\n- \"ajit\\123\"\n- \"123\\Ajit1\"\nNon-match examples:\n- \"\\domain\\user\"\n- \"domain\\\\\\user\"",
        "matches": [
            "Admin\\user1",
            "ajit\\123",
            "123\\Ajit1"
        ],
        "non_matches": [
            "\\domain\\user",
            "domain\\\\\\user",
            "dom ain\\user"
        ],
        "stress_tests": []
    },
    {
        "id": 1857,
        "expression": "^((((0?[13578])|(1[02]))[\\-]?((0?[1-9]|[0-2][0-9])|(3[01])))|(((0?[469])|(11))[\\-]?((0?[1-9]|[0-2][0-9])|(30)))|(0?[2][\\-]?(0?[1-9]|[0-2][0-9])))[\\-]?\\d{2}$",
        "raw_prompt": "I was looking for a date format that allowed 1 or 2 digit Month and Days and 2 digit years. I found and tweak this one\nbased off Cliff Schneide Date example.",
        "refined_prompt": "\nMatch examples:\n- \"03-25-08\"\n- \"3-25-08\"\n- \"3-1-08\"\nNon-match examples:\n- \"03-25-2008\"\n- \"3-25-2008\"",
        "matches": [
            "03-25-08",
            "3-25-08",
            "3-1-08"
        ],
        "non_matches": [
            "03-25-2008",
            "3-25-2008",
            "3/25/2008"
        ],
        "stress_tests": []
    },
    {
        "id": 1863,
        "expression": "^\\s*[a-zA-Z0-9,\\s]+\\s*$",
        "raw_prompt": "Will take space, number, no special characters",
        "refined_prompt": "\nMatch examples:\n- \"Project Name1\"\n- \"Project 1\"\nNon-match examples:\n- \"Project@1\"\n- \"Project Name^111\"",
        "matches": [
            "Project Name1",
            "Project 1"
        ],
        "non_matches": [
            "Project@1",
            "Project Name^111"
        ],
        "stress_tests": []
    },
    {
        "id": 1866,
        "expression": "^[a-zA-Z_:]+[a-zA-Z_:\\-\\.\\d]*$",
        "raw_prompt": "Valid XML Node or Attribute Names start with a letter <document>, an underscore <_record> or a colon (generally avoid using a colon)\nThe next characters may be letters, digits, underscore, hyphens, periods and colons (but no whitespaces)",
        "refined_prompt": "\nMatch examples:\n- \"_1record\"\n- \"MyXMLTag\"\n- \":ThisIsGr8\"\nNon-match examples:\n- \"1record\"\n- \"My XMLTag\"",
        "matches": [
            "_1record",
            "MyXMLTag",
            ":ThisIsGr8"
        ],
        "non_matches": [
            "1record",
            "My XMLTag",
            "ThisIs<Gr8"
        ],
        "stress_tests": []
    },
    {
        "id": 1867,
        "expression": "^[1-9][0-9][0-9][0-9]$",
        "raw_prompt": "Zip code validation for Switzerland.\nForces 4-digits only zipcode starting at 1000",
        "refined_prompt": "\nMatch examples:\n- \"1000\"\n- \"1200\"\n- \"8200\"\nNon-match examples:\n- \"a-z\"\n- \"aaaa\"",
        "matches": [
            "1000",
            "1200",
            "8200",
            "8048",
            "9999"
        ],
        "non_matches": [
            "a-z",
            "aaaa",
            "123",
            "0000"
        ],
        "stress_tests": []
    },
    {
        "id": 1872,
        "expression": "(?!^[0-9]*$)(?!^[a-zA-Z]*$)^([a-zA-Z0-9]{8,10})$",
        "raw_prompt": "Validates a strong password. It must be between 8 and 10 characters, contain at least one digit and one alphabetic character, and must not contain special characters",
        "refined_prompt": "\nMatch examples:\n- \"test1test\"\nNon-match examples:\n- \"testtest\"",
        "matches": [
            "test1test"
        ],
        "non_matches": [
            "testtest"
        ],
        "stress_tests": []
    },
    {
        "id": 1873,
        "expression": "style=\"[^\"]*\"|'[^']*'",
        "raw_prompt": "Get the style attribute inner text contained inside \" or ' caracters with the \"style=\" prefix.",
        "refined_prompt": "\nMatch examples:\n- \"style=\"width: 10px;border:0\" , style='width: 10px;border:0'\"\nNon-match examples:\n- \"style = \"width:10px\"\"",
        "matches": [
            "style=\"width: 10px;border:0\" , style='width: 10px;border:0'"
        ],
        "non_matches": [
            "style = \"width:10px\""
        ],
        "stress_tests": []
    },
    {
        "id": 1877,
        "expression": "((0[1-9])|(1[0-2]))\\/(([0-9])|([0-2][0-9])|(3[0-1]))/\\d{2}",
        "raw_prompt": "Validates dates in the following format: MM/DD/YY",
        "refined_prompt": "\nMatch examples:\n- \"01/30/08\"\n- \"12/04/99\"\n- \"01/05/10\"\nNon-match examples:\n- \"13/30/05\"\n- \"9/33/99\"",
        "matches": [
            "01/30/08",
            "12/04/99",
            "01/05/10"
        ],
        "non_matches": [
            "13/30/05",
            "9/33/99",
            "1/05/02"
        ],
        "stress_tests": []
    },
    {
        "id": 1881,
        "expression": "^http[s]?://([a-zA-Z0-9\\-]+\\.)*([a-zA-Z]{3,61}|[a-zA-Z]{1,}\\.[a-zA-Z]{2})/.*$",
        "raw_prompt": "Used for matching a URL and can be used for extracting the domain name from a given URL ending with '/'.\nConcat $2 and $3 to get the domain name.",
        "refined_prompt": "\nMatch examples:\n- \"http://www.google.com/\"\n- \"http://google.com/\"\n- \"http://code.google.com/\"\nNon-match examples:\n- \"http://www.google.com;\"",
        "matches": [
            "http://www.google.com/",
            "http://google.com/",
            "http://code.google.com/",
            "http://google.co.uk/",
            "http://tx.us/"
        ],
        "non_matches": [
            "http://www.google.com;"
        ],
        "stress_tests": []
    },
    {
        "id": 1884,
        "expression": "^.*(yourdomain.com).*$",
        "raw_prompt": "Matches the TLD of a given domain (replace yourdomain.com with whatever domain you're trying to enforce).\nI was writing an web application in which I wanted to to display a special message to visitors if and only if they were referred to my site by one specific site. However, because the specific site in question was highly dynamic, referring URLs were all over the place in terms of consistency and the only thing I knew I could count on 100% was the TLD (subdomains and file paths acceptable, so long as the TLD matches exactly).",
        "refined_prompt": "\nMatch examples:\n- \"yourdomain.com\"\n- \"http://www.yourdomain.com\"\n- \"http://subdomain.yourdomain.com/pages/manage/?act=4015876&ag=709254588456a\"\nNon-match examples:\n- \"your-domain.com\"\n- \"ourdomain.com\"",
        "matches": [
            "yourdomain.com",
            "http://www.yourdomain.com",
            "http://subdomain.yourdomain.com/pages/manage/?act=4015876&ag=709254588456a"
        ],
        "non_matches": [
            "your-domain.com",
            "ourdomain.com",
            "yourdomain.co"
        ],
        "stress_tests": []
    },
    {
        "id": 1886,
        "expression": "^(\\d{1,8}|(\\d{0,8}\\.{1}\\d{1,2}){1})$",
        "raw_prompt": "Validates a decimal with up to 8 whole places and up to two decimal places",
        "refined_prompt": "\nMatch examples:\n- \"1\"\n- \"1.22\"\n- \"12345678.11\"\nNon-match examples:\n- \"123456789\"\n- \"1.223234\"",
        "matches": [
            "1",
            "1.22",
            "12345678.11",
            ".34"
        ],
        "non_matches": [
            "123456789",
            "1.223234",
            "123456789.11"
        ],
        "stress_tests": []
    },
    {
        "id": 1894,
        "expression": "\\b(0?[1-9]|1[0-2])(\\/)(0?[1-9]|1[0-9]|2[0-9]|3[0-1])(\\/)(0[0-8])\\b",
        "raw_prompt": "Matches the valid date format MM/DD/YY Year from 2000 (00) to 2008 (08) and the month will accept till 12 and the day will accept till 31",
        "refined_prompt": "\nMatch examples:\n- \"01/02/06\"\n- \"12/31/07\"\n- \"1/1/08\"\nNon-match examples:\n- \"01/02/1999\"\n- \"13/32/08\"",
        "matches": [
            "01/02/06",
            "12/31/07",
            "1/1/08"
        ],
        "non_matches": [
            "01/02/1999",
            "13/32/08",
            "01-31-2008"
        ],
        "stress_tests": []
    },
    {
        "id": 1896,
        "expression": "\\b(0[0-9]|1[0-9]|2[0-3])(\\:)(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])(\\:)(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])\\b",
        "raw_prompt": "It will matches the railway time format that 00:00:00 to 23:59:59",
        "refined_prompt": "\nMatch examples:\n- \"00:00:00\"\n- \"23:59:59\"\n- \"10:00:00\"\nNon-match examples:\n- \"24:0:00\"\n- \"20:60:60\"",
        "matches": [
            "00:00:00",
            "23:59:59",
            "10:00:00"
        ],
        "non_matches": [
            "24:0:00",
            "20:60:60",
            "15:00"
        ],
        "stress_tests": []
    },
    {
        "id": 1897,
        "expression": "\\b(0[0-9]|1[0-1])(\\:)(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])(\\:)(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])\\b",
        "raw_prompt": "It will matches the Standard time format that 00:00:00 to 11:59:59",
        "refined_prompt": "\nMatch examples:\n- \"00:00:00\"\n- \"11:59:59\"\n- \"10:00:00\"\nNon-match examples:\n- \"20:00:00\"\n- \"10:60:60\"",
        "matches": [
            "00:00:00",
            "11:59:59",
            "10:00:00"
        ],
        "non_matches": [
            "20:00:00",
            "10:60:60",
            "15:00"
        ],
        "stress_tests": []
    },
    {
        "id": 1898,
        "expression": "\\b(0[0-9]|1[0-1])(\\:)(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])(\\:)(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])\\s*(AM|PM|A|P)\\b",
        "raw_prompt": "It will matches the Standard time format that 00:00:00 AM to 11:59:59 PM",
        "refined_prompt": "\nMatch examples:\n- \"00:00:00 AM\"\n- \"11:59:59 PM\"\n- \"10:00:00 AM\"\nNon-match examples:\n- \"00:00:00\"\n- \"11:59:59\"",
        "matches": [
            "00:00:00 AM",
            "11:59:59 PM",
            "10:00:00 AM"
        ],
        "non_matches": [
            "00:00:00",
            "11:59:59",
            "15:00 PM"
        ],
        "stress_tests": []
    },
    {
        "id": 1899,
        "expression": "\\b(((J(ANUARY|UNE|ULY))|FEBRUARY|MARCH|(A(PRIL|UGUST))|MAY|(SEPT|NOV|DEC)EMBER|OCTOBER))\\s*(0?[1-9]|1[0-9]|2[0-9]|3[0-1])\\s*(\\,)\\s*(200[0-9])\\b",
        "raw_prompt": "VALIDATE THE DATE FORMAT FULL MONTH DAY, CCYY i.e August 30, 2006",
        "refined_prompt": "\nMatch examples:\n- \"JANUARY 26, 2007\"\n- \"MARCH 1, 2001\"\n- \"DECEMBER 31, 2005\"\nNon-match examples:\n- \"JAN 26, 2001\"\n- \"JULY 31 2005\"",
        "matches": [
            "JANUARY 26, 2007",
            "MARCH 1, 2001",
            "DECEMBER 31, 2005"
        ],
        "non_matches": [
            "JAN 26, 2001",
            "JULY 31 2005",
            "AUGUST 01, 08"
        ],
        "stress_tests": []
    },
    {
        "id": 1900,
        "expression": "\\b(((J(ANUARY|UNE|ULY))|FEBRUARY|MARCH|(A(PRIL|UGUST))|MAY|(SEPT|NOV|DEC)EMBER|OCTOBER))\\s*(0?[1-9]|1[0-9]|2[0-9]|3[0-1])\\s*(\\,)\\s*(0[0-9])\\b",
        "raw_prompt": "VALIDATE THE DATE FORMAT FULL MONTH DAY, YY i.e August 30, 06 (2006)",
        "refined_prompt": "\nMatch examples:\n- \"JANUARY 26, 07\"\n- \"MARCH 1, 01\"\n- \"DECEMBER 31, 05\"\nNon-match examples:\n- \"JAN 26, 01\"\n- \"JULY 31 05\"",
        "matches": [
            "JANUARY 26, 07",
            "MARCH 1, 01",
            "DECEMBER 31, 05"
        ],
        "non_matches": [
            "JAN 26, 01",
            "JULY 31 05",
            "AUGUST 01, 2008"
        ],
        "stress_tests": []
    },
    {
        "id": 1901,
        "expression": "\\b((J(AN|UN|UL))|FEB|MAR|(A(PR|UG))|MAY|SEP|NOV|DEC|OCT)\\s*(0?[1-9]|1[0-9]|2[0-9]|3[0-1])\\s*(\\,)\\s*(200[0-9])\\b",
        "raw_prompt": "VALIDATE THE DATE FORMAT SHORT MONTH DAY, CCYY i.e Aug 30, 2006",
        "refined_prompt": "\nMatch examples:\n- \"JAN 26, 2007\"\n- \"MAR 1, 2001\"\n- \"DEC 31, 2005\"\nNon-match examples:\n- \"JANUARY 26, 2001\"\n- \"JUL 31 2005\"",
        "matches": [
            "JAN 26, 2007",
            "MAR 1, 2001",
            "DEC 31, 2005"
        ],
        "non_matches": [
            "JANUARY 26, 2001",
            "JUL 31 2005",
            "AUGUST 01, 08"
        ],
        "stress_tests": []
    },
    {
        "id": 1902,
        "expression": "\\b((J(AN|UN|UL))|FEB|MAR|(A(PR|UG))|MAY|SEP|NOV|DEC|OCT)\\s*(0?[1-9]|1[0-9]|2[0-9]|3[0-1])\\s*(\\,)\\s*(0[0-9])\\b",
        "raw_prompt": "VALIDATE THE DATE FORMAT SHORT MONTH DAY, YY i.e Aug 30, 06 (2006)",
        "refined_prompt": "\nMatch examples:\n- \"JAN 26, 07\"\n- \"MAR 1, 01\"\n- \"DEC 31, 05\"\nNon-match examples:\n- \"JANUARY 26, 01\"\n- \"JUL 31 05\"",
        "matches": [
            "JAN 26, 07",
            "MAR 1, 01",
            "DEC 31, 05"
        ],
        "non_matches": [
            "JANUARY 26, 01",
            "JUL 31 05",
            "AUGUST 01, 08"
        ],
        "stress_tests": []
    },
    {
        "id": 1903,
        "expression": "(\\+1 )?\\d{3} \\d{3} \\d{4}",
        "raw_prompt": "This simple expression validates a USA phone number format where the +1 is required and that the phone number must only consist of numbers and spaces.",
        "refined_prompt": "\nMatch examples:\n- \"+1 808 555 1234\"\nNon-match examples:\n- \"808-555-1234\"\n- \"+1 (808) 555-1234\"",
        "matches": [
            "+1 808 555 1234"
        ],
        "non_matches": [
            "808-555-1234",
            "+1 (808) 555-1234"
        ],
        "stress_tests": []
    },
    {
        "id": 1906,
        "expression": "\\s(?=([^\"]*\"[^\"]*\"[^\"]*)*$|[^\"]*$)",
        "raw_prompt": "Splits a string by spaces, except when the space is within a quote delimited set of characters. Usefull for splitting search field inputs.\nProps to killahbeez",
        "refined_prompt": "\nMatch examples:\n- \"\"two key\" words\"\n- \"\"three key words\"\n- \"three key words\"\nNon-match examples:\n- \"\"no matches\"\"\n- \"\"noMatches\"\"",
        "matches": [
            "\"two key\" words",
            "\"three key words",
            "three key words"
        ],
        "non_matches": [
            "\"no matches\"",
            "\"noMatches\"",
            "noMatches"
        ],
        "stress_tests": []
    },
    {
        "id": 1909,
        "expression": "ICON=\"[^\"]+\"",
        "raw_prompt": "Remove favicon base64 data from Firefox bookmark HTML files, thereby reducing file size (useful for HTML bookmark backup and transfer).",
        "refined_prompt": "\nMatch examples:\n- \"<DT><A HREF=\"http://www.gmail.com/\" ADD_DATE=\"1147950005\" LAST_MODIFIED=\"1147950022\" ICON_URI=\"https://mail.google.com/favicon.ico\" ICON=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAiElEQVQ4jdWPsQ3AIAwEGYtZ2IZpvIGHoaRLm47q0wCyiY2SKspL3/mOJ4T/p8SI0TNnNKJtz5whGSUoMQLMcMOM9T7I14+UfEmHj5TUiikA4EsWGIAtMCUGvBWAWUkULFbZglrRiJREwo0IqNURDLgfjO/I2fLmJlhhN11iLngcb8GbTsHnuQAHliL7fehqZAAAAABJRU5ErkJggg==\" LAST_CHARSET=\"UTF-8\">Google Mail</A>\"\nNon-match examples:\n- \"<DT><A HREF=\"http://flickr.com/\" ADD_DATE=\"1107635483\" LAST_VISIT=\"1189245562\" LAST_MODIFIED=\"1114539579\" LAST_CHARSET=\"UTF-8\" ID=\"rdf:#$Ppq5x3\">Flickr</A>\"",
        "matches": [
            "<DT><A HREF=\"http://www.gmail.com/\" ADD_DATE=\"1147950005\" LAST_MODIFIED=\"1147950022\" ICON_URI=\"https://mail.google.com/favicon.ico\" ICON=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAiElEQVQ4jdWPsQ3AIAwEGYtZ2IZpvIGHoaRLm47q0wCyiY2SKspL3/mOJ4T/p8SI0TNnNKJtz5whGSUoMQLMcMOM9T7I14+UfEmHj5TUiikA4EsWGIAtMCUGvBWAWUkULFbZglrRiJREwo0IqNURDLgfjO/I2fLmJlhhN11iLngcb8GbTsHnuQAHliL7fehqZAAAAABJRU5ErkJggg==\" LAST_CHARSET=\"UTF-8\">Google Mail</A>"
        ],
        "non_matches": [
            "<DT><A HREF=\"http://flickr.com/\" ADD_DATE=\"1107635483\" LAST_VISIT=\"1189245562\" LAST_MODIFIED=\"1114539579\" LAST_CHARSET=\"UTF-8\" ID=\"rdf:#$Ppq5x3\">Flickr</A>"
        ],
        "stress_tests": []
    },
    {
        "id": 1912,
        "expression": "(^\\+?([1-8])?\\d(\\.\\d+)?$)|(^-90$)|(^-(([1-8])?\\d(\\.\\d+)?$))",
        "raw_prompt": "Latitude must<90 >=-90",
        "refined_prompt": "\nMatch examples:\n- \"5.4\"\n- \"-0.58\"\n- \"-90\"\nNon-match examples:\n- \"-120\"\n- \"+1.4F\"",
        "matches": [
            "5.4",
            "-0.58",
            "-90",
            "+87"
        ],
        "non_matches": [
            "-120",
            "+1.4F",
            "90"
        ],
        "stress_tests": []
    },
    {
        "id": 1913,
        "expression": "^((1[01])|(\\d)):[0-5]\\d(:[0-5]\\d)?\\s?([apAP][Mm])?$",
        "raw_prompt": "validate time\nin hh:mm:ss\nhh:mm\nhh:mm:ss pm(am,PM,AM)\n<12h",
        "refined_prompt": "\nMatch examples:\n- \"11:23:43PM\"\n- \"3:25:35\"\n- \"1:23 am\"\nNon-match examples:\n- \"12:01:01\"\n- \"3.14pm\"",
        "matches": [
            "11:23:43PM",
            "3:25:35",
            "1:23 am"
        ],
        "non_matches": [
            "12:01:01",
            "3.14pm",
            "01:24AM"
        ],
        "stress_tests": []
    },
    {
        "id": 1914,
        "expression": "^<\\s*(td|TD)\\s*(\\w|\\W)*\\s*>(\\w|\\W)*</(td|TD)>$",
        "raw_prompt": "match <td ***>***</td> in html,so any other html mark with<sth></sth> is just do a little change to this",
        "refined_prompt": "\nMatch examples:\n- \"<td>hello kitty</td>\"\n- \"<TD WIDTH='20></TD>\"\n- \"<TD >&NBSP;</td>\"\nNon-match examples:\n- \"<td>< /td>\"\n- \"<TD HELLO</td>\"",
        "matches": [
            "<td>hello kitty</td>",
            "<TD WIDTH='20></TD>",
            "<TD >&NBSP;</td>"
        ],
        "non_matches": [
            "<td>< /td>",
            "<TD HELLO</td>",
            "<table></table>"
        ],
        "stress_tests": []
    },
    {
        "id": 1915,
        "expression": "^((([1]\\d{2})|(22[0-3])|([1-9]\\d)|(2[01]\\d)|[1-9]).(([1]\\d{2})|(2[0-4]\\d)|(25[0-5])|([1-9]\\d)|\\d).(([1]\\d{2})|(2[0-4]\\d)|(25[0-5])|([1-9]\\d)|\\d).(([1]\\d{2})|(2[0-4]\\d)|(25[0-5])|([1-9]\\d)|\\d))$",
        "raw_prompt": "match ip\naddress from 1.0.0.0 to 223.255.255.255",
        "refined_prompt": "\nMatch examples:\n- \"192.168.0.1\"\n- \"223.255.255.255\"\n- \"9.0.0.0\"\nNon-match examples:\n- \"0.10.2.52\"\n- \"255.255.255.255\"",
        "matches": [
            "192.168.0.1",
            "223.255.255.255",
            "9.0.0.0"
        ],
        "non_matches": [
            "0.10.2.52",
            "255.255.255.255",
            "127.0.257.1"
        ],
        "stress_tests": []
    },
    {
        "id": 1916,
        "expression": "(((0[13578]|10|12)([/])(0[1-9]|[12][0-9]|3[01])([/])([1-2][0,9][0-9][0-9]))|((0[469]|11)([/])([0][1-9]|[12][0-9]|30)([/])([1-2][0,9][0-9][0-9]))|((02)([/])(0[1-9]|1[0-9]|2[0-8])([/])([1-2][0,9][0-9][0-9]))|((02)([/])(29)(\\.|-|\\/)([02468][048]00))|((02)([/])(29)([/])([13579][26]00))|((02)([/])(29)([/])([0-9][0-9][0][48]))|((02)([/])(29)([/])([0-9][0-9][2468][048]))|((02)([/])(29)([/])([0-9][0-9][13579][26])))",
        "raw_prompt": "This is the USA Date Format. MM/DD/YYYY with checking leaf year",
        "refined_prompt": "\nMatch examples:\n- \"05/15/2008\"\n- \"02/29/2008\"\nNon-match examples:\n- \"05-12-2008\"\n- \"02/29/2007\"",
        "matches": [
            "05/15/2008",
            "02/29/2008"
        ],
        "non_matches": [
            "05-12-2008",
            "02/29/2007"
        ],
        "stress_tests": []
    },
    {
        "id": 1921,
        "expression": "^([a-zA-Z]+[\\'\\,\\.\\-]?[a-zA-Z ]*)+[ ]([a-zA-Z]+[\\'\\,\\.\\-]?[a-zA-Z ]+)+$",
        "raw_prompt": "Requires a person's name including at least 2 parts. (first and last) Allows optional extra names. It allows plenty of initials as well as symbols in names. Restricts symbol usage quite a bit, but allows even names with 2 symbols. Requires last name to have at least 2 characters and cannot be an initial. Works well for filtering names on validation.",
        "refined_prompt": "\nMatch examples:\n- \"E.J. O'Malley\"\n- \"Jack O'Neil\"\n- \"Mary-Lou Elizabeth Jones\"\nNon-match examples:\n- \"Johnathan Michael S.\"\n- \"Prince\"",
        "matches": [
            "E.J. O'Malley",
            "Jack O'Neil",
            "Mary-Lou Elizabeth Jones"
        ],
        "non_matches": [
            "Johnathan Michael S.",
            "Prince",
            "Teddy Has-a..Fake-Name"
        ],
        "stress_tests": []
    },
    {
        "id": 1924,
        "expression": "((19|20)[0-9]{2})-(([1-9])|(0[1-9])|(1[0-2]))-((3[0-1])|([0-2][0-9])|([0-9]))",
        "raw_prompt": "Validate the year month and day.",
        "refined_prompt": "\nMatch examples:\n- \"2008-12-15\"\nNon-match examples:\n- \"1556/9/8\"",
        "matches": [
            "2008-12-15"
        ],
        "non_matches": [
            "1556/9/8"
        ],
        "stress_tests": []
    },
    {
        "id": 1925,
        "expression": "^[:*:]",
        "raw_prompt": "This checks whether the string is equals to \"*\" i.e., contains only \"*(Asterisk)\" or begins with Asterisk.",
        "refined_prompt": "\nMatch examples:\n- \"*\"\n- \"*Asdf\"\nNon-match examples:\n- \"a*\"\n- \"asdf\"",
        "matches": [
            "*",
            "*Asdf"
        ],
        "non_matches": [
            "a*",
            "asdf"
        ],
        "stress_tests": []
    },
    {
        "id": 1927,
        "expression": "^[0-9]+\\.?[0-9]?[0-9]?[0,5]?$",
        "raw_prompt": "The time should be fractional number and divisible by 0.005",
        "refined_prompt": "\nMatch examples:\n- \"1.005\"\n- \"60\"\n- \"0.08\"\nNon-match examples:\n- \"1.009\"\n- \"-8\"",
        "matches": [
            "1.005",
            "60",
            "0.08"
        ],
        "non_matches": [
            "1.009",
            "-8",
            ".005"
        ],
        "stress_tests": []
    },
    {
        "id": 1931,
        "expression": "^\\d+\\/?\\d*$",
        "raw_prompt": "This simple expression is used to validate fractions or UK odds.\nIt will match integers, allowing 10/1 to be entered as 10, and fractions.\nIt will not match negative numbers or fractions, spaces or any alphabetical characters.",
        "refined_prompt": "\nMatch examples:\n- \"10\"\n- \"2/3\"\n- \"100/30\"\nNon-match examples:\n- \"-10\"\n- \"-2/3\"",
        "matches": [
            "10",
            "2/3",
            "100/30"
        ],
        "non_matches": [
            "-10",
            "-2/3",
            "text",
            "10 / 1",
            "42/7eok"
        ],
        "stress_tests": []
    },
    {
        "id": 1933,
        "expression": "^(\\d{1,4}?[.]{0,1}?\\d{0,3}?)$",
        "raw_prompt": "This expression validate the add of numbers with or without decimal",
        "refined_prompt": "\nMatch examples:\n- \"123\"\n- \"123.1\"\n- \"100.\"\nNon-match examples:\n- \"12345.1234\"\n- \".012\"",
        "matches": [
            "123",
            "123.1",
            "100.",
            "0.2",
            "2341.123"
        ],
        "non_matches": [
            "12345.1234",
            ".012",
            ".2893"
        ],
        "stress_tests": []
    },
    {
        "id": 1941,
        "expression": "^([\\u20AC]?[1-9]\\d*\\.\\d{3}(?:,\\d{2})?|[\\u20AC]?[1-9]\\d*(?:,\\d{2})?|[\\u20AC]?[1-9]\\d*)$",
        "raw_prompt": "Optional Amount, with optional thousands seperator (using the point) and optional decimal comma. If decimal comma is in string, then 2 trailing digits are required. Also checks for the optional euro sign",
        "refined_prompt": "\nMatch examples:\n- \"1\"\n- \"1,00\"\n- \"1.000,00\"\nNon-match examples:\n- \"1a\"\n- \".00,00\"",
        "matches": [
            "1",
            "1,00",
            "1.000,00",
            "\u20ac1"
        ],
        "non_matches": [
            "1a",
            ".00,00",
            "1,0",
            "$1"
        ],
        "stress_tests": []
    },
    {
        "id": 1943,
        "expression": "\\b[P|p]?(OST|ost)?\\.?\\s*[O|o|0]?(ffice|FFICE)?\\.?\\s*[B|b][O|o|0]?[X|x]?\\.?\\s+[#]?(\\d+)\\b",
        "raw_prompt": "Modified version of Chris Myers' regexp for po boxes. This one won't match the word \"box\" in the address. Only matches if there is a number following the po box. Also accepts a # in front of the number and other spelling variations.",
        "refined_prompt": "\nMatch examples:\n- \"po box 123, p.o.b. #123, box 123\"\nNon-match examples:\n- \"123 box canyon rd\"",
        "matches": [
            "po box 123, p.o.b. #123, box 123"
        ],
        "non_matches": [
            "123 box canyon rd"
        ],
        "stress_tests": []
    },
    {
        "id": 1944,
        "expression": "http[s]?://[a-zA-Z0-9.-/]+",
        "raw_prompt": "Checks to make sure that entry starts with http:// or https:// and that contents are limited to alphas . - /",
        "refined_prompt": "\nMatch examples:\n- \"http://www.google.com\"\n- \"https://www.google.com\"\n- \"http://localhost/\"\nNon-match examples:\n- \"www.google.com\"",
        "matches": [
            "http://www.google.com",
            "https://www.google.com",
            "http://localhost/"
        ],
        "non_matches": [
            "www.google.com"
        ],
        "stress_tests": []
    },
    {
        "id": 1950,
        "expression": "^[-|\\+]?[0-9]{1,3}(\\,[0-9]{3})*$|^[-|\\+]?[0-9]+$",
        "raw_prompt": "Integer with or without commas. Signed or unsigned.",
        "refined_prompt": "\nMatch examples:\n- \"1,234\"\n- \"1234\"\n- \"-1,234\"\nNon-match examples:\n- \"12,34\"\n- \"1.234\"",
        "matches": [
            "1,234",
            "1234",
            "-1,234",
            "-1234"
        ],
        "non_matches": [
            "12,34",
            "1.234",
            "abc"
        ],
        "stress_tests": []
    },
    {
        "id": 1952,
        "expression": "^([0-9]{1}[\\d]{0,2}(\\,[\\d]{3})*(\\,[\\d]{0,2})?|[0-9]{1}[\\d]{0,}(\\,[\\d]{0,2})?|0(\\,[\\d]{0,2})?|(\\,[\\d]{1,2})?)$",
        "raw_prompt": "Match any number , no characters, no empty sets, and accept zero.",
        "refined_prompt": "\nMatch examples:\n- \"0001\"\n- \"12345\"\n- \"\"\nNon-match examples:\n- \"abcd\"\n- \"012a\"",
        "matches": [
            "0001",
            "12345",
            ""
        ],
        "non_matches": [
            "abcd",
            "012a"
        ],
        "stress_tests": []
    },
    {
        "id": 1953,
        "expression": "^(GIR ?0AA|(?:[A-PR-UWYZ](?:\\d|\\d{2}|[A-HK-Y]\\d|[A-HK-Y]\\d\\d|\\d[A-HJKSTUW]|[A-HK-Y]\\d[ABEHMNPRV-Y])) ?\\d[ABD-HJLNP-UW-Z]{2})$",
        "raw_prompt": "This regex matches all valid, current UK Postcodes, including Girobank and non-geographic postcodes, irrespective of whether they contain a space. It does not include overseas territories.\nAdapted from the BS7666 postcode rules at: http://www.cabinetoffice.gov.uk/govtalk/schemasstandards/e-gif/datastandards/address/postcode.aspx",
        "refined_prompt": "\nMatch examples:\n- \"M1 1AA\"\n- \"M60 1NW\"\n- \"CR2 6XH\"\nNon-match examples:\n- \"Q1 1AA\"\n- \"M60 1CW\"",
        "matches": [
            "M1 1AA",
            "M60 1NW",
            "CR2 6XH",
            "DN55 1PT",
            "W1A 1HQ",
            "EC1A 1BB",
            "GIR 0AA"
        ],
        "non_matches": [
            "Q1 1AA",
            "M60 1CW",
            "5R2 6XH",
            "DJ55 1PT",
            "W1M 1HQ",
            "EC1D 1BB",
            "GIR 1AA"
        ],
        "stress_tests": []
    },
    {
        "id": 1954,
        "expression": "^(0\\.|([1-9]([0-9]+)?)\\.){3}(0|([1-9]([0-9]+)?)){1}$",
        "raw_prompt": "A simple regex to check a version information string of the style 1.0.0.0",
        "refined_prompt": "\nMatch examples:\n- \"1.2.3.4\"\nNon-match examples:\n- \"1.2.3\"\n- \"01.02.03.04\"",
        "matches": [
            "1.2.3.4"
        ],
        "non_matches": [
            "1.2.3",
            "01.02.03.04",
            "1.2.3.4Beta"
        ],
        "stress_tests": []
    },
    {
        "id": 1956,
        "expression": "^((\\$?\\-?)|(\\-?\\$?))([0-9]{1,3},([0-9]{3},)*[0-9]{3}|[0-9]+)?(\\.[0-9]*)?$",
        "raw_prompt": "Matches any number which includes the US currency symbol ($), a negative sign (-), comma separators, and a decimal. It matches an unlimited number of decimal places. It does NOT reject an empty string passed to it. Credit goes to Al Kahler for posting the original expression from http://regxlib.com/REDetails.aspx?regexp_id=70 along with a fix for the decimal place.",
        "refined_prompt": "\nMatch examples:\n- \"$.01\"\n- \"1,234.003\"\n- \"834223.1\"\nNon-match examples:\n- \".0,001\"\n- \"1,1.01\"",
        "matches": [
            "$.01",
            "1,234.003",
            "834223.1",
            "$0.01",
            "-$1.50",
            "$-50.123"
        ],
        "non_matches": [
            ".0,001",
            "1,1.01",
            "1E",
            "5$"
        ],
        "stress_tests": []
    },
    {
        "id": 1958,
        "expression": "^[A-Z]\\d{2}(\\.\\d){0,1}$",
        "raw_prompt": "This expression matches ICD-10 code",
        "refined_prompt": "\nMatch examples:\n- \"Z99.9\"\n- \"Z99\"\nNon-match examples:\n- \"Z999\"\n- \"Z99.\"",
        "matches": [
            "Z99.9",
            "Z99"
        ],
        "non_matches": [
            "Z999",
            "Z99.",
            "99"
        ],
        "stress_tests": []
    },
    {
        "id": 1960,
        "expression": "(((0*[1-9]|[12][0-9]|3[01])([-./])(0*[13578]|10|12)([-./])(\\d{4}))|((0*[1-9]|[12][0-9]|30)([-./])(0*[469]|11)([-./])(\\d{4}))|((0*[1-9]|1[0-9]|2[0-8])([-./])(02|2)([-./])(\\d{4}))|((29)(\\.|-|\\/)(02|2)([-./])([02468][048]00))|((29)([-./])(02|2)([-./])([13579][26]00))|((29)([-./])(02|2)([-./])([0-9][0-9][0][48]))|((29)([-./])(02|2)([-./])([0-9][0-9][2468][048]))|((29)([-./])(02|2)([-./])([0-9][0-9][13579][26])))",
        "raw_prompt": "Date in DD/MM/YYYY or D/M/YYYY format.",
        "refined_prompt": "\nMatch examples:\n- \"01/06/2008\"\n- \"1/1/2008\"\nNon-match examples:\n- \"32/13/2008\"\n- \"00/00/2005\"",
        "matches": [
            "01/06/2008",
            "1/1/2008"
        ],
        "non_matches": [
            "32/13/2008",
            "00/00/2005"
        ],
        "stress_tests": []
    },
    {
        "id": 1962,
        "expression": "(?!\\b(xx|yy)\\b)\\b[\\w]+\\b",
        "raw_prompt": "Matches any word except these from alternation (xx|yy|...). Works in JavaScript",
        "refined_prompt": "\nMatch examples:\n- \"x\"\n- \"xxx\"\n- \"xxyy\"\nNon-match examples:\n- \"xx\"\n- \"yy\"",
        "matches": [
            "x",
            "xxx",
            "xxyy",
            "yyx"
        ],
        "non_matches": [
            "xx",
            "yy"
        ],
        "stress_tests": []
    },
    {
        "id": 1964,
        "expression": "^100$|^100.00$|^\\d{0,2}(\\.\\d{1,2})? *%?$",
        "raw_prompt": "Allows percent values from 0 to 100 without the % sign. Can be used with up to 2 decimal places or without any. Also works in ASP.NET regular expression validator control.",
        "refined_prompt": "\nMatch examples:\n- \"0\"\n- \"0.00\"\n- \"50.25\"\nNon-match examples:\n- \"100.01\"\n- \"-1\"",
        "matches": [
            "0",
            "0.00",
            "50.25",
            "100",
            "100.00"
        ],
        "non_matches": [
            "100.01",
            "-1",
            "5.005"
        ],
        "stress_tests": []
    },
    {
        "id": 1970,
        "expression": "<\\/*?(?![^>]*?\\b(?:a|img)\\b)[^>]*?>",
        "raw_prompt": "This regex will match all HTML tags except 'a' tags or 'img' tags. You can edit the list of exclusions as you see fit. I use this regex to strip all HTML tags from source data except anchor tags and image tags.",
        "refined_prompt": "\nMatch examples:\n- \"<script> </html> <anytag>\"\nNon-match examples:\n- \"<a> <img /> </a>\"",
        "matches": [
            "<script> </html> <anytag>"
        ],
        "non_matches": [
            "<a> <img /> </a>"
        ],
        "stress_tests": []
    },
    {
        "id": 1971,
        "expression": "<(script|style)[^>]*?>(?:.|\\n)*?</\\s*\\1\\s*>",
        "raw_prompt": "This regular expression will match only <script> and <style> tags and all content between them. Use this with regex.replace to strip script blocks and style blocks from HTML source.",
        "refined_prompt": "\nMatch examples:\n- \"<script>test</script>, <style>test<style>\"\nNon-match examples:\n- \"-all other html code is ignored-\"",
        "matches": [
            "<script>test</script>, <style>test<style>"
        ],
        "non_matches": [
            "-all other html code is ignored-"
        ],
        "stress_tests": []
    },
    {
        "id": 1972,
        "expression": "^[1-9]{1}$|^[1-9]{1}[0-9]{1}$|^[1-3]{1}[0-6]{1}[0-5]{1}$|^365$",
        "raw_prompt": "This expression allows you to select 1-365 as a numeric value for the days of the year. Must be between 1 and 365 and must be numeric",
        "refined_prompt": "\nMatch examples:\n- \"25\"\n- \"363\"\n- \"110\"\nNon-match examples:\n- \"2.5\"\n- \"0\"",
        "matches": [
            "25",
            "363",
            "110"
        ],
        "non_matches": [
            "2.5",
            "0",
            "400"
        ],
        "stress_tests": []
    },
    {
        "id": 1973,
        "expression": "^.*[_A-Za-z0-9]+[\\t ]+[\\*&]?[\\t ]*[_A-Za-z0-9](::)?[_A-Za-z0-9:]+[\\t ]*\\(( *[ \\[\\]\\*&A-Za-z0-9_]+ *,? *)*\\).*$",
        "raw_prompt": "This (while not perfect) locates c++ function declarations. Useful for working with large source files",
        "refined_prompt": "\nMatch examples:\n- \"void helloworld()\"\n- \"FILE *MyClass::getFile()\"\n- \"int getFibbNum (int place)\"\nNon-match examples:\n- \"getFibbNum(3)\"\n- \"int MyNum;\"",
        "matches": [
            "void helloworld()",
            "FILE *MyClass::getFile()",
            "int getFibbNum (int place)"
        ],
        "non_matches": [
            "getFibbNum(3)",
            "int MyNum;",
            "for (int x=1 ... )"
        ],
        "stress_tests": []
    },
    {
        "id": 1974,
        "expression": "^(\\d{3}-\\d{2}-\\d{4})|(\\d{3}\\d{2}\\d{4})$",
        "raw_prompt": "This will accept SSN in the form of 123-45-6789 OR 123456789.",
        "refined_prompt": "\nMatch examples:\n- \"123-45-6789\"\n- \"123456789\"\n- \"456-63-6666\"\nNon-match examples:\n- \"123-45-459a\"\n- \"222-2-2222\"",
        "matches": [
            "123-45-6789",
            "123456789",
            "456-63-6666"
        ],
        "non_matches": [
            "123-45-459a",
            "222-2-2222",
            "222-222222"
        ],
        "stress_tests": []
    },
    {
        "id": 1977,
        "expression": "^(\\d?)*(\\.\\d{1}|\\.\\d{2})?$",
        "raw_prompt": "Expression to validate currency formatted numbers without the currency symbol",
        "refined_prompt": "\nMatch examples:\n- \"153\"\n- \"33.48\"\n- \"786.1\"\nNon-match examples:\n- \"-123\"\n- \"8524.258\"",
        "matches": [
            "153",
            "33.48",
            "786.1",
            "1567863483.33"
        ],
        "non_matches": [
            "-123",
            "8524.258",
            "eo45"
        ],
        "stress_tests": []
    },
    {
        "id": 1978,
        "expression": "(\\d{3}\\-\\d{2}\\-\\d{4})",
        "raw_prompt": "pattern match for U.S. social security number",
        "refined_prompt": "\nMatch examples:\n- \"111-22-3333\"\nNon-match examples:\n- \"11-222-3333\"\n- \"1111-22-333\"",
        "matches": [
            "111-22-3333"
        ],
        "non_matches": [
            "11-222-3333",
            "1111-22-333"
        ],
        "stress_tests": []
    },
    {
        "id": 1979,
        "expression": "^([a-zA-Z])[a-zA-Z_-]*[\\w_-]*[\\S]$|^([a-zA-Z])[0-9_-]*[\\S]$|^[a-zA-Z]*[\\S]$",
        "raw_prompt": "Will verify if the text is is in a valid user name format like: is alphanumeric, starts with an alphabet and contains no special characters other than underscore or dash.",
        "refined_prompt": "\nMatch examples:\n- \"username\"\n- \"user123\"\n- \"user_123\"\nNon-match examples:\n- \"123username\"\n- \"user name\"",
        "matches": [
            "username",
            "user123",
            "user_123",
            "user-123",
            "username123_type"
        ],
        "non_matches": [
            "123username",
            "user name",
            "_username"
        ],
        "stress_tests": []
    },
    {
        "id": 1984,
        "expression": "(\")([0-9]*)(\",\")([0-9]*)(\"\\))",
        "raw_prompt": "This was made to change non-decimal prices at the end of a huge SQL Insert... To use to replace in DW (without quotes) use sub expression like: $2,$4)",
        "refined_prompt": "\nMatch examples:\n- \"\"0\",\"0\") \"999\",\"999999\")\"\nNon-match examples:\n- \"0,0)\"",
        "matches": [
            "\"0\",\"0\") \"999\",\"999999\")"
        ],
        "non_matches": [
            "0,0)"
        ],
        "stress_tests": []
    },
    {
        "id": 1986,
        "expression": "^([a-zA-Z]{5})([a-zA-Z0-9-]{3,12})",
        "raw_prompt": "Validate: First five characters are letters; characters six-17 are letters, numbers, or hyphen; string length is eight characters minimum, 17 characters maximum",
        "refined_prompt": "\nMatch examples:\n- \"ABCDE123abc-123AB\"\nNon-match examples:\n- \"1BCDE123abc-123AB -BCDE123abc-123AB ABCDE6789012345678\"",
        "matches": [
            "ABCDE123abc-123AB"
        ],
        "non_matches": [
            "1BCDE123abc-123AB -BCDE123abc-123AB ABCDE6789012345678"
        ],
        "stress_tests": []
    },
    {
        "id": 1991,
        "expression": "^((\\(\\d{3}\\) ?)|(\\d{3}-)|(\\(\\d{2}\\) ?)|(\\d{2}-)|(\\(\\d{1}\\) ?)|(\\d{1}-))?\\d{3}-(\\d{3}|\\d{4})",
        "raw_prompt": "Esta es la expresion regular adaptada por mi para validar telefonos fijos chilenos de cualquier compa\u00f1ia, espero sirva a alguien",
        "refined_prompt": "\nMatch examples:\n- \"(041)245-9848\"\n- \"(063)421-232\"\nNon-match examples:\n- \"0412459848\"\n- \"063421232\"",
        "matches": [
            "(041)245-9848",
            "(063)421-232"
        ],
        "non_matches": [
            "0412459848",
            "063421232"
        ],
        "stress_tests": []
    },
    {
        "id": 2008,
        "expression": "^([^S]|S[^E]|SE[^P]).*",
        "raw_prompt": "Matches everything except lines that begin with SEP.\nNow I just need to figure out how to exclude a string that appears in the middle of a line.",
        "refined_prompt": "\nMatch examples:\n- \"SEk001\"\n- \"TAK002\"\nNon-match examples:\n- \"SEP001\"\n- \"SEP002\"",
        "matches": [
            "SEk001",
            "TAK002"
        ],
        "non_matches": [
            "SEP001",
            "SEP002"
        ],
        "stress_tests": []
    },
    {
        "id": 2010,
        "expression": "^(([a-zA-Z]:)|(\\\\{2}\\w+)\\$?)(\\\\(\\w[\\w].*))+(.pdf)$",
        "raw_prompt": "You can use this to check the valid file type you have given to the last in the expression\nlike\n^(([a-zA-Z]:)|(\\\\{2}\\w+)\\$?)(\\\\(\\w[\\w].*))+(.pdf)$\nThis will accept .pdf only\nOR\n^(([a-zA-Z]:)|(\\\\{2}\\w+)\\$?)(\\\\(\\w[\\w].*))+((.pdf)|(.doc))$\nThis will accept .pdf and .doc\nOR\n^(([a-zA-Z]:)|(\\\\{2}\\w+)\\$?)(\\\\(\\w[\\w].*))+((.pdf)|(.doc)|(.txt))$\nThis will accept .pdf , .doc and .txt",
        "refined_prompt": "\nMatch examples:\n- \"C:\\Documents and Settings\\chandan.kumar\\Desktop\\1004.pdf\"\nNon-match examples:\n- \"C:\\Documents and Settings\\All Users\\Documents\\My Pictures\\Sample Pictures\\Sunset.jpg\"",
        "matches": [
            "C:\\Documents and Settings\\chandan.kumar\\Desktop\\1004.pdf"
        ],
        "non_matches": [
            "C:\\Documents and Settings\\All Users\\Documents\\My Pictures\\Sample Pictures\\Sunset.jpg"
        ],
        "stress_tests": []
    },
    {
        "id": 2011,
        "expression": "^([0-1]?[0-9]{1}|2[0-3]{1}):([0-5]{1}[0-9]{1})$",
        "raw_prompt": "This expression will validate if a string represents a time in 24 hour format.\nThe expression will evaluate the string from start to finish. It will not accept 24:00, use 00:00 instead.",
        "refined_prompt": "\nMatch examples:\n- \"1:59\"\n- \"01:59\"\n- \"23:59\"\nNon-match examples:\n- \"24:00\"\n- \"01:60\"",
        "matches": [
            "1:59",
            "01:59",
            "23:59"
        ],
        "non_matches": [
            "24:00",
            "01:60",
            "01:234"
        ],
        "stress_tests": []
    },
    {
        "id": 2013,
        "expression": "([.])([a-z,1-9]{3,4})(\\/)",
        "raw_prompt": "Returns the TLD from a URL.",
        "refined_prompt": "\nMatch examples:\n- \".com/\"\n- \".net/\"\n- \".biz/\"\nNon-match examples:\n- \".co.uk/\"\n- \".org.uk/\"",
        "matches": [
            ".com/",
            ".net/",
            ".biz/",
            ".123/",
            ".mobi/"
        ],
        "non_matches": [
            ".co.uk/",
            ".org.uk/"
        ],
        "stress_tests": []
    },
    {
        "id": 2014,
        "expression": "^\\$?\\d{1,2}\\,\\d{3}?\\,\\d{3}?(\\.(\\d{2}))$|^\\$?\\d{1,3}?\\,\\d{3}?(\\.(\\d{2}))$|^\\$?\\d{1,3}?(\\.(\\d{2}))$",
        "raw_prompt": "Needed to verify a currency amount entered has commas and two decimal spaces to the right. This has a range between 1.99 to the tens of millions. If you want to make the decimal side optional, add a question mark before the final $ in each expression.",
        "refined_prompt": "\nMatch examples:\n- \"1.99\"\n- \"111,111.99\"\n- \"11,111,111.99\"\nNon-match examples:\n- \"1.999\"\n- \"1111\"",
        "matches": [
            "1.99",
            "111,111.99",
            "11,111,111.99"
        ],
        "non_matches": [
            "1.999",
            "1111",
            "1111111",
            "11.9"
        ],
        "stress_tests": []
    },
    {
        "id": 2023,
        "expression": "(1)?-?\\(?\\s*([0-9]{3})\\s*\\)?\\s*-?([0-9]{3})\\s*-?\\s*([0-9]{4})\\s*",
        "raw_prompt": "A very simple regex to parse 10-digit US phone numbers. Captures the leading 1 in $1, the area code in $2, the 3-digit prefix in $3, and the four-digit postfix in $4.\nThis expression DOES allow for reserved area codes (001,etc) which are not typically in use.",
        "refined_prompt": "\nMatch examples:\n- \"(123)456-7890\"\n- \"1234567890\"\n- \"123 456 7890\"\nNon-match examples:\n- \"123456789\"\n- \"(1234)567890\"",
        "matches": [
            "(123)456-7890",
            "1234567890",
            "123 456 7890",
            "123-456-7890",
            "(123)4567890",
            "123-4567890"
        ],
        "non_matches": [
            "123456789",
            "(1234)567890",
            "(12-3)4567890"
        ],
        "stress_tests": []
    },
    {
        "id": 2025,
        "expression": "^(\\+48\\s+)?\\d{3}(\\s*|\\-)\\d{3}(\\s*|\\-)\\d{3}$",
        "raw_prompt": "Supported: +48 prefix (optional); separating elements with hyphen or spaces",
        "refined_prompt": "\nMatch examples:\n- \"+48 500-080-100\"\n- \"500080100\"\n- \"500 080 100\"\nNon-match examples:\n- \"+47 100-100-100\"\n- \"1000-100-100\"",
        "matches": [
            "+48 500-080-100",
            "500080100",
            "500 080 100"
        ],
        "non_matches": [
            "+47 100-100-100",
            "1000-100-100",
            "1000000000"
        ],
        "stress_tests": []
    },
    {
        "id": 2028,
        "expression": "^(.|\\r|\\n){1,10}$",
        "raw_prompt": "This expression can be use to define the maximum length to a textBox.\nU can change the maximum character by replacing the last numeric value that is 10 in my example.\nJust change this number to your desired number like\n^(.|\\r|\\n){1,10}$ : for max 10 character\n^(.|\\r|\\n){1,20}$ : for max 20 character",
        "refined_prompt": "\nMatch examples:\n- \"ChandanKum\"\nNon-match examples:\n- \"ChandanKuma\"",
        "matches": [
            "ChandanKum"
        ],
        "non_matches": [
            "ChandanKuma"
        ],
        "stress_tests": []
    },
    {
        "id": 2031,
        "expression": "\\b[1-9]\\d{3}\\ +[A-Z]{2}\\b",
        "raw_prompt": "Dutch postal codes are ranged from \"1000 AA\" to \"9999 ZZ\".",
        "refined_prompt": "\nMatch examples:\n- \"\"1484 EE\"\"\nNon-match examples:\n- \"\"1484EE\"\"\n- \"\"0111 AB\"\"",
        "matches": [
            "\"1484 EE\""
        ],
        "non_matches": [
            "\"1484EE\"",
            "\"0111 AB\"",
            "\"1484 ee\"",
            "\"1234 ABC\""
        ],
        "stress_tests": []
    },
    {
        "id": 2035,
        "expression": "^[a-zA-Z0-9._\\-]+@[a-z0-9\\-]+(\\.[a-z]+){1,}$",
        "raw_prompt": "Matches simple e-mail addresses such as me@domain.com, me@domain.co.uk, but does not place any restrictions on TLDs other than they must be lower case and alphabetic. a-z, A-Z, 0-9, ., _, and - are all allowed on the left side of @.",
        "refined_prompt": "\nMatch examples:\n- \"me@test.com\"\n- \"me@test.co.uk\"\n- \"me@test.asdf\"\nNon-match examples:\n- \"@test.com\"\n- \"@.com\"",
        "matches": [
            "me@test.com",
            "me@test.co.uk",
            "me@test.asdf"
        ],
        "non_matches": [
            "@test.com",
            "@.com",
            "@."
        ],
        "stress_tests": []
    },
    {
        "id": 2037,
        "expression": "^[a-zA-Z0-9]+[\\s]*[a-zA-Z0-9.\\-\\,\\#]+[\\s]*[a-zA-Z0-9.\\-\\,\\#]+[a-zA-Z0-9\\s.\\-\\,\\#]*$",
        "raw_prompt": "US Addresses validation having atleast 3 characters ignoring any spaces. Can have hash \"#\" comma \",\" dash \"-\" dot \".\" but cannot start with these.",
        "refined_prompt": "\nMatch examples:\n- \"123 E DRACHMAN TUCSON AZ 12345\"\n- \"St # 123, North AVE New York. NY 12345\"\nNon-match examples:\n- \"-1 AVE,1, Aa\"\n- \"#1 Street ,. 20 North,,1 AVE\"",
        "matches": [
            "123 E DRACHMAN TUCSON AZ 12345",
            "St # 123, North AVE New York. NY 12345"
        ],
        "non_matches": [
            "-1 AVE,1, Aa",
            "#1 Street ,. 20 North,,1 AVE"
        ],
        "stress_tests": []
    },
    {
        "id": 2040,
        "expression": "<[^>]*>",
        "raw_prompt": "This Regex Will Remove All Html Tags And Return Simple Plain Text .\nFor Example In C#.NET :\nRegex.Replace(Html, \"<[^>]*>\", string.Empty);",
        "refined_prompt": "\nMatch examples:\n- \"<p> Hello Ali Delshad </p>\"\nNon-match examples:\n- \"Hello Ali Delshad\"",
        "matches": [
            "<p> Hello Ali Delshad </p>"
        ],
        "non_matches": [
            "Hello Ali Delshad"
        ],
        "stress_tests": []
    },
    {
        "id": 2041,
        "expression": "[\\u0600-\\u06FF]",
        "raw_prompt": "This Regex chceck an input string for persian unicode character\nNote that it not work in javascript\nFor Example In C#.NET:\nRegex.IsMatch(Text, \"[\\u0600-\\u06FF]\");",
        "refined_prompt": "\nMatch examples:\n- \"\u0633\u0644\u0627\u0645\"\n- \"hello \u0639\u0644\u06cc\"\n- \"Hi 2 \u0633\u0644\u0627\u0645\"\nNon-match examples:\n- \"Hello\"\n- \"Ali\"",
        "matches": [
            "\u0633\u0644\u0627\u0645",
            "hello \u0639\u0644\u06cc",
            "Hi 2 \u0633\u0644\u0627\u0645"
        ],
        "non_matches": [
            "Hello",
            "Ali",
            "123"
        ],
        "stress_tests": []
    },
    {
        "id": 2049,
        "expression": "^(?=.*\\d)(?=.*[a-z])([a-z0-9]{8,25})$",
        "raw_prompt": "Password matching expression. Password must be at least 8 characters,no more then 25 characters, must include at least 1 lower case letter and 1 numeric digit. Upper case, space and punctuation marks are not allowed.",
        "refined_prompt": "\nMatch examples:\n- \"aaaaaaa1\"\n- \"abcdefghijklmnoprqstu1234\"\n- \"1234567a\"\nNon-match examples:\n- \"aaaaaaA1\"\n- \"0123456789kB\"",
        "matches": [
            "aaaaaaa1",
            "abcdefghijklmnoprqstu1234",
            "1234567a"
        ],
        "non_matches": [
            "aaaaaaA1",
            "0123456789kB",
            "1234567890abcde123456 A%."
        ],
        "stress_tests": []
    },
    {
        "id": 2050,
        "expression": "^\\s*[a-zA-Z\\s]+\\,[0-9\\s]+\\s*$",
        "raw_prompt": "its validating the string as shown in example(matches).",
        "refined_prompt": "\nMatch examples:\n- \"navjot, 24\"\n- \"Sweet, 23\"\nNon-match examples:\n- \"456, abcd\"\n- \"abcd 123\"",
        "matches": [
            "navjot, 24",
            "Sweet, 23"
        ],
        "non_matches": [
            "456, abcd",
            "abcd 123"
        ],
        "stress_tests": []
    },
    {
        "id": 2051,
        "expression": "^(((\\d|([a-f]|[A-F])){2}:){5}(\\d|([a-f]|[A-F])){2})$|^(((\\d|([a-f]|[A-F])){2}-){5}(\\d|([a-f]|[A-F])){2})$|^$",
        "raw_prompt": "Designed to verify a MAC address with no spaces allowed, hex values separated by linux style separator \":\" or by windows style separator \"-\". Also empty string entry is allowed.",
        "refined_prompt": "\nMatch examples:\n- \"A0:B1:C2:D3:E4:F5\"\n- \"A0-B1-C2-D3-E4-F5\"\n- \"\"\nNon-match examples:\n- \"A0-B1-C2-D3-E4:F5\"\n- \"A0 - B1 - C2 - D3 - E4 - F5\"",
        "matches": [
            "A0:B1:C2:D3:E4:F5",
            "A0-B1-C2-D3-E4-F5",
            ""
        ],
        "non_matches": [
            "A0-B1-C2-D3-E4:F5",
            "A0 - B1 - C2 - D3 - E4 - F5",
            "A0:B1:C2:D3:E4:G5"
        ],
        "stress_tests": []
    },
    {
        "id": 2057,
        "expression": "^([0-9a-zA-Z]+(?:[_\\.\\-]?[0-9a-zA-Z]+)*[@](?:[0-9a-zA-Z]+(?:[_\\.\\-]?[0-9a-zA-Z]+)*\\.[a-zA-Z]{2,}|(?:\\d{1,}\\.){3}\\d{1,}))$",
        "raw_prompt": "|| Only alphanum characters accepted at the beginning of the user name and domain name\n|| Does not allow 2+ adjacent non-alphanum characters\n|| IP address accepted as domain\n|| 1+ chars accepted as user name or domain",
        "refined_prompt": "\nMatch examples:\n- \"a@a.aa\"\n- \"a_bc@11.0.0.5\"\n- \"abc@a_bc.a_bc.aa\"\nNon-match examples:\n- \"a__bc@abc.aa\"\n- \"abc@a__bc.aa\"",
        "matches": [
            "a@a.aa",
            "a_bc@11.0.0.5",
            "abc@a_bc.a_bc.aa",
            "1abc@1abc.aa"
        ],
        "non_matches": [
            "a__bc@abc.aa",
            "abc@a__bc.aa",
            "abc_@abc.aa",
            "abc@abc_.aa"
        ],
        "stress_tests": []
    },
    {
        "id": 2065,
        "expression": "^((((((0[1-9])|(1\\d)|(2[0-8]))\\.((0[123456789])|(1[0-2])))|(((29)|(30))\\.((0[13456789])|(1[0-2])))|((31)\\.((0[13578])|(1[02]))))\\.\\d{4})|((29)\\.(02)\\.\\d{2}(([02468][048])|([13579][26]))))(\\s((0\\d)|(1\\d)|(2[0-3]))\\:([0-5]\\d)\\:([0-5]\\d)\\.\\d{7})$",
        "raw_prompt": "Oracle like time stamp with format:\ndd.MM.yyyy HH.mm.SS.xxxxxxx\nBased on European full proved date format with easy changeable dot separator.\nOptimized regular expresion.",
        "refined_prompt": "\nMatch examples:\n- \"29.02.2008 23:50:45.1234567\"\n- \"31.03.2007 00:01:01.0000001\"\n- \"30.04.1999 01:02:03.0000000\"\nNon-match examples:\n- \"29.02.2009 23:50:45.1234567\"\n- \"31.04.2007 00:01:01.0000001\"",
        "matches": [
            "29.02.2008 23:50:45.1234567",
            "31.03.2007 00:01:01.0000001",
            "30.04.1999 01:02:03.0000000"
        ],
        "non_matches": [
            "29.02.2009 23:50:45.1234567",
            "31.04.2007 00:01:01.0000001",
            "30.04.1999 01:02:03.0000"
        ],
        "stress_tests": []
    },
    {
        "id": 2069,
        "expression": "^((([sS]|[nN])[a-hA-Hj-zJ-Z])|(([tT]|[oO])[abfglmqrvwABFGLMQRVW])|([hH][l-zL-Z])|([jJ][lmqrvwLMQRVW]))([0-9]{2})?([0-9]{2})?([0-9]{2})?([0-9]{2})?([0-9]{2})?$",
        "raw_prompt": "Matches standard 0- to 10-figure (non-tetrad) Ordnance Survey of Great Britain (OSGB) Grid References",
        "refined_prompt": "\nMatch examples:\n- \"SH\"\n- \"OF1234567890\"\n- \"NP1234\"\nNon-match examples:\n- \"SH123\"\n- \"SH12D\"",
        "matches": [
            "SH",
            "OF1234567890",
            "NP1234"
        ],
        "non_matches": [
            "SH123",
            "SH12D",
            "NI1234",
            "1234"
        ],
        "stress_tests": []
    },
    {
        "id": 2072,
        "expression": "^(\\d|\\d{1,9}|1\\d{1,9}|20\\d{8}|213\\d{7}|2146\\d{6}|21473\\d{5}|214747\\d{4}|2147482\\d{3}|21474835\\d{2}|214748364[0-7])$",
        "raw_prompt": "Matches any integer from 0 to 2147483647 (max Integer size for C#, Java, others)",
        "refined_prompt": "\nMatch examples:\n- \"0\"\n- \"352533\"\n- \"2147483647\"\nNon-match examples:\n- \"-1\"\n- \"2.4\"",
        "matches": [
            "0",
            "352533",
            "2147483647"
        ],
        "non_matches": [
            "-1",
            "2.4",
            "2147483648"
        ],
        "stress_tests": []
    },
    {
        "id": 2080,
        "expression": "^(\\+?)(\\d{2,4})(\\s?)(\\-?)((\\(0\\))?)(\\s?)(\\d{2})(\\s?)(\\-?)(\\d{3})(\\s?)(\\-?)(\\d{2})(\\s?)(\\-?)(\\d{2})",
        "raw_prompt": "This regex will match various ways of entering a Swiss phone number along with the country code.",
        "refined_prompt": "\nMatch examples:\n- \"+41 44 123 12 34\"\n- \"+41 (0) 44 123 12 34\"\n- \"+41-44-123-1234\"\nNon-match examples:\n- \"+41 0 44 123 1234\"\n- \"+41.44.123.1234\"",
        "matches": [
            "+41 44 123 12 34",
            "+41 (0) 44 123 12 34",
            "+41-44-123-1234",
            "0041 44 123 12 34"
        ],
        "non_matches": [
            "+41 0 44 123 1234",
            "+41.44.123.1234"
        ],
        "stress_tests": []
    },
    {
        "id": 2083,
        "expression": "(((0[123456789]|10|11|12)(([1][9][0-9][0-9])|([2][0-9][0-9][0-9]))))",
        "raw_prompt": "Validates dates that are in month/year (MMYYYY) format without slashes, periods, dashes, or spaces. No special characters or letters allowed. MM values allowed are 01 thru 12. YYYY values allowed are 1900 - 2999.\nThis is an adaptation of Felipe Albacete's MM/YYYY regular expression.",
        "refined_prompt": "\nMatch examples:\n- \"052000\"\n- \"122008\"\n- \"101972\"\nNon-match examples:\n- \"12/2003\"\n- \"131997\"",
        "matches": [
            "052000",
            "122008",
            "101972",
            "041903"
        ],
        "non_matches": [
            "12/2003",
            "131997",
            "51988",
            "111899",
            "04.2004",
            "10-1965"
        ],
        "stress_tests": []
    },
    {
        "id": 2086,
        "expression": "^\\#?[A-Fa-f0-9]{3}([A-Fa-f0-9]{3})?$",
        "raw_prompt": "Matches valid 3 or 6 character hex codes used for HTML or CSS.",
        "refined_prompt": "\nMatch examples:\n- \"fff\"\n- \"#990000\"\n- \"#cc3366\"\nNon-match examples:\n- \"#5555\"\n- \"#ZJK000\"",
        "matches": [
            "fff",
            "#990000",
            "#cc3366",
            "#AAAAAA"
        ],
        "non_matches": [
            "#5555",
            "#ZJK000",
            "CDCDCDCD"
        ],
        "stress_tests": []
    },
    {
        "id": 2087,
        "expression": "^(?=.{6,})(?=.*[0-9].*)(?=.*[a-z].*).*$",
        "raw_prompt": "Password of 6 symbols. Must containt at leats one non-captial letter and at least digit digit",
        "refined_prompt": "\nMatch examples:\n- \"abc123\"\n- \"()()a1\"\n- \"_ABCDa1\"\nNon-match examples:\n- \"abcdef\"\n- \"ab_12\"",
        "matches": [
            "abc123",
            "()()a1",
            "_ABCDa1"
        ],
        "non_matches": [
            "abcdef",
            "ab_12",
            "ABC123"
        ],
        "stress_tests": []
    },
    {
        "id": 2089,
        "expression": "('(?:(?:\\\\'|[^'])*)'|NULL)",
        "raw_prompt": "This is useful to find single quoted strings in mysql dumps.\nIt accepts \\' inside the strings.",
        "refined_prompt": "\nMatch examples:\n- \"'A car'\"\n- \"'Mary\\'s car'\"\n- \"NULL\"\nNon-match examples:\n- \"'asdasdasd\"\n- \"adsfadsf\"",
        "matches": [
            "'A car'",
            "'Mary\\'s car'",
            "NULL"
        ],
        "non_matches": [
            "'asdasdasd",
            "adsfadsf",
            "23123"
        ],
        "stress_tests": []
    },
    {
        "id": 2090,
        "expression": "((\\d{0}[0-9]|\\d{0}[1]\\d{0}[0-2])(\\:)\\d{0}[0-5]\\d{0}[0-9](\\:)\\d{0}[0-5]\\d{0}[0-9]\\s(AM|PM))",
        "raw_prompt": "Matches hours 0-12:minutes 0-59:seconds 0-59 AM|PM",
        "refined_prompt": "\nMatch examples:\n- \"0:00:00 AM, 11:59:59 PM,12:00:00 AM, 5:34:00 PM\"\nNon-match examples:\n- \"1:00 AM, 5:3:00 PM, 5:34:00 P,5:34:00 Pm\"",
        "matches": [
            "0:00:00 AM, 11:59:59 PM,12:00:00 AM, 5:34:00 PM"
        ],
        "non_matches": [
            "1:00 AM, 5:3:00 PM, 5:34:00 P,5:34:00 Pm"
        ],
        "stress_tests": []
    },
    {
        "id": 2091,
        "expression": "^([0]\\d|[1][0-2]\\/([0-2]\\d|[3][0-1])\\/([2][0]\\d{2})\\s([0-1]\\d|[2][0-3])\\:[0-5]\\d\\:[0-5]\\d)?\\s(AM|am|aM|Am|PM|pm|pM|Pm)",
        "raw_prompt": "Date Time with am/pm.",
        "refined_prompt": "\nMatch examples:\n- \"10/13/2008 12:00:00 AM\"\n- \"10/13/2008 12:00:00 PM\"\nNon-match examples:\n- \"10/13/2008 12:00:00\"",
        "matches": [
            "10/13/2008 12:00:00 AM",
            "10/13/2008 12:00:00 PM"
        ],
        "non_matches": [
            "10/13/2008 12:00:00"
        ],
        "stress_tests": []
    },
    {
        "id": 2094,
        "expression": "(?s)(?i)^(?!^.*(dont match me).*$).*$",
        "raw_prompt": "will match anything EXCEPT what you replace \"dont match me\" with.\nyou can replace the last .* with whatever criteria must be matched. example matches anything.",
        "refined_prompt": "\nMatch examples:\n- \"almost anything at all\"\nNon-match examples:\n- \"please dont match me; dont match me at all\"",
        "matches": [
            "almost anything at all"
        ],
        "non_matches": [
            "please dont match me; dont match me at all"
        ],
        "stress_tests": []
    },
    {
        "id": 2095,
        "expression": "^(([1-9]{1}[0-9]{0,5}([.]{1}[0-9]{0,2})?)|(([0]{1}))([.]{1}[0-9]{0,2})?)$",
        "raw_prompt": "This will allow your app to check currency during events such as key down\n(set to decimal(8,2) only)",
        "refined_prompt": "\nMatch examples:\n- \"13\"\n- \"13.\"\n- \"13.1\"\nNon-match examples:\n- \"01\"\n- \".1\"",
        "matches": [
            "13",
            "13.",
            "13.1",
            "13.11",
            "0.",
            "0.1"
        ],
        "non_matches": [
            "01",
            ".1",
            "0.011"
        ],
        "stress_tests": []
    },
    {
        "id": 2101,
        "expression": "(?:^(?:-)?(?:\\d{1,3}\\.(?:\\d{3}\\.)*\\d{3})(?:\\,\\d+)?$|^(?:-)?\\d*(?:\\,\\d+)?$)",
        "raw_prompt": "This validation forces a value wheter to be strict niced or plain input of a numerical value.\nThe separation per thousand should be a (.) dot and must be used exactly or never to be valid.\nCurrently this RX validates german formed values... Just switch \\, with \\. and vice versa to get valid US results.",
        "refined_prompt": "\nMatch examples:\n- \"10000\"\n- \"12.123\"\n- \"5.123,000\"\nNon-match examples:\n- \"1.0000\"\n- \"12.12.00\"",
        "matches": [
            "10000",
            "12.123",
            "5.123,000",
            ",001",
            "1.000.000",
            "1,00"
        ],
        "non_matches": [
            "1.0000",
            "12.12.00",
            "5,123.000",
            ".001",
            "1,000,000",
            "1.00"
        ],
        "stress_tests": []
    },
    {
        "id": 2103,
        "expression": "^[0-3]{1}[0-9]{1}[ ]{1}(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec){1}[ ]{1}[0-9]{2}$",
        "raw_prompt": "This will test to see if a date is formatted in the military style of 'dd MMM yy'",
        "refined_prompt": "\nMatch examples:\n- \"12 DEC 08\"\n- \"03 jan 91\"\n- \"30 Mar 82\"\nNon-match examples:\n- \"41 DEC 08\"\n- \"03 jan 1991\"",
        "matches": [
            "12 DEC 08",
            "03 jan 91",
            "30 Mar 82"
        ],
        "non_matches": [
            "41 DEC 08",
            "03 jan 1991",
            "30 Mar '82"
        ],
        "stress_tests": []
    },
    {
        "id": 2113,
        "expression": "^([a-zA-Z1-9]*)\\.(((a|A)(s|S)(p|P)(x|X))|((h|H)(T|t)(m|M)(l|L))|((h|H)(t|T)(M|m))|((a|A)(s|S)(p|P)))",
        "raw_prompt": "Validate HTM/HTML/ASP/ASPX\ne.g. PageName.html",
        "refined_prompt": "\nMatch examples:\n- \"pagename.html\"\n- \"pagename.aspx\"\n- \"pagename.asp\"\nNon-match examples:\n- \"pagename.txt,\"",
        "matches": [
            "pagename.html",
            "pagename.aspx",
            "pagename.asp",
            "pagename.htm"
        ],
        "non_matches": [
            "pagename.txt,"
        ],
        "stress_tests": []
    },
    {
        "id": 2114,
        "expression": "(((ht|f)tp(s?):\\/\\/)(www\\.[^ \\[\\]\\(\\)\\n\\r\\t]+)|(([012]?[0-9]{1,2}\\.){3}[012]?[0-9]{1,2})\\/)([^ \\[\\]\\(\\),;&quot;\\'&lt;&gt;\\n\\r\\t]+)([^\\. \\[\\]\\(\\),;&quot;\\'&lt;&gt;\\n\\r\\t])|(([012]?[0-9]{1,2}\\.){3}[012]?[0-9]{1,2})",
        "raw_prompt": "Validate URL\ne.g.\nhttp://www.sample.com,\nhttp://61.61.67.123/test.html",
        "refined_prompt": "\nMatch examples:\n- \"http://www.sample.com\"\n- \"http://61.61.67.123/test.html\"\nNon-match examples:\n- \"yahoo.com\"\n- \"www.yahoo.com\"",
        "matches": [
            "http://www.sample.com",
            "http://61.61.67.123/test.html"
        ],
        "non_matches": [
            "yahoo.com",
            "www.yahoo.com",
            "http://yahoo.com"
        ],
        "stress_tests": []
    },
    {
        "id": 2115,
        "expression": "([a-zA-Z1-9]*)\\.(((a|A)(s|S)(p|P)(x|X))|((h|H)(T|t)(m|M)(l|L))|((h|H)(t|T)(M|m))|((a|A)(s|S)(p|P))|((t|T)(x|X)(T|x))|((m|M)(S|s)(P|p)(x|X))|((g|G)(i|I)(F|f))|((d|D)(o|O)(c|C)))",
        "raw_prompt": "Validate Filename,PageName,ImageName etc\nsuch as\nfilename.doc\nfilename.xls\npagename.aspx\npagename.asp\npagename.htm\npagename.html\nExtensions\netc ...",
        "refined_prompt": "\nMatch examples:\n- \"filename.doc,pagename.aspx etc\"\nNon-match examples:\n- \"page.jpg\"",
        "matches": [
            "filename.doc,pagename.aspx etc"
        ],
        "non_matches": [
            "page.jpg"
        ],
        "stress_tests": []
    },
    {
        "id": 2116,
        "expression": "^[-+]?(?:\\d+\\.?|\\.\\d)\\d*(?:[Ee][-+]?\\d+)?$",
        "raw_prompt": "Validates that a string represents a javascript number (as defined by ECMAScript 3 Specs): integer (base-10) or floating\npoint including in the exponential notation. Doesn't match the empty string.",
        "refined_prompt": "\nMatch examples:\n- \"23\"\n- \"-17.e23\"\n- \"+.199E-19\"\nNon-match examples:\n- \"+.e2\"\n- \"23.17.5\"",
        "matches": [
            "23",
            "-17.e23",
            "+.199E-19",
            "10.",
            "10e10"
        ],
        "non_matches": [
            "+.e2",
            "23.17.5",
            "10e2.0",
            "22e"
        ],
        "stress_tests": []
    },
    {
        "id": 2117,
        "expression": "(((s*)(ftp)(s*)|(http)(s*)|mailto|news|file|webcal):(\\S*))|((www.)(\\S*))",
        "raw_prompt": "Matches all kind of URIs: mailto's, http(s), (s)ftp(s), ..., or just www addresses without protocol prefix.",
        "refined_prompt": "\nMatch examples:\n- \"ftp://domain.com\"\n- \"sftp://subdomain.domain.com\"\n- \"mailto:yourname@rommel.com\"\nNon-match examples:\n- \"gopher://anything.com\"\n- \"subdomain.domain.com\"",
        "matches": [
            "ftp://domain.com",
            "sftp://subdomain.domain.com",
            "mailto:yourname@rommel.com",
            "www.domain.be"
        ],
        "non_matches": [
            "gopher://anything.com",
            "subdomain.domain.com",
            "http//somethingforgotten.com"
        ],
        "stress_tests": []
    },
    {
        "id": 2118,
        "expression": "\\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])(?:.\\d{7})?[+|-](0[0-9]|1[0-2]):(00|15|30|45)",
        "raw_prompt": "Complete date-time format according to the ISO 8601 standard.",
        "refined_prompt": "\nMatch examples:\n- \"2004-10-31T22:06:00+12:00\"\n- \"2006-04-31T12:31:39.6230000+05:45\"\n- \"2009-01-08T20:25:26-03:00\"\nNon-match examples:\n- \"2009-01-09T12:23:34\"\n- \"2009-01-09 17:45:22\"",
        "matches": [
            "2004-10-31T22:06:00+12:00",
            "2006-04-31T12:31:39.6230000+05:45",
            "2009-01-08T20:25:26-03:00"
        ],
        "non_matches": [
            "2009-01-09T12:23:34",
            "2009-01-09 17:45:22",
            "2009-05-32T12:67:23-15:00",
            "2009-13-32T25:76:23"
        ],
        "stress_tests": []
    },
    {
        "id": 2123,
        "expression": "^([0-9a-f]{4}\\.[0-9a-f]{4}\\.[0-9a-f]{4})$",
        "raw_prompt": "Matches against dumps of Cisco MAC address tables on newer versions of Cisco IOS.",
        "refined_prompt": "\nMatch examples:\n- \"001e.1324.683f\"\n- \"1234.abcd.1234\"\n- \"ffff.ffff.ffff\"\nNon-match examples:\n- \"001E.1324.683f\"\n- \"001234.abcd.abcd\"",
        "matches": [
            "001e.1324.683f",
            "1234.abcd.1234",
            "ffff.ffff.ffff"
        ],
        "non_matches": [
            "001E.1324.683f",
            "001234.abcd.abcd",
            "abcd.1234.abcd.1234",
            "aa-bb-cc-dd-ee-ff",
            "11:22:33:44:55:66"
        ],
        "stress_tests": []
    },
    {
        "id": 2128,
        "expression": "^([a-zA-Z0-9]+[._-])*[a-zA-Z0-9]+@(([a-zA-Z0-9]+|([a-zA-Z0-9]+[.-])+)[a-zA-Z0-9]+\\.[a-zA-Z]{2,4}|([a-zA-Z]\\.com))$",
        "raw_prompt": "Validates format of email addresses including q.com but not q.net",
        "refined_prompt": "\nMatch examples:\n- \"a.b-c_d@x.y-z.zz\"\nNon-match examples:\n- \"xx@mm.c\"\n- \"x@n.cc\"",
        "matches": [
            "a.b-c_d@x.y-z.zz"
        ],
        "non_matches": [
            "xx@mm.c",
            "x@n.cc",
            "a..b@x-y.zz"
        ],
        "stress_tests": []
    },
    {
        "id": 2130,
        "expression": "^[^\\*]{0,}[\\*]{0,1}[^\\*]{0,}$",
        "raw_prompt": "An expression to validate a search string which accepts a wildcard(asterik) at most once anywhere in the string.",
        "refined_prompt": "\nMatch examples:\n- \"search*\"\n- \"*search\"\n- \"se*rch\"\nNon-match examples:\n- \"search**\"\n- \"**search\"",
        "matches": [
            "search*",
            "*search",
            "se*rch",
            "search",
            "*"
        ],
        "non_matches": [
            "search**",
            "**search",
            "**",
            "s**rch",
            "s*a*ch"
        ],
        "stress_tests": []
    },
    {
        "id": 2132,
        "expression": "\\+44\\s\\(0\\)\\s\\d{2}\\s\\d{4}\\s\\d{4}",
        "raw_prompt": "Simple expression to validate a UK phone number including country code and area code. Requires spacing.",
        "refined_prompt": "\nMatch examples:\n- \"+44 (0) 55 4444 3333\"\nNon-match examples:\n- \"+44 (0) 5555555555\"\n- \"55 4444 3333\"",
        "matches": [
            "+44 (0) 55 4444 3333"
        ],
        "non_matches": [
            "+44 (0) 5555555555",
            "55 4444 3333"
        ],
        "stress_tests": []
    },
    {
        "id": 2133,
        "expression": "\\+353\\(0\\)\\s\\d\\s\\d{3}\\s\\d{4}",
        "raw_prompt": "This simple expression evaluates an Ireland phone number. It requires the country code and dialing instructions for an international call plus spaces within the number.",
        "refined_prompt": "\nMatch examples:\n- \"+353(0) 5 444 3333\"\nNon-match examples:\n- \"+353(0) 55555555\"\n- \"5 444 3333\"",
        "matches": [
            "+353(0) 5 444 3333"
        ],
        "non_matches": [
            "+353(0) 55555555",
            "5 444 3333"
        ],
        "stress_tests": []
    },
    {
        "id": 2136,
        "expression": "(?!^0*$)(?!^0*\\.0*$)^\\d{1,10}(\\.\\d{1,2})?$",
        "raw_prompt": "To validate a number of 10 digits before the decimal point and atmost 2 digits after it",
        "refined_prompt": "\nMatch examples:\n- \"12314\"\n- \"12314.2\"\n- \"12314.32\"\nNon-match examples:\n- \"12314.212\"\n- \"12123.222\"",
        "matches": [
            "12314",
            "12314.2",
            "12314.32"
        ],
        "non_matches": [
            "12314.212",
            "12123.222"
        ],
        "stress_tests": []
    },
    {
        "id": 2137,
        "expression": "(?!^0*$)(?!^0*\\.0*$)^\\d{1,10}(\\.\\d{1,2})?$",
        "raw_prompt": "To validate a number of 10 digits before the decimal point and atmost 2 digits after it",
        "refined_prompt": "\nMatch examples:\n- \"12314\"\n- \"12314.2\"\n- \"12314.32\"\nNon-match examples:\n- \"12314.212\"\n- \"12123.222\"",
        "matches": [
            "12314",
            "12314.2",
            "12314.32"
        ],
        "non_matches": [
            "12314.212",
            "12123.222"
        ],
        "stress_tests": []
    },
    {
        "id": 2138,
        "expression": "(?!^0*$)(?!^0*\\.0*$)^\\d{1,10}(\\.\\d{1,2})?$",
        "raw_prompt": "To validate a number of 10 digits before the decimal point and atmost 2 digits after it",
        "refined_prompt": "\nMatch examples:\n- \"12314\"\n- \"12314.2\"\n- \"12314.32\"\nNon-match examples:\n- \"12314.212\"\n- \"12123.222\"",
        "matches": [
            "12314",
            "12314.2",
            "12314.32"
        ],
        "non_matches": [
            "12314.212",
            "12123.222"
        ],
        "stress_tests": []
    },
    {
        "id": 2139,
        "expression": "(?!^0*$)(?!^0*\\.0*$)^\\d{1,10}(\\.\\d{1,2})?$",
        "raw_prompt": "To validate a number of 10 digits before the decimal point and atmost 2 digits after it",
        "refined_prompt": "\nMatch examples:\n- \"12314\"\n- \"12314.2\"\n- \"12314.32\"\nNon-match examples:\n- \"12314.212\"\n- \"12123.222\"",
        "matches": [
            "12314",
            "12314.2",
            "12314.32"
        ],
        "non_matches": [
            "12314.212",
            "12123.222"
        ],
        "stress_tests": []
    },
    {
        "id": 2140,
        "expression": "(?!^0*$)(?!^0*\\.0*$)^\\d{1,10}(\\.\\d{1,2})?$",
        "raw_prompt": "To validate a number of 10 digits before the decimal point and atmost 2 digits after it",
        "refined_prompt": "\nMatch examples:\n- \"12314\"\n- \"12314.2\"\n- \"12314.32\"\nNon-match examples:\n- \"12314.212\"\n- \"12123.222\"",
        "matches": [
            "12314",
            "12314.2",
            "12314.32"
        ],
        "non_matches": [
            "12314.212",
            "12123.222"
        ],
        "stress_tests": []
    },
    {
        "id": 2143,
        "expression": "^\\d*[0-9](|.\\d*[0-9]|)*$",
        "raw_prompt": "Decimal like 123.23\n123.1234\n12345.456",
        "refined_prompt": "\nMatch examples:\n- \"123.23\"\n- \"123.1234\"\n- \"1234\"\nNon-match examples:\n- \"123a.12\"\n- \"123.34d\"",
        "matches": [
            "123.23",
            "123.1234",
            "1234",
            "1234.456"
        ],
        "non_matches": [
            "123a.12",
            "123.34d",
            "abc"
        ],
        "stress_tests": []
    },
    {
        "id": 2145,
        "expression": "^[a-zA-Z0-9]+(([_][a-zA-Z0-9])?[a-zA-Z0-9]*)*$",
        "raw_prompt": "This Regular Expression. I have used with ASP.NET Regular expression for validating that input string should not have special characters(e.g. $,#,@ etc.]",
        "refined_prompt": "\nMatch examples:\n- \"Employee\"\n- \"Employee_Test\"\n- \"Employee_Dept\"\nNon-match examples:\n- \"Employee.Test\"\n- \"Employee$Test\"",
        "matches": [
            "Employee",
            "Employee_Test",
            "Employee_Dept"
        ],
        "non_matches": [
            "Employee.Test",
            "Employee$Test",
            "Employee@Test"
        ],
        "stress_tests": []
    },
    {
        "id": 2148,
        "expression": "^(0)44[\\s]{0,1}[\\-]{0,1}[\\s]{0,1}2[\\s]{0,1}[1-9]{1}[0-9]{6}$",
        "raw_prompt": "This expression will help you to match chennai telephone numbers. chennai bsnl telephone numbers will start from 2.",
        "refined_prompt": "\nMatch examples:\n- \"044-26320244\"\n- \"04426320244\"\nNon-match examples:\n- \"044-12345678\"\n- \"123-12345678\"",
        "matches": [
            "044-26320244",
            "04426320244"
        ],
        "non_matches": [
            "044-12345678",
            "123-12345678"
        ],
        "stress_tests": []
    },
    {
        "id": 2149,
        "expression": "^(http\\://){1}(((www\\.){1}([a-zA-Z0-9\\-]*\\.){1,}){1}|([a-zA-Z0-9\\-]*\\.){1,10}){1}([a-zA-Z]{2,6}\\.){1}([a-zA-Z0-9\\-\\._\\?\\,\\'/\\\\\\+&amp;%\\$#\\=~])*",
        "raw_prompt": "This checks to see if a URL has http:// in it, and if it has either www or a subdomain before the domain and tld. Without (http\\://) it only does the latter check. Replace http by (http|https|ftp) for other protocols. Still not happy about this: http://www.www.passshouldfail.com",
        "refined_prompt": "\nMatch examples:\n- \"http://www.pass.com http://sub.pass.com http://www.sub.pass.com http://sub.sub.pass.com http://www.sub.sub.pass.com\"\nNon-match examples:\n- \"fail.com\"\n- \"www.fail.com\"",
        "matches": [
            "http://www.pass.com http://sub.pass.com http://www.sub.pass.com http://sub.sub.pass.com http://www.sub.sub.pass.com"
        ],
        "non_matches": [
            "fail.com",
            "www.fail.com",
            "www.www.fail.com",
            "http://fail.com",
            "http://http://fail.com",
            "http://http://www.fail.com",
            "sub.fail.com",
            "www.sub.fail.com",
            "sub.sub.fail.com",
            "www.sub.sub.fail.com"
        ],
        "stress_tests": []
    },
    {
        "id": 2152,
        "expression": "^Content-Type:\\s*(\\w+)\\s*/?\\s*(\\w*)?\\s*;\\s*((\\w+)?\\s*=\\s*((\".+\")|(\\S+)))?",
        "raw_prompt": "Matches the Content-Type for a MIME Mail Message and a Non-Mime Mail Message",
        "refined_prompt": "\nMatch examples:\n- \"Content-Type: multipart/mixed; boundary=\"---myboundary\"\"\n- \"Content-Type: multipart/mixed;boundary=---myBoundarysi3cds\"\n- \"Content-Type: text/plain;\"\nNon-match examples:\n- \"Content Type: multipart/mixed\"\n- \"Content-Type: text/plain\"",
        "matches": [
            "Content-Type: multipart/mixed; boundary=\"---myboundary\"",
            "Content-Type: multipart/mixed;boundary=---myBoundarysi3cds",
            "Content-Type: text/plain;"
        ],
        "non_matches": [
            "Content Type: multipart/mixed",
            "Content-Type: text/plain",
            "Content-Type image/jpeg;"
        ],
        "stress_tests": []
    },
    {
        "id": 2153,
        "expression": "^((0[123456789]|1[0-2])(0[1-3]|1[0-9]|2[0-9]))|((0[13456789]|1[0-2])(30))|((0[13578]|1[02])(31))$",
        "raw_prompt": "Evaluates a date in the format of MMDD. Will evaluate month day ranges accurately with Feb going up to 29.",
        "refined_prompt": "\nMatch examples:\n- \"0229\"\n- \"0331\"\n- \"0630\"\nNon-match examples:\n- \"0230\"\n- \"0431\"",
        "matches": [
            "0229",
            "0331",
            "0630",
            "0902"
        ],
        "non_matches": [
            "0230",
            "0431",
            "1245",
            "1299",
            "0011"
        ],
        "stress_tests": []
    },
    {
        "id": 2154,
        "expression": "^(([A-Z]{1}[a-z]+([\\-][A-Z]{1}[a-z]+)?)([ ]([A-Z]\\.)){0,2}[ ](([A-Z]{1}[a-z]*)|([O]{1}[\\']{1}[A-Z][a-z]{2,}))([ ](Jr\\.|Sr\\.|IV|III|II))?)$",
        "raw_prompt": "Allows:\n1) first last\n2) first mi last\n3) first mi mi last\n4) first mi O'last\n5) first mi mi O'last\n6) first-first last\n7) first-first mi last\n8) first-first mi mi last\n9) first-first mi O'last\n10)first-first mi mi O'last",
        "refined_prompt": "\nMatch examples:\n- \"Ryan O'Malley\"\n- \"Joseph R. Tanner Jr.\"\n- \"Mary-Lou E. Jones\"\nNon-match examples:\n- \"George Herbert Walker Bush\"\n- \"George Walker Bush\"",
        "matches": [
            "Ryan O'Malley",
            "Joseph R. Tanner Jr.",
            "Mary-Lou E. Jones",
            "George H. W. Bush"
        ],
        "non_matches": [
            "George Herbert Walker Bush",
            "George Walker Bush",
            "RYan O'Malley",
            "Joseph Tanner, Jr.",
            "Mary-lou E. Jones"
        ],
        "stress_tests": []
    },
    {
        "id": 2155,
        "expression": "//.*|/\\*[\\s\\S]*?\\*/",
        "raw_prompt": "Matches single line or multi-line comments.",
        "refined_prompt": "\nMatch examples:\n- \"// Comment here\"\n- \"/// Comment here\"\n- \"/* Cmment Here */\"\nNon-match examples:\n- \"/ * Comment Here */\"\n- \"/* Comment here * /\"",
        "matches": [
            "// Comment here",
            "/// Comment here",
            "/* Cmment Here */",
            "/**** Comment Here ****/"
        ],
        "non_matches": [
            "/ * Comment Here */",
            "/* Comment here * /"
        ],
        "stress_tests": []
    },
    {
        "id": 2157,
        "expression": "^(b|B)(f|F)(p|P)(o|O)(\\s*||\\s*C(/|)O\\s*)[0-9]{1,4}",
        "raw_prompt": "Matches BFPO\nAllows for BFPO with no spacing",
        "refined_prompt": "\nMatch examples:\n- \"BFPO 2, BFPO 2222, BFPO C/O 121, BFPO2222\"\nNon-match examples:\n- \"bf po 1212, BFPO 22222\"",
        "matches": [
            "BFPO 2, BFPO 2222, BFPO C/O 121, BFPO2222"
        ],
        "non_matches": [
            "bf po 1212, BFPO 22222"
        ],
        "stress_tests": []
    },
    {
        "id": 2160,
        "expression": "(?=^[!@#$%\\^&*()_\\-+=\\[{\\]};:<>|\\./?a-zA-Z\\d]{7,}$)(?=([!@#$%\\^&*()_\\-+=\\[{\\]};:<>|\\./?a-zA-Z\\d]*\\W+){1,})[!@#$%\\^&*()_\\-+=\\[{\\]};:<>|\\./?a-zA-Z\\d]*$",
        "raw_prompt": "Regex to validate strong password for .NET MembershipProvider ValidatePassword. Regex checks for minimum required password length and for minimum required non-alphanumeric characters. Change value '7' according to MinRequiredPasswordLength and '1' to MinRequiredNonAlphanumericCharacters.",
        "refined_prompt": "\nMatch examples:\n- \"12345!r@r\"\n- \"#dfgjaydh%\"\n- \"aA1!@#$%\"\nNon-match examples:\n- \"12345rfg\"\n- \"hsjahdgs\"",
        "matches": [
            "12345!r@r",
            "#dfgjaydh%",
            "aA1!@#$%",
            "11111#aZ"
        ],
        "non_matches": [
            "12345rfg",
            "hsjahdgs",
            "12345"
        ],
        "stress_tests": []
    },
    {
        "id": 2161,
        "expression": "^(([0-1]?[0-9])|([2][0-3])):([0-5][0-9])$",
        "raw_prompt": "Matches a string if it is a valid time in the format of HH:MM",
        "refined_prompt": "\nMatch examples:\n- \"02:04\"\n- \"16:56\"\n- \"23:59\"\nNon-match examples:\n- \"02:00 PM\"\n- \"PM2:00\"",
        "matches": [
            "02:04",
            "16:56",
            "23:59",
            "1:01"
        ],
        "non_matches": [
            "02:00 PM",
            "PM2:00",
            "24:00"
        ],
        "stress_tests": []
    },
    {
        "id": 2168,
        "expression": "^[0-9]{6}-[0-9pPtTfF][0-9]{3}$",
        "raw_prompt": "Other Swedish personnummer regexps do not take into account that at Swedish universities, foreigners might get special temporary personnummers with a \"P\", \"T\", or \"F\" instead of the first of the four last numbers.\nThis code fixes the problem, but does not check the validity of the date, or the last number.",
        "refined_prompt": "\nMatch examples:\n- \"123456-1234\"\n- \"123456-P234\"\n- \"123456-f234\"\nNon-match examples:\n- \"123456-12\"\n- \"1234561234\"",
        "matches": [
            "123456-1234",
            "123456-P234",
            "123456-f234"
        ],
        "non_matches": [
            "123456-12",
            "1234561234",
            "123456"
        ],
        "stress_tests": []
    },
    {
        "id": 2169,
        "expression": "^\\s*(([/-9!#-'*+=?A-~-]+(?:\\.[/-9!#-'*+=?A-~-]+)*|\"(?:[^\"\\r\\n\\\\]|\\\\.)*\")@([A-Za-z][0-9A-Za-z-]*[0-9A-Za-z]?(?:\\.[A-Za-z][0-9A-Za-z-]*[0-9A-Za-z]?)*|\\[(?:[^\\[\\]\\r\\n\\\\]|\\\\.)*\\]))\\s*$",
        "raw_prompt": "This validates against the RFC 2821 (SMTP) syntax unit 'Mailbox' [equiv. to addr-spec - not address - element of RFC 2822] (the one a certain critic keeps linking to validates the RFC822 'address' element which includes support for stuff like \"Group:User <address>,User <address>;\", obsolete smtp routing syntax like <@host1,@host2:user@host>, etc)\nThere are some differences. This version does not allow line breaks for continuation lines. It also applies the stricter standards of RFC 2821 (SMTP) to the domain portion of the address.\nUsername may be a quoted string (but not \"multiple\".\"quoted\".\"strings\" - RFC 2822's grammar appears to allow this but the SMTP grammar does not). Also only one piece enclosed in [Brackets] (for IP email addresses) is allowed in the domain; that is you can't have user@[1.2.3.4].[5.6.7.8] as implied by the RFC2822 but not SMTP. Whitespace is only allowed in quoted strings. It is silently ignored at the beginning or end.\nCapture group 1 is the email address, group 2 is the username, group 3 is the domain.",
        "refined_prompt": "\nMatch examples:\n- \"user@example.com\"\n- \"user+sub@example.com\"\n- \"\"user name\"@example.com\"\nNon-match examples:\n- \"no_at_sign\"\n- \"invalid...adjacent_dots@example.com\"",
        "matches": [
            "user@example.com",
            "user+sub@example.com",
            "\"user name\"@example.com",
            "user@[192.0.2.4]"
        ],
        "non_matches": [
            "no_at_sign",
            "invalid...adjacent_dots@example.com",
            "no quote@example.com",
            "user@192.0.2.4"
        ],
        "stress_tests": []
    },
    {
        "id": 2187,
        "expression": "^((5[1-5])([0-9]{2})((-|\\s)?[0-9]{4}){3})$",
        "raw_prompt": "Validates all Mastercard numbers starting with 51-55 with a total of 16 digits. Allows for spaces and -'s.",
        "refined_prompt": "\nMatch examples:\n- \"5144-0000-0000-0000\"\n- \"5343 0000 0000 0000\"\n- \"5400000000000000\"\nNon-match examples:\n- \"5600....\"\n- \"4100....\"",
        "matches": [
            "5144-0000-0000-0000",
            "5343 0000 0000 0000",
            "5400000000000000"
        ],
        "non_matches": [
            "5600....",
            "4100...."
        ],
        "stress_tests": []
    },
    {
        "id": 2188,
        "expression": "[_\\w-]+(?:\\.[_\\w-]+)*@(?:[\\w-]+\\.)+(?:[\\w-]{2,4})(?![\\w]+)",
        "raw_prompt": "matches the most of the email addresses.",
        "refined_prompt": "\nMatch examples:\n- \"a.a@w3.org\"\n- \"b@sohu.com\"\n- \"s-s@33.cc\"\nNon-match examples:\n- \"a@b\"\n- \"a@b.commmm\"",
        "matches": [
            "a.a@w3.org",
            "b@sohu.com",
            "s-s@33.cc"
        ],
        "non_matches": [
            "a@b",
            "a@b.commmm",
            "a.@b.cc",
            "a@.cc",
            "dd@g.netfooooooooo...ooo"
        ],
        "stress_tests": []
    },
    {
        "id": 2190,
        "expression": "^(\\d)?(\\d|,)*\\.?\\d{1,2}$",
        "raw_prompt": "Validates Numeric values with commas and limited decimal places. Can change the value d{1,2} to limit decimal places from 1 to n",
        "refined_prompt": "\nMatch examples:\n- \"1,000\"\n- \"1,200.45\"\n- \"4,567,567.45\"\nNon-match examples:\n- \"$1,000\"\n- \"1,200.45343\"",
        "matches": [
            "1,000",
            "1,200.45",
            "4,567,567.45",
            "2450.45"
        ],
        "non_matches": [
            "$1,000",
            "1,200.45343",
            "2.5.000"
        ],
        "stress_tests": []
    },
    {
        "id": 2191,
        "expression": "([a-zA-Z]{2}[0-9]{1,2}\\s{0,1}[0-9]{1,2}[a-zA-Z]{2})",
        "raw_prompt": "This is a simple post code regex for UK. It does a wonderfull job.",
        "refined_prompt": "\nMatch examples:\n- \"GL50 4ED\"\n- \"GL504ED\"\n- \"gl504ed\"\nNon-match examples:\n- \"1323\"\n- \"3ws23\"",
        "matches": [
            "GL50 4ED",
            "GL504ED",
            "gl504ed",
            "gl50 4ed",
            "GL5 4ED",
            "GL5 43ED"
        ],
        "non_matches": [
            "1323",
            "3ws23"
        ],
        "stress_tests": []
    },
    {
        "id": 2192,
        "expression": "^([a-zA-Z]:\\\\)?[^\\x00-\\x1F\"<>\\|:\\*\\?/]+\\.[a-zA-Z]{3,4}$",
        "raw_prompt": "This matches a valid windows filename. Not a valid path.I wanted something simple that covered all the bases",
        "refined_prompt": "\nMatch examples:\n- \"file.txt\"\n- \"fie.txt.pdf\"\n- \"file(with parenthesis).pdf\"\nNon-match examples:\n- \"*file.pdf\"\n- \"file.tx\"",
        "matches": [
            "file.txt",
            "fie.txt.pdf",
            "file(with parenthesis).pdf"
        ],
        "non_matches": [
            "*file.pdf",
            "file.tx"
        ],
        "stress_tests": []
    },
    {
        "id": 2193,
        "expression": "(?=^.{7,20}$)(?=.*\\d)(?=.*[a-zA-Z])(?!.*\\s)[0-9a-zA-Z*$-+?_&=!%{}/'.]*$",
        "raw_prompt": "Password length must be between 7 and 20 characters, include at least one alphabetic and one numeric character, and may include some special characters.",
        "refined_prompt": "\nMatch examples:\n- \"test1234\"\n- \"test$%9*\"\n- \"Test$123\"\nNon-match examples:\n- \"testing\"\n- \"12345678\"",
        "matches": [
            "test1234",
            "test$%9*",
            "Test$123"
        ],
        "non_matches": [
            "testing",
            "12345678",
            "!@#$%^&*"
        ],
        "stress_tests": []
    },
    {
        "id": 2201,
        "expression": "^[+]\\d{1,2}\\(\\d{2,3}\\)\\d{6,8}(\\#\\d{1,10})?$",
        "raw_prompt": "Phone number with country prefix +2 or +22 (one or two digits), then City code in parenthesis, like (444)? then phone number 6 to 8 digits and optional extension '#XXX' up to 10 digits",
        "refined_prompt": "\nMatch examples:\n- \"+7(834)4328933#890\"\n- \"+72(834)43289323#8902892\"\n- \"+33(834)328932\"\nNon-match examples:\n- \"+7(834)4328933#\"\n- \"+7(834)4328#89908\"",
        "matches": [
            "+7(834)4328933#890",
            "+72(834)43289323#8902892",
            "+33(834)328932"
        ],
        "non_matches": [
            "+7(834)4328933#",
            "+7(834)4328#89908",
            "+723(834)4328#89908"
        ],
        "stress_tests": []
    },
    {
        "id": 2203,
        "expression": "^(\\+[0-9]{2,}[0-9]{4,}[0-9]*)(x?[0-9]{1,})?$",
        "raw_prompt": "This comes from our requirement to have tight clean telephone database column. This expression supports only strict format and none others.It accepts any international country code with optional extension number.",
        "refined_prompt": "\nMatch examples:\n- \"+17034567890\"\n- \"+17034567890x1234\"\n- \"+912024553455\"\nNon-match examples:\n- \"x1234\"\n- \"+1\"",
        "matches": [
            "+17034567890",
            "+17034567890x1234",
            "+912024553455",
            "+912024553455x12",
            "+441237761457"
        ],
        "non_matches": [
            "x1234",
            "+1",
            "+123",
            "+x1234",
            "+12x12",
            "+1(703)4563245x1234"
        ],
        "stress_tests": []
    },
    {
        "id": 2206,
        "expression": "^([0][1-9]|[1][0-2]):[0-5][0-9] {1}(AM|PM|am|pm)$",
        "raw_prompt": "Matches if the string is in hh:mm am/pm format. Also the hour and minute values should have left padding 0's if they are single digit.",
        "refined_prompt": "\nMatch examples:\n- \"03:45 am\"\n- \"10:24 PM\"\n- \"01:03 pm\"\nNon-match examples:\n- \"8:15 am\"\n- \"16:10\"",
        "matches": [
            "03:45 am",
            "10:24 PM",
            "01:03 pm"
        ],
        "non_matches": [
            "8:15 am",
            "16:10",
            "10:60 pm",
            "10:13"
        ],
        "stress_tests": []
    },
    {
        "id": 2213,
        "expression": "[\\(]{1,}[^)]*[)]{1,}",
        "raw_prompt": "Will find any texts within a string that is enclosed within parenthesis ( )",
        "refined_prompt": "\nMatch examples:\n- \"Test (test 1)\"\n- \"(test)\"\n- \"Test (test 1) Test (test 2)\"\nNon-match examples:\n- \"Test\"",
        "matches": [
            "Test (test 1)",
            "(test)",
            "Test (test 1) Test (test 2)"
        ],
        "non_matches": [
            "Test"
        ],
        "stress_tests": []
    },
    {
        "id": 2215,
        "expression": "^/{1}(((/{1}\\.{1})?[a-zA-Z0-9 ]+/?)+(\\.{1}[a-zA-Z0-9]{2,4})?)$",
        "raw_prompt": "This expressions was written for C#. Matches all valid Linux absolute paths (files or folders). Will not work for relative paths that do not begin with a /, Also will only match files that have extensions consisting of 2, 3, or 4 characters. Currently fails with _ . or - in the path, this will be updated at some point.",
        "refined_prompt": "\nMatch examples:\n- \"/mnt/share/\"\n- \"/home/.BASH\"\n- \"/mnt/share/pic.jpeg\"\nNon-match examples:\n- \"mnt/share\"\n- \"//mnt///share//\"",
        "matches": [
            "/mnt/share/",
            "/home/.BASH",
            "/mnt/share/pic.jpeg",
            "/mnt/share/install.sh"
        ],
        "non_matches": [
            "mnt/share",
            "//mnt///share//",
            "/mnt/share/install.installer",
            "/home\\user"
        ],
        "stress_tests": []
    },
    {
        "id": 2218,
        "expression": "^([0-9]{2})(01|02|03|04|05|06|07|08|09|10|11|12|51|52|53|54|55|56|57|58|59|60|61|62)(([0]{1}[1-9]{1})|([1-2]{1}[0-9]{1})|([3]{1}[0-1]{1}))/([0-9]{3,4})$",
        "raw_prompt": "Law 301/1995 z. Z. SR from 14. december 1995. PIN from 1900 to 1953 have sufix with three digits, PIN beyond 1954 have four digits in sufix. In first part of woman PIN is month of birth (3rd & 4th digit) increase +50.",
        "refined_prompt": "\nMatch examples:\n- \"760612/5689\"\n- \"826020/5568\"\n- \"500101/256\"\nNon-match examples:\n- \"680645/256\"\n- \"707212/1258\"",
        "matches": [
            "760612/5689",
            "826020/5568",
            "500101/256"
        ],
        "non_matches": [
            "680645/256",
            "707212/1258",
            "260015/4598"
        ],
        "stress_tests": []
    },
    {
        "id": 2222,
        "expression": "^(((([\\*]{1}){1})|((\\*\\/){0,1}(([0-9]{1}){1}|(([1-5]{1}){1}([0-9]{1}){1}){1}))) ((([\\*]{1}){1})|((\\*\\/){0,1}(([0-9]{1}){1}|(([1]{1}){1}([0-9]{1}){1}){1}|([2]{1}){1}([0-3]{1}){1}))) ((([\\*]{1}){1})|((\\*\\/){0,1}(([1-9]{1}){1}|(([1-2]{1}){1}([0-9]{1}){1}){1}|([3]{1}){1}([0-1]{1}){1}))) ((([\\*]{1}){1})|((\\*\\/){0,1}(([1-9]{1}){1}|(([1-2]{1}){1}([0-9]{1}){1}){1}|([3]{1}){1}([0-1]{1}){1}))|(jan|feb|mar|apr|may|jun|jul|aug|sep|okt|nov|dec)) ((([\\*]{1}){1})|((\\*\\/){0,1}(([0-7]{1}){1}))|(sun|mon|tue|wed|thu|fri|sat)))$",
        "raw_prompt": "SUPPORTED constructions:\n[*] - all five commands;\n[number] - minutes 0...59, hours 0...23, day in month 1...31, months 1...12, day in week 0...7 (0 & 7 is sun);\n[*/nubmer] - see construction [number];\n[word] - only months (4th command) and days in week (5th command), warning this regexp is case sensitive (lower letters).\nNON SUPPORTED constructions:\n[number-number] and\n[number,number].",
        "refined_prompt": "\nMatch examples:\n- \"*/15 */12 30 feb 7\"\n- \"10 * * * */2\"\n- \"* * * * *\"\nNon-match examples:\n- \"62 * * */2 *\"\n- \"* * * 0 *\"",
        "matches": [
            "*/15 */12 30 feb 7",
            "10 * * * */2",
            "* * * * *"
        ],
        "non_matches": [
            "62 * * */2 *",
            "* * * 0 *",
            "* * * Feb *"
        ],
        "stress_tests": []
    },
    {
        "id": 2223,
        "expression": "^(B(A|B|C|J|L|N|R|S|Y)|CA|D(K|S|T)|G(A|L)|H(C|E)|IL|K(A|I|E|K|M|N|S)|L(E|C|M|V)|M(A|I|L|T|Y)|N(I|O|M|R|Z)|P(B|D|E|O|K|N|P|T|U|V)|R(A|K|S|V)|S(A|B|C|E|I|K|L|O|N|P|V)|T(A|C|N|O|R|S|T|V)|V(K|T)|Z(A|C|H|I|M|V))([ ]{0,1})([0-9]{3})([A-Z]{2})$",
        "raw_prompt": "Case sensitive (upper)!",
        "refined_prompt": "\nMatch examples:\n- \"BB123AB\"\n- \"KE 999BB\"\nNon-match examples:\n- \"QT 123AB\"\n- \"BB 1234AA\"",
        "matches": [
            "BB123AB",
            "KE 999BB"
        ],
        "non_matches": [
            "QT 123AB",
            "BB 1234AA",
            "BB001ABC"
        ],
        "stress_tests": []
    },
    {
        "id": 2224,
        "expression": "^([a-hA-H]{1}[1-8]{1})$",
        "raw_prompt": "Letter (a - h) + number (1 - 8). Case insensitive.",
        "refined_prompt": "\nMatch examples:\n- \"A1\"\n- \"a8\"\n- \"b3\"\nNon-match examples:\n- \"i5\"\n- \"F9\"",
        "matches": [
            "A1",
            "a8",
            "b3"
        ],
        "non_matches": [
            "i5",
            "F9",
            "AA"
        ],
        "stress_tests": []
    },
    {
        "id": 2226,
        "expression": "<title>(.*?)</title>",
        "raw_prompt": "This regular expression can be used to extract titles from web page",
        "refined_prompt": "\nMatch examples:\n- \"<title>Regular Expression Library</title>\"\nNon-match examples:\n- \"<td>Regular Expression Library</td>\"",
        "matches": [
            "<title>Regular Expression Library</title>"
        ],
        "non_matches": [
            "<td>Regular Expression Library</td>"
        ],
        "stress_tests": []
    },
    {
        "id": 2241,
        "expression": "^([1-9]{1}|[1-9]{1}[0-9]{1,3}|[1-5]{1}[0-9]{4}|6[0-4]{1}[0-9]{3}|65[0-4]{1}[0-9]{2}|655[0-2]{1}[0-9]{1}|6553[0-6]{1})$",
        "raw_prompt": "Communication ports in PC between 1 - 65536.",
        "refined_prompt": "\nMatch examples:\n- \"1\"\n- \"80\"\n- \"65536\"\nNon-match examples:\n- \"0\"\n- \"0999\"",
        "matches": [
            "1",
            "80",
            "65536"
        ],
        "non_matches": [
            "0",
            "0999",
            "65537"
        ],
        "stress_tests": []
    },
    {
        "id": 2246,
        "expression": "^(0|(([1-9]{1}|[1-9]{1}[0-9]{1}|[1-9]{1}[0-9]{2}){1}(\\ [0-9]{3}){0,})),(([0-9]{2})|\\-\\-)([\\ ]{1})(\u20ac|EUR|EURO){1}$",
        "raw_prompt": "Supported symbols are \u20ac or EUR or EURO (all case sensitive).",
        "refined_prompt": "\nMatch examples:\n- \"0,00 \u20ac\"\n- \"1 234 567,89 EUR\"\n- \"1,-- EURO\"\nNon-match examples:\n- \"00,00 \u20ac\"\n- \"1234567,89 EUR\"",
        "matches": [
            "0,00 \u20ac",
            "1 234 567,89 EUR",
            "1,-- EURO"
        ],
        "non_matches": [
            "00,00 \u20ac",
            "1234567,89 EUR",
            "0 555,55 EURO",
            "2,2 EUR",
            "2,- EUR"
        ],
        "stress_tests": []
    },
    {
        "id": 2247,
        "expression": "^(big5|euc(kr|jpms)|binary|greek|tis620|hebrew|ascii|swe7|koi8(r|u)|(u|keyb)cs2|(dec|hp|utf|geostd|armscii)8|gb(k|2312)|cp(8(5(0|2)|66)|932|125(0|1|6|7))|latin(1|2|5|7)|(u|s)jis|mac(ce|roman))$",
        "raw_prompt": "supported all charsets in MySQL 5.1, case sensitive (lower)",
        "refined_prompt": "\nMatch examples:\n- \"utf8\"\n- \"cp1251\"\n- \"latin7\"\nNon-match examples:\n- \"utf-8\"\n- \"utf16\"",
        "matches": [
            "utf8",
            "cp1251",
            "latin7"
        ],
        "non_matches": [
            "utf-8",
            "utf16",
            "cp1252",
            "LATIN1",
            "cp 850"
        ],
        "stress_tests": []
    },
    {
        "id": 2250,
        "expression": "function[\\s]+[\\S]+[\\s]*([\\s]*)[\\s]*{[\\s]*([\\S]|[\\s])*[\\s]*}",
        "raw_prompt": "detect javascript function in HTML",
        "refined_prompt": "\nMatch examples:\n- \"function displaymessage() { alert(\"Hello World!\"); }\"\n- \"function Load_dvCont7() { loadBreaking('/Services/IncludePart/LevelOne/?T=7&Id=2007731105943979989&P=', '_dvCont7' , '1'); }\"\nNon-match examples:\n- \"any other HTML tag\"",
        "matches": [
            "function displaymessage() { alert(\"Hello World!\"); }",
            "function Load_dvCont7() { loadBreaking('/Services/IncludePart/LevelOne/?T=7&Id=2007731105943979989&P=', '_dvCont7' , '1'); }"
        ],
        "non_matches": [
            "any other HTML tag"
        ],
        "stress_tests": []
    },
    {
        "id": 2259,
        "expression": "^(0?[1-9]|1[0-2])\\/(0?[1-9]|[1-2][0-9]|3[0-1])\\/(0[1-9]|[1-9][0-9]|175[3-9]|17[6-9][0-9]|1[8-9][0-9]{2}|[2-9][0-9]{3})$",
        "raw_prompt": "Matches all dates (mm/dd/yyyy or mm/dd/yy) greater than or equal to the SQL minimum date of 01/01/1753 and less than or equal to 12/31/9999. Does not check for leap years.",
        "refined_prompt": "\nMatch examples:\n- \"01/01/1753\"\n- \"9/2/09\"\n- \"12/02/1980\"\nNon-match examples:\n- \"1/1/1\"\n- \"13/1/01\"",
        "matches": [
            "01/01/1753",
            "9/2/09",
            "12/02/1980",
            "12/31/9999"
        ],
        "non_matches": [
            "1/1/1",
            "13/1/01",
            "01/0/2001",
            "12/31/1752",
            "1-1-1900"
        ],
        "stress_tests": []
    },
    {
        "id": 2262,
        "expression": "^\\d{1,3}((\\.\\d{1,3}){3}|(\\.\\d{1,3}){5})$",
        "raw_prompt": "validate both IP V4 and IP V6",
        "refined_prompt": "\nMatch examples:\n- \"192.168.0.1\"\n- \"000.000.000.000.000.000\"\n- \"999.999.999.999.999.999\"\nNon-match examples:\n- \"1.1.1.1.1\"\n- \"1.1\"",
        "matches": [
            "192.168.0.1",
            "000.000.000.000.000.000",
            "999.999.999.999.999.999"
        ],
        "non_matches": [
            "1.1.1.1.1",
            "1.1",
            "a.b.c.d.e.f.g"
        ],
        "stress_tests": []
    },
    {
        "id": 2263,
        "expression": "<(.|\\n)*?>",
        "raw_prompt": "This regex will remove the HTML tags with content",
        "refined_prompt": "\nMatch examples:\n- \"<BR> </a>\"\nNon-match examples:\n- \"any text without tag\"",
        "matches": [
            "<BR> </a>"
        ],
        "non_matches": [
            "any text without tag"
        ],
        "stress_tests": []
    },
    {
        "id": 2264,
        "expression": "^(((0|128|192|224|240|248|252|254).0.0.0)|(255.(0|128|192|224|240|248|252|254).0.0)|(255.255.(0|128|192|224|240|248|252|254).0)|(255.255.255.(0|128|192|224|240|248|252|254)))$",
        "raw_prompt": "netmask address. I know this is nod good enough :)",
        "refined_prompt": "\nMatch examples:\n- \"255.255.192.0\"\n- \"240.0.0.0\"\n- \"255.255.255.0\"\nNon-match examples:\n- \"255.0.192.0\"\n- \"240.128.0.0\"",
        "matches": [
            "255.255.192.0",
            "240.0.0.0",
            "255.255.255.0"
        ],
        "non_matches": [
            "255.0.192.0",
            "240.128.0.0",
            "240.255.255.0"
        ],
        "stress_tests": []
    },
    {
        "id": 2265,
        "expression": "^((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[0-9]{1,2})\\.){3}(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[0-9]{1,2})(/([0-9]|[0-2][0-9]|3[0-2]))$",
        "raw_prompt": "ip address/netmask couple",
        "refined_prompt": "\nMatch examples:\n- \"192.168.0.5/24\"\n- \"255.255.0.0/32\"\nNon-match examples:\n- \"192.256.0.5/24\"\n- \"255.255.0.0/40\"",
        "matches": [
            "192.168.0.5/24",
            "255.255.0.0/32"
        ],
        "non_matches": [
            "192.256.0.5/24",
            "255.255.0.0/40"
        ],
        "stress_tests": []
    },
    {
        "id": 2266,
        "expression": "\\b([A-Za-z]+) +(\\1\\b)",
        "raw_prompt": "\"one one\" can be replaced with \"one\". This RE will help you in removing the duplicated successor with single word or character. The replacement string will be $1",
        "refined_prompt": "\nMatch examples:\n- \"one one, two two, you you, work work, I I\"\nNon-match examples:\n- \"normal sentence\"",
        "matches": [
            "one one, two two, you you, work work, I I"
        ],
        "non_matches": [
            "normal sentence"
        ],
        "stress_tests": []
    },
    {
        "id": 2267,
        "expression": "^[a-zA-Z][a-zA-Z0-9_\\.\\-]+@([a-zA-Z0-9-]{2,}\\.)+([a-zA-Z]{2,4}|[a-zA-Z]{2}\\.[a-zA-Z]{2})$",
        "raw_prompt": "This will validate most legal e-mail adresses with the correct syntax.",
        "refined_prompt": "\nMatch examples:\n- \"name@website.com\"\n- \"first_second@website.co.uk\"\n- \"blah.blah.007@website.se\"\nNon-match examples:\n- \"0name@website.com\"\n- \"name&@website.net\"",
        "matches": [
            "name@website.com",
            "first_second@website.co.uk",
            "blah.blah.007@website.se"
        ],
        "non_matches": [
            "0name@website.com",
            "name&@website.net",
            "blahblah@website"
        ],
        "stress_tests": []
    },
    {
        "id": 2273,
        "expression": "\\b(((0[13578]|1[02])[\\/\\.-]?(0[1-9]|[12]\\d|3[01])[\\/\\.-]?(19|20)?(\\d{2}))|(0[13456789]|1[012])[\\/\\.-]?(0[1-9]|[12]\\d|30)[\\/\\.-]?(19|20)?(\\d{2}))|(02[\\/\\.-]?(0[1-9]|1\\d|2[0-8])[\\/\\.-]?(19|20)?(\\d{2}))|(02[\\/\\.-]?29[\\/\\.-]?(19|20)?((0[48]|[2468][048]|[13579][26])|(00)))\\b",
        "raw_prompt": "I needed to have a way where users could type in any date format like the following: mm/dd/yyyy, mm/dd/yy, mmddyy, mmddyyyy with the ability to use \"/\" and \".\" and \"-\" or nothing as separation characters. I use this in a RegularExpression Validator control in ASP.NET",
        "refined_prompt": "\nMatch examples:\n- \"032103\"\n- \"02/29/2008\"\n- \"10.31.1990\"\nNon-match examples:\n- \"2-29-00\"\n- \"11.31.1992\"",
        "matches": [
            "032103",
            "02/29/2008",
            "10.31.1990",
            "010102"
        ],
        "non_matches": [
            "2-29-00",
            "11.31.1992",
            "063178",
            "02/29/2005"
        ],
        "stress_tests": []
    },
    {
        "id": 2277,
        "expression": "@([_a-zA-Z]+)",
        "raw_prompt": "Can be used to find SQL Server parmeters in a SQL string. Does not attempt to weed-out \"@\" characters in embedded string values.",
        "refined_prompt": "\nMatch examples:\n- \"SELECT COUNT(pk) FROM Employees WHERE TypeID = @Type\"\nNon-match examples:\n- \"SELECT COUNT(pk) FROM Employees WHERE TypeID = 1\"",
        "matches": [
            "SELECT COUNT(pk) FROM Employees WHERE TypeID = @Type"
        ],
        "non_matches": [
            "SELECT COUNT(pk) FROM Employees WHERE TypeID = 1"
        ],
        "stress_tests": []
    },
    {
        "id": 2278,
        "expression": "(\\d{2}|\\d{4})(?:\\-)?([0]{1}\\d{1}|[1]{1}[0-2]{1})(?:\\-)?([0-2]{1}\\d{1}|[3]{1}[0-1]{1})(?:\\s)?([0-1]{1}\\d{1}|[2]{1}[0-3]{1})(?::)?([0-5]{1}\\d{1})(?::)?([0-5]{1}\\d{1})",
        "raw_prompt": "Will match a date accepted by MySQL datetime type.\nYears with 2 or 4 digits from any range.\nMonths with 2 digits from 00 to 12.\ndays with 2 digits from 00 to 31.\nHours with 2 digits from 00-23\nMinutes with 2 digits from 00 to 59.\nSeconds with 2 digits from 00 to 59.",
        "refined_prompt": "\nMatch examples:\n- \"00-00-00 00:00:00\"\n- \"0000-00-00 00:00:00\"\n- \"09-05-22 08:16:00\"\nNon-match examples:\n- \"2009-13:01 00:00:00\"\n- \"2009-12-32 00:00:00\"",
        "matches": [
            "00-00-00 00:00:00",
            "0000-00-00 00:00:00",
            "09-05-22 08:16:00",
            "1970-00-00 00:00:00",
            "20090522081600"
        ],
        "non_matches": [
            "2009-13:01 00:00:00",
            "2009-12-32 00:00:00",
            "2002-12-31 24:00:00",
            "2002-12-31 23:60:00",
            "02-12-31 23:00:60"
        ],
        "stress_tests": []
    },
    {
        "id": 2279,
        "expression": "^(0|[-]{1}([1-9]{1}[0-9]{0,1}|[1]{1}([0-1]{1}[0-9]{1}|[2]{1}[0-8]{1}))|(\\+)?([1-9]{1}[0-9]{0,1}|[1]{1}([0-1]{1}[0-9]{1}|[2]{1}[0-7]{1})))$",
        "raw_prompt": "Not just a number, a byte type. Will match any number from range -128 to 127.",
        "refined_prompt": "\nMatch examples:\n- \"-128\"\n- \"127\"\n- \"0\"\nNon-match examples:\n- \"-129\"\n- \"128\"",
        "matches": [
            "-128",
            "127",
            "0",
            "1",
            "-10"
        ],
        "non_matches": [
            "-129",
            "128",
            "-0",
            "+0"
        ],
        "stress_tests": []
    },
    {
        "id": 2281,
        "expression": "^(0|[-]{1}([1-9]{1}[0-9]{0,3}|[1-2]{1}[0-9]{1,4}|[3]{1}([0-1]{1}[0-9]{3}|[2]{1}([0-6]{1}[0-9]{2}|[7]{1}([0-5]{1}[0-9]{1}|([6]{1}[0-8]{1})))))|(\\+)?([1-9]{1}[0-9]{0,3}|[1-2]{1}[0-9]{1,4}|[3]{1}([0-1]{1}[0-9]{3}|[2]{1}([0-6]{1}[0-9]{2}|[7]{1}([0-5]{1}[0-9]{1}|([6]{1}[0-7]{1}))))))$",
        "raw_prompt": "Short type, will match a short number from range -32768 to 32767.",
        "refined_prompt": "\nMatch examples:\n- \"-32768\"\n- \"-10\"\n- \"0\"\nNon-match examples:\n- \"+0\"\n- \"-0\"",
        "matches": [
            "-32768",
            "-10",
            "0",
            "10",
            "32767"
        ],
        "non_matches": [
            "+0",
            "-0",
            "-32769",
            "32768"
        ],
        "stress_tests": []
    },
    {
        "id": 2282,
        "expression": "^(0|(\\+)?([1-9]{1}[0-9]{0,3})|([1-5]{1}[0-9]{1,4}|[6]{1}([0-4]{1}[0-9]{3}|[5]{1}([0-4]{1}[0-9]{2}|[5]{1}([0-2]{1}[0-9]{1}|[3]{1}[0-5]{1})))))$",
        "raw_prompt": "Will match an unsigned short number from range 0 to 65535",
        "refined_prompt": "\nMatch examples:\n- \"0\"\n- \"100\"\n- \"65535\"\nNon-match examples:\n- \"-0\"\n- \"+0\"",
        "matches": [
            "0",
            "100",
            "65535"
        ],
        "non_matches": [
            "-0",
            "+0",
            "-10",
            "65536"
        ],
        "stress_tests": []
    },
    {
        "id": 2284,
        "expression": "^(0|(\\+)?[1-9]{1}[0-9]{0,8}|(\\+)?[1-3]{1}[0-9]{1,9}|(\\+)?[4]{1}([0-1]{1}[0-9]{8}|[2]{1}([0-8]{1}[0-9]{7}|[9]{1}([0-3]{1}[0-9]{6}|[4]{1}([0-8]{1}[0-9]{5}|[9]{1}([0-5]{1}[0-9]{4}|[6]{1}([0-6]{1}[0-9]{3}|[7]{1}([0-1]{1}[0-9]{2}|[2]{1}([0-8]{1}[0-9]{1}|[9]{1}[0-5]{1})))))))))$",
        "raw_prompt": "Will match any unsigned integer from range 0 to 4294967295",
        "refined_prompt": "\nMatch examples:\n- \"0\"\n- \"1000\"\n- \"4294967295\"\nNon-match examples:\n- \"-100\"\n- \"-0\"",
        "matches": [
            "0",
            "1000",
            "4294967295"
        ],
        "non_matches": [
            "-100",
            "-0",
            "+0",
            "4294967296"
        ],
        "stress_tests": []
    },
    {
        "id": 2293,
        "expression": "^(?=.*[\\d])(?=.*[A-Z])(?=.*[a-z])[\\w\\d!@#$%_]{6,40}$",
        "raw_prompt": "Password must be 6-40 characters - {6,40}\nMust have no spaces, at least 1 digit (?=.*[\\d]), at least 1 uppercase letter (?=.*[A-Z]) and at least one lowercase letter (?=.*[a-z]).\nAllows specifying special characters - !@#$%_",
        "refined_prompt": "\nMatch examples:\n- \"Pa5$Word\"\n- \"HORS3y\"\n- \"Th1$IsMyR3allYl0ngPa$$\"\nNon-match examples:\n- \"PASSWORD\"\n- \"password\"",
        "matches": [
            "Pa5$Word",
            "HORS3y",
            "Th1$IsMyR3allYl0ngPa$$"
        ],
        "non_matches": [
            "PASSWORD",
            "password",
            "Password",
            "1234567"
        ],
        "stress_tests": []
    },
    {
        "id": 2294,
        "expression": "^([0-1][0-9]|[2][0-3]|[0-9]):([0-5][0-9])(?::([0-5][0-9]))?$",
        "raw_prompt": "Validate hours with seconds returning mirrors correctly.",
        "refined_prompt": "\nMatch examples:\n- \"09:05\"\n- \"10:00\"\n- \"1:15\"\nNon-match examples:\n- \"9:5\"\n- \"09:1\"",
        "matches": [
            "09:05",
            "10:00",
            "1:15",
            "00:59:00",
            "23:01:59"
        ],
        "non_matches": [
            "9:5",
            "09:1",
            "0:1",
            "0:00:0",
            "1:1:11"
        ],
        "stress_tests": []
    },
    {
        "id": 2295,
        "expression": "^([0-2]\\d|3[0-1]|[1-9])\\/(0\\d|1[0-2]|[1-9])\\/(\\d{4})$",
        "raw_prompt": "Validate a date format: d/m/Y.\nSee examples.",
        "refined_prompt": "\nMatch examples:\n- \"1/05/1990\"\n- \"01/1/2006\"\n- \"01/01/2008\"\nNon-match examples:\n- \"01/01/90\"\n- \"32/02/2009\"",
        "matches": [
            "1/05/1990",
            "01/1/2006",
            "01/01/2008",
            "5/5/2009",
            "1/1/1990",
            "29/05/2009"
        ],
        "non_matches": [
            "01/01/90",
            "32/02/2009",
            "1/13/1990",
            "0/0/2009"
        ],
        "stress_tests": []
    },
    {
        "id": 2296,
        "expression": "^([0-1][0-9]|2[0-3]){1}:([0-5][0-9]){1}:([0-5][0-9]){1},([0-9][0-9][0-9]){1} --> ([0-1][0-9]|2[0-3]){1}:([0-5][0-9]){1}:([0-5][0-9]){1},([0-9][0-9][0-9]){1}(.*)$",
        "raw_prompt": "e. g. HH:MM:SS:ttt --> HH:MM:SS:ttt;\n$1 is start hour;\n$2 is start minute;\n$3 is start second;\n$4 is start s/1000;\n$5 is stop hour;\n$6 is stop minute;\n$7 is stop second;\n$8 is stop s/1000;",
        "refined_prompt": "\nMatch examples:\n- \"00:12:35,126 --> 00:12:35,526\"\nNon-match examples:\n- \"00:59:35,126 --> 00:60:20,500\"\n- \"00:16:20,200 --> 00:16:20,30\"",
        "matches": [
            "00:12:35,126 --> 00:12:35,526"
        ],
        "non_matches": [
            "00:59:35,126 --> 00:60:20,500",
            "00:16:20,200 --> 00:16:20,30",
            "01:01:01.000 --> 01:01:01.900"
        ],
        "stress_tests": []
    },
    {
        "id": 2297,
        "expression": "^\\{([1-9]{1}|[1-9]{1}[0-9]{1,}){1}\\}\\{([1-9]{1}|[1-9]{1}[0-9]{1,}){1}\\}(.*)$",
        "raw_prompt": "e. g. {11510}{11810}Blah, blah, blah.;\n$1 is start;\n$2 is stop;",
        "refined_prompt": "\nMatch examples:\n- \"{100}{150}subtitle\"\n- \"{1234}{1234}subtitle\"\n- \"{1}{2}subtitle\"\nNon-match examples:\n- \"{0100}{1000}subtitle\"\n- \"{}{100}subtitle\"",
        "matches": [
            "{100}{150}subtitle",
            "{1234}{1234}subtitle",
            "{1}{2}subtitle"
        ],
        "non_matches": [
            "{0100}{1000}subtitle",
            "{}{100}subtitle",
            "{500}{}subtitle"
        ],
        "stress_tests": []
    },
    {
        "id": 2298,
        "expression": "\"([^\\\\\"]|\\\\.)*\"",
        "raw_prompt": "to get the text betwen double quotes",
        "refined_prompt": "\nMatch examples:\n- \"\"Ram\", \"Ram Shyam\"\"\nNon-match examples:\n- \"ram , shyam\"",
        "matches": [
            "\"Ram\", \"Ram Shyam\""
        ],
        "non_matches": [
            "ram , shyam"
        ],
        "stress_tests": []
    },
    {
        "id": 2301,
        "expression": "^(\\$?)((\\d{1,20})|(\\d{1,2}((,?\\d{3}){0,6}))|(\\d{3}((,?\\d{3}){0,5})))$",
        "raw_prompt": "This expression will allow whole dollar amounts (along with $ and ,) which are 20 digit wide. So the maximum amount will be $99,999,999,999,999,999,999. Note: This regular expression allows skipped commas, but will not allow multiple or commas at the wrong location. This can be used for all languages that have comma before the 3rd, 6th, 9th... digit.",
        "refined_prompt": "\nMatch examples:\n- \"$99,999,999,999,999,999,999\"\n- \"$56,987\"\n- \"56,123456,456\"\nNon-match examples:\n- \"$77,8,888\"\n- \"asadf\"",
        "matches": [
            "$99,999,999,999,999,999,999",
            "$56,987",
            "56,123456,456"
        ],
        "non_matches": [
            "$77,8,888",
            "asadf",
            "67.98"
        ],
        "stress_tests": []
    },
    {
        "id": 2303,
        "expression": "^([a-zA-Z])(?=.*\\d)\\w{4,9}$",
        "raw_prompt": "Check Password: 5 - 10 characters long, start with a letter and contain at least one number. No special characters",
        "refined_prompt": "\nMatch examples:\n- \"a2345\"\n- \"abcd1\"\n- \"abc123\"\nNon-match examples:\n- \"1abc\"\n- \"1abcd\"",
        "matches": [
            "a2345",
            "abcd1",
            "abc123"
        ],
        "non_matches": [
            "1abc",
            "1abcd",
            "a2345678910"
        ],
        "stress_tests": []
    },
    {
        "id": 2304,
        "expression": "^\\w*[-]*\\w*\\\\\\w*$",
        "raw_prompt": "It Accepts hyphen in the domain name",
        "refined_prompt": "\nMatch examples:\n- \"scandent-blr\\abc\"\nNon-match examples:\n- \"abc\"",
        "matches": [
            "scandent-blr\\abc"
        ],
        "non_matches": [
            "abc"
        ],
        "stress_tests": []
    },
    {
        "id": 2306,
        "expression": "^http\\://www.[a-zA-Z0-9\\-\\.]+\\.[a-zA-Z]{2,3}/$",
        "raw_prompt": "This regex only matches clean domain names. No path after. Ends in a forward slash. Starts with http://www. It is pretty slack on the TLD requiring a 2 or 3 letter ending. This part could be tightened up if you wanted to be restrict it to specific TLDs.",
        "refined_prompt": "\nMatch examples:\n- \"http://www.somedomain.co.uk/\"\n- \"http://www.somedomain.com/\"\n- \"http://www.dodgydomain.com.com/\"\nNon-match examples:\n- \"http://www.somedomain.co.uk/withpath.aspx\"\n- \"http://somedomainwithoutwww.co.uk\"",
        "matches": [
            "http://www.somedomain.co.uk/",
            "http://www.somedomain.com/",
            "http://www.dodgydomain.com.com/"
        ],
        "non_matches": [
            "http://www.somedomain.co.uk/withpath.aspx",
            "http://somedomainwithoutwww.co.uk",
            "http://www.com/",
            "www.noprotocolprefix.com/",
            "https://www.secureprotocolprefix.com/",
            "http://www.notrailingslash.co.uk",
            "HTTP://WWW.beginswithcaps.com/"
        ],
        "stress_tests": []
    },
    {
        "id": 2307,
        "expression": "\\.([A-Za-z0-9]{2,5}($|\\b\\?))",
        "raw_prompt": "Pattern matches all file extensions from two(2) to five(5) characters in length (e.g. Adobe Illustrator [*.ai] or Extensible Hypertext Markup Language [*.xhtml]). Input can be an absolute path, relative path, URI, directory path, etc. If there are get variables in a URI input, they are ignored.",
        "refined_prompt": "\nMatch examples:\n- \"http://regexlib.com/Add.aspx\"\n- \"/path/to/filename.txt\"\n- \"TheSpanishInquisition.mpeg\"\nNon-match examples:\n- \"Non-extentionFileName\"\n- \"FilenameWithOneCharacterExtension.q\"",
        "matches": [
            "http://regexlib.com/Add.aspx",
            "/path/to/filename.txt",
            "TheSpanishInquisition.mpeg",
            "42.ai",
            "Dont Panic.xhtml",
            "http://localhost/webPage/index.php?variable=value"
        ],
        "non_matches": [
            "Non-extentionFileName",
            "FilenameWithOneCharacterExtension.q",
            "FIlenameWithSixOrMoreCharactersExtension.invalid"
        ],
        "stress_tests": []
    },
    {
        "id": 2316,
        "expression": "^[+-]?[0-9]+$",
        "raw_prompt": "Single- or multi-digit signed Integer.",
        "refined_prompt": "\nMatch examples:\n- \"12\"\n- \"-2\"\n- \"+3213\"\nNon-match examples:\n- \"abc\"\n- \"@41\"",
        "matches": [
            "12",
            "-2",
            "+3213"
        ],
        "non_matches": [
            "abc",
            "@41",
            "43.12"
        ],
        "stress_tests": []
    },
    {
        "id": 2317,
        "expression": "^[+-]?\\d*(([,.]\\d{3})+)?([,.]\\d+)?([eE][+-]?\\d+)?$",
        "raw_prompt": "Matches any integer or decimal number with either dot (.) or comma (,) as decimal- and thousands-separator. Also accepts Scientific notation.",
        "refined_prompt": "\nMatch examples:\n- \"-4,233.2832e12\"\n- \"+232\"\n- \"-0.12e-5\"\nNon-match examples:\n- \"abc\"\n- \"@41\"",
        "matches": [
            "-4,233.2832e12",
            "+232",
            "-0.12e-5"
        ],
        "non_matches": [
            "abc",
            "@41",
            "0x423"
        ],
        "stress_tests": []
    },
    {
        "id": 2318,
        "expression": "^(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9]{1,2})(\\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9]{1,2})){3}$",
        "raw_prompt": "This matches any valid IPV4 IP Address. It includes 0-255 range checks since none of the IP components may exceed 255.",
        "refined_prompt": "\nMatch examples:\n- \"97.67.44.20\"\n- \"199.154.37.214\"\n- \"127.0.0.1\"\nNon-match examples:\n- \"63.125.94.287\"\n- \"140.370.a.187\"",
        "matches": [
            "97.67.44.20",
            "199.154.37.214",
            "127.0.0.1"
        ],
        "non_matches": [
            "63.125.94.287",
            "140.370.a.187",
            "94.923.1"
        ],
        "stress_tests": []
    },
    {
        "id": 2320,
        "expression": "^.*([^\\.][\\.](([gG][iI][fF])|([Jj][pP][Gg])|([Jj][pP][Ee][Gg])|([Bb][mM][pP])|([Pp][nN][Gg])))",
        "raw_prompt": "By using this we can upload only images files. This is the simplest and its execution is fast.",
        "refined_prompt": "\nMatch examples:\n- \"D:\\Documents and Settings\\Administrator\\Desktop\\New Folder\\60101-prep.png\"\nNon-match examples:\n- \"D:\\Documents and Settings\\Administrator\\Desktop\\New Folder\\60101-prep.pdf\"",
        "matches": [
            "D:\\Documents and Settings\\Administrator\\Desktop\\New Folder\\60101-prep.png"
        ],
        "non_matches": [
            "D:\\Documents and Settings\\Administrator\\Desktop\\New Folder\\60101-prep.pdf"
        ],
        "stress_tests": []
    },
    {
        "id": 2322,
        "expression": "^#?(([a-fA-F0-9]{3}){1,2})$",
        "raw_prompt": "Matches any valid 3 or 6 digit hexadecimal colour value.",
        "refined_prompt": "\nMatch examples:\n- \"#ff9900\"\n- \"#abc\"\n- \"#92fea5\"\nNon-match examples:\n- \"ab\"\n- \"#92a2\"",
        "matches": [
            "#ff9900",
            "#abc",
            "#92fea5"
        ],
        "non_matches": [
            "ab",
            "#92a2",
            "32z"
        ],
        "stress_tests": []
    },
    {
        "id": 2333,
        "expression": "(\"((\\\\.)|[^\\\\\"])*\")",
        "raw_prompt": "match string between chars \" \" as in source code",
        "refined_prompt": "\nMatch examples:\n- \"\"\"\"\n- \"\"\\n\"\"\n- \"\"test\"\"\nNon-match examples:\n- \"test\"\n- \"\"test\"",
        "matches": [
            "\"\"",
            "\"\\n\"",
            "\"test\"",
            "\"test 1 \\\"test 2 \\\" test 3\""
        ],
        "non_matches": [
            "test",
            "\"test",
            "\"test\\\""
        ],
        "stress_tests": []
    },
    {
        "id": 2334,
        "expression": "('((\\\\.)|[^\\\\'])*')",
        "raw_prompt": "match string between chars ' ' as in source code",
        "refined_prompt": "\nMatch examples:\n- \"''\"\n- \"'\\n'\"\n- \"'test'\"\nNon-match examples:\n- \"test\"\n- \"'test\"",
        "matches": [
            "''",
            "'\\n'",
            "'test'",
            "'test 1 \\'test 2 \\' test 3'"
        ],
        "non_matches": [
            "test",
            "'test",
            "'test\\'"
        ],
        "stress_tests": []
    },
    {
        "id": 2335,
        "expression": "[0-9]{1,2}[:|\u00b0][0-9]{1,2}[:|'](?:\\b[0-9]+(?:\\.[0-9]*)?|\\.[0-9]+\\b)\"?[N|S|E|W]",
        "raw_prompt": "Matches common Degree, Minute, Second coordinate values. The last part can be easily modified to be latitude or longitude specific by changing\n[N|S|E|W] to [N|S] for latitude or [E|W] for longitude.",
        "refined_prompt": "\nMatch examples:\n- \"12:12:12.223546\"N\"\n- \"12:12:12.2246N\"\n- \"15:17:6\"S\"\nNon-match examples:\n- \"12.2225\"\n- \"15.25.257S\"",
        "matches": [
            "12:12:12.223546\"N",
            "12:12:12.2246N",
            "15:17:6\"S",
            "12\u00b030'23.256547\"S"
        ],
        "non_matches": [
            "12.2225",
            "15.25.257S",
            "AA:BB:CC.DDS"
        ],
        "stress_tests": []
    },
    {
        "id": 2339,
        "expression": "^(\\d){8}$",
        "raw_prompt": "UK Bank account numbers are 8 digits. One bank uses 7 digits so in the validation error message you should instruct the user to prefix with a zero of their code is too short. If you want to allow the 7 digit codes as well use this regex: http://regexlib.com/REDetails.aspx?regexp_id=2707",
        "refined_prompt": "\nMatch examples:\n- \"08464524\"\n- \"45832484\"\n- \"24899544\"\nNon-match examples:\n- \"1234567\"\n- \"1 5 2226 44\"",
        "matches": [
            "08464524",
            "45832484",
            "24899544"
        ],
        "non_matches": [
            "1234567",
            "1 5 2226 44",
            "123456789"
        ],
        "stress_tests": []
    },
    {
        "id": 2340,
        "expression": "^(\\d){7,8}$",
        "raw_prompt": "UK Bank Account. One bank account issues 7 digit bank codes and you should prefix a 0 yourself after input. If you want strict validation of 8 characters use this regex: http://regexlib.com/REDetails.aspx?regexp_id=2706",
        "refined_prompt": "\nMatch examples:\n- \"1234567\"\n- \"12345678\"\nNon-match examples:\n- \"123456\"\n- \"123 4567\"",
        "matches": [
            "1234567",
            "12345678"
        ],
        "non_matches": [
            "123456",
            "123 4567",
            "123456789"
        ],
        "stress_tests": []
    },
    {
        "id": 2341,
        "expression": "^[^\\s]+$",
        "raw_prompt": "No whitespace is allowed in a string",
        "refined_prompt": "\nMatch examples:\n- \"nowhitespace\"\n- \"onewordonly\"\n- \"anotherexample\"\nNon-match examples:\n- \"two words\"\n- \"three words here\"",
        "matches": [
            "nowhitespace",
            "onewordonly",
            "anotherexample"
        ],
        "non_matches": [
            "two words",
            "three words here",
            "anything with spaces"
        ],
        "stress_tests": []
    },
    {
        "id": 2342,
        "expression": "\".*?[^\"\\\\]\"(?!\")|\"\"",
        "raw_prompt": "match the csharp string Syntax",
        "refined_prompt": "\nMatch examples:\n- \"\"C#\"\"\n- \"\"My Club Site tag\"\",\"\"line or slogan\"\"\nNon-match examples:\n- \"C#\"\"",
        "matches": [
            "\"C#\"",
            "\"My Club Site tag\"\",\"\"line or slogan\""
        ],
        "non_matches": [
            "C#\""
        ],
        "stress_tests": []
    },
    {
        "id": 2345,
        "expression": "(((((0[1-9]|[12][0-9]|3[01])/(0[13578]|1[02]))|((0[1-9]|[12][0-9]|30)/(0[469]|11))|((0[1-9]|[1][0-9]|2[0-8]))/02)/([0-9]{3}[1-9]|[0-9]{2}[1-9][0-9]{1}|[0-9]{1}[1-9][0-9]{2}|[1-9][0-9]{3}) ((([0-1][0-9])|([2][0-3]))[:][0-5][0-9]$))|(29/02/(([0-9]{2})(0[48]|[2468][048]|[13579][26])|((0[48]|[2468][048]|[3579][26])00)) ((([0-1][0-9])|([2][0-3]))[:][0-5][0-9]$)))",
        "raw_prompt": "this expression validates a date-time field in European dd/mm/yyyy hh:mm format",
        "refined_prompt": "\nMatch examples:\n- \"29/02/2008 15:30\"\nNon-match examples:\n- \"29/02/2009 25:62\"",
        "matches": [
            "29/02/2008 15:30"
        ],
        "non_matches": [
            "29/02/2009 25:62"
        ],
        "stress_tests": []
    },
    {
        "id": 2348,
        "expression": "^((.)(?!\\2{2,}))+$",
        "raw_prompt": "This pattern matches strings where no more than two equal characters may come in succession.\nTo modify the amount of characters allowed, change the second number (the two inside \"{2,}\")to the desired limit.",
        "refined_prompt": "\nMatch examples:\n- \"Abba\"\n- \"p4ssw0rd\"\n- \"Whatever\"\nNon-match examples:\n- \"Abbba\"\n- \"p4sssw0rd\"",
        "matches": [
            "Abba",
            "p4ssw0rd",
            "Whatever"
        ],
        "non_matches": [
            "Abbba",
            "p4sssw0rd",
            "Whateverrr"
        ],
        "stress_tests": []
    },
    {
        "id": 2352,
        "expression": "^[\\w_.]{5,12}$",
        "raw_prompt": "validate usernames with dot or underscoures doesn't allow spaces and accept characters between 5 and 15 no other characters",
        "refined_prompt": "\nMatch examples:\n- \"Ahmad.egypt\"\n- \"ahmad_egypt\"\nNon-match examples:\n- \"Ahmad@egypt\"\n- \"Ahmad*egypt\"",
        "matches": [
            "Ahmad.egypt",
            "ahmad_egypt"
        ],
        "non_matches": [
            "Ahmad@egypt",
            "Ahmad*egypt"
        ],
        "stress_tests": []
    },
    {
        "id": 2353,
        "expression": "^([^\\s]){5,12}$",
        "raw_prompt": "validate text against spaces and accept from 5 to 12 character",
        "refined_prompt": "\nMatch examples:\n- \"ahmed\"\n- \"Muhammad\"\n- \"Hassan\"\nNon-match examples:\n- \"a hmed\"\n- \"Hass an\"",
        "matches": [
            "ahmed",
            "Muhammad",
            "Hassan"
        ],
        "non_matches": [
            "a hmed",
            "Hass an"
        ],
        "stress_tests": []
    },
    {
        "id": 2355,
        "expression": "^((\\+)?(\\d{2}[-])?(\\d{10}){1})?(\\d{11}){0,1}?$",
        "raw_prompt": "India phone number, accept with optional +91 national code and 0 for land and mobile number prefix . Allows optional - after national code",
        "refined_prompt": "\nMatch examples:\n- \"+91-9764544544\"\n- \"09764544544\"\n- \"01087656444\"\nNon-match examples:\n- \"+91-01087656444\"\n- \"+91-09764544544\"",
        "matches": [
            "+91-9764544544",
            "09764544544",
            "01087656444",
            "+91-1087656444"
        ],
        "non_matches": [
            "+91-01087656444",
            "+91-09764544544",
            "+9178786765652"
        ],
        "stress_tests": []
    },
    {
        "id": 2360,
        "expression": "^(([0-9]{1})|([0-9]{1}[0-9]{1})|([1-3]{1}[0-6]{1}[0-5]{1}))d(([0-9]{1})|(1[0-9]{1})|([1-2]{1}[0-3]{1}))h(([0-9]{1})|([1-5]{1}[0-9]{1}))m$",
        "raw_prompt": "Duration validation similar to MS Project (5d16h45m, etc). Does not allow more than 365 days, 23 hrs or 59 min.",
        "refined_prompt": "\nMatch examples:\n- \"365d23h59m\"\n- \"90d18h45m\"\n- \"05d19h45m\"\nNon-match examples:\n- \"366d23h45m\"\n- \"90d24h5m\"",
        "matches": [
            "365d23h59m",
            "90d18h45m",
            "05d19h45m"
        ],
        "non_matches": [
            "366d23h45m",
            "90d24h5m",
            "90d6h60m"
        ],
        "stress_tests": []
    },
    {
        "id": 2370,
        "expression": "^(0?[1-9]|1[012])/([012][0-9]|[1-9]|3[01])/([12][0-9]{3})$",
        "raw_prompt": "In month/day/year format. Matches valid months (1-12) and valid days (1-31) and a valid 4 digit year (from 1000-2999). $1 = month, $2 = day, $3 = year. Sadly, it doesn't check to make sure that months have a valid number of days (no Feb 30th checks, etc).",
        "refined_prompt": "\nMatch examples:\n- \"1/12/2003\"\n- \"04/8/1995\"\n- \"12/31/2035\"\nNon-match examples:\n- \"13/04/2000\"\n- \"4/32/1593\"",
        "matches": [
            "1/12/2003",
            "04/8/1995",
            "12/31/2035",
            "5/06/1911"
        ],
        "non_matches": [
            "13/04/2000",
            "4/32/1593",
            "",
            "5/6/98"
        ],
        "stress_tests": []
    },
    {
        "id": 2373,
        "expression": "^\\<(\\w){1,}\\>(.){0,}([\\</]|[\\<])(\\w){1,}\\>$",
        "raw_prompt": "validates HTML tags",
        "refined_prompt": "\nMatch examples:\n- \"<br><b>fsd</b><br>\"\nNon-match examples:\n- \"<br><<<<>br>\"",
        "matches": [
            "<br><b>fsd</b><br>"
        ],
        "non_matches": [
            "<br><<<<>br>"
        ],
        "stress_tests": []
    },
    {
        "id": 2376,
        "expression": "^(([0]?[1-9])|(1[0-2]))\\/(([0]?[1-9])|([1,2]\\d{1})|([3][0,1]))\\/[12]\\d{3}$",
        "raw_prompt": "This regular expression matches the format MM/DD/YYYY. Month and Day can have an optional leading 0. Months are from 01-12, days are from 01-31, and years are from 1000-2999.",
        "refined_prompt": "\nMatch examples:\n- \"1/1/1999\"\n- \"01/01/2001\"\n- \"12/31/1900\"\nNon-match examples:\n- \"00/12/0999\"\n- \"13/1/2000\"",
        "matches": [
            "1/1/1999",
            "01/01/2001",
            "12/31/1900"
        ],
        "non_matches": [
            "00/12/0999",
            "13/1/2000",
            "10/0/2009"
        ],
        "stress_tests": []
    },
    {
        "id": 2377,
        "expression": "^(.)+\\.(jpg|jpeg|JPG|JPEG)$",
        "raw_prompt": "validates jpg/jpeg picture extension",
        "refined_prompt": "\nMatch examples:\n- \"marko.jpg\"\n- \"marko.pic.jpeg\"\nNon-match examples:\n- \"marko.exe\"",
        "matches": [
            "marko.jpg",
            "marko.pic.jpeg"
        ],
        "non_matches": [
            "marko.exe"
        ],
        "stress_tests": []
    },
    {
        "id": 2379,
        "expression": "[^A-Za-z0-9 ]",
        "raw_prompt": "search special character form a given sting space is ignored.",
        "refined_prompt": "\nMatch examples:\n- \"#This Is $$## Where Your Main String Goes\"\nNon-match examples:\n- \"This is a test\"",
        "matches": [
            "#This Is $$## Where Your Main String Goes"
        ],
        "non_matches": [
            "This is a test"
        ],
        "stress_tests": []
    },
    {
        "id": 2383,
        "expression": "^([1-9]\\d{3}|0[1-9]\\d{2}|00[1-9]\\d{1}|000[1-9]{1})$",
        "raw_prompt": "This RE will match all numbers between (including) 0001 and 9999. Four places of digits are mandatory in this expression.",
        "refined_prompt": "\nMatch examples:\n- \"0001\"\n- \"0064\"\n- \"0948\"\nNon-match examples:\n- \"1\"\n- \"64\"",
        "matches": [
            "0001",
            "0064",
            "0948",
            "7697"
        ],
        "non_matches": [
            "1",
            "64",
            "948"
        ],
        "stress_tests": []
    },
    {
        "id": 2384,
        "expression": "^([\\d]*[1-9]+[\\d]*)$",
        "raw_prompt": "RE to match numbers with value greater than 0.",
        "refined_prompt": "\nMatch examples:\n- \"0001\"\n- \"120064\"\n- \"1000000\"\nNon-match examples:\n- \"0\"\n- \"000000000\"",
        "matches": [
            "0001",
            "120064",
            "1000000",
            "1"
        ],
        "non_matches": [
            "0",
            "000000000",
            "0000"
        ],
        "stress_tests": []
    },
    {
        "id": 2387,
        "expression": "^[-+]?\\d+(\\.\\d)?\\d*$",
        "raw_prompt": "Number(no space or thousand separator with point(.) as decimal delimiter.",
        "refined_prompt": "\nMatch examples:\n- \"-3\"\n- \"3.1231\"\n- \"+972\"\nNon-match examples:\n- \".3\"\n- \"51.\"",
        "matches": [
            "-3",
            "3.1231",
            "+972"
        ],
        "non_matches": [
            ".3",
            "51.",
            "+3.3.1"
        ],
        "stress_tests": []
    },
    {
        "id": 2389,
        "expression": "((http|ftp|https|ftps):\\/\\/)?[\\w\\-_\\.]+\\.(([0-9]{1,3})|([a-zA-Z]{2,3})|(aero|arpa|asia|coop|info|jobs|mobi|museum|name|travel))+(:[0-9]+)?\\/?(([\\w\\-\\.,@^%:/~\\+#]*[\\w\\-\\@^%/~\\+#])((\\?[a-zA-Z0-9\\[\\]\\-\\._+%\\$#\\=~',]*=[a-zA-Z0-9\\[\\]\\-\\._+%\\$#\\=~',]*)+(&[a-zA-Z0-9\\[\\]\\-\\._+%\\$#\\=~',]*=[a-zA-Z0-9\\[\\]\\-\\._+%\\$#\\=~',]*)*)?)?",
        "raw_prompt": "Based on the work of N H (http://regexlib.com/REDetails.aspx?regexp_id=96). Added ftps protocol, makes protocol optional, makes slash after site optional.",
        "refined_prompt": "\nMatch examples:\n- \"google.com\"\n- \"http://mysite.org:80/thispage.asp\"\n- \"ftp://ftp.upload.com/\"\nNon-match examples:\n- \"nomatchcom\"",
        "matches": [
            "google.com",
            "http://mysite.org:80/thispage.asp",
            "ftp://ftp.upload.com/"
        ],
        "non_matches": [
            "nomatchcom"
        ],
        "stress_tests": []
    },
    {
        "id": 2393,
        "expression": "((\\+44\\s?\\(0\\)\\s?\\d{2,4})|(\\+44\\s?(01|02|03|07|08)\\d{2,3})|(\\+44\\s?(1|2|3|7|8)\\d{2,3})|(\\(\\+44\\)\\s?\\d{3,4})|(\\(\\d{5}\\))|((01|02|03|07|08)\\d{2,3})|(\\d{5}))(\\s|-|.)(((\\d{3,4})(\\s|-)(\\d{3,4}))|((\\d{6,7})))",
        "raw_prompt": "Matches over 18 different combinations for UK phone numbers that I could find. If there are any errors please get in touch.",
        "refined_prompt": "\nMatch examples:\n- \"0121 111 1111\"\n- \"+44 (0)21 444 4444\"\n- \"07941 111 111\"\nNon-match examples:\n- \"0121_111_3333\"",
        "matches": [
            "0121 111 1111",
            "+44 (0)21 444 4444",
            "07941 111 111",
            "07941 111111",
            "(+44) 121 222 3333"
        ],
        "non_matches": [
            "0121_111_3333"
        ],
        "stress_tests": []
    },
    {
        "id": 2397,
        "expression": "^(?-i:A[LKSZRAEP]|C[AOT]|D[EC]|F[LM]|G[AU]|HI|I[ADLN]|K[SY]|LA|M[ADEHINOPST]|N[CDEHJMVY]|O[HKR]|P[ARW]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY])$",
        "raw_prompt": "Validates US state abbreviations used by the Post Office.",
        "refined_prompt": "\nMatch examples:\n- \"CA\"\n- \"FL\"\n- \"HI\"\nNon-match examples:\n- \"Ca\"\n- \"NK\"",
        "matches": [
            "CA",
            "FL",
            "HI"
        ],
        "non_matches": [
            "Ca",
            "NK",
            "CAL"
        ],
        "stress_tests": []
    },
    {
        "id": 2398,
        "expression": "^([0-9]|[1-9]\\d|[1-7]\\d{2}|800)$",
        "raw_prompt": "Validates if the GMAT score is in the correct range and format",
        "refined_prompt": "\nMatch examples:\n- \"0\"\n- \"190\"\n- \"800\"\nNon-match examples:\n- \"050\"\n- \"700.5\"",
        "matches": [
            "0",
            "190",
            "800"
        ],
        "non_matches": [
            "050",
            "700.5",
            "abc",
            "801"
        ],
        "stress_tests": []
    },
    {
        "id": 2399,
        "expression": "^[6]\\d{7}$",
        "raw_prompt": "In Singapore, the first digit must start with a \"6\", and the rest is made up of 7 digits, which means that there are 8 digits in a Singapore's telephone number.",
        "refined_prompt": "\nMatch examples:\n- \"61234567\"\n- \"63829324\"\n- \"67654321\"\nNon-match examples:\n- \"6123-4567\"\n- \"6-CALL-CPY\"",
        "matches": [
            "61234567",
            "63829324",
            "67654321"
        ],
        "non_matches": [
            "6123-4567",
            "6-CALL-CPY",
            "6123abcd"
        ],
        "stress_tests": []
    },
    {
        "id": 2400,
        "expression": "^[SFTG]\\d{7}[A-Z]$",
        "raw_prompt": "The National Registry Identification Number (NRIC) of Singapore is made up of the first character being a S/F/T or G. The next 2 numbers is the year of birth for people born 1967 and later. The last character is a checksum done on the numbers, and the algorithm will not be released.",
        "refined_prompt": "\nMatch examples:\n- \"S9912345A\"\n- \"T1234567V\"\n- \"F0094839P\"\nNon-match examples:\n- \"K4928940829F\"\n- \"T1234567\"",
        "matches": [
            "S9912345A",
            "T1234567V",
            "F0094839P"
        ],
        "non_matches": [
            "K4928940829F",
            "T1234567",
            "M1234567C"
        ],
        "stress_tests": []
    },
    {
        "id": 2401,
        "expression": "([0-9]+)\\s(d)\\s(([0-1][0-9])|([2][0-3])):([0-5][0-9]):([0-5][0-9])",
        "raw_prompt": "Displays duration in\n1 d 22:33:44 format. Can be modified to match some other formats e.g. 1.22:33:44 if needed. Takes a 24-hour day into account.",
        "refined_prompt": "\nMatch examples:\n- \"1 d 22:33:44\"\n- \"109 d 11:02:00\"\n- \"0 d 00:00:00\"\nNon-match examples:\n- \"d 22:33:44\"\n- \"1 d 24:00:00\"",
        "matches": [
            "1 d 22:33:44",
            "109 d 11:02:00",
            "0 d 00:00:00"
        ],
        "non_matches": [
            "d 22:33:44",
            "1 d 24:00:00",
            "3 d 11:75:00"
        ],
        "stress_tests": []
    },
    {
        "id": 2403,
        "expression": "^.*(?:kumar).*$",
        "raw_prompt": "This will match those string which contains the word \"kumar\"",
        "refined_prompt": "\nMatch examples:\n- \"my name is kumar\"\nNon-match examples:\n- \"I am mohan\"",
        "matches": [
            "my name is kumar"
        ],
        "non_matches": [
            "I am mohan"
        ],
        "stress_tests": []
    },
    {
        "id": 2405,
        "expression": "(\\b(10|11|12|13|14|15|16|17|18|19)[0-9]\\b)",
        "raw_prompt": "Match the numbers 100 to 199",
        "refined_prompt": "\nMatch examples:\n- \"100 to 199\"\nNon-match examples:\n- \"200, 300, 1, 55, 99\"",
        "matches": [
            "100 to 199"
        ],
        "non_matches": [
            "200, 300, 1, 55, 99"
        ],
        "stress_tests": []
    },
    {
        "id": 2406,
        "expression": "^[1-9]{1,2}(.5)?$",
        "raw_prompt": "This is a simple regular expression which allows 1 to 99 in .5 increments which I originally developed for a forum post",
        "refined_prompt": "\nMatch examples:\n- \"1.5\"\n- \"99.5\"\n- \"35.5\"\nNon-match examples:\n- \".5\"\n- \"100\"",
        "matches": [
            "1.5",
            "99.5",
            "35.5",
            "43",
            "64",
            "24"
        ],
        "non_matches": [
            ".5",
            "100",
            "0",
            "0.5",
            "34.3",
            "24.356",
            "36.55"
        ],
        "stress_tests": []
    },
    {
        "id": 2409,
        "expression": "https?://[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*(?:\\.[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*)*/\\S*",
        "raw_prompt": "HTTP(S) URL validator with embededded multi-part host name validator, RFC-compliant but does not validate length of components or overall length. Path portion after host name is free-form and will need refinement if you want to validate it.",
        "refined_prompt": "\nMatch examples:\n- \"http://www.example.com/ https://localhost/whatever\"\nNon-match examples:\n- \"http://www.example.com ftp://localhost/whatever\"",
        "matches": [
            "http://www.example.com/ https://localhost/whatever"
        ],
        "non_matches": [
            "http://www.example.com ftp://localhost/whatever"
        ],
        "stress_tests": []
    },
    {
        "id": 2410,
        "expression": "[A-Za-z0-9!#$%&'*+\\-/=?^_`{|}~]+(?:\\.[A-Za-z0-9!#$%&'*+\\-/=?^_`{|}~]+)*@[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*(?:\\.[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*)*",
        "raw_prompt": "Email address validator with embededded multi-part host name validator, RFC-compliant but does not validate length of components or overall length.",
        "refined_prompt": "\nMatch examples:\n- \"mike@localhost sue@example.com\"\nNon-match examples:\n- \"mike @localhost sue.@example.com\"",
        "matches": [
            "mike@localhost sue@example.com"
        ],
        "non_matches": [
            "mike @localhost sue.@example.com"
        ],
        "stress_tests": []
    },
    {
        "id": 2413,
        "expression": "(?<!/)/(\\w+\\.\\w+)?$",
        "raw_prompt": "Gets the file name from a URL including the \"/\". If the URL ends in \"/\" the \"/\" is matched.",
        "refined_prompt": "\nMatch examples:\n- \"/index.htm\"\n- \"/\"\n- \"/default.aspx\"\nNon-match examples:\n- \"google.com\"\n- \"hi everybody\"",
        "matches": [
            "/index.htm",
            "/",
            "/default.aspx"
        ],
        "non_matches": [
            "google.com",
            "hi everybody",
            "\\myFile.txt"
        ],
        "stress_tests": []
    },
    {
        "id": 2420,
        "expression": "\\d{4}\\s\\d{4}\\s\\d{4}\\s\\d{4}$",
        "raw_prompt": "Validate the Wii Code format. If you like to have slashes and spaces you can change the \"\\s\" for \"[\\s-]\"",
        "refined_prompt": "\nMatch examples:\n- \"1234 5678 9101 1121\"\n- \"0000 0000 0000 0000\"\n- \"8924 3578 3248 3212\"\nNon-match examples:\n- \"1234-5678-9101-1121\"\n- \"ABCD EFGH IJKL MNOP\"",
        "matches": [
            "1234 5678 9101 1121",
            "0000 0000 0000 0000",
            "8924 3578 3248 3212"
        ],
        "non_matches": [
            "1234-5678-9101-1121",
            "ABCD EFGH IJKL MNOP",
            "ABCD-1234 IJKL-4321"
        ],
        "stress_tests": []
    },
    {
        "id": 2421,
        "expression": "^(?=(.*[a-zA-Z].*){2,})(?=.*\\d.*)(?=.*\\W.*)[a-zA-Z0-9\\S]{8,15}$",
        "raw_prompt": "Strong passwords with min 8 - max 15 character length, at least two letters (not case sensitive), one number, one special character (all, not just defined), space is not allowed.",
        "refined_prompt": "\nMatch examples:\n- \"&test*81\"\n- \"te$tPa55word\"\n- \"testpass(7\"\nNon-match examples:\n- \"mypassword\"\n- \"pass%5\"",
        "matches": [
            "&test*81",
            "te$tPa55word",
            "testpass(7"
        ],
        "non_matches": [
            "mypassword",
            "pass%5",
            "test5324",
            "374833e**"
        ],
        "stress_tests": []
    },
    {
        "id": 2422,
        "expression": "^((([\\+][\\s]{0,1})|([0]{2}[\\s-]{0,1}))([358]{3})([\\s-]{0,1})|([0]{1}))(([1-9]{1}[0-9]{0,1})([\\s-]{0,1})([0-9]{2,4})([\\s-]{0,1})([0-9]{2,4})([\\s-]{0,1}))([0-9]{0,3}){1}$",
        "raw_prompt": "General phone number validation for Finland.\nIt will pass old and new format numbers.\nBetween numbers space or dash can be used ones.\nnumber has to start\n+358 or 00358 or 0\nare code can be 2 or 3 digit. I could not come with better idea then this",
        "refined_prompt": "\nMatch examples:\n- \"003589999999\"\n- \"00 358 999 999\"\n- \"00 358 9999 999\"\nNon-match examples:\n- \"050 999 9999 9999 999\"\n- \"151212\"",
        "matches": [
            "003589999999",
            "00 358 999 999",
            "00 358 9999 999",
            "00 358 999 9999",
            "091212",
            "09 99 99 99"
        ],
        "non_matches": [
            "050 999 9999 9999 999",
            "151212"
        ],
        "stress_tests": []
    },
    {
        "id": 2425,
        "expression": "^([0-2]{0,1})([0-3]{1})(\\.[0-9]{1,2})?$|^([0-1]{0,1})([0-9]{1})(\\.[0-9]{1,2})?$|^-?(24)(\\.[0]{1,2})?$|^([0-9]{1})(\\.[0-9]{1,2})?$",
        "raw_prompt": "Allows positive(non-negative) decimal values with 2 floating point values and less than or equal to 24.",
        "refined_prompt": "\nMatch examples:\n- \"23.50\"\n- \"20.80\"\n- \"23.99\"\nNon-match examples:\n- \"24.01\"\n- \"25\"",
        "matches": [
            "23.50",
            "20.80",
            "23.99",
            "24.00",
            "23",
            "20"
        ],
        "non_matches": [
            "24.01",
            "25",
            "20.900",
            "-20",
            "-25.50"
        ],
        "stress_tests": []
    },
    {
        "id": 2426,
        "expression": "^(02\\d\\s?\\d{4}\\s?\\d{4})|((01|05)\\d{2}\\s?\\d{3}\\s?\\d{4})|((01|05)\\d{3}\\s?\\d{5,6})|((01|05)\\d{4}\\s?\\d{4,5})$",
        "raw_prompt": "Based on the source listed below. I have added in the 05 prefix for allowing UK voip landlines. I dont know if the spacings are all ofcom approved like the original regex but the patterns it supports are:\n029 99999999 or 029 9999 9999; 0199 9999999 or 0199 999 9999; 01999 99999; 01999 999999; 019999 9999; 019999 99999; 0599 9999999 or 0599 999 9999; 05999 99999; 05999 999999; 059999 9999; 059999 99999;",
        "refined_prompt": "\nMatch examples:\n- \"020 1234 5678\"\n- \"0123 4567890\"\n- \"01234 456789\"\nNon-match examples:\n- \"02476 123456\"\n- \"0845 123456\"",
        "matches": [
            "020 1234 5678",
            "0123 4567890",
            "01234 456789",
            "05234 456789"
        ],
        "non_matches": [
            "02476 123456",
            "0845 123456",
            "07712 345678",
            "0800 100 2496"
        ],
        "stress_tests": []
    },
    {
        "id": 2427,
        "expression": "^(BE)[0-1]{1}[0-9]{9}$|^((BE)|(BE ))[0-1]{1}(\\d{3})([.]{1})(\\d{3})([.]{1})(\\d{3})",
        "raw_prompt": "VAT Number BE. Assumes BE followed by 0 or 1 or ' ' the digits will grouped by xxxxxxxxxx or xxxx.xxx.xxx. If you only want VAT numbers starting with 0 then replace [0-1]{1} with [0]",
        "refined_prompt": "\nMatch examples:\n- \"BE 0471.339.727\"\n- \"BE0471.339.727\"\n- \"BE0471339727\"\nNon-match examples:\n- \"BE 0471.3397.27\"\n- \"BE 047133972\"",
        "matches": [
            "BE 0471.339.727",
            "BE0471.339.727",
            "BE0471339727"
        ],
        "non_matches": [
            "BE 0471.3397.27",
            "BE 047133972",
            "0471339727"
        ],
        "stress_tests": []
    },
    {
        "id": 2430,
        "expression": "^(?=.*\\d)(?=.*[A-Za-z])(?!.*[!@#\\$%\\^&\\*\\(\\)\\+=\\|;'\"{}<>\\.\\?\\-_\\\\/:,~`]).{6,20}$",
        "raw_prompt": "Validates passwords to be 6-20 characters of letter and numbers and NO special characters (that appear on the keyboard). Adjust numbers at the end and remove special characters (after the \"(?!\") as needed. Numbers appear at the END to address an IE problem with zero-width look-aheads.",
        "refined_prompt": "\nMatch examples:\n- \"abc123\"\n- \"8e9272wi8\"\n- \"WEF896wdfso\"\nNon-match examples:\n- \"iD0notM@tch\"\n- \"n3itherDO_!\"",
        "matches": [
            "abc123",
            "8e9272wi8",
            "WEF896wdfso"
        ],
        "non_matches": [
            "iD0notM@tch",
            "n3itherDO_!"
        ],
        "stress_tests": []
    },
    {
        "id": 2431,
        "expression": "\\?<.+?>",
        "raw_prompt": "Matches the name portion of a named group. Useful for \"cleaning\" regular expressions for use with ASP controls (since they don't support named groups).",
        "refined_prompt": "\nMatch examples:\n- \"(?<myname>[a-zA-Z])\"\nNon-match examples:\n- \"([a-zA-Z])\"",
        "matches": [
            "(?<myname>[a-zA-Z])"
        ],
        "non_matches": [
            "([a-zA-Z])"
        ],
        "stress_tests": []
    },
    {
        "id": 2439,
        "expression": "^([a-z]{2,3}(\\.[a-zA-Z][a-zA-Z_$0-9]*)*)\\.([A-Z][a-zA-Z_$0-9]*)$",
        "raw_prompt": "Regular Expression for validating fully qualified Java Class Names that follows the Java Naming Conventions for widely available classes (see: http://java.sun.com/docs/books/jls/third_edition/html/names.html#6.8).\nGroup 1 gives the package name, group 3 gives the class name.",
        "refined_prompt": "\nMatch examples:\n- \"foo.Bar\"\n- \"foo.bar.IFBar1\"\n- \"wo.w_1.Ffo$o.Bar\"\nNon-match examples:\n- \"Bar\"\n- \"Foo.Bar\"",
        "matches": [
            "foo.Bar",
            "foo.bar.IFBar1",
            "wo.w_1.Ffo$o.Bar"
        ],
        "non_matches": [
            "Bar",
            "Foo.Bar",
            "foo.bar",
            "foo/Bar",
            "fooo.Bar"
        ],
        "stress_tests": []
    },
    {
        "id": 2440,
        "expression": "^(1(0|7|9)2?)\\.([01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\\.([01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\\.([01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])$",
        "raw_prompt": "validates private ip addresses\nneeds to be a bit more refined",
        "refined_prompt": "\nMatch examples:\n- \"10.10.10.10\"\n- \"192.168.16.4\"\n- \"172.016.22.55\"\nNon-match examples:\n- \"a.c.s.s\"\n- \"100.10.10.10\"",
        "matches": [
            "10.10.10.10",
            "192.168.16.4",
            "172.016.22.55"
        ],
        "non_matches": [
            "a.c.s.s",
            "100.10.10.10",
            "188.142.25.2",
            "651817"
        ],
        "stress_tests": []
    },
    {
        "id": 2441,
        "expression": "^(([a-zA-Z][a-zA-Z_$0-9]*(\\.[a-zA-Z][a-zA-Z_$0-9]*)*)\\.)?([a-zA-Z][a-zA-Z_$0-9]*)$",
        "raw_prompt": "Regular Expression for validating fully qualified Java Class Names that follows the Java Naming Conventions for local classes (see: http://java.sun.com/docs/books/jls/third_edition/html/names.html#6.8).\nGroup 2 gives the package name, group 4 gives the class name.",
        "refined_prompt": "\nMatch examples:\n- \"Bar\"\n- \"f.B1\"\n- \"fo_$1.bar.Foo.bar\"\nNon-match examples:\n- \"1Bar\"\n- \"foo-.Bar\"",
        "matches": [
            "Bar",
            "f.B1",
            "fo_$1.bar.Foo.bar"
        ],
        "non_matches": [
            "1Bar",
            "foo-.Bar",
            "foo/Bar"
        ],
        "stress_tests": []
    },
    {
        "id": 2443,
        "expression": "\\<script[^>]*>[\\w|\\t|\\r\\|\\W]*?</script>",
        "raw_prompt": "match all script blocks in html file or aspx file.",
        "refined_prompt": "\nMatch examples:\n- \"<script type=\"text/javascript\" src=\"test.js\"></script> <script> test </script\"\nNon-match examples:\n- \"<%=Get(\"Configurator\")%>\"",
        "matches": [
            "<script type=\"text/javascript\" src=\"test.js\"></script> <script> test </script"
        ],
        "non_matches": [
            "<%=Get(\"Configurator\")%>"
        ],
        "stress_tests": []
    },
    {
        "id": 2444,
        "expression": "^-?\\d+([.,]?\\d+)?$",
        "raw_prompt": "It just accepts negative and positive numeric entries. Dot (.) or comma (,) signs accepted only once.",
        "refined_prompt": "\nMatch examples:\n- \"43\"\n- \"-43\"\n- \"43.56\"\nNon-match examples:\n- \"ABC\"\n- \"A43\"",
        "matches": [
            "43",
            "-43",
            "43.56",
            "-43.56",
            "43,56",
            "-43,56"
        ],
        "non_matches": [
            "ABC",
            "A43",
            "43A",
            "43.A3",
            "-43.A3",
            "43.,56",
            "43.",
            "43,",
            ",56",
            ".56"
        ],
        "stress_tests": []
    },
    {
        "id": 2445,
        "expression": "^\\d+([.,]?\\d+)?$",
        "raw_prompt": "It just accepts only positive numbers. Also accepts Dot (.) and comma (,) signs only once.",
        "refined_prompt": "\nMatch examples:\n- \"43\"\n- \"43.56\"\n- \"43,56\"\nNon-match examples:\n- \"ABC\"\n- \"A43\"",
        "matches": [
            "43",
            "43.56",
            "43,56"
        ],
        "non_matches": [
            "ABC",
            "A43",
            "43A",
            "43.A3",
            "43.",
            "43,",
            ",56",
            ".56"
        ],
        "stress_tests": []
    },
    {
        "id": 2446,
        "expression": "^-?\\d+([^.,])?$",
        "raw_prompt": "Accepts positive and negative integers.",
        "refined_prompt": "\nMatch examples:\n- \"34\"\n- \"-34\"\n- \"1\"\nNon-match examples:\n- \"34.5\"\n- \"-34.5\"",
        "matches": [
            "34",
            "-34",
            "1",
            "-1",
            "1000000000",
            "-1000000000"
        ],
        "non_matches": [
            "34.5",
            "-34.5",
            "34,5",
            "-34,5",
            "34.",
            "34,",
            ".5",
            ",5"
        ],
        "stress_tests": []
    },
    {
        "id": 2447,
        "expression": "^\\d+([^.,])?$",
        "raw_prompt": "Accepts positive integers.",
        "refined_prompt": "\nMatch examples:\n- \"34\"\n- \"1\"\n- \"1000000000\"\nNon-match examples:\n- \"-34\"\n- \"-1\"",
        "matches": [
            "34",
            "1",
            "1000000000"
        ],
        "non_matches": [
            "-34",
            "-1",
            "-1000000000",
            "34.5",
            "-34.5",
            "34,5",
            "-34,5",
            "34.",
            "34,",
            ".5",
            ",5"
        ],
        "stress_tests": []
    },
    {
        "id": 2449,
        "expression": "(?:Error|Warning|Exception)",
        "raw_prompt": "Find any and all occurences of any of the three terms \"Error\" \"Warning\" \"Exception\" in a log or txt file.\nUse this as a filter with TextAnalysisTool.NET for quick parsing of log files when looking for errors",
        "refined_prompt": "\nMatch examples:\n- \"2009-11-07 08:04:49.401 UTC Warning w3wp.24 SoapUtilities.CreateException ThrowException: actor = http://servername.subdomain.domain.com:8530/SimpleAuthWebService/SimpleAuth.asmx, ID=9ea54fc1-1351-4fb3-a6a3-ba52d5bd4671, ErrorCode=InternalServerError, Message=, Client=?\"\nNon-match examples:\n- \"Any log/text file that does not contain the words in the expression\"",
        "matches": [
            "2009-11-07 08:04:49.401 UTC Warning w3wp.24 SoapUtilities.CreateException ThrowException: actor = http://servername.subdomain.domain.com:8530/SimpleAuthWebService/SimpleAuth.asmx, ID=9ea54fc1-1351-4fb3-a6a3-ba52d5bd4671, ErrorCode=InternalServerError, Message=, Client=?"
        ],
        "non_matches": [
            "Any log/text file that does not contain the words in the expression"
        ],
        "stress_tests": []
    },
    {
        "id": 2451,
        "expression": "^(?![DFIOQU])([ABCEGHJ-NPRSTVXY]\\d[A-Z][ ]\\d[A-Z]\\d)$",
        "raw_prompt": "Validates Canadian postal codes.\nFormat: A9A 9A9\nCannot contain: DFIOQU\nFirst letter must be one of: ABCEGHJKLMNPRSTVXY",
        "refined_prompt": "\nMatch examples:\n- \"A9A 9A9\"\n- \"T3P 6N1\"\nNon-match examples:\n- \"D9U 1O5\"",
        "matches": [
            "A9A 9A9",
            "T3P 6N1"
        ],
        "non_matches": [
            "D9U 1O5"
        ],
        "stress_tests": []
    },
    {
        "id": 2454,
        "expression": "^(ht|f)tp(s?)\\:\\/\\/(([a-zA-Z0-9\\-\\._]+(\\.[a-zA-Z0-9\\-\\._]+)+)|localhost)(\\/?)([a-zA-Z0-9\\-\\.\\?\\,\\'\\/\\\\\\+&amp;%\\$#_]*)?([\\d\\w\\.\\/\\%\\+\\-\\=\\&amp;\\?\\:\\\\\\&quot;\\'\\,\\|\\~\\;]*)$",
        "raw_prompt": "Validates URL to see if the input pattern is a valid URL (ftp, http, https, etc); can be easily modified to support others such as file:/// | Pattern has been tested using .NET runtime engine | localhost literal support for windows IIS server and visal studio (2005 or later) built-in asp.net web-server",
        "refined_prompt": "\nMatch examples:\n- \"http://regexlib.com\"\n- \"http://www.google.com\"\n- \"ftp://teach.me.regex/checkpattern/o\"\nNon-match examples:\n- \"http://\"\n- \"http://whoisyourdaddy\"",
        "matches": [
            "http://regexlib.com",
            "http://www.google.com",
            "ftp://teach.me.regex/checkpattern/o",
            "http://www.google.com/search?hl=en&source=hp&q=asp.net",
            "https://secure.mailserver.com",
            "http://localhost/mypage.html",
            "http://localhost:89783/mypage.aspx",
            "http://go.com",
            "http://forum.whoisyourdaddy.org/index.html?RegID=7449046&Daddy=dontknow&son=me"
        ],
        "non_matches": [
            "http://",
            "http://whoisyourdaddy",
            "httpOrhttpsOrftp.com"
        ],
        "stress_tests": []
    },
    {
        "id": 2459,
        "expression": "^<(?:@[a-z0-9][a-z0-9-]*[a-z0-9](?:\\.[a-z0-9][a-z0-9-]*[a-z0-9])+(?:,@[a-z0-9][a-z0-9-]*[a-z0-9](?:\\.[a-z0-9][a-z0-9-]*[a-z0-9])+)*:)?([a-zA-Z0-9!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]+(?:\\.[a-zA-Z0-9!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]+)*@[a-z0-9][a-z0-9-]*[a-z0-9](?:\\.[a-z0-9][a-z0-9-]*[a-z0-9])+)>$",
        "raw_prompt": "forward-path and reverse-path as defined in RFC 2821",
        "refined_prompt": "\nMatch examples:\n- \"<@arsec.sk,@beton.cz,@polo-domena.com:gkusnir@example.org>\"\nNon-match examples:\n- \"<@arsec.sk,@beton.cz, @polo-domena.com:gkusnir@example.org>\"",
        "matches": [
            "<@arsec.sk,@beton.cz,@polo-domena.com:gkusnir@example.org>"
        ],
        "non_matches": [
            "<@arsec.sk,@beton.cz, @polo-domena.com:gkusnir@example.org>"
        ],
        "stress_tests": []
    },
    {
        "id": 2461,
        "expression": "^[-\\w\\s\"'=/!@#%&,;:`~\\.\\$\\^\\{\\[\\(\\|\\)\\]\\}\\*\\+\\?\\\\]*$",
        "raw_prompt": "Anti-HTML pattern for english sentences. any < or > will make it not match.",
        "refined_prompt": "\nMatch examples:\n- \"Test *1 - 2% + $3=#7 ... ?! &lt;\"\nNon-match examples:\n- \"<a href=\"http:/acleditor.com\">CraigsListMultiplier</a>\"",
        "matches": [
            "Test *1 - 2% + $3=#7 ... ?! &lt;"
        ],
        "non_matches": [
            "<a href=\"http:/acleditor.com\">CraigsListMultiplier</a>"
        ],
        "stress_tests": []
    },
    {
        "id": 2463,
        "expression": "^[a-zA-Z0-9\\-]+\\.cn$",
        "raw_prompt": "select .cn from domain where nic.deleted",
        "refined_prompt": "\nMatch examples:\n- \"dotnetblog.cn\"\nNon-match examples:\n- \"dotnetblog.com.cn,dotnetblog.com.cn\"",
        "matches": [
            "dotnetblog.cn"
        ],
        "non_matches": [
            "dotnetblog.com.cn,dotnetblog.com.cn"
        ],
        "stress_tests": []
    },
    {
        "id": 2466,
        "expression": "\\A(.*?)\\s+(\\d+[a-zA-Z]{0,1}\\s{0,1}[-]{1}\\s{0,1}\\d*[a-zA-Z]{0,1}|\\d+[a-zA-Z-]{0,1}\\d*[a-zA-Z]{0,1})",
        "raw_prompt": "This pattern splits the streetname and housenumber of Dutch Postal Addresses.",
        "refined_prompt": "\nMatch examples:\n- \"Sophia van Teylingenstraat 19\"\n- \"Abrikozenstraat 116A\"\n- \"Laan van Meerdervoort 1218-1220\"\nNon-match examples:\n- \"none\"",
        "matches": [
            "Sophia van Teylingenstraat 19",
            "Abrikozenstraat 116A",
            "Laan van Meerdervoort 1218-1220",
            "Laan van Meerdervoort 1218 - 1220"
        ],
        "non_matches": [
            "none"
        ],
        "stress_tests": []
    },
    {
        "id": 2467,
        "expression": "^([a-zA-Z0-9]{1,15})$",
        "raw_prompt": "Simple validation reg ex that requires 1-15 alphanumeric characters",
        "refined_prompt": "\nMatch examples:\n- \"kazoosoft\"\n- \"tw33tfan\"\n- \"MediaOwls\"\nNon-match examples:\n- \"@lpha\"\n- \"bad\\username\"",
        "matches": [
            "kazoosoft",
            "tw33tfan",
            "MediaOwls"
        ],
        "non_matches": [
            "@lpha",
            "bad\\username",
            "badname1234567890"
        ],
        "stress_tests": []
    },
    {
        "id": 2470,
        "expression": "^([1-9]{0,1})([0-9]{1})((\\.[0-9]{0,1})([0-9]{1})|(\\,[0-9]{0,1})([0-9]{1}))?$",
        "raw_prompt": "Vat percentage format for Indian and Germany.Maximum two digit before decimal and after decimal",
        "refined_prompt": "\nMatch examples:\n- \"89.56\"\n- \"14.69\"\n- \"56,23\"\nNon-match examples:\n- \"100.56\"\n- \"25.365\"",
        "matches": [
            "89.56",
            "14.69",
            "56,23"
        ],
        "non_matches": [
            "100.56",
            "25.365",
            "125,56"
        ],
        "stress_tests": []
    },
    {
        "id": 2476,
        "expression": "(?!^[0-9 ]*$)(?!^[a-zA-Z ]*$)^([a-zA-Z0-9 ]{6,15})$",
        "raw_prompt": "This expression validates alphanumeric with one alphabet compulsory and one numeric compulsory and accepts minimum 6 characters and max 15 characters irrespective of the order and case.It doesnt accept special characters",
        "refined_prompt": "\nMatch examples:\n- \"1DAV100\"\nNon-match examples:\n- \"asdfgh,asd.123 etc.,\"",
        "matches": [
            "1DAV100"
        ],
        "non_matches": [
            "asdfgh,asd.123 etc.,"
        ],
        "stress_tests": []
    },
    {
        "id": 2480,
        "expression": "^[a-zA-Z]\\w{0,30}$",
        "raw_prompt": "A simple expression to verify a FORTRAN variable name to within 31 chars.",
        "refined_prompt": "\nMatch examples:\n- \"ABC1_1\"\n- \"ABcdef\"\n- \"abc_def_123\"\nNon-match examples:\n- \"1A\"\n- \"_ABC\"",
        "matches": [
            "ABC1_1",
            "ABcdef",
            "abc_def_123"
        ],
        "non_matches": [
            "1A",
            "_ABC",
            "a1234567890123456789012345678901"
        ],
        "stress_tests": []
    },
    {
        "id": 2482,
        "expression": "^[A-Za-z0-9_]+$",
        "raw_prompt": "This expression checks whether the string contains lower or uppercase characters and numbers from zero to nine and an underscore",
        "refined_prompt": "\nMatch examples:\n- \"ab_12\"\nNon-match examples:\n- \"%$\"",
        "matches": [
            "ab_12"
        ],
        "non_matches": [
            "%$"
        ],
        "stress_tests": []
    },
    {
        "id": 2485,
        "expression": "^\\d{1,6}\\040([A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,})$|^\\d{1,6}\\040([A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,})$|^\\d{1,6}\\040([A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,})$",
        "raw_prompt": "This will accept any 6 digit street address only, with min of two and up to four street names.",
        "refined_prompt": "\nMatch examples:\n- \"123456 My Street\"\n- \"123 West Main St\"\n- \"12345 Via De La Rosa\"\nNon-match examples:\n- \"123 Street\"\n- \"1234 W Side Street\"",
        "matches": [
            "123456 My Street",
            "123 West Main St",
            "12345 Via De La Rosa"
        ],
        "non_matches": [
            "123 Street",
            "1234 W Side Street"
        ],
        "stress_tests": []
    },
    {
        "id": 2486,
        "expression": "\\(\\d{3}\\)\\040\\d{3}-\\d{4}",
        "raw_prompt": "Phone Number in (###) ###-#### Format Only",
        "refined_prompt": "\nMatch examples:\n- \"(717) 899-9998\"\nNon-match examples:\n- \"(717)999-9999\"\n- \"999-999-9999\"",
        "matches": [
            "(717) 899-9998"
        ],
        "non_matches": [
            "(717)999-9999",
            "999-999-9999"
        ],
        "stress_tests": []
    },
    {
        "id": 2487,
        "expression": "\\(714|760|949|619|909|951|818|310|323|213|323|562|626\\)\\040\\d{3}-\\d{4}",
        "raw_prompt": "Phone Numbers Format (###) ###-#### with only SoCal Area Codes. Use or replace with Area Codes You need.",
        "refined_prompt": "\nMatch examples:\n- \"(714) 123-4567\"\n- \"(949) 555-5555\"\n- \"(323) 467-1070\"\nNon-match examples:\n- \"(808) 666-6666\"\n- \"(111)123-4567\"",
        "matches": [
            "(714) 123-4567",
            "(949) 555-5555",
            "(323) 467-1070"
        ],
        "non_matches": [
            "(808) 666-6666",
            "(111)123-4567",
            "Any Non SoCal Area Code"
        ],
        "stress_tests": []
    },
    {
        "id": 2488,
        "expression": "714|760|949|619|909|951|818|310|323|213|323|562|626-\\d{3}-\\d{4}",
        "raw_prompt": "Phone Number in ###-###-#### Format Only with Southern California Area Codes. Use or Replace Area Codes",
        "refined_prompt": "\nMatch examples:\n- \"714-333-3333\"\n- \"818-222-2222\"\n- \"323-333-3333\"\nNon-match examples:\n- \"808-123-4567\"\n- \"(808) 123-4567\"",
        "matches": [
            "714-333-3333",
            "818-222-2222",
            "323-333-3333"
        ],
        "non_matches": [
            "808-123-4567",
            "(808) 123-4567",
            "Any Non So Cal Area Code"
        ],
        "stress_tests": []
    },
    {
        "id": 2492,
        "expression": "^\\D{0,2}[0]{0,3}[1]{0,1}\\D{0,2}([2-9])(\\d{2})\\D{0,2}(\\d{3})\\D{0,2}(\\d{3})\\D{0,2}(\\d{1})\\D{0,2}$",
        "raw_prompt": "Very useful if you want to use ANY-NON-DIGIT as delimiter and return proper US-Phone-Number. Use \"($1) $2-$3$4\" to get Number in form: \"(234) 567-8901\".\nWill ignore starting 1, 01, 001, +1 etc.\nValidates and also captures AreaCode, Prefix and Suffix for reformatting.\nIn all matching examples, it will return the same result. I have not found any exception yet.",
        "refined_prompt": "\nMatch examples:\n- \"(234) 567-8901\"\n- \"+1-234-567-890-1\"\n- \"+001 2345678901\"\nNon-match examples:\n- \"12X345678901\"\n- \"23456789X01\"",
        "matches": [
            "(234) 567-8901",
            "+1-234-567-890-1",
            "+001 2345678901",
            "+1/234/567/890-1",
            "0012345678901",
            "X234X567X890X1X",
            "(+001)(234)(5678901)",
            "+1(234)5678901",
            "+1 234 567 890-1",
            "[234][567][890(1)]",
            "234/567/890/1",
            "12345678901"
        ],
        "non_matches": [
            "12X345678901",
            "23456789X01",
            "5678901"
        ],
        "stress_tests": []
    },
    {
        "id": 2494,
        "expression": "((&#[0-9]+|&[a-zA-Z]+[0-9]*?);)",
        "raw_prompt": "Matches HTML 'amp' codes",
        "refined_prompt": "\nMatch examples:\n- \"&reg;\"\n- \"&nbsp;\"\n- \"&#32;\"\nNon-match examples:\n- \"&32;\"",
        "matches": [
            "&reg;",
            "&nbsp;",
            "&#32;"
        ],
        "non_matches": [
            "&32;"
        ],
        "stress_tests": []
    },
    {
        "id": 2497,
        "expression": "^(?:mailto:)?(?:[a-z][\\w~%!&amp;',;=\\-\\.$\\(\\)\\*\\+]*)@(?:[a-z0-9][\\w\\-]*[a-z0-9]*\\.)*(?:(?:(?:[a-z0-9][\\w\\-]*[a-z0-9]*)(?:\\.[a-z0-9]+)?)|(?:(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)))$",
        "raw_prompt": "I think this is a very good e-mail validation match expression\nPS: you have got to try RegexBuddy it's a very cool tool that helps realy http://www.regexbuddy.com",
        "refined_prompt": "\nMatch examples:\n- \"mailto:support@regexbuddy.com\"\n- \"user@172.168.0.1\"\n- \"user%20name@domain.com\"\nNon-match examples:\n- \"@172.168.0.1\"\n- \"domain.com\"",
        "matches": [
            "mailto:support@regexbuddy.com",
            "user@172.168.0.1",
            "user%20name@domain.com",
            "admin@localhost"
        ],
        "non_matches": [
            "@172.168.0.1",
            "domain.com",
            "user%20name@domain.com/test"
        ],
        "stress_tests": []
    },
    {
        "id": 2500,
        "expression": "^(?:(?:\\.\\./)|/)?(?:\\w(?:[\\w`~!$=;\\-\\+\\.\\^\\(\\)\\|\\{\\}\\[\\]]|(?:%\\d\\d))*\\w?)?(?:/\\w(?:[\\w`~!$=;\\-\\+\\.\\^\\(\\)\\|\\{\\}\\[\\]]|(?:%\\d\\d))*\\w?)*(?:\\?[^#]+)?(?:#[a-z0-9]\\w*)?$",
        "raw_prompt": "parse/match url path with:\n1. optional relative path\n2. optional query string\n3. optional fragments",
        "refined_prompt": "\nMatch examples:\n- \"..//test/tesf\"\n- \"/cgi-bin/version.pl?r=fhjkjh%20ds&djj=fffsd#kit\"\n- \"index.html\"\nNon-match examples:\n- \".path./index.html\"\n- \"about:blank\"",
        "matches": [
            "..//test/tesf",
            "/cgi-bin/version.pl?r=fhjkjh%20ds&djj=fffsd#kit",
            "index.html",
            "/?q=test"
        ],
        "non_matches": [
            ".path./index.html",
            "about:blank",
            "..///test/tesf"
        ],
        "stress_tests": []
    },
    {
        "id": 2502,
        "expression": "^#[\\dA-Fa-f]{3}(?:[\\dA-Fa-f]{3}[\\dA-Fa-f]{0,2})?$",
        "raw_prompt": "matches # + 3 hex numbers + optional 3 more hex numbers and 2 more hex numbers for alpha\nPS: you have got to try RegexBuddy it's a very cool tool that helps realy http://www.regexbuddy.com",
        "refined_prompt": "\nMatch examples:\n- \"#fff\"\n- \"#123456\"\n- \"#12345678\"\nNon-match examples:\n- \"#1234\"\n- \"#0\"",
        "matches": [
            "#fff",
            "#123456",
            "#12345678",
            "#1f35cc"
        ],
        "non_matches": [
            "#1234",
            "#0",
            "#123456789"
        ],
        "stress_tests": []
    },
    {
        "id": 2507,
        "expression": "^[0-9#\\*abcdABCD]+$",
        "raw_prompt": "Tests expression for DTMF combinations (numbers 0-9, asterisk, octothorpe and A,B,C,D or a,b,c,d). Does not limit number of occurrences or their order.",
        "refined_prompt": "\nMatch examples:\n- \"*AB132#\"\n- \"12#AB*3\"\n- \"*c3d42a##\"\nNon-match examples:\n- \"r13\"\n- \"#bCz31*\"",
        "matches": [
            "*AB132#",
            "12#AB*3",
            "*c3d42a##"
        ],
        "non_matches": [
            "r13",
            "#bCz31*",
            "*%#"
        ],
        "stress_tests": []
    },
    {
        "id": 2512,
        "expression": "^[0-9]+(,[0-9]+)*$",
        "raw_prompt": "Parses comma-separated numbers. Doesn't allow spaces inbetween numbers and/or between numbers and commas. Allows single number to be added. Doesn't allow sequence to end with a comma.",
        "refined_prompt": "\nMatch examples:\n- \"1321\"\n- \"1321,0,42412\"\n- \"0,1,2,3,4\"\nNon-match examples:\n- \"1321,,42412\"\n- \"12c,13d,23\"",
        "matches": [
            "1321",
            "1321,0,42412",
            "0,1,2,3,4"
        ],
        "non_matches": [
            "1321,,42412",
            "12c,13d,23",
            "445,",
            "412 , 421, 4122",
            "42 4,41"
        ],
        "stress_tests": []
    },
    {
        "id": 2519,
        "expression": "^((\\+){1}91){1}[1-9]{1}[0-9]{9}$",
        "raw_prompt": "In this Pattern +91 will be the prefix in the Mobile number(of 10 digits).",
        "refined_prompt": "\nMatch examples:\n- \"+919123456789\"\nNon-match examples:\n- \"+91 9123456789\"\n- \"+91-9123456789\"",
        "matches": [
            "+919123456789"
        ],
        "non_matches": [
            "+91 9123456789",
            "+91-9123456789"
        ],
        "stress_tests": []
    },
    {
        "id": 2531,
        "expression": "^\\d{8,8}$|^[SC]{2,2}\\d{6,6}$",
        "raw_prompt": "Matches against a valid UK Limited company numer, either Scotland, Wales England or Northern Ireland. Either 8 numerical digits or SC followed by 6 numerical digits are allowed",
        "refined_prompt": "\nMatch examples:\n- \"12345678\"\n- \"SC123456\"\nNon-match examples:\n- \"123456789\"\n- \"AB123456\"",
        "matches": [
            "12345678",
            "SC123456"
        ],
        "non_matches": [
            "123456789",
            "AB123456",
            "a2345678"
        ],
        "stress_tests": []
    },
    {
        "id": 2532,
        "expression": "megaupload\\.com.*(?:\\?|&)(?:(?:folderi)?d|f)=([A-Z-a-z0-9]{8})",
        "raw_prompt": "Detects megaupload files and folders links.",
        "refined_prompt": "\nMatch examples:\n- \"http://www.megaupload.com/?d=QDNFF02H\"\n- \"http://www.megaupload.com/?f=TSNFLU2K\"\n- \"http://www.megaupload.com/xml/folderfiles.php?folderid=1DGR6C4H\"\nNon-match examples:\n- \"http://www.megaupload.com/?k=TSNFLU2K\"\n- \"http://www.megaupload.com/?f=TSNFLU#@\"",
        "matches": [
            "http://www.megaupload.com/?d=QDNFF02H",
            "http://www.megaupload.com/?f=TSNFLU2K",
            "http://www.megaupload.com/xml/folderfiles.php?folderid=1DGR6C4H"
        ],
        "non_matches": [
            "http://www.megaupload.com/?k=TSNFLU2K",
            "http://www.megaupload.com/?f=TSNFLU#@",
            "http://www.megaupload.com/xml/folderfiles.php?folderod=1DGR6C4H"
        ],
        "stress_tests": []
    },
    {
        "id": 2536,
        "expression": "\\$(\\d*)??,??(\\d*)??,??(\\d*)\\.(\\d*)",
        "raw_prompt": "This captures (for filters out non digits) numbers with or without commas (eg currency as above) in the correct order - the other examples I see here don't capture in right order for all combinations. It doesn't check lengths or leading digits or number of digits between commas- that is left as an exercise for the student.\nFirst example gives:[4],[234],[567],[89]\nSecond gives:\n[],[1],[234],[80]\nrather than the incorrect:\n[1],[],[234],[80]",
        "refined_prompt": "\nMatch examples:\n- \"$1,234,567.89\"\n- \"$1,234.80\"\n- \"$34.45\"\nNon-match examples:\n- \"$1,234\"\n- \"$123-45\"",
        "matches": [
            "$1,234,567.89",
            "$1,234.80",
            "$34.45",
            "$1234.5"
        ],
        "non_matches": [
            "$1,234",
            "$123-45",
            "$-123.00"
        ],
        "stress_tests": []
    },
    {
        "id": 2539,
        "expression": "^[89][0-9]{9}",
        "raw_prompt": "This will accept all the Mobile nos starting with 8 or 9 and having exactly 10 digits (total) or it must be blank",
        "refined_prompt": "\nMatch examples:\n- \"9323444432\"\n- \"8022234456\"\n- \"8812345678\"\nNon-match examples:\n- \"72\"\n- \"54353454\"",
        "matches": [
            "9323444432",
            "8022234456",
            "8812345678"
        ],
        "non_matches": [
            "72",
            "54353454",
            "01212",
            "7644321108",
            "79055",
            "asdfg",
            "12ase"
        ],
        "stress_tests": []
    },
    {
        "id": 2542,
        "expression": "^[\\d]{3}[\\s\\-]*[\\d]{3}[\\s\\-]*[\\d]{4}\\s*$",
        "raw_prompt": "Used to check US phone pattern",
        "refined_prompt": "\nMatch examples:\n- \"222-222-2222\"\n- \"333 333 3333\"\nNon-match examples:\n- \"3333333\"\n- \"3333-333-33\"",
        "matches": [
            "222-222-2222",
            "333 333 3333"
        ],
        "non_matches": [
            "3333333",
            "3333-333-33"
        ],
        "stress_tests": []
    },
    {
        "id": 2543,
        "expression": "background-image.[^<]*?;",
        "raw_prompt": "returns the background-image property with its value. It will not return the uppercase property value like Background-image.",
        "refined_prompt": "\nMatch examples:\n- \"<div style=\"overflow: hidden; background-image:url(https://d2img01/z/Badge/N8_5x2_75/Tall_buildings_lores.gif);\"\nNon-match examples:\n- \"<div style=\"overflow: hidden; Background-image:url(https://d2img01/z/Badge/N8_5x2_75/Tall_buildings_lores.gif);\"",
        "matches": [
            "<div style=\"overflow: hidden; background-image:url(https://d2img01/z/Badge/N8_5x2_75/Tall_buildings_lores.gif);"
        ],
        "non_matches": [
            "<div style=\"overflow: hidden; Background-image:url(https://d2img01/z/Badge/N8_5x2_75/Tall_buildings_lores.gif);"
        ],
        "stress_tests": []
    },
    {
        "id": 2547,
        "expression": "^(([01]?[0-9]{1,2}|2[0-4][0-9]|25[0-5])\\.){3}([01]?[0-9]{1,2}|2[0-4][0-9]|25[0-5])$",
        "raw_prompt": "This is a standard perl-compatible regexp for ip4 address validation",
        "refined_prompt": "\nMatch examples:\n- \"192.168.0.1\"\nNon-match examples:\n- \"192.259.800.1\"",
        "matches": [
            "192.168.0.1"
        ],
        "non_matches": [
            "192.259.800.1"
        ],
        "stress_tests": []
    },
    {
        "id": 2548,
        "expression": "^(000000[1-9])$|^(00000[1-9][0-9])$|^(0000[1-9][0-9][0-9])$|^(000[1-9][0-9][0-9][0-9])$|^(00[1-9][0-9][0-9][0-9][0-9])$|^(0[1-9][0-9][0-9][0-9][0-9][0-9])$|^([1-9][0-9][0-9][0-9][0-9][0-9][0-9])$",
        "raw_prompt": "This will check to see if the string entered is all digits and is seven digits long. It will allow for leading zeros and also not allow for all zeros to be entered.",
        "refined_prompt": "\nMatch examples:\n- \"0000001\"\n- \"1234567\"\n- \"0003344\"\nNon-match examples:\n- \"000012\"\n- \"12345678\"",
        "matches": [
            "0000001",
            "1234567",
            "0003344"
        ],
        "non_matches": [
            "000012",
            "12345678",
            "123456A"
        ],
        "stress_tests": []
    },
    {
        "id": 2549,
        "expression": "^((((0?[13578]|1[02])\\/([0-2]?[1-9]|20|3[0-1]))|((0?[469]|11)\\/([0-2]?[1-9]|20|30))|(0?2\\/([0-1]?[1-9]|2[0-8])))\\/((19|20)?\\d{2}))|(0?2\\/29\\/((19|20)?(04|08|12|16|20|24|28|32|36|40|44|48|52|56|60|64|68|72|76|80|84|88|92|96)|2000))$",
        "raw_prompt": "Check that a valid date has been entered. Uses mm/dd/yyyy or m/d/yy format or various combinations. Checks for valid leap years.",
        "refined_prompt": "\nMatch examples:\n- \"2/28/1990\"\n- \"2/29/1992\"\n- \"03/1/10\"\nNon-match examples:\n- \"2/29/90\"\n- \"11/31/2010\"",
        "matches": [
            "2/28/1990",
            "2/29/1992",
            "03/1/10"
        ],
        "non_matches": [
            "2/29/90",
            "11/31/2010"
        ],
        "stress_tests": []
    },
    {
        "id": 2550,
        "expression": "^[0-9][0-9,]*[0-9]$",
        "raw_prompt": "It is for Comma separated integer values only.it won't allow comma before and end string.\nValid Expression :\n123,345,4444444,56,6\nInvalid Expressions :\n12,@@34,fsff,333,\n,12,234,456\n34,567,3456,\n111,11fff,&*,fff,567\nthe above all invalid.",
        "refined_prompt": "\nMatch examples:\n- \"123,345,4444444,56,6\"\nNon-match examples:\n- \"12,@@34,fsff,333,\"",
        "matches": [
            "123,345,4444444,56,6"
        ],
        "non_matches": [
            "12,@@34,fsff,333,"
        ],
        "stress_tests": []
    },
    {
        "id": 2553,
        "expression": "^((0*[0-1]?[0-9]{1,2}\\.)|(0*((2[0-4][0-9])|(25[0-5]))\\.)){3}((0*[0-1]?[0-9]{1,2})|(0*((2[0-4][0-9])|(25[0-5]))))$",
        "raw_prompt": "Matches ip addresses. Takes into account trailing left zeros.",
        "refined_prompt": "\nMatch examples:\n- \"172.18.200.101\"\n- \"00172.18.200.001\"\n- \"172.255.255.255\"\nNon-match examples:\n- \"172.256.255.255\"\n- \"1072.255.255.255\"",
        "matches": [
            "172.18.200.101",
            "00172.18.200.001",
            "172.255.255.255"
        ],
        "non_matches": [
            "172.256.255.255",
            "1072.255.255.255",
            "172.255.255.1.1"
        ],
        "stress_tests": []
    },
    {
        "id": 2555,
        "expression": "\\b([A-CEGHJ-PR-TW-Z]{1}[A-CEGHJ-NPR-TW-Z]{1}(?<!BG|GB|NK|KN|TN|NT|ZZ))[0-9]{6}[A-DFM]{1}\\b",
        "raw_prompt": "First letter cannot be: D, F, I, Q, U, or V\nSecond letter cannot be: D, F, I, O, Q, U, or V\nThe first two character combinations BG, GB, NK, KN, TN, NT, and ZZ are not used.\nFollowed by 6 digits (0-9)\nFinished by a suffix: A, B, C, D, F, or M",
        "refined_prompt": "\nMatch examples:\n- \"JG103759A\"\n- \"AP019283D\"\n- \"AB103455B\"\nNon-match examples:\n- \"CK945723N\"\n- \"BG103442A\"",
        "matches": [
            "JG103759A",
            "AP019283D",
            "AB103455B",
            "SS345603D"
        ],
        "non_matches": [
            "CK945723N",
            "BG103442A",
            "NT834238A",
            "ZZ834758A"
        ],
        "stress_tests": []
    },
    {
        "id": 2566,
        "expression": "(<meta [.\\w\\W]*?\\>)|(<style [.\\w\\W]*?</style>)|(<link [.\\w\\W]*?\\>)|(<script [.\\w\\W]*?</script>)",
        "raw_prompt": "Parses the objects out from an html header. These objects are: meta, style, link, and script. Use with the multiline option to pull from multine scripts and styles.",
        "refined_prompt": "\nMatch examples:\n- \"<head runat=\"server\"> <title></title> <script type=\"text/javascript\"> // // function foo() { } // </script> <style type=\"text/css\"> /* ** ** */ .foo { font-size : large;} </style> <script src=\"includes/JScript1.js\" type=\"text/javascript\"></script> <link href=\"includes/Stylesheet1.css\" rel=\"stylesheet\" type=\"text/css\" /> <script type=\"text/javascript\"> // // function foo2() { } // </script> <style type=\"text/css\"> /* **\"\nNon-match examples:\n- \"Um....\"",
        "matches": [
            "<head runat=\"server\"> <title></title> <script type=\"text/javascript\"> // // function foo() { } // </script> <style type=\"text/css\"> /* ** ** */ .foo { font-size : large;} </style> <script src=\"includes/JScript1.js\" type=\"text/javascript\"></script> <link href=\"includes/Stylesheet1.css\" rel=\"stylesheet\" type=\"text/css\" /> <script type=\"text/javascript\"> // // function foo2() { } // </script> <style type=\"text/css\"> /* **"
        ],
        "non_matches": [
            "Um...."
        ],
        "stress_tests": []
    },
    {
        "id": 2567,
        "expression": "[NS] \\d{1,}(\\:[0-5]\\d){2}.{0,1}\\d{0,},[EW] \\d{1,}(\\:[0-5]\\d){2}.{0,1}\\d{0,}",
        "raw_prompt": "Latitude and longitude coordinates separated by a comma in the form:\nN 0:59:59.99,E 0:59:59.99 No restriction on degrees. Use split on comma to separate Latitude and Longitude then on colon and space for parts to convert into a decimal value.",
        "refined_prompt": "\nMatch examples:\n- \"N 50:54:44.99,W 4:59:11.0\"\n- \"N 38:55:02.90,W 76:59:31.19\"\n- \"N 22:16:42,E 114:09:32\"\nNon-match examples:\n- \"N 22:66:61,E 85:00:33\"\n- \"E 00:00:00.00,N 00:00:00.00\"",
        "matches": [
            "N 50:54:44.99,W 4:59:11.0",
            "N 38:55:02.90,W 76:59:31.19",
            "N 22:16:42,E 114:09:32"
        ],
        "non_matches": [
            "N 22:66:61,E 85:00:33",
            "E 00:00:00.00,N 00:00:00.00",
            "N00:00:00.00, E00:00:00.00"
        ],
        "stress_tests": []
    },
    {
        "id": 2568,
        "expression": "(?<=[[]tex[]]).*?(?=[[]/tex[]])",
        "raw_prompt": "This expression helps in finding any text inside [tex] \u2013 [/tex] tags. For example returns x+y=z for the following input [tex]x+y=z[/tex] Was written for parsing LaTex equations written by users in Html editor. Despite its\u2019 original purpose it can be used for matching of any arbitrary tags in squared brackets.",
        "refined_prompt": "\nMatch examples:\n- \"[tex]x+y=10[/tex]\"\n- \"[tex] i \\hbar {\\partial \\over \\partial t} \\Psi(x,\\,t)= -{\\hbar^2 \\over 2m} {\\partial^2 \\over \\partial x^2} \\Psi(x,\\,t)+ V(x)\\Psi(x,\\,t)\\, [/tex]\"\n- \"[tex] [/tex]\"\nNon-match examples:\n- \"No match [tex] [/tx]\"\n- \"[tex] NO match [tex]\"",
        "matches": [
            "[tex]x+y=10[/tex]",
            "[tex] i \\hbar {\\partial \\over \\partial t} \\Psi(x,\\,t)= -{\\hbar^2 \\over 2m} {\\partial^2 \\over \\partial x^2} \\Psi(x,\\,t)+ V(x)\\Psi(x,\\,t)\\, [/tex]",
            "[tex] [/tex]"
        ],
        "non_matches": [
            "No match [tex] [/tx]",
            "[tex] NO match [tex]",
            "[tx] No match [/tex]"
        ],
        "stress_tests": []
    },
    {
        "id": 2570,
        "expression": "(^[1-9]$)|(^10$)",
        "raw_prompt": "Matches the numbers 1-10 and only the numbers 1-10.",
        "refined_prompt": "\nMatch examples:\n- \"1\"\n- \"8\"\n- \"10\"\nNon-match examples:\n- \"0\"\n- \"11\"",
        "matches": [
            "1",
            "8",
            "10"
        ],
        "non_matches": [
            "0",
            "11",
            "99"
        ],
        "stress_tests": []
    },
    {
        "id": 2572,
        "expression": "^[A-Za-z]$",
        "raw_prompt": "Matches a string that contains exactly one letter in the range A-Z or a-z.",
        "refined_prompt": "\nMatch examples:\n- \"B\"\n- \"L\"\n- \"a\"\nNon-match examples:\n- \"BL\"\n- \"akz\"",
        "matches": [
            "B",
            "L",
            "a",
            "k",
            "z"
        ],
        "non_matches": [
            "BL",
            "akz",
            "Az"
        ],
        "stress_tests": []
    },
    {
        "id": 2573,
        "expression": "http://(www\\.)?([^\\.]+)\\.com",
        "raw_prompt": "This regex matches 'http://' optionally followed by 'www.' then starts a group and matches one or more of any character that is not a full stop/period (.) closes the group then matches '.com'.",
        "refined_prompt": "\nMatch examples:\n- \"http://www.yahoo.com\"\n- \"http://yahoo.com\"\nNon-match examples:\n- \"yahoo.com\"",
        "matches": [
            "http://www.yahoo.com",
            "http://yahoo.com"
        ],
        "non_matches": [
            "yahoo.com"
        ],
        "stress_tests": []
    },
    {
        "id": 2574,
        "expression": "[^\\u0009\\u000A\\u000D\\u0020-\\uD7FF\\uE000-\\uFFFD\\u10000-\\u10FFFF]",
        "raw_prompt": "RegEx to match Invalid XML character",
        "refined_prompt": "\nMatch examples:\n- \"\u0019\"\n- \"\b\"\n- \"\u0010\"\nNon-match examples:\n- \"abc\"\n- \"0x007F\"",
        "matches": [
            "\u0019",
            "\b",
            "\u0010"
        ],
        "non_matches": [
            "abc",
            "0x007F",
            "xyz"
        ],
        "stress_tests": []
    },
    {
        "id": 2577,
        "expression": "^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[^a-zA-Z0-9])(?!.*\\s).{8,20}$",
        "raw_prompt": "Password between 8 and 20 characters; must contain at least one lowercase letter, one uppercase letter, one numeric digit, and one special character, but cannot contain whitespace.",
        "refined_prompt": "\nMatch examples:\n- \"Abc1234#\"\n- \"abcD$123\"\n- \"A1b2&C3!\"\nNon-match examples:\n- \"abcd1234\"\n- \"AbCd!@#$\"",
        "matches": [
            "Abc1234#",
            "abcD$123",
            "A1b2&C3!"
        ],
        "non_matches": [
            "abcd1234",
            "AbCd!@#$",
            "Abc 123#"
        ],
        "stress_tests": []
    },
    {
        "id": 2580,
        "expression": "(<(!--|script)(.|\\n[^<])*(--|script)>)|(<|&lt;)(/?[\\w!?]+)\\s?[^<]*(>|&gt;)|(\\&[\\w]+\\;)",
        "raw_prompt": "Matches any text inside greater than less than characters. Can be used to remove HTML Markup including attributes and comments.",
        "refined_prompt": "\nMatch examples:\n- \"<p><font face=\"Trebuchet MS\" size=\"2\" >summary of </font></p>\"\n- \"<body><font face=\"Trebuchet MS\" size=\"2\" >Example 2</font></body>\"\n- \"<!-- Comment-->\"\nNon-match examples:\n- \"Regular Text\"\n- \"Regular Text2\"",
        "matches": [
            "<p><font face=\"Trebuchet MS\" size=\"2\" >summary of </font></p>",
            "<body><font face=\"Trebuchet MS\" size=\"2\" >Example 2</font></body>",
            "<!-- Comment-->"
        ],
        "non_matches": [
            "Regular Text",
            "Regular Text2",
            "Regular Text3"
        ],
        "stress_tests": []
    },
    {
        "id": 2581,
        "expression": "(\"(?:(?:(?:\\\\.)|[^\"\\\\\\r\\n])*)\"|'(?:(?:(?:\\\\.)|[^'\\\\\\r\\n])*)'|`(?:(?:(?:\\\\.)|[^`\\\\\\r\\n])*)`)|((?:-- .*)|(?:#.*)|(?:/\\*(?:(?:[^*]|\\*(?!/))*)\\*/))",
        "raw_prompt": "Isolates MySQL Query strings and comments. Lines that look like comments inside strings are not falsely recognised as comments. To strip comments from a MySQL Query, simply replace all matches with group 1",
        "refined_prompt": "\nMatch examples:\n- \"-- insurance\"\n- \"# renaming some primary keys\"\n- \"/**/\"\nNon-match examples:\n- \"ALTER TABLE table_insurance_covered\"",
        "matches": [
            "-- insurance",
            "# renaming some primary keys",
            "/**/",
            "\"hello -- this is not a comment\""
        ],
        "non_matches": [
            "ALTER TABLE table_insurance_covered"
        ],
        "stress_tests": []
    },
    {
        "id": 2586,
        "expression": "^(?=.*[!@#$%^&*()\\-_=+`~\\[\\]{}?|])(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9]).{8,20}$",
        "raw_prompt": "This should require all of the following: An uppercase letter, a lowercase letter, a number and a special character from the provided list. Lastly, it needs to be between 8 and 20 characters long.\nA lot of expressions I've found here don't require all four, this should. I'm pretty new at regex though, so I hope that other people will help strengthen this expression.\nWhen testing on this site, make sure you have the Case Insensitive checkbox turned off.",
        "refined_prompt": "\nMatch examples:\n- \"p2sSw@rd\"\n- \"p2sSw@rd#l0ngEr\"\n- \"abc#$%GH1\"\nNon-match examples:\n- \"p2ssw@rd\"\n- \"p2sSw@rd#l0ngErThisIs2l0ng\"",
        "matches": [
            "p2sSw@rd",
            "p2sSw@rd#l0ngEr",
            "abc#$%GH1"
        ],
        "non_matches": [
            "p2ssw@rd",
            "p2sSw@rd#l0ngErThisIs2l0ng",
            "abc123DEF"
        ],
        "stress_tests": []
    },
    {
        "id": 2588,
        "expression": "^#(\\d{6})|^#([A-F]{6})|^#([A-F]|[0-9]){6}",
        "raw_prompt": "Hexadecimal color values to validate the system must begin with a # symbol, which can be combination of numbers and letters AF, but the letters must be uppercase.",
        "refined_prompt": "\nMatch examples:\n- \"#000000\"\n- \"#FFFFFF\"\n- \"#000FFF\"\nNon-match examples:\n- \"#ffffff\"\n- \"#ABC\"",
        "matches": [
            "#000000",
            "#FFFFFF",
            "#000FFF",
            "#FFF000",
            "#A1B2C3"
        ],
        "non_matches": [
            "#ffffff",
            "#ABC",
            "#123",
            "#AJKSDD",
            "#a1b2c3",
            "abcdef",
            "123456"
        ],
        "stress_tests": []
    },
    {
        "id": 2591,
        "expression": "^([+]39)?\\s?((313)|(32[03789])|(33[013456789])|(34[0256789])|(36[0368])|(37[037])|(38[0389])|(39[0123]))[\\s-]?([\\d]{7})$",
        "raw_prompt": "This pattern matches italian mobile phone numbers:\n- Tim (330, 331, 333, 334, 335, 336, 337, 338, 339, 360, 363, 366, 368)\n- Vodafone Italia (340, 342, 345, 346, 347, 348, 349)\n- Wind (320, 323, 327, 328, 329, 380, 383, 388, 389)\n- 3 Italia (390, 391, 392, 393)\n- RFI (313)\n- virtual operators (370, 373, 377)",
        "refined_prompt": "\nMatch examples:\n- \"+393381234567\"\n- \"+39 3381234567\"\n- \"+39 338 1234567\"\nNon-match examples:\n- \"0039 338 1234567\"\n- \"(338)1234567\"",
        "matches": [
            "+393381234567",
            "+39 3381234567",
            "+39 338 1234567",
            "+39 338-1234567",
            "3381234567",
            "3381234567",
            "338 1234567",
            "338-1234567"
        ],
        "non_matches": [
            "0039 338 1234567",
            "(338)1234567",
            "338/1234567"
        ],
        "stress_tests": []
    },
    {
        "id": 2593,
        "expression": "^(?!0{1})\\d{6}",
        "raw_prompt": "Indian Postal has siz digit of length and does not start with zero",
        "refined_prompt": "\nMatch examples:\n- \"362265\"\n- \"1254215\"\n- \"256201\"\nNon-match examples:\n- \"021545\"",
        "matches": [
            "362265",
            "1254215",
            "256201"
        ],
        "non_matches": [
            "021545"
        ],
        "stress_tests": []
    },
    {
        "id": 2596,
        "expression": "^([a-zA-Z][a-zA-Z0-9+-.]*):((\\/\\/(((([a-zA-Z0-9\\-._~!$&'()*+,;=':]|(%[0-9a-fA-F]{2}))*)@)?((\\[((((([0-9a-fA-F]{1,4}:){6}|(::([0-9a-fA-F]{1,4}:){5})|(([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:){4})|((([0-9a-fA-F]{1,4}:)?[0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:){3})|((([0-9a-fA-F]{1,4}:){0,2}[0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:){2})|((([0-9a-fA-F]{1,4}:){0,3}[0-9a-fA-F]{1,4})?::[0-9a-fA-F]{1,4}:)|((([0-9a-fA-F]{1,4}:){0,4}[0-9a-fA-F]{1,4})?::))((([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4}))|(([0-9]|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5]))\\.([0-9]|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5]))\\.([0-9]|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5]))\\.([0-9]|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5])))))|((([0-9a-fA-F]{1,4}:){0,5}[0-9a-fA-F]{1,4})?::[0-9a-fA-F]{1,4})|((([0-9a-fA-F]{1,4}:){0,5}[0-9a-fA-F]{1,4})?::))|(v[0-9a-fA-F]+\\.[a-zA-Z0-9\\-._~!$&'()*+,;=':]+))\\])|(([0-9]|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5]))\\.([0-9]|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5]))\\.([0-9]|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5]))\\.([0-9]|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5])))|(([a-zA-Z0-9\\-._~!$&'()*+,;=']|(%[0-9a-fA-F]{2}))*))(:[0-9]*)?)((\\/([a-zA-Z0-9\\-._~!$&'()*+,;=':@]|(%[0-9a-fA-F]{2}))*)*))|(\\/?(([a-zA-Z0-9\\-._~!$&'()*+,;=':@]|(%[0-9a-fA-F]{2}))+(\\/([a-zA-Z0-9\\-._~!$&'()*+,;=':@]|(%[0-9a-fA-F]{2}))*)*)?))(\\?(([a-zA-Z0-9\\-._~!$&'()*+,;=':@\\/?]|(%[0-9a-fA-F]{2}))*))?((#(([a-zA-Z0-9\\-._~!$&'()*+,;=':@\\/?]|(%[0-9a-fA-F]{2}))*)))?$",
        "raw_prompt": "Manually derived this from the grammar in Appendix A of RFC3986 (Uniform Resource Identifier (URI): Generic Syntax).\nMatches anything that fits the generic syntax of a URI. Supports IPv6 hosts.",
        "refined_prompt": "\nMatch examples:\n- \"http://user:pwd@domain.com:123/dir/subdir/?qp1=v%d3&qp2=98#frag\"\n- \"http://192.168.0.0:123/dir/subdir/?qp1=v%d3&qp2=98#frag\"\n- \"svn+ssh://[D456::1234:4321]:123/dir/subdir/?qp1=v%d3&qp2=98#frag\"\nNon-match examples:\n- \"http://user:pwddomain.com:123/dir/subdir/?qp1=v%d3&qp2=98#frag\"\n- \"http://192.168.0.0:123/dir/subdir/?qp1=v%d&qp2=98#frag\"",
        "matches": [
            "http://user:pwd@domain.com:123/dir/subdir/?qp1=v%d3&qp2=98#frag",
            "http://192.168.0.0:123/dir/subdir/?qp1=v%d3&qp2=98#frag",
            "svn+ssh://[D456::1234:4321]:123/dir/subdir/?qp1=v%d3&qp2=98#frag"
        ],
        "non_matches": [
            "http://user:pwddomain.com:123/dir/subdir/?qp1=v%d3&qp2=98#frag",
            "http://192.168.0.0:123/dir/subdir/?qp1=v%d&qp2=98#frag",
            "svn+ssh://[D456::12344321]:123/dir/subdir/?qp1=v%d3&qp2=98#frag"
        ],
        "stress_tests": []
    },
    {
        "id": 2598,
        "expression": "^(\\+[1-9]\\d+) ([1-9]\\d+) ([1-9]\\d+)(\\-\\d+){0,1}$|^(0\\d+) ([1-9]\\d+)(\\-\\d+){0,1}$|^([1-9]\\d+)(\\-\\d+){0,1}$",
        "raw_prompt": "Matches a Din 5008 formatted phone number, except of \"special numbers\" like \"0180 5 12345\"",
        "refined_prompt": "\nMatch examples:\n- \"+49 12 3456789\"\n- \"+49 12 34567-89\"\n- \"012 3456789\"\nNon-match examples:\n- \"+49 012 3456789\"\n- \"+49 (0)12 3456789\"",
        "matches": [
            "+49 12 3456789",
            "+49 12 34567-89",
            "012 3456789",
            "1234567-89"
        ],
        "non_matches": [
            "+49 012 3456789",
            "+49 (0)12 3456789",
            "0180 5 12345"
        ],
        "stress_tests": []
    },
    {
        "id": 2602,
        "expression": "^\\w+\\.((?:\\w+\\.)+\\w+)$",
        "raw_prompt": "Drops the first subdomain from a domain name with at least one subdomain. Fails if the domain does not contain a subdomain.",
        "refined_prompt": "\nMatch examples:\n- \"www.google.com\"\n- \"www.wave.google.com\"\n- \"as.vcu.acadia.memco.edu\"\nNon-match examples:\n- \"google.com\"\n- \"microsoft.com\"",
        "matches": [
            "www.google.com",
            "www.wave.google.com",
            "as.vcu.acadia.memco.edu"
        ],
        "non_matches": [
            "google.com",
            "microsoft.com",
            "memco.edu"
        ],
        "stress_tests": []
    },
    {
        "id": 2603,
        "expression": "^[0-9]{4} {0,1}[A-Z]{2}$",
        "raw_prompt": "Check the Dutch postal code offical format of \"9999 AA\". Since it is often stored in a database without the space, this pattern allows 0 or 1 space.",
        "refined_prompt": "\nMatch examples:\n- \"9999 AA\"\n- \"9999AA\"\nNon-match examples:\n- \"9999 aa\"\n- \"9999?AA\"",
        "matches": [
            "9999 AA",
            "9999AA"
        ],
        "non_matches": [
            "9999 aa",
            "9999?AA"
        ],
        "stress_tests": []
    },
    {
        "id": 2606,
        "expression": "(?![A-Z](\\d)\\1{5,})(^[A-Z]{1,3}(\\d{6}|\\d{9})$)|(^\\d{9}[A-Z][0-9|A-Z]?$)",
        "raw_prompt": "Matches valid Medicare HIC number according to CMS specifications",
        "refined_prompt": "\nMatch examples:\n- \"H123456\"\n- \"XYZ123456789\"\n- \"123456789B\"\nNon-match examples:\n- \"H123\"\n- \"H999999\"",
        "matches": [
            "H123456",
            "XYZ123456789",
            "123456789B"
        ],
        "non_matches": [
            "H123",
            "H999999",
            "H1234XB"
        ],
        "stress_tests": []
    },
    {
        "id": 2618,
        "expression": "^[^iIoOqQ'-]{10,17}$",
        "raw_prompt": "Validates US VIN. It could be between 10 and 17 character in length and should never contain i, l, o, O, q, Q, ' or -.",
        "refined_prompt": "\nMatch examples:\n- \"12345awertasfggr\"\nNon-match examples:\n- \"12345qwertasfggr\"",
        "matches": [
            "12345awertasfggr"
        ],
        "non_matches": [
            "12345qwertasfggr"
        ],
        "stress_tests": []
    },
    {
        "id": 2620,
        "expression": "^((.){1,}(\\d){1,}(.){0,})$",
        "raw_prompt": "Does a very basic validation on Danish street addresses.\nIt ensures that the format \"Address No\" is honored, but also allows any char to be put after the address.\nThis is to ensure additions like floor, and which door it is. Ex. \"Addrees No Floor LeftDoor.\"\nEnjoy!",
        "refined_prompt": "\nMatch examples:\n- \"Teststreet 32\"\n- \"T\u00f8rststr\u00e6de 4\"\n- \"T\u00f8rststr\u00e6de 24 1. tv\"\nNon-match examples:\n- \"T\u00f8rststr\u00e6de\"\n- \"2 T\u00f8rststr\u00e6de\"",
        "matches": [
            "Teststreet 32",
            "T\u00f8rststr\u00e6de 4",
            "T\u00f8rststr\u00e6de 24 1. tv"
        ],
        "non_matches": [
            "T\u00f8rststr\u00e6de",
            "2 T\u00f8rststr\u00e6de"
        ],
        "stress_tests": []
    },
    {
        "id": 2626,
        "expression": "/\"(\\\\[\"\\\\]|[^\"])*(\"|$)|'(\\\\['\\\\]|[^'])*('|$)|(\\\\[\"'\\\\]|[^\\s\"'])+/g",
        "raw_prompt": "Intended for single line. JavaScript match() method (or equivalent) creates an array of values each of which is either an unquoted string of non-whitespace chars, or a quoted string which can contain whitespace, escaped quotes (\\' or \\\"), escaped escaped chars (\\\\), or be empty ('' or \"\"). Splits on whitespace AND splits on opening and closing quotes. An unclosed quote matches all until end of input. The Matching Example is ready for enclosure in single quotes. Output of Matching Example: [0]=a\n[1]=' b\"\\'b '\n[2]='b2'\n[3]=\"c\\\"'c\"\n[4]=\"d",
        "refined_prompt": "\nMatch examples:\n- \"a \\' b\"\\\\\\'b \\'\\'b2\\' \"c\\\\\"\\'c\" \"d\"\nNon-match examples:\n- \"only strings with <1 non-whitespace char\"",
        "matches": [
            "a \\' b\"\\\\\\'b \\'\\'b2\\' \"c\\\\\"\\'c\" \"d"
        ],
        "non_matches": [
            "only strings with <1 non-whitespace char"
        ],
        "stress_tests": []
    },
    {
        "id": 2631,
        "expression": "^(([0-1][0-9]|2[0-3])[0-5][0-9]\\-([0-1][0-9]|2[0-3])[0-5][0-9]|[C|c]losed)$",
        "raw_prompt": "This allows for a single line input of open and close times (for a store/office).",
        "refined_prompt": "\nMatch examples:\n- \"0700-1530\"\n- \"1130-2310\"\n- \"Closed\"\nNon-match examples:\n- \"0700\"\n- \"Not open\"",
        "matches": [
            "0700-1530",
            "1130-2310",
            "Closed",
            "closed",
            "0000-2359"
        ],
        "non_matches": [
            "0700",
            "Not open",
            "0700-2400",
            "3159-0761"
        ],
        "stress_tests": []
    },
    {
        "id": 2634,
        "expression": "\\d{1,2}(/|-)\\d{1,2}(/|-)\\d{2,4}",
        "raw_prompt": "This is regular expression for date.\neg.:02/06/2010\n2/6/10\n02-06-2010\n2-6-10",
        "refined_prompt": "\nMatch examples:\n- \"02/06/2010\"\nNon-match examples:\n- \"02 June 2010\"",
        "matches": [
            "02/06/2010"
        ],
        "non_matches": [
            "02 June 2010"
        ],
        "stress_tests": []
    },
    {
        "id": 2635,
        "expression": "^\\.{0,2}[\\/\\\\]",
        "raw_prompt": "Will match any web path that's supposed to start in the root (e.g. with \"/\" in front of it.",
        "refined_prompt": "\nMatch examples:\n- \"./some/file.html \\this\\is\\a.file ../blah/blah\"\nNon-match examples:\n- \"path\\in\\current.folder\"",
        "matches": [
            "./some/file.html \\this\\is\\a.file ../blah/blah"
        ],
        "non_matches": [
            "path\\in\\current.folder"
        ],
        "stress_tests": []
    },
    {
        "id": 2643,
        "expression": "^([_a-zA-Z0-9-]+(\\.[_a-zA-Z0-9-]+)*@[a-zA-Z0-9-]+(\\.[a-zA-Z0-9-]+)*\\.(([0-9]{1,3})|([a-zA-Z]{2,})))(;[ ]?[_a-zA-Z0-9-]+(\\.[_a-zA-Z0-9-]+)*@[a-zA-Z0-9-]+(\\.[a-zA-Z0-9-]+)*\\.(([0-9]{1,3})|([a-zA-Z]{2,})))*$",
        "raw_prompt": "Matches a semi-colon-delimited string of email addresses. Delimiter can include a space after the semi-colon. Based on/thanks to David Huyck's pattern, with the domain extension opened up and specific extensions removed.",
        "refined_prompt": "\nMatch examples:\n- \"jdude@yahoo.com\"\n- \"jdude@yahoo.com; janedoe@hotmail.com\"\n- \"jdude@yahoo.com; janedoe@hotmail.com; billybob@127.0.0.1\"\nNon-match examples:\n- \"jdudeyahoo.com\"\n- \"jdude@yahoo.com or janedoe@hotmail.com\"",
        "matches": [
            "jdude@yahoo.com",
            "jdude@yahoo.com; janedoe@hotmail.com",
            "jdude@yahoo.com; janedoe@hotmail.com; billybob@127.0.0.1"
        ],
        "non_matches": [
            "jdudeyahoo.com",
            "jdude@yahoo.com or janedoe@hotmail.com",
            "jdude@yahoo.com, janedoe@hotmail.com, billybob@127.0.0.1"
        ],
        "stress_tests": []
    },
    {
        "id": 2648,
        "expression": "^(3[0-1]|2[0-9]|1[0-9]|0[1-9])(0[0-9]|1[0-9]|2[0-3])([0-5][0-9])\\sUTC\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s[0-9]{2}$",
        "raw_prompt": "In military messages and communications (e.g. on naval charts, or maps showing troop movements) the format is DDHHMMZ Mon YY, so for instance, \"271545Z FEB 08\" represents 15:45 Zulu time (which is to say UTC) on the 27th of February, 2008.\nFor Radio Navigational Warnings (RNWs), the international format is slightly different, using the explicit UTC text instead of the Zulu character, becoming \"DDhhmm UTC Jun YY\". E.g. \"240923 UTC Jun 10\" is \"9:23am on 24th June 2010\".",
        "refined_prompt": "\nMatch examples:\n- \"312359 UTC Jun 99\"\nNon-match examples:\n- \"322567 UTC June 1999\"",
        "matches": [
            "312359 UTC Jun 99"
        ],
        "non_matches": [
            "322567 UTC June 1999"
        ],
        "stress_tests": []
    },
    {
        "id": 2649,
        "expression": "^[\\w]+[-\\.\\w]*@[-\\w]+\\.[a-z]{2,6}(\\.[a-z]{2,6})?$",
        "raw_prompt": "@ Before you can have underlined, connection, point character, @there are three points after the characters are not allowed",
        "refined_prompt": "\nMatch examples:\n- \"abc@cde.com\"\n- \"abd@def.com.cn\"\n- \"a2b_cd3-2fg.ss@a2bd5_sd-mbv.com.cn\"\nNon-match examples:\n- \"abc@ccddme.my.com.cn\"",
        "matches": [
            "abc@cde.com",
            "abd@def.com.cn",
            "a2b_cd3-2fg.ss@a2bd5_sd-mbv.com.cn"
        ],
        "non_matches": [
            "abc@ccddme.my.com.cn"
        ],
        "stress_tests": []
    },
    {
        "id": 2654,
        "expression": "^(\\d+\\.\\d+)$",
        "raw_prompt": "This will validate atleast minimum of one digit in either side of Decimal point",
        "refined_prompt": "\nMatch examples:\n- \"1.22\"\n- \"12.23\"\n- \"123.123\"\nNon-match examples:\n- \"1..\"\n- \".\"",
        "matches": [
            "1.22",
            "12.23",
            "123.123"
        ],
        "non_matches": [
            "1..",
            ".",
            "123.",
            ".213"
        ],
        "stress_tests": []
    },
    {
        "id": 2655,
        "expression": "^\\s*[+-]?\\s*(?:\\d{1,3}(?:(,?)\\d{3})?(?:\\1\\d{3})*(\\.\\d*)?|\\.\\d+)\\s*$",
        "raw_prompt": "Matches numbers. May include decimals, thousands separators, and sign.",
        "refined_prompt": "\nMatch examples:\n- \"5,000\"\n- \"- 10\"\n- \".1\"\nNon-match examples:\n- \"7.000.000\"\n- \"5,0000\"",
        "matches": [
            "5,000",
            "- 10",
            ".1"
        ],
        "non_matches": [
            "7.000.000",
            "5,0000",
            "1.000,000"
        ],
        "stress_tests": []
    },
    {
        "id": 2662,
        "expression": "^([9]{1})([234789]{1})([0-9]{8})$",
        "raw_prompt": "Its 10 digits Indian Mobile Number validation.",
        "refined_prompt": "\nMatch examples:\n- \"9829373514\"\nNon-match examples:\n- \"919829373514\"\n- \"09829373514\"",
        "matches": [
            "9829373514"
        ],
        "non_matches": [
            "919829373514",
            "09829373514"
        ],
        "stress_tests": []
    },
    {
        "id": 2663,
        "expression": "^([Aa][LKSZRAEPlkszraep]|[Cc][AOTaot]|[Dd][ECec]|[Ff][LMlm]|[Gg][AUau]|[Hh][Ii]|[Ii][ADLNadln]|[Kk][SYsy]|[Ll][Aa]|[Mm][ADEHINOPSTadehinopst]|[Nn][CDEHJMVYcdehjmvy]|[Oo][HKRhkr]|[Pp][ARWarw]|[Rr][Ii]|[Ss][CDcd]|[Tt][NXnx]|[Uu][Tt]|[Vv][AITait]|[Ww][AIVYaivy])$",
        "raw_prompt": "This is just a simple US states and territories in 2 character regex. Requires valid 2 letter abbreviations. It accepts the Lower and Upper Case Entries.",
        "refined_prompt": "\nMatch examples:\n- \"MN\"\n- \"tx\"\n- \"Tx\"\nNon-match examples:\n- \"M\"\n- \"23\"",
        "matches": [
            "MN",
            "tx",
            "Tx"
        ],
        "non_matches": [
            "M",
            "23",
            "Alaska",
            "zz"
        ],
        "stress_tests": []
    },
    {
        "id": 2664,
        "expression": "([0-9][0-9])((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))\\-([0-9][0-9])\\-([0-9][0-9][0-9][0-9])",
        "raw_prompt": "Simple Malaysian New IC Number Validation.\nLength: 8 characters.\nFormat: YYMMDD-99-9999",
        "refined_prompt": "\nMatch examples:\n- \"900120-01-5567\"\nNon-match examples:\n- \"909020-01-5567\"\n- \"900120-0A-5567\"",
        "matches": [
            "900120-01-5567"
        ],
        "non_matches": [
            "909020-01-5567",
            "900120-0A-5567",
            "900120-01-55"
        ],
        "stress_tests": []
    },
    {
        "id": 2665,
        "expression": "^([EV])?\\d{3,3}(\\.\\d{1,2})?$",
        "raw_prompt": "validates an ICD9 medical code which MAY start with an E or V, 3 digits, and MAY be followed by a period and a 1-2 digit sub-code",
        "refined_prompt": "\nMatch examples:\n- \"123.45\"\n- \"E123.45\"\n- \"V123.45\"\nNon-match examples:\n- \"e123\"\n- \"X123\"",
        "matches": [
            "123.45",
            "E123.45",
            "V123.45",
            "456.7",
            "E456.7",
            "V456.7",
            "987",
            "E987",
            "V987"
        ],
        "non_matches": [
            "e123",
            "X123",
            "e123.4",
            "e123.45",
            "E12345"
        ],
        "stress_tests": []
    },
    {
        "id": 2666,
        "expression": "^([EV])?\\d{3,3}(\\.\\d{1,2})?(, *([EV])?\\d{3,3}(\\.\\d{1,2})?)*$",
        "raw_prompt": "See my sigle ICD9 validator for ICD9 rules. This does the same, and validates for comma delitter (with optiona space after comma)",
        "refined_prompt": "\nMatch examples:\n- \"E123\"\n- \"E123.45, V456.6\"\n- \"V456,E987.2, 123.45\"\nNon-match examples:\n- \"E123V456\"\n- \"E123, x\"",
        "matches": [
            "E123",
            "E123.45, V456.6",
            "V456,E987.2, 123.45"
        ],
        "non_matches": [
            "E123V456",
            "E123, x",
            "12;467.789"
        ],
        "stress_tests": []
    },
    {
        "id": 2667,
        "expression": "^\\d{4,4}[A-Z0-9]$",
        "raw_prompt": "a CPT code is a 4 digits + a captial letter or number (forming 5 character code). The CPT code describes a medical procedure",
        "refined_prompt": "\nMatch examples:\n- \"0001F\"\n- \"21082\"\nNon-match examples:\n- \"F0123\"\n- \"0001f\"",
        "matches": [
            "0001F",
            "21082"
        ],
        "non_matches": [
            "F0123",
            "0001f",
            "100F"
        ],
        "stress_tests": []
    },
    {
        "id": 2671,
        "expression": "^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,8}[a-zA-Z0-9]$",
        "raw_prompt": "This expression will validate user name with the following rules\n1- It must start and end with a digit or character\n2- It must be exactly 4 to 10 character long\n3- Allowed Special Characters are _.-",
        "refined_prompt": "\nMatch examples:\n- \"1.ma\"\n- \"user\"\n- \"ma_mo-on.r\"\nNon-match examples:\n- \"_user\"\n- \"asfd@12\"",
        "matches": [
            "1.ma",
            "user",
            "ma_mo-on.r"
        ],
        "non_matches": [
            "_user",
            "asfd@12",
            "user."
        ],
        "stress_tests": []
    },
    {
        "id": 2674,
        "expression": "^([0-1]?[0-9]|[2][0-3]):([0-5][0-9]):([0-5][0-9])$",
        "raw_prompt": "match time for : H:nn:ss or HH:nn:ss",
        "refined_prompt": "\nMatch examples:\n- \"01:00:59\"\n- \"1:59:00\"\n- \"23:59:59\"\nNon-match examples:\n- \"24:00:00\"",
        "matches": [
            "01:00:59",
            "1:59:00",
            "23:59:59"
        ],
        "non_matches": [
            "24:00:00"
        ],
        "stress_tests": []
    },
    {
        "id": 2677,
        "expression": "^(([0-2]\\d|[3][0-1])\\/([0]\\d|[1][0-2])\\/[2][0]\\d{2})$|^(([0-2]\\d|[3][0-1])\\/([0]\\d|[1][0-2])\\/[2][0]\\d{2}\\s00\\:00\\:00)$",
        "raw_prompt": "This expression will parse the date with zero time span only (e.g. 26/07/2010 00:00:00)",
        "refined_prompt": "\nMatch examples:\n- \"26/07/2010 00:00:00\"\nNon-match examples:\n- \"26/07/2010 10:00:00\"\n- \"26/07/2010 10:34:14\"",
        "matches": [
            "26/07/2010 00:00:00"
        ],
        "non_matches": [
            "26/07/2010 10:00:00",
            "26/07/2010 10:34:14"
        ],
        "stress_tests": []
    },
    {
        "id": 2679,
        "expression": "[-+]?((\\.[0-9]+|[0-9]+\\.[0-9]+)([eE][-+][0-9]+)?|[0-9]+)",
        "raw_prompt": "Used in my SVG parser.\nExplanation:\nMay start with + or -. This is followed by either an integer, or a float (\"dot numbers\", \"numbers dot numbers\" or \"numbers dot\" followed by an optional scientific postfix (+ or - followed by numbers) )\nI'm using it to parse lists of floats, add ^$ boundaries if you want it to match whole lines.",
        "refined_prompt": "\nMatch examples:\n- \"10.2\"\n- \".0\"\n- \"3.9265e+2\"\nNon-match examples:\n- \"-one\"\n- \".\"",
        "matches": [
            "10.2",
            ".0",
            "3.9265e+2",
            "5"
        ],
        "non_matches": [
            "-one",
            ".",
            "whatever"
        ],
        "stress_tests": []
    },
    {
        "id": 2682,
        "expression": "(?<=(,|;|:))\\s(?=((?:(?!<).)*>))",
        "raw_prompt": "Needing a way to shrink HTML based email to the smallest amount of characters, we wanted to remove any extra unnecessary white space characters in attributes such as style. This finds any space with a proceeding comma, semi-colon, or colon, and then checks with a lookahead for the closing > with a negative lookbehind to make sure that a < opening does not exist. The secondary trailing look behind is done to make sure that it does not change any content contained in the element.",
        "refined_prompt": "\nMatch examples:\n- \"<table width=\"750px\" cellpadding=\"0\" cellspacing=\"0\" style=\"font-family: Arial , Helvetica , Sans-Serif ; font-size: 10pt;\">\"\nNon-match examples:\n- \"<td>1, 2, 3</td>\"",
        "matches": [
            "<table width=\"750px\" cellpadding=\"0\" cellspacing=\"0\" style=\"font-family: Arial , Helvetica , Sans-Serif ; font-size: 10pt;\">"
        ],
        "non_matches": [
            "<td>1, 2, 3</td>"
        ],
        "stress_tests": []
    },
    {
        "id": 2683,
        "expression": "(\\d{2}\\.\\d{3}\\.\\d{3}\\/\\d{4}\\-\\d{2})|(\\d{3}\\.\\d{3}\\.\\d{3}\\-\\d{2})",
        "raw_prompt": "Valida e mascara CNPJ ou CPF dependendo do valor informado. Se informado dois digitos mais o ponto, ser\u00e1 mascarado CNPJ se nao , CPF",
        "refined_prompt": "\nMatch examples:\n- \"12.123.123/1234-11\"\n- \"123.123.123-12\"\nNon-match examples:\n- \"qualquer letra\"",
        "matches": [
            "12.123.123/1234-11",
            "123.123.123-12"
        ],
        "non_matches": [
            "qualquer letra"
        ],
        "stress_tests": []
    },
    {
        "id": 2684,
        "expression": "^([1-9]+\\d{0,2},(\\d{3},)*\\d{3}(\\.\\d{1,2})?|[1-9]+\\d*(\\.\\d{1,2})?)$",
        "raw_prompt": "Accepts non-negative numbers with max two decimals. Commas can be added after every thousand.",
        "refined_prompt": "\nMatch examples:\n- \"1200\"\n- \"1,200\"\n- \"1,200.0\"\nNon-match examples:\n- \"-43\"\n- \"0\"",
        "matches": [
            "1200",
            "1,200",
            "1,200.0",
            "12,324,532.23"
        ],
        "non_matches": [
            "-43",
            "0",
            "01,423,534.23",
            "24.4223",
            "32,42,123"
        ],
        "stress_tests": []
    },
    {
        "id": 2687,
        "expression": "jquery\\-(\\d|\\.)*\\.min\\.js",
        "raw_prompt": "Checks for filename of any version of minified jquery in string.",
        "refined_prompt": "\nMatch examples:\n- \"jquery-1.4.2.min.js\"\nNon-match examples:\n- \"jquery.js, jquery-1.3.2.js\"",
        "matches": [
            "jquery-1.4.2.min.js"
        ],
        "non_matches": [
            "jquery.js, jquery-1.3.2.js"
        ],
        "stress_tests": []
    },
    {
        "id": 2694,
        "expression": "(http|ftp|https):\\/\\/(\\w[\\w\\-_\\.]*\\.)?([_\\-\\w]+)(:[0-9]+)?([\\/[\\w_\\.-]+]*)\\/(\\.?\\w[\\w._-]*[\\w_-])?(#\\w+)?([\\w\\-\\.,@?^=%&amp;:\\~\\+#]*[\\w\\-\\@?^=%&amp;\\/\\~\\+#])?",
        "raw_prompt": "divides an url into the different parts: protocol, subdomain, tld, port, folder, file, anchor, parameter",
        "refined_prompt": "\nMatch examples:\n- \"http://www.example.com/folder/file.php#anchor?parameter=value\"\nNon-match examples:\n- \"www.example.com\"",
        "matches": [
            "http://www.example.com/folder/file.php#anchor?parameter=value"
        ],
        "non_matches": [
            "www.example.com"
        ],
        "stress_tests": []
    },
    {
        "id": 2696,
        "expression": "^\\s*((31([-/ ])((0?[13578])|(1[02]))\\3(\\d\\d)?\\d\\d)|((([012]?[1-9])|([123]0))([-/ ])((0?[13-9])|(1[0-2]))\\12(\\d\\d)?\\d\\d)|(((2[0-8])|(1[0-9])|(0?[1-9]))([-/ ])0?2\\22(\\d\\d)?\\d\\d)|(29([-/ ])0?2\\25(((\\d\\d)?(([2468][048])|([13579][26])|(0[48])))|((([02468][048])|([13579][26]))00))))\\s*$",
        "raw_prompt": "This .NET regular expression matches all valid dates in dd/MM/yyyy , dd-MM-yyyy or dd MM yyyy formats between 1/1/0000 and 31/12/9999 with the leading zero for the day and month portions being optional. The century for the year is optional for all dates except for the 29th of February of century years divisible by 400. This expression also validates the 29th of February for leap years, defined as (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0).",
        "refined_prompt": "\nMatch examples:\n- \"29-2-2000\"\n- \"31/12/9999\"\n- \"1 1 0000\"\nNon-match examples:\n- \"29/2/1900\"\n- \"29/02/2001\"",
        "matches": [
            "29-2-2000",
            "31/12/9999",
            "1 1 0000",
            "29/02/0000",
            "8/3/9841"
        ],
        "non_matches": [
            "29/2/1900",
            "29/02/2001",
            "31/04/2000",
            "28/02-1934",
            "1/13/1978"
        ],
        "stress_tests": []
    },
    {
        "id": 2699,
        "expression": "^[0-9]*[1-9]+[0-9]*$",
        "raw_prompt": "Allows only positive integers that are greater than 0. Also allows for infinite zeros leading the integer\nBased on William Powell's Pattern Title, but modified to allow for leading zeros.",
        "refined_prompt": "\nMatch examples:\n- \"1\"\n- \"12\"\n- \"124\"\nNon-match examples:\n- \"-1\"\n- \"a\"",
        "matches": [
            "1",
            "12",
            "124",
            "01",
            "0012",
            "000124"
        ],
        "non_matches": [
            "-1",
            "a",
            "1.0",
            "0000"
        ],
        "stress_tests": []
    },
    {
        "id": 2700,
        "expression": "^([A-Za-z]{6}[0-9lmnpqrstuvLMNPQRSTUV]{2}[abcdehlmprstABCDEHLMPRST]{1}[0-9lmnpqrstuvLMNPQRSTUV]{2}[A-Za-z]{1}[0-9lmnpqrstuvLMNPQRSTUV]{3}[A-Za-z]{1})|([0-9]{11})$",
        "raw_prompt": "Pattern to verify Codice Fiscale Italiano (TIN, Tax Identification Number).\nInclude verification of Codice Fiscale to natural, artificial, legal and juristic person, with and without OMOCODIA (verifica del codice fiscale per persone fisiche e persone giuridiche, anche in caso di omocodia).\nCodice Fiscale, CF, omocodia, persone fisiche, persone giuridiche, italian fiscal code, TIN, Tax Identification Number.",
        "refined_prompt": "\nMatch examples:\n- \"VRDGPP13R10B293P\"\n- \"VRDGPP13R10B29PP\"\n- \"12345678901\"\nNon-match examples:\n- \"VRDGPP13R10B293\"\n- \"VRDGPP13R10B29BP\"",
        "matches": [
            "VRDGPP13R10B293P",
            "VRDGPP13R10B29PP",
            "12345678901"
        ],
        "non_matches": [
            "VRDGPP13R10B293",
            "VRDGPP13R10B29BP",
            "1234567890"
        ],
        "stress_tests": []
    },
    {
        "id": 2701,
        "expression": "^[0-9a-zA-Z]+([0-9a-zA-Z]*[-._+])*[0-9a-zA-Z]+@[0-9a-zA-Z]+([-.][0-9a-zA-Z]+)*([0-9a-zA-Z]*[.])[a-zA-Z]{2,6}$",
        "raw_prompt": "Pattern to verify email addresses. Take a look at match / not match. It works very well. E-mail, email, mail, e-mail address, email address, mail address.",
        "refined_prompt": "\nMatch examples:\n- \"john-smith@example.com\"\n- \"john.smith@example.com\"\n- \"john_smith@x-ample.com\"\nNon-match examples:\n- \".john-smith@example.com\"\n- \"@example.com\"",
        "matches": [
            "john-smith@example.com",
            "john.smith@example.com",
            "john_smith@x-ample.com"
        ],
        "non_matches": [
            ".john-smith@example.com",
            "@example.com",
            "johnsmith@example."
        ],
        "stress_tests": []
    },
    {
        "id": 2703,
        "expression": "[0](\\d{9})|([0](\\d{2})( |-|)((\\d{3}))( |-|)(\\d{4}))|[0](\\d{2})( |-|)(\\d{7})|(\\+|00|09)(\\d{2}|\\d{3})( |-|)(\\d{2})( |-|)((\\d{3}))( |-|)(\\d{4})",
        "raw_prompt": "allows validation of phone numbers in different formats, including local dialing code (eg 033 or 076) or international dialing code in the formats +12 or 0012 or 0912.",
        "refined_prompt": "\nMatch examples:\n- \"073-386-2612\"\n- \"0443862612\"\n- \"076 858 7777\"\nNon-match examples:\n- \"qdsq11123\"",
        "matches": [
            "073-386-2612",
            "0443862612",
            "076 858 7777",
            "+27 76 858 7777",
            "0027 765877777",
            "0956 33 8881234"
        ],
        "non_matches": [
            "qdsq11123"
        ],
        "stress_tests": []
    },
    {
        "id": 2707,
        "expression": "<img\\s((width|height|alt|align|style)=\"[^\"]*\"\\s)*src=\"(\\/?[a-z0-9_-]\\/?)+\\.(png|jpg|jpeg|gif)\"(\\s(width|height|alt|align|style)=\"[^\"]*\")*\\s*\\/>",
        "raw_prompt": "Will match an image with the most common attributes.",
        "refined_prompt": "\nMatch examples:\n- \"<img width=\"80\" height=\"80\" style=\"border: none\" src=\"img/fluffy.jpg\" alt=\"cat\"/>\"\nNon-match examples:\n- \"<img src=\"img/fluffy\" >\"",
        "matches": [
            "<img width=\"80\" height=\"80\" style=\"border: none\" src=\"img/fluffy.jpg\" alt=\"cat\"/>"
        ],
        "non_matches": [
            "<img src=\"img/fluffy\" >"
        ],
        "stress_tests": []
    },
    {
        "id": 2708,
        "expression": "(([+]?34) ?)?(6(([0-9]{8})|([0-9]{2} [0-9]{6})|([0-9]{2} [0-9]{3} [0-9]{3}))|9(([0-9]{8})|([0-9]{2} [0-9]{6})|([1-9] [0-9]{7})|([0-9]{2} [0-9]{3} [0-9]{3})|([0-9]{2} [0-9]{2} [0-9]{2} [0-9]{2})))",
        "raw_prompt": "This regular expression allows to verify mobile phone numbers (600) and telephone numbers (900). Not provide premium charging phones (line 800). The number may be separated by spaces in groups of three digits, or one group of three number plus two groups of three numbers for fixed phones.",
        "refined_prompt": "\nMatch examples:\n- \"952 566 009\"\n- \"+34 615 977 911\"\n- \"967 90 23 44\"\nNon-match examples:\n- \"802 59 23 09\"\n- \"677 90 23 44\"",
        "matches": [
            "952 566 009",
            "+34 615 977 911",
            "967 90 23 44"
        ],
        "non_matches": [
            "802 59 23 09",
            "677 90 23 44",
            "67 7 809 235"
        ],
        "stress_tests": []
    },
    {
        "id": 2710,
        "expression": "^([1-9][0-9]?|100)%$",
        "raw_prompt": "Matches a percentage between 1 and 100. Accepts up to 2 decimal places. No decimal places accepted.",
        "refined_prompt": "\nMatch examples:\n- \"1%\"\n- \"52%\"\n- \"100%\"\nNon-match examples:\n- \"0%\"\n- \"100\"",
        "matches": [
            "1%",
            "52%",
            "100%"
        ],
        "non_matches": [
            "0%",
            "100",
            "101%",
            "52",
            "52.4%"
        ],
        "stress_tests": []
    },
    {
        "id": 2714,
        "expression": "(\\<!--\\s*.*?((--\\>)|$))",
        "raw_prompt": "matches comments <!-- --> in string. Singleline option must be enabled. It works well also with multiple comment start tags such as: <!--this is comment <!--and this as well and end-- of comment\nis!-- >right now-->. It also matches comments in between script or style tags <script> <!-- --> </script>",
        "refined_prompt": "\nMatch examples:\n- \"<!-- comment <!-- continuing -- >and ends now-->\"\nNon-match examples:\n- \"< !-- not comment -->, <a href=\"--\">, all other html code\"",
        "matches": [
            "<!-- comment <!-- continuing -- >and ends now-->"
        ],
        "non_matches": [
            "< !-- not comment -->, <a href=\"--\">, all other html code"
        ],
        "stress_tests": []
    },
    {
        "id": 2715,
        "expression": "(\\<\\?php\\s+.*?((\\?\\>)|$))",
        "raw_prompt": "Get code in between php tag <?php and ?> or until end of string if end of tag not found. Singleline option must be enabled!",
        "refined_prompt": "\nMatch examples:\n- \"<?php this is code in php ?>\"\nNon-match examples:\n- \"text outside php tag\"",
        "matches": [
            "<?php this is code in php ?>"
        ],
        "non_matches": [
            "text outside php tag"
        ],
        "stress_tests": []
    },
    {
        "id": 2725,
        "expression": "(?!000)(?!666)^([0-8]\\d{2})(\\d{2})(\\d{4})$",
        "raw_prompt": "Validates SSN for INTEGERS ONLY. This does not allow spaces or dashes.\nFollowing this info:\nhttp://www.socialsecurity.gov/employer/randomization.html\nStarting in June 2011, the SSA will begin randomizing SSN creation. The only exclusions are SSNs beginning with 000, 666, or 900-999. That rather simplifies things.",
        "refined_prompt": "\nMatch examples:\n- \"001191873\"\n- \"667191873\"\n- \"899191873\"\nNon-match examples:\n- \"000191873\"\n- \"666191873\"",
        "matches": [
            "001191873",
            "667191873",
            "899191873"
        ],
        "non_matches": [
            "000191873",
            "666191873",
            "901191873"
        ],
        "stress_tests": []
    },
    {
        "id": 2727,
        "expression": "^[^'<>?%!\\s]{1,20}$",
        "raw_prompt": "Disallow ' or < or > or ? or % or ! or space in a string. Minimum character is 1 and maximum is 20 in a string.",
        "refined_prompt": "\nMatch examples:\n- \"abcd123\"\n- \"--+abc\"\nNon-match examples:\n- \"abc'123\"\n- \"abc?\"",
        "matches": [
            "abcd123",
            "--+abc"
        ],
        "non_matches": [
            "abc'123",
            "abc?",
            "abc abc",
            "<script>"
        ],
        "stress_tests": []
    },
    {
        "id": 2735,
        "expression": "^([0-9][0-9])[.]([0-9][0-9])[.]([0-9][0-9])$",
        "raw_prompt": "Versioning in XX.YY.ZZ format",
        "refined_prompt": "\nMatch examples:\n- \"01.02.23\"\nNon-match examples:\n- \"1.2.3\"",
        "matches": [
            "01.02.23"
        ],
        "non_matches": [
            "1.2.3"
        ],
        "stress_tests": []
    },
    {
        "id": 2740,
        "expression": "[\\\\\"\"=/>](25[0-4]|2[0-4][0-9]|1\\d{2}|\\d{2})\\.((25[0-4]|2[0-4][0-9]|1\\d{2}|\\d{1,2})\\.){2}(25[0-4]|2[0-4][0-9]|1\\d{2}|\\d{2}|[1-9])\\b[\\\\\"\"=:;,/<]",
        "raw_prompt": "This expression is ideal used for \"identifying some plain application configuration files that contain any form of ip addresses, with or without port number followed and with protocol at the beginning\".\n[\\\\\"\"=/] can be removed on both ends to seach IPs in text files, but with it, it has better accuracy - there are version numbers in the application configuration files.\nIt also does not match IPs that have one digit at the first number.",
        "refined_prompt": "\nMatch examples:\n- \"/172.21.134.89: /127.0.0.1: \"14.14.14.14\"\"\nNon-match examples:\n- \"\"255.255.255.255\" \"243.243.2.0\" \"2.222.222.222\" /2224.2224.2224.2224:\"",
        "matches": [
            "/172.21.134.89: /127.0.0.1: \"14.14.14.14\""
        ],
        "non_matches": [
            "\"255.255.255.255\" \"243.243.2.0\" \"2.222.222.222\" /2224.2224.2224.2224:"
        ],
        "stress_tests": []
    },
    {
        "id": 2742,
        "expression": "\\b(1(?!27\\.0\\.0\\.1)\\d{1,2}|2[0-4][0-9]|25[0-4]|\\d{1,2})\\.(?:\\d{1,3}\\.){2}(25[0-5]|2[0-4][0-9]|1\\d{2}|\\d{2}|[1-9])\\b",
        "raw_prompt": "Match all IP addresses other than 127.0.0.1. It dose not match an IP has 0 at the last number",
        "refined_prompt": "\nMatch examples:\n- \"172.21.134.89 127.1.1.1 7.0.0.1 214.214.214.214\"\nNon-match examples:\n- \"127.0.0.1 192.168.1.0 255.255.255.255\"",
        "matches": [
            "172.21.134.89 127.1.1.1 7.0.0.1 214.214.214.214"
        ],
        "non_matches": [
            "127.0.0.1 192.168.1.0 255.255.255.255"
        ],
        "stress_tests": []
    },
    {
        "id": 2743,
        "expression": "[\\\\\"\"=:;,](([\\w][\\w\\-\\.]*)\\.)?([\\w][\\w\\-]+)(\\.([\\w][\\w\\.]*))?\\\\sql\\d{1,3}[\\\\\"\"=:;,]",
        "raw_prompt": "This expression is ideal used for \"identifying some plain application configuration files that contain any form of MSSQL database/instance reference in connection string\". Dose not match .\\sql. [\\\\\"\"=/] can be removed on both ends to seach server/instance in text files, but with it, it has better accuracy",
        "refined_prompt": "\nMatch examples:\n- \"=abc\\sql022, =abc.e.f.g\\sql078, =192.168.1.1\\sql001, =234\\sql003,\"\nNon-match examples:\n- \"sql .\\sql003\"",
        "matches": [
            "=abc\\sql022, =abc.e.f.g\\sql078, =192.168.1.1\\sql001, =234\\sql003,"
        ],
        "non_matches": [
            "sql .\\sql003"
        ],
        "stress_tests": []
    },
    {
        "id": 2750,
        "expression": "(^\\d{1,9})+(,\\d{1,9})*$",
        "raw_prompt": "Positive Whole number matched from 0 to 9999999. Only 9 digits length is allowed in every comma separated value.Can be easily changed to modify the length of the comma separated values.",
        "refined_prompt": "\nMatch examples:\n- \"123,158,19\"\n- \"123456789,9568523,1\"\n- \"1,2,3\"\nNon-match examples:\n- \"0,0,\"\n- \",3444,0999\"",
        "matches": [
            "123,158,19",
            "123456789,9568523,1",
            "1,2,3"
        ],
        "non_matches": [
            "0,0,",
            ",3444,0999",
            "1234567890,25689,1425"
        ],
        "stress_tests": []
    },
    {
        "id": 2753,
        "expression": "^(((19|2\\d)\\d{2}\\/(((0?[13578]|1[02])\\/31)|((0?[1,3-9]|1[0-2])\\/(29|30))))|((((19|2\\d)(0[48]|[2468][048]|[13579][26])|(2[048]00)))\\/0?2\\/29)|((19|2\\d)\\d{2})\\/((0?[1-9])|(1[0-2]))\\/(0?[1-9]|1\\d|2[0-8]))$",
        "raw_prompt": "this expression validates a date-time field in yyyy/m/d format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1900-2999, and all 2 digits years except 00",
        "refined_prompt": "\nMatch examples:\n- \"2008/2/29\"\n- \"2010/12/31\"\n- \"2400/02/29\"\nNon-match examples:\n- \"2009/2/29\"\n- \"2010/11/31\"",
        "matches": [
            "2008/2/29",
            "2010/12/31",
            "2400/02/29"
        ],
        "non_matches": [
            "2009/2/29",
            "2010/11/31",
            "2100/02/29"
        ],
        "stress_tests": []
    },
    {
        "id": 2754,
        "expression": "^(((1[6-9]|[2-9]\\d)\\d{2}\\/(((0?[13578]|1[02])\\/31)|((0?[1,3-9]|1[0-2])\\/(29|30))))|((((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))\\/0?2\\/29)|((1[6-9]|[2-9]\\d)\\d{2})\\/((0?[1-9])|(1[0-2]))\\/(0?[1-9]|1\\d|2[0-8]))$",
        "raw_prompt": "this expression validates a date-time field in yyyy/m/d format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00",
        "refined_prompt": "\nMatch examples:\n- \"2008/2/29\"\n- \"2010/12/31\"\n- \"2400/02/29\"\nNon-match examples:\n- \"2009/2/29\"\n- \"2010/11/31\"",
        "matches": [
            "2008/2/29",
            "2010/12/31",
            "2400/02/29"
        ],
        "non_matches": [
            "2009/2/29",
            "2010/11/31",
            "2100/02/29"
        ],
        "stress_tests": []
    },
    {
        "id": 2755,
        "expression": "^(((1[6-9]|[2-9]\\d)\\d{2}([-|\\/])(((0?[13578]|1[02])([-|\\/])31)|((0?[1,3-9]|1[0-2])([-|\\/])(29|30))))|((((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))([-|\\/])0?2([-|\\/])29)|((1[6-9]|[2-9]\\d)\\d{2})([-|\\/])((0?[1-9])|(1[0-2]))([-|\\/])(0?[1-9]|1\\d|2[0-8]))$",
        "raw_prompt": "this expression validates a date-time field in yyyy/m/d or yyyy-m-d format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00",
        "refined_prompt": "\nMatch examples:\n- \"2008/2/29\"\n- \"2010/12/31\"\n- \"2400-02-29\"\nNon-match examples:\n- \"2009/2/29\"\n- \"2010/11/31\"",
        "matches": [
            "2008/2/29",
            "2010/12/31",
            "2400-02-29"
        ],
        "non_matches": [
            "2009/2/29",
            "2010/11/31",
            "2100-02-29"
        ],
        "stress_tests": []
    },
    {
        "id": 2756,
        "expression": "^(((1[6-9]|[2-9]\\d)\\d{2}([-|\\/])(((0?[13578]|1[02])([-|\\/])31)|((0?[1,3-9]|1[0-2])([-|\\/])(29|30))))|((((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))([-|\\/])0?2([-|\\/])29)|((1[6-9]|[2-9]\\d)\\d{2})([-|\\/])((0?[1-9])|(1[0-2]))([-|\\/])(0?[1-9]|1\\d|2[0-8]))(\\s)((([0]?[1-9]|1[0-2])(:|\\.)[0-5][0-9]((:|\\.)[0-5][0-9])?(\\s)?([aApP][mM]))|(([0]?[0-9]|1[0-9]|2[0-3])(:|\\.)[0-5][0-9]((:|\\.)[0-5][0-9])?))$",
        "raw_prompt": "this expression validates a date-time field in yyyy/m/d h:m:s or yyyy-m-d h:m:s format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00.\nMatches times seperated by either : or . will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.",
        "refined_prompt": "\nMatch examples:\n- \"2008/2/29 8:25:59\"\n- \"2010/12/31 11:25AM\"\n- \"2400-02-29 09:30\"\nNon-match examples:\n- \"2009/2/29 8:25:59\"\n- \"2010/11/31 11:25AM\"",
        "matches": [
            "2008/2/29 8:25:59",
            "2010/12/31 11:25AM",
            "2400-02-29 09:30"
        ],
        "non_matches": [
            "2009/2/29 8:25:59",
            "2010/11/31 11:25AM",
            "2100-02-29 09:30"
        ],
        "stress_tests": []
    },
    {
        "id": 2757,
        "expression": "^(0?[1-9]|[12][0-9]|3[01])[- /.](0?[1-9]|1[012])[- /.](19|20)?[0-9]{2}? ?((([0-1]?\\d)|(2[0-3])):[0-5]\\d)?(:[0-5]\\d)? ?([a,p,A,P][m,M])?$",
        "raw_prompt": "Regex to match date and or time either in 12 or 24 hour format.\nIt will also allow for am/pm with mixed cases.",
        "refined_prompt": "\nMatch examples:\n- \"31-12-2010 14:15:22\"\n- \"1.1.2010 00:00:00\"\n- \"2/1/2010\"\nNon-match examples:\n- \"1.31.2011\"\n- \"31.1.2011 1455\"",
        "matches": [
            "31-12-2010 14:15:22",
            "1.1.2010 00:00:00",
            "2/1/2010",
            "31/1/2011 05:22 pm"
        ],
        "non_matches": [
            "1.31.2011",
            "31.1.2011 1455",
            "31.1.2011 14 pm"
        ],
        "stress_tests": []
    },
    {
        "id": 2761,
        "expression": "^([1-9]\\d*|0)(([.,]\\d*[1-9])?)$",
        "raw_prompt": "Positive real multi-digit number: don't allow preciding zero, last decimal digit zero not allowed.",
        "refined_prompt": "\nMatch examples:\n- \"1500\"\n- \"0,331\"\n- \"12.005\"\nNon-match examples:\n- \"01500\"\n- \"0,330\"",
        "matches": [
            "1500",
            "0,331",
            "12.005"
        ],
        "non_matches": [
            "01500",
            "0,330",
            "012.0050"
        ],
        "stress_tests": []
    },
    {
        "id": 2762,
        "expression": "^[^<>`~!/@\\#},.?\"-$%:;)(_ ^{&*=|'+]+$",
        "raw_prompt": "This regular expression will remove all invalid chars from a string",
        "refined_prompt": "\nMatch examples:\n- \"AdnanSattar\"\nNon-match examples:\n- \"Adnan=Sattar\"",
        "matches": [
            "AdnanSattar"
        ],
        "non_matches": [
            "Adnan=Sattar"
        ],
        "stress_tests": []
    },
    {
        "id": 2763,
        "expression": "^[a-zA-Z]{1}[\\w\\sa-zA-Z\\d_]*[^\\s]$",
        "raw_prompt": "Username start only with alphabet, and then can combine with any digit, space, and underscore. Reject other special character and space in the begin and the end of characters.",
        "refined_prompt": "\nMatch examples:\n- \"Dodol 123\"\n- \"Dodol_garut\"\n- \"dodol li pret 5 kali\"\nNon-match examples:\n- \"23dodol\"\n- \"_dodol garut\"",
        "matches": [
            "Dodol 123",
            "Dodol_garut",
            "dodol li pret 5 kali"
        ],
        "non_matches": [
            "23dodol",
            "_dodol garut",
            "dodol . / d"
        ],
        "stress_tests": []
    },
    {
        "id": 2764,
        "expression": "^(\\d+(,\\d+)*)+$",
        "raw_prompt": "Evaluates an 'n' series of non decimal numbers separated by a coma",
        "refined_prompt": "\nMatch examples:\n- \"1\"\n- \"1,2,3,4,5\"\n- \"1234,54321,0987654321\"\nNon-match examples:\n- \",1\"\n- \"1,2,3,\"",
        "matches": [
            "1",
            "1,2,3,4,5",
            "1234,54321,0987654321"
        ],
        "non_matches": [
            ",1",
            "1,2,3,",
            "1.2,2.3,3"
        ],
        "stress_tests": []
    },
    {
        "id": 2768,
        "expression": "^(?-i:A[DEFGILMNOQRSTUWZ]|B[ABDEFGHIJMNORSTVWYZ]|C[ACDFGHIKLMNORSUVXYZ]|D[EJKMOZ]|E[CEGHRST]|F[IJKMOR]|G[ABDEFHILMNPQRSTUWY]|H[KMNRTU]|I[DELNOQRST]|J[MOP]|K[EGHIMNPRWYZ]|L[ABCIKRSTUVY]|M[ACDGHKLMNOPQRSTUVWXYZ]|N[ACEFGILOPRUZ]|O[M]|P[AEFGHKLMNRSTWY]|QA|R[EOUW]|S[ABCDEGHIJKLMNORTVYZ]|T[CDFGHJKLMNORTVWZ]|U[AGMSYZ]|V[ACEGINU]|W[FS]|Y[ET]|Z[AMW])$",
        "raw_prompt": "Matches against the two character country abbreviations (as of 2010).\n\"AD\",\"AE\",\"AF\",\"AG\",\"AI\",\"AL\",\"AM\",\"AN\",\"AO\",\"AQ\",\"AR\",\"AS\",\"AT\",\"AU\",\"AW\",\"AZ\",\"BA\",\"BB\",\"BD\",\"BE\",\"BF\",\"BG\",\"BH\",\"BI\",\"BJ\",\"BM\",\"BN\",\"BO\",\"BR\",\"BS\",\"BT\",\"BV\",\"BW\",\"BY\",\"BZ\",\"CA\",\"CC\",\"CD\",\"CF\",\"CG\",\"CH\",\"CI\",\"CK\",\"CL\",\"CM\",\"CN\",\"CO\",\"CR\",\"CS\",\"CU\",\"CV\",\"CX\",\"CY\",\"CZ\",\"DE\",\"DJ\",\"DK\",\"DM\",\"DO\",\"DZ\",\"EC\",\"EE\",\"EG\",\"EH\",\"ER\",\"ES\",\"ET\",\"FI\",\"FJ\",\"FK\",\"FM\",\"FO\",\"FR\",\"GA\",\"GB\",\"GD\",\"GE\",\"GF\",\"GH\",\"GI\",\"GL\",\"GM\",\"GN\",\"GP\",\"GQ\",\"GR\",\"GS\",\"GT\",\"GU\",\"GW\",\"GY\",\"HK\",\"HM\",\"HN\",\"HR\",\"HT\",\"HU\",\"ID\",\"IE\",\"IL\",\"IN\",\"IO\",\"IQ\",\"IR\",\"IS\",\"IT\",\"JM\",\"JO\",\"JP\",\"KE\",\"KG\",\"KH\",\"KI\",\"KM\",\"KN\",\"KP\",\"KR\",\"KW\",\"KY\",\"KZ\",\"LA\",\"LB\",\"LC\",\"LI\",\"LK\",\"LR\",\"LS\",\"LT\",\"LU\",\"LV\",\"LY\",\"MA\",\"MC\",\"MD\",\"MG\",\"MH\",\"MK\",\"ML\",\"MM\",\"MN\",\"MO\",\"MP\",\"MQ\",\"MR\",\"MS\",\"MT\",\"MU\",\"MV\",\"MW\",\"MX\",\"MY\",\"MZ\",\"NA\",\"NC\",\"NE\",\"NF\",\"NG\",\"NI\",\"NL\",\"NO\",\"NP\",\"NR\",\"NU\",\"NZ\",\"OM\",\"PA\",\"PE\",\"PF\",\"PG\",\"PH\",\"PK\",\"PL\",\"PM\",\"PN\",\"PR\",\"PS\",\"PT\",\"PW\",\"PY\",\"QA\",\"RE\",\"RO\",\"RU\",\"RW\",\"SA\",\"SB\",\"SC\",\"SD\",\"SE\",\"SG\",\"SH\",\"SI\",\"SJ\",\"SK\",\"SL\",\"SM\",\"SN\",\"SO\",\"SR\",\"ST\",\"SV\",\"SY\",\"SZ\",\"TC\",\"TD\",\"TF\",\"TG\",\"TH\",\"TJ\",\"TK\",\"TL\",\"TM\",\"TN\",\"TO\",\"TR\",\"TT\",\"TV\",\"TW\",\"TZ\",\"UA\",\"UG\",\"UM\",\"US\",\"UY\",\"UZ\",\"VA\",\"VC\",\"VE\",\"VG\",\"VI\",\"VN\",\"VU\",\"WF\",\"WS\",\"YE\",\"YT\",\"ZA\",\"ZM\",\"ZW\"",
        "refined_prompt": "\nMatch examples:\n- \"US\"\n- \"CA\"\n- \"MX\"\nNon-match examples:\n- \"NX\"\n- \"12\"",
        "matches": [
            "US",
            "CA",
            "MX"
        ],
        "non_matches": [
            "NX",
            "12",
            "USA"
        ],
        "stress_tests": []
    },
    {
        "id": 2780,
        "expression": "^(\\+48\\s*)?\\d{2}\\s*\\d{3}(\\s*|\\-)\\d{2}(\\s*|\\-)\\d{2}$",
        "raw_prompt": "Polish stationary phone number. Mask +48 XX XXXXXXX\nor +48 XX-XXX-XX-XX or +48 XXXXXXXXX",
        "refined_prompt": "\nMatch examples:\n- \"+48222222222\"\n- \"+48 22 3333333\"\n- \"+48 22 842 33 33\"\nNon-match examples:\n- \"+48-22-2222222\"\n- \"+49 22 222222\"",
        "matches": [
            "+48222222222",
            "+48 22 3333333",
            "+48 22 842 33 33"
        ],
        "non_matches": [
            "+48-22-2222222",
            "+49 22 222222"
        ],
        "stress_tests": []
    },
    {
        "id": 2781,
        "expression": "^((\\d{3}[- ]\\d{3}[- ]\\d{2}[- ]\\d{2})|(\\d{3}[- ]\\d{2}[- ]\\d{2}[- ]\\d{3}))$",
        "raw_prompt": "allow to insert input for polish tax identyfication number (NIP). Mask accepted:\nXXX-XX-XX-XXX ; XXX-XXX-XX-XX ; XXX XX XX XXX ; XXX XXX XX XX",
        "refined_prompt": "\nMatch examples:\n- \"222-22-22-222\"\n- \"222-222-22-22\"\n- \"222 22 22 222\"\nNon-match examples:\n- \"2222222222\"\n- \"XXXXXXXXXX\"",
        "matches": [
            "222-22-22-222",
            "222-222-22-22",
            "222 22 22 222",
            "222 222 22 22"
        ],
        "non_matches": [
            "2222222222",
            "XXXXXXXXXX"
        ],
        "stress_tests": []
    },
    {
        "id": 2788,
        "expression": "^[1]?[-\\.\\s]?(\\(\\d{3}\\)|\\d{3}){1}[-\\.\\s]?\\d{3}[-\\.\\s]?\\d{4}(\\s+|\\s*[-\\.x]{1}\\d{1,6})?$",
        "raw_prompt": "This expression will match a 10 or 11 digit US phone number with optional area code parenthesis, non-standard seperators such as spaces or dot's (.), and an extension up to 6 digits long",
        "refined_prompt": "\nMatch examples:\n- \"(800) 555-1212\"\n- \"999.555.1212 x1234\"\n- \"19995551212x123456\"\nNon-match examples:\n- \"555-1212\"\n- \"(800 555-1212\"",
        "matches": [
            "(800) 555-1212",
            "999.555.1212 x1234",
            "19995551212x123456"
        ],
        "non_matches": [
            "555-1212",
            "(800 555-1212",
            "888...555-1212"
        ],
        "stress_tests": []
    },
    {
        "id": 2790,
        "expression": "[0-9]{1,2}[:|\u00b0|\u00ba][0-9]{1,2}[:|'](?:\\b[0-9]+(?:\\.[0-9]*)?|\\.[0-9]+\\b)\"?[N|S|E|W]",
        "raw_prompt": "This is a slightly modified version of Kurt's DMS Coordinate regex so all the credit should go to Kurt - I just modified it to match a second character that may commonly be used to represent degrees",
        "refined_prompt": "\nMatch examples:\n- \"37\u00ba41'26\"N,97\u00ba20'0\"W (comma delimited, commas do not match...obviously :)\"\nNon-match examples:\n- \"\u221e , \u03c6, \u03c0 ....etc.... see Kurt's documentation\"",
        "matches": [
            "37\u00ba41'26\"N,97\u00ba20'0\"W (comma delimited, commas do not match...obviously :)"
        ],
        "non_matches": [
            "\u221e , \u03c6, \u03c0 ....etc.... see Kurt's documentation"
        ],
        "stress_tests": []
    },
    {
        "id": 2797,
        "expression": "^([0-9A-F]{2}[:-]){5}([0-9A-F]{2})$",
        "raw_prompt": "This regular expression will validate against a valid MAC address. The 6 bytes are hexadecimal and separated by semi colon or dash caracters.",
        "refined_prompt": "\nMatch examples:\n- \"01:23:45:67:89:AB\"\nNon-match examples:\n- \"01:23:45:67:89:X9\"",
        "matches": [
            "01:23:45:67:89:AB"
        ],
        "non_matches": [
            "01:23:45:67:89:X9"
        ],
        "stress_tests": []
    },
    {
        "id": 2799,
        "expression": "^[+]?((\\d*[1-9]+\\d*\\.?\\d*)|(\\d*\\.\\d*[1-9]+\\d*))$",
        "raw_prompt": "Matches any positive decimal number > 0 with optional leading '+' symbol and optional leading or trailing zeros on both sides of the decimal point. Decimal point is also optional and either side of the decimal is optional.",
        "refined_prompt": "\nMatch examples:\n- \"010\"\n- \"010.\"\n- \".010\"\nNon-match examples:\n- \".\"\n- \"0\"",
        "matches": [
            "010",
            "010.",
            ".010",
            "010.010"
        ],
        "non_matches": [
            ".",
            "0",
            "0.",
            ".0",
            "0.0",
            "0.00",
            "00.0",
            "00.00",
            "-0",
            "-1",
            "a"
        ],
        "stress_tests": []
    },
    {
        "id": 2803,
        "expression": "\\b[A-Z0-9]{5}\\d{1}[01567]\\d{1}([0][1-9]|[12][0-9]|[3][0-1])\\d{1}[A-Z0-9]{3}[A-Z]{2}\\b",
        "raw_prompt": "Matches the UK Drivers License format:\ni. Must be 16 characters\nii. First 5 characters are alphanumeric.\niii. Next 6 characters must be numeric\niv. Next 3 characters are alphanumeric\nv. Last 2 characters are alpha\nvi. Second character of numeric section can only be 0, 1, 5 or 6. 7.\nFourth and fifth characters of numeric section must be in the range 01 to 31.",
        "refined_prompt": "\nMatch examples:\n- \"SASAS701062AB8DD ASD12405315AA4AA ABCDE101010XY9AA\"\nNon-match examples:\n- \"SASAS701062AB8D ASD12405315AA4A ABCDE101010XY9A ABD2A121010AM9FA ABCDE101010XY9A9 AbCdE711215GG9aa AFG98101010AM9Fa SSSSS841215SS9SS AFG98101000AM9FA AF\u00ac98101010AM9FA ABC99808275m99sc ABC99808275m99sca ABC99808275m99scsd ABCDE654321A98\"",
        "matches": [
            "SASAS701062AB8DD ASD12405315AA4AA ABCDE101010XY9AA"
        ],
        "non_matches": [
            "SASAS701062AB8D ASD12405315AA4A ABCDE101010XY9A ABD2A121010AM9FA ABCDE101010XY9A9 AbCdE711215GG9aa AFG98101010AM9Fa SSSSS841215SS9SS AFG98101000AM9FA AF\u00ac98101010AM9FA ABC99808275m99sc ABC99808275m99sca ABC99808275m99scsd ABCDE654321A98"
        ],
        "stress_tests": []
    },
    {
        "id": 2809,
        "expression": "^[a-zA-Z][a-zA-Z\\-' ]*[a-zA-Z ]$",
        "raw_prompt": "Check for person name in database for example.\nA person name is a string compound of letters in upper or lower case and three more typographical characters, the hyphen (-), the simple quote or apostrophe (') and the space. For these three characters, not at the beginning or the end of the string.",
        "refined_prompt": "\nMatch examples:\n- \"Pierre-Francis d'Astier de Weyergans-Migery\"\n- \"Jeanne d'Arc\"\n- \"Nicolas Sarkozy\"\nNon-match examples:\n- \"-tutu\"\n- \"tutu-\"",
        "matches": [
            "Pierre-Francis d'Astier de Weyergans-Migery",
            "Jeanne d'Arc",
            "Nicolas Sarkozy",
            "Charles de Gaulle",
            "Dominique Strauss-Kahn"
        ],
        "non_matches": [
            "-tutu",
            "tutu-",
            "'tutu",
            "tutu'",
            "tu1tu",
            "tu*tu",
            "1tutu",
            "tutu*"
        ],
        "stress_tests": []
    },
    {
        "id": 2812,
        "expression": "^([1-9]|1[0-2]|0[1-9]){1}(:[0-5][0-9][ ][aApP][mM]){1}$",
        "raw_prompt": "This will validate 12 hours time format with AM/am PM/pm",
        "refined_prompt": "\nMatch examples:\n- \"11:11 AM\"\n- \"01:11 PM\"\n- \"12:59 AM\"\nNon-match examples:\n- \"21:11 AM\"\n- \"00:00 PM\"",
        "matches": [
            "11:11 AM",
            "01:11 PM",
            "12:59 AM"
        ],
        "non_matches": [
            "21:11 AM",
            "00:00 PM",
            "10:70 AM",
            "10:50PM"
        ],
        "stress_tests": []
    },
    {
        "id": 2814,
        "expression": "^((61|\\+61)?\\s?)04[0-9]{2}\\s?([0-9]{3}\\s?[0-9]{3}|[0-9]{2}\\s?[0-9]{2}\\s?[0-9]{2})$",
        "raw_prompt": "Validates an Australian mobile telephone number that can include an international prefix and four plus (two or three-digit) grouping.\nI use it in ASP.NET MVC DataAnnotations [RegularExpression()] attributes where I don't get to easily strip out spaces beforehand.",
        "refined_prompt": "\nMatch examples:\n- \"0418123456\"\n- \"0411 123 456\"\n- \"0414 12 34 56\"\nNon-match examples:\n- \"0418 1 23 45 6\"\n- \"04 01 123456\"",
        "matches": [
            "0418123456",
            "0411 123 456",
            "0414 12 34 56",
            "61 0401 123 456",
            "+61 0418 12 34 56"
        ],
        "non_matches": [
            "0418 1 23 45 6",
            "04 01 123456",
            "+62 0418 12 34 56"
        ],
        "stress_tests": []
    },
    {
        "id": 2816,
        "expression": "(((^[>]?1.0)(\\d)?(\\d)?)|(^[<]?1.0(([1-9])|(\\d[1-9])|([1-9]\\d)))|(^[<]?1.4(0)?(0)?)|(^[<>]?1.(([123])(\\d)?(\\d)?)))$",
        "raw_prompt": "Range validator for urine lab panel specific gravity. The valid range is 1.000 to 1.400 inclusive. Sometimes < and > are used but not in the context of <1.000 nor >1.400. To 1, 2 or 3 decimals. Normal range is 1.003 to 1.03 but is left to the viewer.",
        "refined_prompt": "\nMatch examples:\n- \">1.0\"\n- \"<1.001\"\n- \">1.399\"\nNon-match examples:\n- \">1.400\"\n- \"1.\"",
        "matches": [
            ">1.0",
            "<1.001",
            ">1.399"
        ],
        "non_matches": [
            ">1.400",
            "1.",
            "1.0011"
        ],
        "stress_tests": []
    },
    {
        "id": 2818,
        "expression": "(\\'([^\\'\\\\]*\\\\.)*[^\\'\\\\]*\\')+",
        "raw_prompt": "Matches mysql single-quoted string literals. double quotes and backslashed quotes are recognised.",
        "refined_prompt": "\nMatch examples:\n- \"'this is ''a'' string\\n with \\'embedded\\' quotes'\"\nNon-match examples:\n- \"'a string \\'without\\' terminator\"",
        "matches": [
            "'this is ''a'' string\\n with \\'embedded\\' quotes'"
        ],
        "non_matches": [
            "'a string \\'without\\' terminator"
        ],
        "stress_tests": []
    },
    {
        "id": 2822,
        "expression": "[1-9][0-9]{3}[ ]?(([a-rt-zA-RT-Z][a-zA-Z])|([sS][bce-rt-xBCE-RT-X]))",
        "raw_prompt": "Most RegExpr for dutch zip codes are too simple. For historic reasons, the two-letter combinations SS, SA and SD are not allowed.\nThere should be one space between the numbers and letters, but I allow any number of spaces. Also I allow lowercase. In the early days of dutch zip codes, some letters were not allowed to avoid confusion (F,I,Q, O etc). Nowadays, they are not excluded anymore, because we ran out of letter combinations.\nIt should be easy to make the RegExpr more strict, by prescribing ONE mandatory space and allowing only uppercase.",
        "refined_prompt": "\nMatch examples:\n- \"1234HG\"\n- \"3454 FG\"\n- \"1000 AA\"\nNon-match examples:\n- \"0987 SE\"\n- \"8767 SD\"",
        "matches": [
            "1234HG",
            "3454 FG",
            "1000 AA",
            "3456 sg"
        ],
        "non_matches": [
            "0987 SE",
            "8767 SD",
            "6756 ss"
        ],
        "stress_tests": []
    },
    {
        "id": 2827,
        "expression": "^(((0?[1-9]|1\\d|2[0-8])|(0?[13456789]|1[012])/(29|30)|(0?[13578]|1[02])/31)/(0?[1-9]|1[012])/(19|[2-9]\\d)\\d{2}|0?29/0?2/((19|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|(([2468][048]|[3579][26])00)))$",
        "raw_prompt": "DD/MM/YYYY with leap year detection as most of the date regex are in MM/DD/YYYY format. Allows MM and DD to be 1 or 2 digits, eg. D/M/YYYY, D/MM/YYYY or DD/M/YYYY",
        "refined_prompt": "\nMatch examples:\n- \"21/01/1972\"\n- \"21/1/1972\"\n- \"1/1/1972\"\nNon-match examples:\n- \"21-01-1972\"\n- \"21-01-1972\"",
        "matches": [
            "21/01/1972",
            "21/1/1972",
            "1/1/1972",
            "29/2/2012",
            "29/02/2012"
        ],
        "non_matches": [
            "21-01-1972",
            "21-01-1972",
            "29/02/2011"
        ],
        "stress_tests": []
    },
    {
        "id": 2832,
        "expression": "^http[s]?://twitter\\.com/(#!/)?[a-zA-Z0-9]{1,15}[/]?$",
        "raw_prompt": "Allows http and https, bans www prefix, username portion is clamped to the rules it gives you at signup and also allows an optional trailing slash. [UPDATED] allows the #! notation that twitter used.",
        "refined_prompt": "\nMatch examples:\n- \"http://twitter.com/rtpharry/\"\n- \"http://twitter.com/rtpharry\"\n- \"https://twitter.com/rtpharry/\"\nNon-match examples:\n- \"http://www.twitter.com/wwwprefix/\"\n- \"http://twitter.com/longerthan15characters/\"",
        "matches": [
            "http://twitter.com/rtpharry/",
            "http://twitter.com/rtpharry",
            "https://twitter.com/rtpharry/",
            "https://twitter.com/rtpharry",
            "http://twitter.com/#!/rtpharry/"
        ],
        "non_matches": [
            "http://www.twitter.com/wwwprefix/",
            "http://twitter.com/longerthan15characters/",
            "http://twitter.com/illegal$chars/"
        ],
        "stress_tests": []
    },
    {
        "id": 2833,
        "expression": "(?=^.{1,}$)(?!.*\\s)[0-9a-zA-Z!@#$%*()_+^&\\[\\]]*$",
        "raw_prompt": "Regular Expression which does not allow SPACE but allows every possible alpha-numeric and special characters.",
        "refined_prompt": "\nMatch examples:\n- \"abc*()A123\"\n- \"12xyz[_]\"\nNon-match examples:\n- \"no space\"\n- \"abc *0123[]\"",
        "matches": [
            "abc*()A123",
            "12xyz[_]"
        ],
        "non_matches": [
            "no space",
            "abc *0123[]"
        ],
        "stress_tests": []
    },
    {
        "id": 2835,
        "expression": "^(([0-9]{2,4})([-\\s\\/]{0,1})([0-9]{4,8}))?$",
        "raw_prompt": "validate mobile and land phone numbers.\nAllow space - / or nothing number and area codes",
        "refined_prompt": "\nMatch examples:\n- \"02/583725\"\n- \"3471231231\"\n- \"02 12345678\"\nNon-match examples:\n- \"+3902/583725\"\n- \"0 2998765\"",
        "matches": [
            "02/583725",
            "3471231231",
            "02 12345678"
        ],
        "non_matches": [
            "+3902/583725",
            "0 2998765",
            "02 996 876"
        ],
        "stress_tests": []
    },
    {
        "id": 2836,
        "expression": "\\b(?!000)(?!666)(?!9)[0-9]{3}[ -]?(?!00)[0-9]{2}[ -]?(?!0000)[0-9]{4}\\b",
        "raw_prompt": "Finds 9 digit numbers within word boundaries, not separated or separated by - or space, not starting with 000, 666, or 900-999, not containing 00 or 0000 in the middle or at the end of SSN (in compliance with current SSN rules).",
        "refined_prompt": "\nMatch examples:\n- \"123-45-6789, 123 45 6789, 123456789, 123-45 6789, 123-456789, 123 456789, etc.\"\nNon-match examples:\n- \"000-45-6789, 666-45-6789, 123-00-6789, 123-45-0000, 900-45-6789 through 999-45-6789\"",
        "matches": [
            "123-45-6789, 123 45 6789, 123456789, 123-45 6789, 123-456789, 123 456789, etc."
        ],
        "non_matches": [
            "000-45-6789, 666-45-6789, 123-00-6789, 123-45-0000, 900-45-6789 through 999-45-6789"
        ],
        "stress_tests": []
    },
    {
        "id": 2841,
        "expression": "&amp;#([0-9]{1,5}|x[0-9a-fA-F]{1,4});",
        "raw_prompt": "Find all html encoded characters as dec &amp;#[0-9]{1,5}; or hex &amp;#x[0-9a-fA-F]{1,4}; values. Remember to remove \"amp;\" which is used for making this post possible.",
        "refined_prompt": "\nMatch examples:\n- \"&amp;#160;\"\n- \"&amp;#xa0;\"\nNon-match examples:\n- \"&amp;nbsp;\"",
        "matches": [
            "&amp;#160;",
            "&amp;#xa0;"
        ],
        "non_matches": [
            "&amp;nbsp;"
        ],
        "stress_tests": []
    },
    {
        "id": 2844,
        "expression": "(Mo(n(day)?)?|Tu(e(sday)?)?|We(d(nesday)?)?|Th(u(rsday)?)?|Fr(i(day)?)?|Sa(t(urday)?)?|Su(n(day)?)?)",
        "raw_prompt": "The expression matches any weekday name (english) in short (2 or 3 characters) or full style. Use it with case insensitive mode in your date matching expressions.",
        "refined_prompt": "\nMatch examples:\n- \"Mo\"\n- \"Sun\"\nNon-match examples:\n- \"Any\"",
        "matches": [
            "Mo",
            "Sun"
        ],
        "non_matches": [
            "Any"
        ],
        "stress_tests": []
    },
    {
        "id": 2850,
        "expression": "^[_a-z0-9-]+(\\.[_a-z0-9-]+)*@[a-z0-9]+(-?[a-z0-9]+)?(\\.[a-z0-9]+(-?[a-z0-9]+)?)*\\.([a-z]{2}|xn\\-{2}[a-z0-9]{4,18}|arpa|aero|asia|biz|cat|com|coop|edu|gov|info|int|jobs|mil|mobi|museum|name|net|org|pro|tel|travel|xxx)$",
        "raw_prompt": "Validates email addresses (except those using IP) according to list of TLD's http://data.iana.org/TLD/tlds-alpha-by-domain.txt .",
        "refined_prompt": "\nMatch examples:\n- \"name@domain.com\"\n- \"first.last@abc.d-e.fg\"\n- \"first.middle.last@a-b.c-d.xxx\"\nNon-match examples:\n- \"name@abc-.de\"\n- \"first.last@-abc.defg.hij\"",
        "matches": [
            "name@domain.com",
            "first.last@abc.d-e.fg",
            "first.middle.last@a-b.c-d.xxx",
            "name-surname@foreign.xn--h2brj9c"
        ],
        "non_matches": [
            "name@abc-.de",
            "first.last@-abc.defg.hij",
            "first.last@123.123.123.123"
        ],
        "stress_tests": []
    },
    {
        "id": 2852,
        "expression": "(CREATE|ALTER) +(PROCEDURE|PROC|FUNCTION|VIEW) *(\\[(.*)\\]|(.*))",
        "raw_prompt": "Expression to detect the name of the stored procedure / function / view, useful to detect automatically the name of the sproc the produced text in SQL",
        "refined_prompt": "\nMatch examples:\n- \"CREATE PROC[spTest], CREATE FUNCTION fnTest, ALTER PROCEDURE spTestOther\"\nNon-match examples:\n- \"DROP PROC xxx, CREATE CURSOR xxx\"",
        "matches": [
            "CREATE PROC[spTest], CREATE FUNCTION fnTest, ALTER PROCEDURE spTestOther"
        ],
        "non_matches": [
            "DROP PROC xxx, CREATE CURSOR xxx"
        ],
        "stress_tests": []
    },
    {
        "id": 2853,
        "expression": "^(?!^(5|15|18|30)$)\\d+$",
        "raw_prompt": "Because a regular expression only deals with a single character at a time it can be a challenge to work with numbers as they often contain multiple digits. This regex allows any number except the numbers in the list. It does this by using a negative look ahead to fail the regex if it finds an excluded number.",
        "refined_prompt": "\nMatch examples:\n- \"1\"\n- \"325\"\n- \"515\"\nNon-match examples:\n- \"5\"\n- \"15\"",
        "matches": [
            "1",
            "325",
            "515",
            "300"
        ],
        "non_matches": [
            "5",
            "15",
            "18",
            "30"
        ],
        "stress_tests": []
    },
    {
        "id": 2854,
        "expression": "\\.(?i:)(?:jpg|gif)$",
        "raw_prompt": "This expression will only allow the .jpg and .gif file to get uploaded.\nThis handles the case of the file type i.e. it will accept .gif and .GIF both and so on .JPG and .jpg.",
        "refined_prompt": "\nMatch examples:\n- \"mypicture.jpg, MYPICTURE.JPG, MYPICTURE.GIF, mypicture.gif\"\nNon-match examples:\n- \"mypicture.png, mypicture.bmp\"",
        "matches": [
            "mypicture.jpg, MYPICTURE.JPG, MYPICTURE.GIF, mypicture.gif"
        ],
        "non_matches": [
            "mypicture.png, mypicture.bmp"
        ],
        "stress_tests": []
    },
    {
        "id": 2861,
        "expression": "^(net.tcp\\://|(ht|f)tp(s?)\\://)\\S+",
        "raw_prompt": "For validate uri directions that must occur at the beginning of the string net.tcp|http|https|ftp|ftps://",
        "refined_prompt": "\nMatch examples:\n- \"http://ww.nancy.net/Servicios/ProxyWSService.svc\"\n- \"net.tcp://testwcf02.com:808/Tasacion\"\n- \"ftps://nancy.inet:/ProxyFTP\"\nNon-match examples:\n- \"C:\"\n- \"C:\\inetpub\\wwwroot\\file.asmx\"",
        "matches": [
            "http://ww.nancy.net/Servicios/ProxyWSService.svc",
            "net.tcp://testwcf02.com:808/Tasacion",
            "ftps://nancy.inet:/ProxyFTP"
        ],
        "non_matches": [
            "C:",
            "C:\\inetpub\\wwwroot\\file.asmx",
            "file.svc"
        ],
        "stress_tests": []
    },
    {
        "id": 2868,
        "expression": "(\\(0\\d\\d\\)\\s\\d{3}[\\s-]+\\d{4})|(0\\d\\d[\\s-]+\\d{3}[\\s-]+\\d{4})|(0\\d{9})|(\\+\\d\\d\\s?[\\(\\s]\\d\\d[\\)\\s]\\s?\\d{3}[\\s-]?\\d{4})",
        "raw_prompt": "Tries to match the format of phone numbers within South Africa. Does not try to validate phone numbers based on actual numbers (e.g. cell networks or other landline prefixes)",
        "refined_prompt": "\nMatch examples:\n- \"(011) 123 4543,(011) 123-4543,(011) 212 8765,011 876 8789,0118768789,011-876-8789,082 821 9090,+27 11 123 1231,+27 (11) 123-1231,+27 (11) 123 1231,+27(11)123-1231,+27 11 1238765\"\nNon-match examples:\n- \"011 1234 242\"",
        "matches": [
            "(011) 123 4543,(011) 123-4543,(011) 212 8765,011 876 8789,0118768789,011-876-8789,082 821 9090,+27 11 123 1231,+27 (11) 123-1231,+27 (11) 123 1231,+27(11)123-1231,+27 11 1238765"
        ],
        "non_matches": [
            "011 1234 242"
        ],
        "stress_tests": []
    },
    {
        "id": 2869,
        "expression": "^(?:[\\w]\\:|\\\\)(\\\\[a-z_\\-\\s0-9\\.]+)+\\.(txt|gif|pdf|doc|docx|xls|xlsx)$",
        "raw_prompt": "Regular Expression to validate file path and extension.Compatible with JavaScript and ASP.NET",
        "refined_prompt": "\nMatch examples:\n- \"\\\\192.168.0.1\\folder\\file.pdf\"\n- \"\\\\192.168.0.1\\my folder\\folder.2\\file.gif\"\n- \"c:\\my folder\\abc abc.docx\"\nNon-match examples:\n- \"\\\\192.168.0.1\\folder\\fi/le.pdf\"\n- \"\\\\192.168.0.1\\folder\\\\file.pdf\"",
        "matches": [
            "\\\\192.168.0.1\\folder\\file.pdf",
            "\\\\192.168.0.1\\my folder\\folder.2\\file.gif",
            "c:\\my folder\\abc abc.docx",
            "c:\\my-folder\\another_folder\\abc.v2.docx"
        ],
        "non_matches": [
            "\\\\192.168.0.1\\folder\\fi/le.pdf",
            "\\\\192.168.0.1\\folder\\\\file.pdf",
            "\\\\192.168.0.1\\my folder\\folder.2\\.gif",
            "c:\\my folder\\another_folder\\.docx",
            "c:\\my folder\\\\another_folder\\abc.docx",
            "c:\\my folder\\another_folder\\ab*c.v2.docx",
            "c:\\my?folder\\another_folder\\abc.v2.docx",
            "file.xls"
        ],
        "stress_tests": []
    },
    {
        "id": 2877,
        "expression": "^(?:-([0-9]{1,2})|([0-9]{4}))?(?:-?(?:([0-9]{2})?(?:-?([0-9]{2}))?|W([0-9]{2})(?:-?([1-7]))?|([0-9]{3})))?(?:T([0-9]{2})(?::?([0-9]{2})(?::?([0-9]{2}))?)?(?:[,\\.]([0-9]+))?(?:(Z)|([+-])([0-9]{2})(?::?([0-9]{2}))?)?)?$",
        "raw_prompt": "Validate and parse date/time string in ISO8601 format. Works with complete representation in both with basic and extended formats. Some of turncated representations and most of representations with reduced precision are also supported. It does not validate range of date/time fields in any way.\nCaptured fields may be empty depending on what kind of representation is used.\nYear: $1 two-digit year with implicit century or $2 full 4-digit year.\nCalendar date: $3 month, $4 day of the month.\nWeek date: $5 week of the year, $6 day of the week.\nOrdinal date: $7 day of the year.\nTime: $8 hours, $9 minutes, $10 seconds, $11 fractional part of last non-empty time field.\nTime zone: if $12 is Z then it's UTC zone, otherwise offset may be given as $13 direction (+/-), $14 hours and $15 minutes.",
        "refined_prompt": "\nMatch examples:\n- \"19850412T232050Z\"\n- \"1985-04-12T10:15:30+0400\"\n- \"1985102\"\nNon-match examples:\n- \"11111\"\n- \"23,5\"",
        "matches": [
            "19850412T232050Z",
            "1985-04-12T10:15:30+0400",
            "1985102",
            "1985-102",
            "1985W155",
            "1985-W15-5",
            "T23:20:50",
            "T23,347"
        ],
        "non_matches": [
            "11111",
            "23,5",
            "23:20"
        ],
        "stress_tests": []
    },
    {
        "id": 2879,
        "expression": "^(?i:([a-z])\\1?(?!\\1)){2,}$",
        "raw_prompt": "This was designed to match a single name field which required a minimum length of 2 characters and no triplicate characters.",
        "refined_prompt": "\nMatch examples:\n- \"John\"\n- \"Bob\"\n- \"Smith\"\nNon-match examples:\n- \"aa\"\n- \"aaa\"",
        "matches": [
            "John",
            "Bob",
            "Smith",
            "Jones"
        ],
        "non_matches": [
            "aa",
            "aaa",
            "Smiiith"
        ],
        "stress_tests": []
    },
    {
        "id": 2882,
        "expression": "^(((0|((\\+)?91(\\-)?))|((\\((\\+)?91\\)(\\-)?)))?[7-9]\\d{9})?$",
        "raw_prompt": "First digit can be 7 or 8 or 9.\nNo. can have any of the following prefixes\n0\n91\n91-\n(91)-\n+91\n(+91)\n(+91)-",
        "refined_prompt": "\nMatch examples:\n- \"9876543210\"\n- \"09876543210\"\n- \"919876543210\"\nNon-match examples:\n- \"9198279\"\n- \"6789123456\"",
        "matches": [
            "9876543210",
            "09876543210",
            "919876543210",
            "+919876543210",
            "91-9876543210",
            "+91-9876543210",
            "(91)9876543210",
            "(+91)9876543210",
            "(91)-9876543210",
            "(+91)-9876543210"
        ],
        "non_matches": [
            "9198279",
            "6789123456",
            "0-9876543210",
            "+(91)-9876543210"
        ],
        "stress_tests": []
    },
    {
        "id": 2883,
        "expression": "(?:[Yy][Oo][Uu][Tt][Uu][Bb][Ee]\\.[Cc][Oo][Mm]/watch\\?v=)([\\w-]{11})",
        "raw_prompt": ".NET 3.5 Tested. Used to extract the YouTubeID from a fully qualified YouTube URL.\nDim _Regex As New Regex(\"(?:[Yy][Oo][Uu][Tt][Uu][Bb][Ee]\\.[Cc][Oo][Mm]/watch\\?v=)([\\w-]{11})\", RegexOptions.IgnoreCase Or RegexOptions.Compiled)\nDim _RegexMatch As Match = _Regex.Match(\"http://www.youtube.com/watch?v=pW2GSdxxwDg\")\nDim _YouTubeVideoID As System.String = _RegexMatch.Groups(1).Value",
        "refined_prompt": "\nMatch examples:\n- \"http://www.youtube.com/watch?v=pW2GSdxxwDg\"\n- \"http://www.youtube.com/watch?v=-7P7_kxZQ5I\"\n- \"http://www.youtube.com/watch?v=7sPKHwsupmQ&playnext=1&list=PL40CB7986D1A9A285\"\nNon-match examples:\n- \"http://www.youtu.be/watch?v=pW2GSdxxwDg\"",
        "matches": [
            "http://www.youtube.com/watch?v=pW2GSdxxwDg",
            "http://www.youtube.com/watch?v=-7P7_kxZQ5I",
            "http://www.youtube.com/watch?v=7sPKHwsupmQ&playnext=1&list=PL40CB7986D1A9A285",
            "http://www.youtube.com/watch?v=r-di4gJvq4Q&feature=channel_video_title"
        ],
        "non_matches": [
            "http://www.youtu.be/watch?v=pW2GSdxxwDg"
        ],
        "stress_tests": []
    },
    {
        "id": 2884,
        "expression": "^[^-]{1}?[^\\\"\\']*$",
        "raw_prompt": "to accept only alphanumeric with all special characters except (double/single Quotes). and if numbers then only positive numbers",
        "refined_prompt": "\nMatch examples:\n- \"65 ghf, 65% - consumed, hello, 64 - 56\"\nNon-match examples:\n- \"-65 ghf, -164, 65% - \"consumed\"\"",
        "matches": [
            "65 ghf, 65% - consumed, hello, 64 - 56"
        ],
        "non_matches": [
            "-65 ghf, -164, 65% - \"consumed\""
        ],
        "stress_tests": []
    },
    {
        "id": 2890,
        "expression": "^(?:(?=[02468][048]00|[13579][26]00|[0-9][0-9]0[48]|[0-9][0-9][2468][048]|[0-9][0-9][13579][26])\\d{4}(?:(-|)(?:(?:00[1-9]|0[1-9][0-9]|[1-2][0-9][0-9]|3[0-5][0-9]|36[0-6])|(?:01|03|05|07|08|10|12)(?:\\1(?:0[1-9]|[12][0-9]|3[01]))?|(?:04|06|09|11)(?:\\1(?:0[1-9]|[12][0-9]|30))?|02(?:\\1(?:0[1-9]|[12][0-9]))?|W(?:0[1-9]|[1-4][0-9]|5[0-3])(?:\\1[1-7])?))?)$|^(?:(?![02468][048]00|[13579][26]00|[0-9][0-9]0[48]|[0-9][0-9][2468][048]|[0-9][0-9][13579][26])\\d{4}(?:(-|)(?:(?:00[1-9]|0[1-9][0-9]|[1-2][0-9][0-9]|3[0-5][0-9]|36[0-5])|(?:01|03|05|07|08|10|12)(?:\\2(?:0[1-9]|[12][0-9]|3[01]))?|(?:04|06|09|11)(?:\\2(?:0[1-9]|[12][0-9]|30))?|(?:02)(?:\\2(?:0[1-9]|1[0-9]|2[0-8]))?|W(?:0[1-9]|[1-4][0-9]|5[0-3])(?:\\2[1-7])?))?)$",
        "raw_prompt": "Validate a date according to the ISO 8601 standard (no time part) considering long-short months to allow 31st day of month and leap years to allow 29th February. I took Ted Cambron's implementation, simplified and added support for leap years and long-short months.",
        "refined_prompt": "\nMatch examples:\n- \"1600-02-29\"\nNon-match examples:\n- \"2011-02-29\"",
        "matches": [
            "1600-02-29"
        ],
        "non_matches": [
            "2011-02-29"
        ],
        "stress_tests": []
    },
    {
        "id": 2896,
        "expression": "\\b(((20)((0[0-9])|(1[0-1])))|(([1][^0-8])?\\d{2}))((0[1-9])|1[0-2])((0[1-9])|(2[0-9])|(3[01]))[-+]?\\d{4}[,.]?\\b",
        "raw_prompt": "Matches a Swedish social security number in format xxYYMMDD-NNNN, xxYYMMDD+NNNN, YYMMDD-NNNN, YYMMDD-NNNN and YYMMDDNNN. Does not allow birth years before 1900 and after 2011.\nTo raise the birth year to higher level of birth just change the 1[0-1] part to i.e. 1[0-4] to allow birth years up to 2014 etc.\nThis will find the SSN within a string. Also allow for a comma(,) or period(.) behind the SSN.",
        "refined_prompt": "\nMatch examples:\n- \"7712314582\"\n- \"810325+0782\"\n- \"19771231-4582\"\nNon-match examples:\n- \"137712314582\"\n- \"201211224567\"",
        "matches": [
            "7712314582",
            "810325+0782",
            "19771231-4582"
        ],
        "non_matches": [
            "137712314582",
            "201211224567",
            "10880215-0987"
        ],
        "stress_tests": []
    },
    {
        "id": 2898,
        "expression": "^(((20)((0[0-9])|(1[0-1])))|(([1][^0-8])?\\d{2}))((0[1-9])|1[0-2])((0[1-9])|(2[0-9])|(3[01]))[-]?\\d{4}$",
        "raw_prompt": "Matches a Swedish social security number in format CCYYMMDD-NNNN, CCYYMMDDNNNN, YYMMDD-NNNN and YYMMDDNNNN on a single line. More useful version of my earlier expression. Will only match 1900 - 2011 years.",
        "refined_prompt": "\nMatch examples:\n- \"7712314582\"\n- \"810325-0782\"\n- \"19771231-4582\"\nNon-match examples:\n- \"137712314582\"\n- \"201211224567\"",
        "matches": [
            "7712314582",
            "810325-0782",
            "19771231-4582",
            "197712314582"
        ],
        "non_matches": [
            "137712314582",
            "201211224567",
            "10880215-0987"
        ],
        "stress_tests": []
    },
    {
        "id": 2903,
        "expression": "(?:youtu\\.be\\/|youtube.com\\/(?:watch\\?.*\\bv=|embed\\/|v\\/)|ytimg\\.com\\/vi\\/)(.+?)(?:[^-a-zA-Z0-9]|$)",
        "raw_prompt": "This regex should recognize a Youtube video ID from any Youtube URL, embed snippet, or preview image.",
        "refined_prompt": "\nMatch examples:\n- \"http://www.youtube.com/watch?v=QH2-TGUlwu4\"\n- \"http://youtu.be/QH2-TGUlwu4\"\n- \"http://www.youtube.com/embed/QH2-TGUlwu4\"\nNon-match examples:\n- \"asdf\"",
        "matches": [
            "http://www.youtube.com/watch?v=QH2-TGUlwu4",
            "http://youtu.be/QH2-TGUlwu4",
            "http://www.youtube.com/embed/QH2-TGUlwu4",
            "http://www.youtube.com/v/QH2-TGUlwu4?version=3&amp;hl=en_US",
            "http://i4.ytimg.com/vi/QH2-TGUlwu4/default.jpg"
        ],
        "non_matches": [
            "asdf"
        ],
        "stress_tests": []
    },
    {
        "id": 2906,
        "expression": "(http|ftp|https)://[a-zA-Z0-9\\-\\.]+\\.[a-zA-Z]{2,4}(/\\S*)?$",
        "raw_prompt": "This Regex check protocol (ftp, http, https), extension should be between 2 and 4 chars example (.co.uk, .com, .us and .info), domain or subdomain name between protocol and extension should contain the following chars\na-z, A-Z, 0-9, \"-\", and \".\"\nThe rest of URL after \"/\" contain unicode char",
        "refined_prompt": "\nMatch examples:\n- \"http://domain-1.us\"\n- \"ftp://www.domain.co.uk\"\n- \"https://domain.info\"\nNon-match examples:\n- \"http://domain.infor\"\n- \"http://domain_1.com\"",
        "matches": [
            "http://domain-1.us",
            "ftp://www.domain.co.uk",
            "https://domain.info",
            "https://subdomain.domain.info",
            "http://subdomain.domain.info/\u0627\u0644\u062c\u0632\u0627\u0626\u0631.html"
        ],
        "non_matches": [
            "http://domain.infor",
            "http://domain_1.com"
        ],
        "stress_tests": []
    },
    {
        "id": 2913,
        "expression": "^((\\d{1,3}(,\\d{3})*)|(\\d{1,3}))$",
        "raw_prompt": "Matches all properly formatted integers of 1 or more integer with commas separating each group of 3 integers",
        "refined_prompt": "\nMatch examples:\n- \"10\"\n- \"100\"\n- \"1,000\"\nNon-match examples:\n- \"1000\"\n- \"1,0000\"",
        "matches": [
            "10",
            "100",
            "1,000",
            "1,000,000,000,000"
        ],
        "non_matches": [
            "1000",
            "1,0000",
            "1000,000"
        ],
        "stress_tests": []
    },
    {
        "id": 2919,
        "expression": "(\\d{5}-\\d{4}|\\d{5})",
        "raw_prompt": "Matches:\nfive digits hypen four digits\nor just five digits\nanywhere within string.\nC#\nstring reg_usa_postcode = @\"(\\d{5}-\\d{4}|\\d{5})\";",
        "refined_prompt": "\nMatch examples:\n- \"Ohio 43050-2495 USA, Houston 77053 USA Texax\"\nNon-match examples:\n- \"USA 4512, Texas 1234-1234 US\"",
        "matches": [
            "Ohio 43050-2495 USA, Houston 77053 USA Texax"
        ],
        "non_matches": [
            "USA 4512, Texas 1234-1234 US"
        ],
        "stress_tests": []
    },
    {
        "id": 2931,
        "expression": "start\\s*([^$]*)\\s*(.*?)",
        "raw_prompt": "Matches a string and grabs all data till the end of the string/text/sentence.\nEg.\nI wonder why all programming languages start with a hello world program !!",
        "refined_prompt": "\nMatch examples:\n- \"start with a hello world program !!\"\nNon-match examples:\n- \".\"",
        "matches": [
            "start with a hello world program !!"
        ],
        "non_matches": [
            "."
        ],
        "stress_tests": []
    },
    {
        "id": 2932,
        "expression": "wonder\\s*([^$]*)\\s*with",
        "raw_prompt": "Matches and returns the text provided the match string and the end string. Eg. I wonder why all programming languages start with a hello world program !!",
        "refined_prompt": "\nMatch examples:\n- \"wonder why all programming languages start with\"\nNon-match examples:\n- \".\"",
        "matches": [
            "wonder why all programming languages start with"
        ],
        "non_matches": [
            "."
        ],
        "stress_tests": []
    },
    {
        "id": 2933,
        "expression": "^((\\D*[a-z]\\D*[A-Z]\\D*)|(\\D*[A-Z]\\D*[a-z]\\D*)|(\\D*\\W\\D*[a-z])|(\\D*\\W\\D*[A-Z])|(\\D*[a-z]\\D*\\W)|(\\D*[A-Z]\\D*\\W))$",
        "raw_prompt": "Password validation with any two of combinations: [A-Z],[a-z],Punctuation Symbols with minimum user requirement without digits.If digit is added , it wont validate.As per requirement add '.{n,m}' without quotes before the $ sign in the expression.",
        "refined_prompt": "\nMatch examples:\n- \"Sara,sA,%g,&HHJ,G(*,hgh%\"\nNon-match examples:\n- \"Sa2,hjH7,7&h\"",
        "matches": [
            "Sara,sA,%g,&HHJ,G(*,hgh%"
        ],
        "non_matches": [
            "Sa2,hjH7,7&h"
        ],
        "stress_tests": []
    },
    {
        "id": 2937,
        "expression": "((?:Microsoft)?.?(?:(?:Windows.NT.(?:[1-4].[0-9]))|(?:Win(?:dows)?.?NT).?[1-4](?:.?[0-9])?|NT[1-4]))",
        "raw_prompt": "Matches the \"Official\" and several other popular expressions of the \"Windows NT\" line of operating systems. Used to discern one OS version from another. Must include at least one digit of the version number (1 to 4 or 1.0 to 4.9 will match).\nOnly one capture group will return the full, matching string.",
        "refined_prompt": "\nMatch examples:\n- \"Windows NT 4.0\"\n- \"Microsoft Windows NT 4.0\"\n- \"Microsoft Windows NT 3.5\"\nNon-match examples:\n- \"WinNT\"\n- \"Win NT\"",
        "matches": [
            "Windows NT 4.0",
            "Microsoft Windows NT 4.0",
            "Microsoft Windows NT 3.5",
            "Win NT4",
            "NT4",
            "Windows_NT_4.0",
            "MicrosoftWindowsNT3.1",
            "WindowsNT4",
            "Windows_NT.4"
        ],
        "non_matches": [
            "WinNT",
            "Win NT",
            "Windows 2000",
            "Windows NT"
        ],
        "stress_tests": []
    },
    {
        "id": 2944,
        "expression": "^([A-Z]+\\s*[A-Z]+)$",
        "raw_prompt": "1 or 2 words with 1 or no space. Words are in all capital letters. Nothing in front or end of word(s).",
        "refined_prompt": "\nMatch examples:\n- \"JOHN DOE\"\n- \"BOB\"\n- \"MELTON HILL\"\nNon-match examples:\n- \"John 3\"\n- \"THE CHEROKEE LAKE\"",
        "matches": [
            "JOHN DOE",
            "BOB",
            "MELTON HILL"
        ],
        "non_matches": [
            "John 3",
            "THE CHEROKEE LAKE",
            "Bill"
        ],
        "stress_tests": []
    },
    {
        "id": 2950,
        "expression": "^[\\u0600-\\u06ff\\s]+$|[\\u0750-\\u077f\\s]+$|[\\ufb50-\\ufc3f\\s]+$|[\\ufe70-\\ufefc\\s]+$|^$",
        "raw_prompt": "Arabic Word only or Null String",
        "refined_prompt": "\nMatch examples:\n- \"\u0645\u062d\u0645\u062f \u0627\u062d\u0645\u062f\"\nNon-match examples:\n- \"\u0645\u062d\u0645\u062f \u0627\u062d\u0645\u062f gjghj\"",
        "matches": [
            "\u0645\u062d\u0645\u062f \u0627\u062d\u0645\u062f"
        ],
        "non_matches": [
            "\u0645\u062d\u0645\u062f \u0627\u062d\u0645\u062f gjghj"
        ],
        "stress_tests": []
    },
    {
        "id": 2951,
        "expression": "^[5,6]\\d{7}|^$",
        "raw_prompt": "Number Begin Specfic Number 5 or 6 and Lenght 8 or Null string",
        "refined_prompt": "\nMatch examples:\n- \"64564654\"\nNon-match examples:\n- \"24564654\"",
        "matches": [
            "64564654"
        ],
        "non_matches": [
            "24564654"
        ],
        "stress_tests": []
    },
    {
        "id": 2952,
        "expression": "([+(]?\\d{0,2}[)]?)([-/.\\s]?\\d+)+",
        "raw_prompt": "it will validate phone number formats like -\n1. (91)123-456-7890\n2. +91-123-456-7890\n3. 911234567890\n4. 1234567890\n5. (91)123/456/7890\n6. +91/123/456/7890\n7. (91)123.456.7890\n8. +91.123.456.7890\nThere is no limitation on the repeating pattern",
        "refined_prompt": "\nMatch examples:\n- \"+91.123.456.7890\"\nNon-match examples:\n- \"symbols other than '/' '.' '(' ')' '-' will not be allowed\"",
        "matches": [
            "+91.123.456.7890"
        ],
        "non_matches": [
            "symbols other than '/' '.' '(' ')' '-' will not be allowed"
        ],
        "stress_tests": []
    },
    {
        "id": 2970,
        "expression": "^((((0[1-9]|[1-2][0-9]|3[0-1])[./-](0[13578]|10|12))|((0[1-9]|[1-2][0-9])[./-](02))|(((0[1-9])|([1-2][0-9])|(30))[./-](0[469]|11)))[./-]((19\\d{2})|(2[012]\\d{2})))$",
        "raw_prompt": "Date pattern for date format\nDD-MM-YYYY or\nDD/MM/YYYY or\nDD.MM.YYYY.\nYear value limited from 1900-2299",
        "refined_prompt": "\nMatch examples:\n- \"01/01/1900\"\n- \"29/02/2012\"\n- \"31/12/2101\"\nNon-match examples:\n- \"30/02/2012\"\n- \"31/04/2010\"",
        "matches": [
            "01/01/1900",
            "29/02/2012",
            "31/12/2101"
        ],
        "non_matches": [
            "30/02/2012",
            "31/04/2010",
            "31.05.2300"
        ],
        "stress_tests": []
    },
    {
        "id": 2972,
        "expression": "^\\S{1}(?:.){4,}\\S$",
        "raw_prompt": "Check if a string contains at least 6 characters. Can not end or start with whitespace but can contain any other. PCRE optimized with none-capturing parentheses.",
        "refined_prompt": "\nMatch examples:\n- \"4 good p@ssW0rd?\"\n- \"password\"\nNon-match examples:\n- \"pass\"\n- \"word\"",
        "matches": [
            "4 good p@ssW0rd?",
            "password"
        ],
        "non_matches": [
            "pass",
            "word",
            "12345"
        ],
        "stress_tests": []
    },
    {
        "id": 2973,
        "expression": "^(0|1)+$",
        "raw_prompt": "A REGEXP that validate a binary number on more rows.",
        "refined_prompt": "\nMatch examples:\n- \"01001010101001\"\nNon-match examples:\n- \"010102002010010\"",
        "matches": [
            "01001010101001"
        ],
        "non_matches": [
            "010102002010010"
        ],
        "stress_tests": []
    },
    {
        "id": 2980,
        "expression": "(\\w+),[^(]+\\((\\w+)\\)\\s+(\\w+)\\s+(\\d+)/(\\d+)\\s+(\\d+)?",
        "raw_prompt": "7750 Birthday & Anniversayr Report",
        "refined_prompt": "\nMatch examples:\n- \"Alexander, Doug (DOUG) Sharon 02/12 Hilscher, Susan M. (SUSAN) Woody 02/22 44\"\nNon-match examples:\n- \"asdf\"",
        "matches": [
            "Alexander, Doug (DOUG) Sharon 02/12 Hilscher, Susan M. (SUSAN) Woody 02/22 44"
        ],
        "non_matches": [
            "asdf"
        ],
        "stress_tests": []
    },
    {
        "id": 2984,
        "expression": "(?i)((sun(day)?|mon(day)?|tue(sday)?|wed(nesday)?|thu(rsday)?|fri(day)?|sat(urday)?),?\\s)?((jan(uary)?|feb(ruary)?|mar(ch)?|apr(il)?|may|jun(e)?|jul(y)?|aug(ust)?|sep(tember)?|oct(ober)?|nov(ember)?|dec(ember)?)\\s)+((0?[1-9]|[1-2][0-9]|3[0-1]),?\\s)+([1-2][0-9][0-9][0-9])",
        "raw_prompt": "Matches full textual date formats. Case insensitive, optional commas, short and long weekdays and months, optional weekdays, optional leading zeros in date.",
        "refined_prompt": "\nMatch examples:\n- \"Sun, Mar 7, 2012\"\n- \"Sunday, March 7, 2012\"\n- \"March 07, 2012\"\nNon-match examples:\n- \"07MAR2012\"\n- \"03/07/2012\"",
        "matches": [
            "Sun, Mar 7, 2012",
            "Sunday, March 7, 2012",
            "March 07, 2012",
            "SUN MARCH 7 2012"
        ],
        "non_matches": [
            "07MAR2012",
            "03/07/2012",
            "Mar-07-2012"
        ],
        "stress_tests": []
    },
    {
        "id": 2988,
        "expression": "^\\d+((\\.|\\,)\\d+)?$",
        "raw_prompt": "Decimal with comma or dot",
        "refined_prompt": "\nMatch examples:\n- \"11,11\"\n- \"33.33\"\n- \"22\"\nNon-match examples:\n- \".11\"\n- \".33\"",
        "matches": [
            "11,11",
            "33.33",
            "22"
        ],
        "non_matches": [
            ".11",
            ".33",
            "11,111.1"
        ],
        "stress_tests": []
    },
    {
        "id": 2989,
        "expression": "^[1-9]+[0-9]*$",
        "raw_prompt": "Matches all Positive Numbers not including zero (0). Does not allow decimals.",
        "refined_prompt": "\nMatch examples:\n- \"1\"\n- \"12\"\n- \"1000\"\nNon-match examples:\n- \"0\"\n- \"-2\"",
        "matches": [
            "1",
            "12",
            "1000"
        ],
        "non_matches": [
            "0",
            "-2",
            "1.00"
        ],
        "stress_tests": []
    },
    {
        "id": 2992,
        "expression": "^(?=^.{1,254}$)(^(?:(?!\\.|-)([a-z0-9\\-\\*]{1,63}|([a-z0-9\\-]{1,62}[a-z0-9]))\\.)+(?:[a-z]{2,})$)$",
        "raw_prompt": "This regex matches FQDNs plus domains starting with an or containing asterisk. This is usefull for DNS configuration tools where you might have domains like *.domain.de or 12.152.80.in-addr.arpa.",
        "refined_prompt": "\nMatch examples:\n- \"12.152.80.in-addr.arpa\"\n- \"*.domain.de\"\n- \"test.de\"\nNon-match examples:\n- \"test\"\n- \"test.\"",
        "matches": [
            "12.152.80.in-addr.arpa",
            "*.domain.de",
            "test.de"
        ],
        "non_matches": [
            "test",
            "test.",
            "-.de"
        ],
        "stress_tests": []
    },
    {
        "id": 2994,
        "expression": "ISBN(-1(?:(0)|3))?:?\\x20(\\s)*[0-9]+[- ][0-9]+[- ][0-9]+[- ][0-9]*[- ]*[xX0-9]",
        "raw_prompt": "To find ISBN-10 or ISBN-13 text",
        "refined_prompt": "\nMatch examples:\n- \"ISBN-13 978-3-642-11746-6 SomeText\"\n- \"ISBN 978-3-642-11746-6\"\n- \"ISBN-10 3-642-11746-5 SomeText\"\nNon-match examples:\n- \"ISBN : 978-3-642-11746-6\"\n- \"ISBN-10 : 3-642-11746-5\"",
        "matches": [
            "ISBN-13 978-3-642-11746-6 SomeText",
            "ISBN 978-3-642-11746-6",
            "ISBN-10 3-642-11746-5 SomeText",
            "ISBN 3-642-11746-5",
            "ISBN: 978-3-642-11746-6"
        ],
        "non_matches": [
            "ISBN : 978-3-642-11746-6",
            "ISBN-10 : 3-642-11746-5",
            "ISBN-13 : 978-3-642-11746-6"
        ],
        "stress_tests": []
    },
    {
        "id": 3001,
        "expression": "^[\\d]{1,}?\\.[\\d]{2}$",
        "raw_prompt": "This will check that the string is made of up numbers in a D.XX with at least on number for D",
        "refined_prompt": "\nMatch examples:\n- \"1234.56\"\n- \"1.50\"\n- \"0.50\"\nNon-match examples:\n- \"X23.50\"\n- \"23.5\"",
        "matches": [
            "1234.56",
            "1.50",
            "0.50"
        ],
        "non_matches": [
            "X23.50",
            "23.5",
            ".50"
        ],
        "stress_tests": []
    },
    {
        "id": 3003,
        "expression": "^(0[1-9]|[12][0-9]|3[01])[\\s\\.\\-/](J(anuary|uly|an|AN)|M(arch|ar|AR|ay|AY)|A(ugust|ug|UG)|(O(ctober|ct|CT)|(D(ecember|ec|EC))))[\\s\\.\\-/][1-9][0-9]{3}|(0[1-9]|[12][0-9]|30)[\\s\\.\\-/](A(pril|pr|PR)|J(une|un|UN)|S(eptember|ep|EP)|N(ovember|ov|OV))[\\s\\.\\-/][1-9][0-9]{3}|(0[1-9]|1[0-9]|2[0-8])[\\s\\.\\-/]F(ebruary|eb|EB)[\\s\\.\\-/][1-9][0-9]{3}|29[\\s\\.\\-/]F(ebruary|eb|EB)[\\s\\.\\-/]((0[48]|[2468][048]|[13579][26])00|[0-9]{2}(0[48]|[2468][048]|[13579][26]))$",
        "raw_prompt": "Verifies all valid Gregorian dates of the form DD MONTH YYYY, and short month names, taking days/month and leap years into account. Accepts space, -, . and / between paramters.",
        "refined_prompt": "\nMatch examples:\n- \"05 March 2012\"\n- \"29-Feb-2012\"\n- \"31.DEC.2011\"\nNon-match examples:\n- \"32 March 2012\"\n- \"29-Feb-2011\"",
        "matches": [
            "05 March 2012",
            "29-Feb-2012",
            "31.DEC.2011"
        ],
        "non_matches": [
            "32 March 2012",
            "29-Feb-2011",
            "2011.DEC.31"
        ],
        "stress_tests": []
    },
    {
        "id": 3004,
        "expression": "(([1-9])|(0[1-9])|(1[0-2]))\\/(([0-9])|([0-2][0-9])|(3[0-1]))\\/(([0-9][0-9])|([1-2][0,9][0-9][0-9]))\\s+(20|21|22|23|[01]\\d|\\d)(([:.][0-5]\\d){1,2})$",
        "raw_prompt": "Validates Date and time in the format mm/dd/yyyy hh:mi:ss",
        "refined_prompt": "\nMatch examples:\n- \"10/12/2012 14:58:32\"\nNon-match examples:\n- \"14/65/20 25:25:25\"",
        "matches": [
            "10/12/2012 14:58:32"
        ],
        "non_matches": [
            "14/65/20 25:25:25"
        ],
        "stress_tests": []
    },
    {
        "id": 3005,
        "expression": "\\b([0-1]?\\d{1,2}|2[0-4]\\d|25[0-5])(\\.([0-1]?\\d{1,2}|2[0-4]\\d|25[0-5])){3}\\b",
        "raw_prompt": "Matches any IPv4.",
        "refined_prompt": "\nMatch examples:\n- \"192.168.11.12\"\n- \"123.123.123.012\"\n- \"0.0.0.1\"\nNon-match examples:\n- \"192.168.11\"\n- \"256.10.11.12\"",
        "matches": [
            "192.168.11.12",
            "123.123.123.012",
            "0.0.0.1"
        ],
        "non_matches": [
            "192.168.11",
            "256.10.11.12",
            "10.101.1.900",
            "192.168.1. 2",
            "192.168.10.0001"
        ],
        "stress_tests": []
    },
    {
        "id": 3011,
        "expression": "(http://)?(www\\.)?(youtube|yimg|youtu)\\.([A-Za-z]{2,4}|[A-Za-z]{2}\\.[A-Za-z]{2})/(watch\\?v=)?[A-Za-z0-9\\-_]{6,12}(&[A-Za-z0-9\\-_]{1,}=[A-Za-z0-9\\-_]{1,})*",
        "raw_prompt": "Matches only valid YouTube links. This includes directly linked videos (yimg) and using YouTube's shortening service (youtu.be). Also supports local domains, like youtube.nl, youtube.de, youtube.co.uk, etc.",
        "refined_prompt": "\nMatch examples:\n- \"www.youtube.co.uk/watch?v=KUlv7qraZaM\"\n- \"http://www.yimg.com/watch?v=KUlv7qraZaM\"\n- \"http://www.youtube.com/watch?v=apxKFXJ8jSg&feature=relmfu\"\nNon-match examples:\n- \"youtube.com/watch/v=apxKFXJ8jSg\"",
        "matches": [
            "www.youtube.co.uk/watch?v=KUlv7qraZaM",
            "http://www.yimg.com/watch?v=KUlv7qraZaM",
            "http://www.youtube.com/watch?v=apxKFXJ8jSg&feature=relmfu",
            "youtu.be/apxKFXJ8jSg"
        ],
        "non_matches": [
            "youtube.com/watch/v=apxKFXJ8jSg"
        ],
        "stress_tests": []
    },
    {
        "id": 3012,
        "expression": "^(([1][0-2])|([0]?[1-9]{1}))\\/(([0-2]?\\d{1})|([3][0,1]{1}))\\/(([1]{1}[9]{1}[9]{1}\\d{1})|([2-9]{1}\\d{3}))$",
        "raw_prompt": "MM/DD/YYYY\nYear from 1990-9999\nThx to: http://regexlib.com/%28X%281%29%29/REDetails.aspx?regexp_id=60",
        "refined_prompt": "\nMatch examples:\n- \"12/31/2012\"\n- \"12/0/2012\"\n- \"2/31/2012\"\nNon-match examples:\n- \"19/28/2012\"\n- \"0/12/1999\"",
        "matches": [
            "12/31/2012",
            "12/0/2012",
            "2/31/2012"
        ],
        "non_matches": [
            "19/28/2012",
            "0/12/1999",
            "5/25/1980"
        ],
        "stress_tests": []
    },
    {
        "id": 3014,
        "expression": "^\\s*[a-zA-Z0-9,\\s]+\\s*$",
        "raw_prompt": "This regular expression allows user to add string spaces and numbers.",
        "refined_prompt": "\nMatch examples:\n- \"Valid Text, 1\"\n- \"2nd Text is valid\"\n- \"Comma , is valid\"\nNon-match examples:\n- \"asd#!#@\"\n- \"asdfasd_asdf\"",
        "matches": [
            "Valid Text, 1",
            "2nd Text is valid",
            "Comma , is valid"
        ],
        "non_matches": [
            "asd#!#@",
            "asdfasd_asdf",
            "2323_SDF_sdf"
        ],
        "stress_tests": []
    },
    {
        "id": 3018,
        "expression": "^[1-9]+\\d*\\.\\d{2}$",
        "raw_prompt": "Useful for matching monetary values formatted without commas, leading zeros, currency symbols.",
        "refined_prompt": "\nMatch examples:\n- \"25.97\"\n- \"5.39\"\n- \"1000.24\"\nNon-match examples:\n- \"0.23\"\n- \"01.45\"",
        "matches": [
            "25.97",
            "5.39",
            "1000.24",
            "10340.23"
        ],
        "non_matches": [
            "0.23",
            "01.45",
            "10,000.23",
            "1000.2"
        ],
        "stress_tests": []
    },
    {
        "id": 3019,
        "expression": "^(?!0?2/3)(?!0?2/29/.{3}[13579])(?!0?2/29/.{2}[02468][26])(?!0?2/29/.{2}[13579][048])(?!(0?[469]|11)/31)(?!0?2/29/[13579][01345789]0{2})(?!0?2/29/[02468][1235679]0{2})(0?[1-9]|1[012])/(0?[1-9]|[12][0-9]|3[01])/([0-9]{4})$",
        "raw_prompt": "Validates dates in the format MM/DD/YYYY, M/D/YYYY, or any permutation in between. Takes into account leap year as well as the rule that century marks are leap years only if they are divisible by 400.",
        "refined_prompt": "\nMatch examples:\n- \"1/30/2012\"\n- \"2/29/2012\"\n- \"02/29/2400\"\nNon-match examples:\n- \"04/31/2000\"\n- \"02/29/2100\"",
        "matches": [
            "1/30/2012",
            "2/29/2012",
            "02/29/2400"
        ],
        "non_matches": [
            "04/31/2000",
            "02/29/2100",
            "2/30/2012"
        ],
        "stress_tests": []
    },
    {
        "id": 3021,
        "expression": "^0$|^0\\.{1}(\\d{1,2})$|^[1-9]{1}[0-9]*\\.?(\\d{1,2})$|^[1-9]+[0-9]*$",
        "raw_prompt": "Matches any non-negative, non-signed real number with maximum of 2 decimal spaces. The decimal is denoted by a . symbol.",
        "refined_prompt": "\nMatch examples:\n- \"0.4\"\n- \"50.76\"\n- \"100\"\nNon-match examples:\n- \"+5\"\n- \".32\"",
        "matches": [
            "0.4",
            "50.76",
            "100",
            "120.00",
            "0",
            "0.00"
        ],
        "non_matches": [
            "+5",
            ".32",
            "00",
            "15.123",
            "-5",
            "4."
        ],
        "stress_tests": []
    },
    {
        "id": 3022,
        "expression": "(^(?!0{5})(\\d{5})(?!-?0{4})(|-\\d{4})?$)",
        "raw_prompt": "This expression matches two different formats of zip codes: 5 digit US ZIP code and 5 digit US ZIP code + 4.The first one must be 5 numeric digits. The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits.",
        "refined_prompt": "\nMatch examples:\n- \"12345\"\n- \"12345-1234\"\nNon-match examples:\n- \"00000\"\n- \"123451234\"",
        "matches": [
            "12345",
            "12345-1234"
        ],
        "non_matches": [
            "00000",
            "123451234",
            "12345-0000",
            "00000-0000",
            "00000-1234",
            "000001234"
        ],
        "stress_tests": []
    },
    {
        "id": 3023,
        "expression": "^([987]{1})(\\d{1})(\\d{8})",
        "raw_prompt": "indian mobile number perfect validation for three number series's that start with 9,8,7. if you want you can easily add one more series that you want in feature. it validates 10 digit number starting with 9,8,7 and followed by 9 digits 0-9 in any order.",
        "refined_prompt": "\nMatch examples:\n- \"9848012345,804812345,7000000000\"\nNon-match examples:\n- \"6897895648,+919848012345\"",
        "matches": [
            "9848012345,804812345,7000000000"
        ],
        "non_matches": [
            "6897895648,+919848012345"
        ],
        "stress_tests": []
    },
    {
        "id": 3030,
        "expression": "^(((?:(?:f|ht)tps?(?!\\:\\/\\/[-\\.\\w]+@)|mailto(?=\\:\\/\\/[-\\.\\w]+@))\\:\\/\\/)?(?:((?:(?:(?:2(?:[0-4]\\d|5[0-5])|[01]?\\d?\\d))(?:\\.(?:2(?:[0-4]\\d|5[0-5])|[01]?\\d?\\d)){3})|(?:(?:[a-zA-Z0-9](?:[-\\w]*[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,6}(?:(?:\\/[-\\w]+(?=\\/))*)?)|(?:[0-9a-zA-Z](?:[-.\\w]*[0-9a-zA-Z])?@(?:[0-9a-zA-Z](?:[-\\w]*[0-9a-zA-Z])?\\.)+[a-zA-Z]{2,6}(?![\\/\\?])))(\\/[-\\w]+)?(?:(?<=\\w)\\.([a-zA-Z0-9]{2,4}))?(?:(?<=\\w)\\?([a-zA-Z][-\\w]*=[-\\w]+(?:&[a-zA-Z][-\\w]*=[-\\w]+)*))?))$",
        "raw_prompt": "Designed for full url matching in common hyperlink text including: 1. ftp(s),http(s), and mailto protocols. 2. ip, domain names and sub-domains, and standard email addresses. 3. files with extensions and parameters. Match provides whole match and protocol, address, page, file extension, and parameter sub-matches for use in parsing. If you see anything that can be improved, by all means provide me some feedback. Thanks!",
        "refined_prompt": "\nMatch examples:\n- \"ftp://255.255.255.255\"\n- \"http://www.domain.com\"\n- \"mailto://user@domain.com\"\nNon-match examples:\n- \"https://user@domain.com\"\n- \"user@domain.com/dir?param=value\"",
        "matches": [
            "ftp://255.255.255.255",
            "http://www.domain.com",
            "mailto://user@domain.com",
            "domain.com/dir/page.ext?param=value&param=value"
        ],
        "non_matches": [
            "https://user@domain.com",
            "user@domain.com/dir?param=value",
            "256.256.256.256",
            "ftps://sub.domain.com/.ext",
            "domain.com/?param=value"
        ],
        "stress_tests": []
    },
    {
        "id": 3033,
        "expression": "^\\d+(\\,\\d{1,2})?$",
        "raw_prompt": "Matches a currency value (without currency symbol) using , for decimal digits separator",
        "refined_prompt": "\nMatch examples:\n- \"0,12\"\n- \"100\"\n- \"100,1\"\nNon-match examples:\n- \"0,123\"\n- \"10.1\"",
        "matches": [
            "0,12",
            "100",
            "100,1"
        ],
        "non_matches": [
            "0,123",
            "10.1",
            ",23"
        ],
        "stress_tests": []
    },
    {
        "id": 3037,
        "expression": "^(([1-9][0-9]{0,3}|[1-4][0-9]{4}|5([0-8][0-9]{3}|9([0-2][0-9]{2}|3([0-8][0-9]|9[01]))))|(6(4(5(1[2-9]|[2-9][0-9])|[6-9][0-9]{2})|5([0-4][0-9]{2}|5([0-2][0-9]|3[0-4]))))|(1(3(1(0(7[2-9]|[89][0-9])|[1-9][0-9]{2})|[2-9][0-9]{3})|[4-9][0-9]{4})|[2-9][0-9]{5}|[1-9][0-9]{6,8}|[1-3][0-9]{9}|4([01][0-9]{8}|2([0-8][0-9]{7}|9([0-3][0-9]{6}|4([0-8][0-9]{5}|9([0-5][0-9]{4}|6([0-6][0-9]{3}|7([01][0-9]{2}|2([0-8][0-9]|9[0-4]))))))))))$",
        "raw_prompt": "will match muliple numeric ranges, from range (1 to 59391) , (64512 to 65534) and (131072 to 4294967294)",
        "refined_prompt": "\nMatch examples:\n- \"1\"\n- \"59391\"\n- \"65000\"\nNon-match examples:\n- \"0\"\n- \"59392\"",
        "matches": [
            "1",
            "59391",
            "65000",
            "4294967294"
        ],
        "non_matches": [
            "0",
            "59392",
            "66000",
            "4294967295"
        ],
        "stress_tests": []
    },
    {
        "id": 3038,
        "expression": "(?!^0*\\.0*$)^\\d{1,10}(\\.\\d{1,2})?$",
        "raw_prompt": "1 to 10 digits are allowed before the decimal. 1 to 2 digits are allowed after decimal. Zero is allowed. Whole numbers allowed.",
        "refined_prompt": "\nMatch examples:\n- \"0\"\n- \"2.50\"\n- \"9999999999.99\"\nNon-match examples:\n- \".50\"\n- \"999999999999\"",
        "matches": [
            "0",
            "2.50",
            "9999999999.99",
            "1.1"
        ],
        "non_matches": [
            ".50",
            "999999999999",
            "1000000.369"
        ],
        "stress_tests": []
    },
    {
        "id": 3040,
        "expression": "((X|x):-?(180(\\.0+)?|[0-1]?[0-7]?[0-9](\\.\\d+)?))([ ]|,)*((Y|y):-?(90(\\.0+)?|[0-8]?[0-9](\\.\\d+)?))",
        "raw_prompt": "Latitude and Longitude in Decimal Degrees useful for X (longitude), Y (latitude) coordinate systems such as WGS84.\nPrefix x: and y: must be used in order.\nX range: -180.00 to 180.00\nY range: -90.00 to 90.00",
        "refined_prompt": "\nMatch examples:\n- \"x:180.00, , ,,, Y:-90.000\"\n- \"x:180y:-90\"\n- \"X:179.99999, Y:-89.99\"\nNon-match examples:\n- \"x:-180.01, y:-90.001\"\n- \"x:-180., y:-90.\"",
        "matches": [
            "x:180.00, , ,,, Y:-90.000",
            "x:180y:-90",
            "X:179.99999, Y:-89.99",
            "X:50 y:5.540",
            "x:050y:05.123",
            "x:0, y:0",
            "X:-179.99999, Y:-89.99",
            "X:-180, y:-90",
            "x:-180.00, Y:-90.000"
        ],
        "non_matches": [
            "x:-180.01, y:-90.001",
            "x:-180., y:-90.",
            "x:180.01, y:90.001",
            "x:180., y:90.",
            "x:180-y:90"
        ],
        "stress_tests": []
    },
    {
        "id": 3041,
        "expression": "[A-Z][a-zA-Z]+ [A-Z][a-zA-Z]+",
        "raw_prompt": "Find proper names in the form John Doe",
        "refined_prompt": "\nMatch examples:\n- \"John Doe\"\n- \"Jeff Tart\"\n- \"Sally Tong\"\nNon-match examples:\n- \"rebecca Hart\"\n- \"Joe\"",
        "matches": [
            "John Doe",
            "Jeff Tart",
            "Sally Tong"
        ],
        "non_matches": [
            "rebecca Hart",
            "Joe",
            "Jeff bridges"
        ],
        "stress_tests": []
    },
    {
        "id": 3043,
        "expression": "<(\\s*/?\\s*)\\w+?(\\s*(([\\w-]+=\"[^\"]*?\")|([\\w-]+='[^']*?')|([\\w-]+=[^'\"<>\\s]+)))*(\\s*/?\\s*)>",
        "raw_prompt": "This RE strips HTML open and close tags from text with any attributes provided, including not properly formatted tags.",
        "refined_prompt": "\nMatch examples:\n- \"<html>, <meta http-equiv=Content-Type content=\"text/html; charset=windows-1250\">, < / html body=\"<'something'>\" body='\"any thing\"' b=jj123-qqj / >\"\nNon-match examples:\n- \"<html / d>, <html body='something\">, <d /html>\"",
        "matches": [
            "<html>, <meta http-equiv=Content-Type content=\"text/html; charset=windows-1250\">, < / html body=\"<'something'>\" body='\"any thing\"' b=jj123-qqj / >"
        ],
        "non_matches": [
            "<html / d>, <html body='something\">, <d /html>"
        ],
        "stress_tests": []
    },
    {
        "id": 3047,
        "expression": "^((\\+92)|(0092))-{0,1}\\d{3}-{0,1}\\d{7}$|^\\d{11}$|^\\d{4}-\\d{7}$",
        "raw_prompt": "The expression is used to validate all the number which follows the format of pakistani mobile companies cell phone number format.\ni.e. Ufone, Warid, Mobilink, Zong, telenor etc",
        "refined_prompt": "\nMatch examples:\n- \"03231234567\"\n- \"0345-1234567\"\n- \"+923211234567\"\nNon-match examples:\n- \"3331234567\"\n- \"0333-123-4567\"",
        "matches": [
            "03231234567",
            "0345-1234567",
            "+923211234567",
            "+92324-1234567",
            "+92-3331234567",
            "+92-333-1234567",
            "00923331234567",
            "0092333-1234567",
            "0092-3331234567",
            "0092-333-1234567"
        ],
        "non_matches": [
            "3331234567",
            "0333-123-4567",
            "92513331234567"
        ],
        "stress_tests": []
    },
    {
        "id": 3049,
        "expression": "(?:\\b\\w*(\\w\\w?)\\1{2,}\\w*\\b)",
        "raw_prompt": "Word deformed by repeating a character, or a pair of characters. Common in internet communication, can be useful for detecting emotions.",
        "refined_prompt": "\nMatch examples:\n- \"wooot\"\n- \"yeeeeah\"\n- \"lalalala\"\nNon-match examples:\n- \"teepee\"\n- \"mississippi\"",
        "matches": [
            "wooot",
            "yeeeeah",
            "lalalala",
            "hahahaha"
        ],
        "non_matches": [
            "teepee",
            "mississippi"
        ],
        "stress_tests": []
    },
    {
        "id": 3058,
        "expression": "^\\s*[a-zA-Z0-9,&\\s]+\\s*$",
        "raw_prompt": "only accept chara, & ,\\ , not allowed- @@ ## $$",
        "refined_prompt": "\nMatch examples:\n- \"AAAA333\"\nNon-match examples:\n- \"@@@$$\"",
        "matches": [
            "AAAA333"
        ],
        "non_matches": [
            "@@@$$"
        ],
        "stress_tests": []
    },
    {
        "id": 3059,
        "expression": "^([0])([1])([1,2,3,4,6,7,8,9])([0-9][0-9][0-9][0-9][0-9][0-9][0-9])",
        "raw_prompt": "accepts malaysian mobile number example (011,012,013...) plus 7 additional numbers",
        "refined_prompt": "\nMatch examples:\n- \"0171234567\"\n- \"0141234567\"\n- \"0167791990\"\nNon-match examples:\n- \"0151234567\"\n- \"0211234567\"",
        "matches": [
            "0171234567",
            "0141234567",
            "0167791990"
        ],
        "non_matches": [
            "0151234567",
            "0211234567",
            "1011234567"
        ],
        "stress_tests": []
    },
    {
        "id": 3064,
        "expression": "[?&]([^&#=]+)(?:=([^&#]*))?",
        "raw_prompt": "Matches parameters in an URL's query part. The parameters' name and value will be available as subsrting $1 and $2. $2 will be empty if the value is empty (e.g. \"\u2026&param=&\u2026\") or undefined if there's no equals to sign (e.g. \"\u2026&param&\u2026\").",
        "refined_prompt": "\nMatch examples:\n- \"http://example.com/?param=value&emptyParam=&undefinedParam#anchor\"\n- \"https://www.google.com/imghp?hl=en&tab=wi\"\n- \"http://www.youtube.com/results?search_type=videos&search_query=Regular+Expressions&uni=3\"\nNon-match examples:\n- \"http://example.com/#anchor\"\n- \"http://www.google.com/\"",
        "matches": [
            "http://example.com/?param=value&emptyParam=&undefinedParam#anchor",
            "https://www.google.com/imghp?hl=en&tab=wi",
            "http://www.youtube.com/results?search_type=videos&search_query=Regular+Expressions&uni=3"
        ],
        "non_matches": [
            "http://example.com/#anchor",
            "http://www.google.com/",
            "URL's with no GET parameters"
        ],
        "stress_tests": []
    },
    {
        "id": 3065,
        "expression": "^((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5]))$",
        "raw_prompt": "Matches valids TCP/IP-Adresses",
        "refined_prompt": "\nMatch examples:\n- \"0.0.0.0\"\n- \"100.10.0.1\"\n- \"255.255.255.255\"\nNon-match examples:\n- \"..12.23\"\n- \"a.23.345\"",
        "matches": [
            "0.0.0.0",
            "100.10.0.1",
            "255.255.255.255"
        ],
        "non_matches": [
            "..12.23",
            "a.23.345",
            "400.500.300.300"
        ],
        "stress_tests": []
    },
    {
        "id": 3066,
        "expression": "^01[1,2,3,4,6,7,8,9]\\d{7,8}$",
        "raw_prompt": "allows the new 8 digit numbers aswell as 7 digit numbers without the 015",
        "refined_prompt": "\nMatch examples:\n- \"01712345677\"\n- \"0141234567\"\n- \"0167791990\"\nNon-match examples:\n- \"0151234567\"\n- \"021567\"",
        "matches": [
            "01712345677",
            "0141234567",
            "0167791990",
            "01277784921"
        ],
        "non_matches": [
            "0151234567",
            "021567",
            "101123456734"
        ],
        "stress_tests": []
    },
    {
        "id": 3071,
        "expression": "^(~?/|[a-zA-Z]:[\\\\/]).+",
        "raw_prompt": "Written to tell absolute and relative paths apart (by matching only absolute paths) on *nix or Windows systems, for a cross-platform PHP project. Admittedly there are a few weird edges cases that will outwit the pattern, like the %FOO% anchor things that can be used in windows paths.",
        "refined_prompt": "\nMatch examples:\n- \"/usr/local/lib\"\n- \"~/temp\"\n- \"C:\\windows\\path\"\nNon-match examples:\n- \"file.ext\"\n- \"./path/file\"",
        "matches": [
            "/usr/local/lib",
            "~/temp",
            "C:\\windows\\path"
        ],
        "non_matches": [
            "file.ext",
            "./path/file",
            "~file"
        ],
        "stress_tests": []
    },
    {
        "id": 3074,
        "expression": "^[^\\\\/:*?\"\"<>|.][^\\\\/:*?\"\"<>|]*(?<!\\.)(^[^\\\\/:*?\"\"<>|]|$)|^$",
        "raw_prompt": "Regex for valid folder name.\n1. Do not allow \\ / : * ? \" < > | any where in the language (folder) name.\n2. Do not allow . at beginning or end of text. '.' can present in middle of text.",
        "refined_prompt": "\nMatch examples:\n- \"ValidFolder.Name\"\n- \"Folder!@#$%^&()\"\n- \"New Folder\"\nNon-match examples:\n- \"InvalidFolderName>\"\n- \"InvalidFolder.\"",
        "matches": [
            "ValidFolder.Name",
            "Folder!@#$%^&()",
            "New Folder"
        ],
        "non_matches": [
            "InvalidFolderName>",
            "InvalidFolder.",
            "Invalid<>Folder"
        ],
        "stress_tests": []
    },
    {
        "id": 3075,
        "expression": "(?:@[A-Z]\\w*\\s+)*(?:(?:public|private|protected)\\s+)?(?:(?:(?:abstract|final|native|transient|static|synchronized)\\s+)*(?:<(?:\\?|[A-Z]\\w*)(?:\\s+(?:extends|super)\\s+[A-Z]\\w*)?(?:(?:,\\s*(?:\\?|[A-Z]\\w*))(?:\\s+(?:extends|super)\\s+[A-Z]\\w*)?)*>\\s+)?(?:(?:(?:[A-Z]\\w*(?:<[A-Z]\\w*>)?|int|float|double|char|byte|long|short|boolean)(?:(?:\\[\\]))*)|void)+)\\s+(([a-zA-Z]\\w*)\\s*\\(\\s*(((?:[A-Z]\\w*(?:<(?:\\?|[A-Z]\\w*)(?:\\s+(?:extends|super)\\s+[A-Z]\\w*)?(?:(?:,\\s*(?:\\?|[A-Z]\\w*))(?:\\s+(?:extends|super)\\s+[A-Z]\\w*)?)*>)?|int|float|double|char|boolean|byte|long|short)(?:(?:\\[\\])|\\.\\.\\.)?\\s+[a-z]\\w*)(?:,\\s*((?:[A-Z]\\w*(?:<[A-Z]\\w*>)?|int|float|double|char|byte|long|short|boolean)(?:(?:\\[\\])|\\.\\.\\.)?\\s+[a-z]\\w*))*)?\\s*\\))",
        "raw_prompt": "\\1 references the method signature (eg main(String[] args)), \\2 references the method name (eg main), \\3 references the args (eg String[] args), and \\4 and up reference each arg in turn (including type names). Supports @interfaces, java keywords/primitives, generic classes (including bounded and unbounded parameters), varargs, and array classes, but due to recursion limitations, generic types can only go one level deep (List<String> is ok, but List<List<String>> isn't).\nDoes not match Constructors.",
        "refined_prompt": "\nMatch examples:\n- \"public static void main(String... args)\"\nNon-match examples:\n- \"public static void Main(string... args)\"",
        "matches": [
            "public static void main(String... args)"
        ],
        "non_matches": [
            "public static void Main(string... args)"
        ],
        "stress_tests": []
    },
    {
        "id": 3083,
        "expression": "^(0{0,1}[1-9][0-9]){1}(\\s){0,1}(\\-){0,1}(\\s){0,1}[1-9]{1}([0-9]{3}|[0-9]{4})(\\-){0,1}(\\s){0,1}[0-9]{4}$",
        "raw_prompt": "Validation to Brazilian telephone number (mobile or not), including DDD and allowing \"9o D\u00edgito\" (on all DDDs). It also accept 2 or 3 digit DDD (11 or 011).\n----- Valid to: ----- 11 98989-9090, 11 977777777, 83-8855-8981, 1199999888, 011 42511992, 01142511992, 011-42511992, 011 4251-1992, 011-4251-1992, 011 98989-9090, 011 977777777, 083-8855-8981, 011999998888, 083 4251-1010, 01192222-3333\n----- Invalid to: ----- 011 9898-90909, 08 98989-9090, 083 4251.1010",
        "refined_prompt": "\nMatch examples:\n- \"1142511992\"\n- \"11 42511992\"\n- \"11-42511992\"\nNon-match examples:\n- \"08 98989-9090\"\n- \"083 4251.1010\"",
        "matches": [
            "1142511992",
            "11 42511992",
            "11-42511992",
            "11 4251-1992",
            "11-4251-1992",
            "011 98989-9090"
        ],
        "non_matches": [
            "08 98989-9090",
            "083 4251.1010",
            "011 9898-90909"
        ],
        "stress_tests": []
    },
    {
        "id": 3097,
        "expression": "<a[\\s]+[^>]*?.*?>([^<]+|.*?)?<\\/a>",
        "raw_prompt": "for cut links on PHP\n$text = preg_replace(\"/<a[\\s]+[^>]*?.*?>([^<]+|.*?)?<\\/a>/s\",\"\",$text);",
        "refined_prompt": "\nMatch examples:\n- \"<a href=\"http://www.tss-s.ru/index.php?option=com_content&amp;task=view&amp;id=170&amp;Itemid=75\">\u041a\u0410\u0417\u0410\u0425\u0421\u0422\u0410\u041d</a>\"\nNon-match examples:\n- \"<a href=\"http://www.tss-s.ru/index.php?option=com_content&amp;task=view&amp;id=170&amp;Itemid=75\">\u041a\u0410\u0417\u0410\u0425\u0421\u0422\u0410\u041d< /a>\"",
        "matches": [
            "<a href=\"http://www.tss-s.ru/index.php?option=com_content&amp;task=view&amp;id=170&amp;Itemid=75\">\u041a\u0410\u0417\u0410\u0425\u0421\u0422\u0410\u041d</a>"
        ],
        "non_matches": [
            "<a href=\"http://www.tss-s.ru/index.php?option=com_content&amp;task=view&amp;id=170&amp;Itemid=75\">\u041a\u0410\u0417\u0410\u0425\u0421\u0422\u0410\u041d< /a>"
        ],
        "stress_tests": []
    },
    {
        "id": 3100,
        "expression": "^([A-Z]{0,3}?[0-9]{9}($[0-9]{0}|[A-Z]{1}))",
        "raw_prompt": "Medicare number validation:XXXYYYYYYYYYZBBXXX- can be up to 3 letters. Not requiredYYY- 9 digits \u2013 requiredZ- must be letter. No number. Not requiredBB- can be letter or numbers. Not required. Can only exist if Z is exists.",
        "refined_prompt": "\nMatch examples:\n- \"ABC123456789A12\"\nNon-match examples:\n- \"CA1234567885\"",
        "matches": [
            "ABC123456789A12"
        ],
        "non_matches": [
            "CA1234567885"
        ],
        "stress_tests": []
    },
    {
        "id": 3105,
        "expression": "(\\w+([-+.']\\w+)*@(gmail.com))",
        "raw_prompt": "This expression will fail if the host/domain does not end with @gmail.com",
        "refined_prompt": "\nMatch examples:\n- \"tester@gmail.com\"\nNon-match examples:\n- \"tester@gmail.net\"\n- \"tester@bob.com\"",
        "matches": [
            "tester@gmail.com"
        ],
        "non_matches": [
            "tester@gmail.net",
            "tester@bob.com"
        ],
        "stress_tests": []
    },
    {
        "id": 3110,
        "expression": "^((\\([2-9]\\d{2}\\)[ ]?)|([2-9]\\d{2})[- ]?)\\d{3}[- ]?\\d{4}$",
        "raw_prompt": "Requires area code, optional parentheses but requires both. Allows '-' or ' '.",
        "refined_prompt": "\nMatch examples:\n- \"(555) 555-5555\"\n- \"555-555-5555\"\n- \"555 555-5555\"\nNon-match examples:\n- \"(555 555-5555, (555)-555-5555\"\n- \"555) 555-5555\"",
        "matches": [
            "(555) 555-5555",
            "555-555-5555",
            "555 555-5555"
        ],
        "non_matches": [
            "(555 555-5555, (555)-555-5555",
            "555) 555-5555"
        ],
        "stress_tests": []
    },
    {
        "id": 3111,
        "expression": "(?!^0*$)(?!^0*\\.0*$)^\\d{1,16}(\\.\\d{1,2})?$",
        "raw_prompt": "Decimal 18,2 valid 16 digits before decimal place\ni.e. upto 16 digit without decimal place is valid. With decimal place 16digit and 2 digits after decimal place is valid",
        "refined_prompt": "\nMatch examples:\n- \"1234567890123456.12\"\nNon-match examples:\n- \"12345678901234567.12\"",
        "matches": [
            "1234567890123456.12"
        ],
        "non_matches": [
            "12345678901234567.12"
        ],
        "stress_tests": []
    },
    {
        "id": 3112,
        "expression": "^((?!string).)*$",
        "raw_prompt": "This expression will NOT match any string that contains the word \"string\". You can replace \"string\" with any list of characters you would like to prevent matching on.",
        "refined_prompt": "\nMatch examples:\n- \"strin\"\n- \"tring\"\n- \"123tring\"\nNon-match examples:\n- \"string\"\n- \"123string\"",
        "matches": [
            "strin",
            "tring",
            "123tring",
            "strin123"
        ],
        "non_matches": [
            "string",
            "123string",
            "string123",
            "anythingwithstringinit"
        ],
        "stress_tests": []
    },
    {
        "id": 3115,
        "expression": "(([0-2]{1}[0-9]{1})|([3-3]{1}[0-1]))/[1-12]{2}/[1900-2999]{4}\\s(([0-0]{1}[0-9]{1})|([1-1]{1}[0-9]{1})|([2-2]{1}[0-3]{1})):[0-5]{1}[0-9]{1}:[0-5]{1}[0-9]{1}",
        "raw_prompt": "UK Data and Time\nUse an 'onupdated' method to correct '31/02/2012' to 28/02/2012, for example.\nMS Visual Studio 2010",
        "refined_prompt": "\nMatch examples:\n- \"18/12/2012 09:52:07 31/02/2012 09:52:07\"\nNon-match examples:\n- \"32/12/3000 09:52:07\"",
        "matches": [
            "18/12/2012 09:52:07 31/02/2012 09:52:07"
        ],
        "non_matches": [
            "32/12/3000 09:52:07"
        ],
        "stress_tests": []
    },
    {
        "id": 3123,
        "expression": "^((((19|20)(([02468][048])|([13579][26])).02.29))|((20[0-9][0-9])|(19[0-9][0-9])).((((0[1-9])|(1[0-2])).((0[1-9])|(1[0-9])|(2[0-8])))|((((0[13578])|(1[02])).31)|(((0[1,3-9])|(1[0-2])).(29|30)))))$",
        "raw_prompt": "Validates yyyy.MM.dd and yyyy-MM-dd format date,and also verifying leap years.",
        "refined_prompt": "\nMatch examples:\n- \"2000.02.29\"\n- \"1976.11.10\"\n- \"1988-02-29\"\nNon-match examples:\n- \"2001.02.29\"\n- \"1980.04.31\"",
        "matches": [
            "2000.02.29",
            "1976.11.10",
            "1988-02-29"
        ],
        "non_matches": [
            "2001.02.29",
            "1980.04.31",
            "1977-05-32"
        ],
        "stress_tests": []
    },
    {
        "id": 3125,
        "expression": "(^[1-9]{1,3}(,\\d{3})*$)|(^0$)",
        "raw_prompt": "Unsigned integer with ',' (comma) as thousands separator, for example: 1,234,500",
        "refined_prompt": "\nMatch examples:\n- \"1,234,500\"\n- \"45\"\n- \"45,111\"\nNon-match examples:\n- \"1,23\"\n- \"0,450\"",
        "matches": [
            "1,234,500",
            "45",
            "45,111",
            "0",
            "1,000",
            "25,123"
        ],
        "non_matches": [
            "1,23",
            "0,450",
            "1000",
            "1000,000",
            "300,1234"
        ],
        "stress_tests": []
    },
    {
        "id": 3127,
        "expression": "^P(([0-9]+([.,][0-9]*)?Y)?([0-9]+([.,][0-9]*)?M)?([0-9]+([.,][0-9]*)?D)?T?([0-9]+([.,][0-9]*)?H)?([0-9]+([.,][0-9]*)?M)?([0-9]+([.,][0-9]*)?S)?)|\\d{4}-?(0[1-9]|11|12)-?(?:[0-2]\\d|30|31)T((?:[0-1][0-9]|[2][0-3]):?(?:[0-5][0-9]):?(?:[0-5][0-9]|60)|2400|24:00)$",
        "raw_prompt": "Test for valid ISO 8601 duration value",
        "refined_prompt": "\nMatch examples:\n- \"P3Y6M4DT12H30M5S P23DT23H P4Y P1M PT1M P0.5Y P0,5Y PT36H P1DT12H P0003-06-04T12:30:05\"\nNon-match examples:\n- \"1234567\"",
        "matches": [
            "P3Y6M4DT12H30M5S P23DT23H P4Y P1M PT1M P0.5Y P0,5Y PT36H P1DT12H P0003-06-04T12:30:05"
        ],
        "non_matches": [
            "1234567"
        ],
        "stress_tests": []
    },
    {
        "id": 3144,
        "expression": "((\\d{1,5})*\\.*(\\d{0,3})\"[W|D|H|DIA][X|\\s]).*",
        "raw_prompt": "It matches product dimensions in inches",
        "refined_prompt": "\nMatch examples:\n- \"24.5\"WX25\"DX24.125\"H\"\n- \"24.5\"WX25\"H \\ 24.5\"W X 25\"H\"\nNon-match examples:\n- \"24.5WX25DX24.125H\"\n- \"24.5\"\"",
        "matches": [
            "24.5\"WX25\"DX24.125\"H",
            "24.5\"WX25\"H \\ 24.5\"W X 25\"H"
        ],
        "non_matches": [
            "24.5WX25DX24.125H",
            "24.5\"",
            "24.5\"X25\""
        ],
        "stress_tests": []
    },
    {
        "id": 3145,
        "expression": "^((0|(\\(0\\)))?|(00|(\\(00\\)))?(\\s?|-?)(27|\\(27\\))|((\\+27))|(\\(\\+27\\))|\\(00(\\s?|-?)27\\))( |-)?(\\(?0?\\)?)( |-)?\\(?(1[0-9]|2[1-4,7-9]|3[1-6,9]|4[0-9]|5[1,3,6-9]|7[1-4,6,8,9]|8[0-9])\\)?(\\s?|-?)((\\d{3}(\\s?|-?)\\d{4}$)|((\\d{4})(\\s?|-?)(\\d{3})$)|([0-2](\\s?|-?)(\\d{3}(\\s?|-?)\\d{3}$)))",
        "raw_prompt": "Matches all valid mobile numbers, landline numbers, share call etc in all common phone number notations",
        "refined_prompt": "\nMatch examples:\n- \"+27-11-399-7206\"\nNon-match examples:\n- \"075-356-6364\"",
        "matches": [
            "+27-11-399-7206"
        ],
        "non_matches": [
            "075-356-6364"
        ],
        "stress_tests": []
    },
    {
        "id": 3148,
        "expression": "^((http(s){0,1}\\:\\/\\/){0,1}([a-z|A-Z|0-9|\\.|\\-|_]){4,255}(\\:\\d{1,5}){0,1}){0,1}((\\/([a-z|A-Z|0-9|\\.|\\-|_]|\\%[A-F|a-f|0-9]{2}){1,255}){1,255}\\/{0,1}){0,1}(|\\/{0,1}\\?[a-z|A-Z|0-9|\\.|\\-|_]{1,255}\\=([a-z|A-Z|0-9|\\.|\\-|_|\\+|\\:]|\\%[A-F|a-f|0-9]{2}|\\&[a-z|A-Z]{2,12}\\;){0,255}){0,1}((\\&[a-z|A-Z|0-9|\\.|\\-|_]{1,255}\\=([a-z|A-Z|0-9|\\.|\\-|_|\\+|\\:]|\\%[A-F|a-f|0-9]{2}|\\&[a-z|A-Z]{2,12}\\;){0,255}){0,255})(\\/{0,1}|\\#([a-z|A-Z|0-9|\\.|\\-|_|\\+|\\:]|\\%[A-F|a-f|0-9]{2}|\\&[a-z|A-Z]{2,12}\\;){0,255})$",
        "raw_prompt": "Validates completely for relative and absolute paths, and allows port definitions. Also contains parameter validation, and allows for anchors and URL escape characters.",
        "refined_prompt": "\nMatch examples:\n- \"http://www.google.com\"\n- \"https://sub.domain.com:8080/ok\"\n- \"mobi.yoursite.org/%e3498549843\"\nNon-match examples:\n- \"http://site.com/?id=4095?x=485\"\n- \"http://site.com:3098594\"",
        "matches": [
            "http://www.google.com",
            "https://sub.domain.com:8080/ok",
            "mobi.yoursite.org/%e3498549843",
            "/relative_path/ok/home.aspx?id=4985&x=5"
        ],
        "non_matches": [
            "http://site.com/?id=4095?x=485",
            "http://site.com:3098594",
            "www.site.org?p=this is wrong"
        ],
        "stress_tests": []
    },
    {
        "id": 3149,
        "expression": "((?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[\\W_]).{6,50})",
        "raw_prompt": "Password requires at least 1 lower case character, 1 upper case character, 1 number, 1 special character and must be at least 6 characters and at most 50",
        "refined_prompt": "\nMatch examples:\n- \"Abcde1!\"\n- \"Abcde1$\"\n- \"ABCDe1!\"\nNon-match examples:\n- \"abcde1!\"\n- \"ABCDE1!\"",
        "matches": [
            "Abcde1!",
            "Abcde1$",
            "ABCDe1!"
        ],
        "non_matches": [
            "abcde1!",
            "ABCDE1!",
            "abcdef"
        ],
        "stress_tests": []
    },
    {
        "id": 3156,
        "expression": "-?[0-9]{4}-(((0(1|3|5|7|8)|1(0|2))-(0[1-9]|(1|2)[0-9]|3[0-1]))|((0(4|6|9)|11)-(0[1-9]|(1|2)[0-9]|30))|(02-(0[1-9]|(1|2)[0-9])))T([0-1][0-9]|2[0-4]):(0[0-9]|[1-5][0-9]):(0[0-9]|[1-5][0-9])(\\.[0-999])?((\\+|-)([0-1][0-9]|2[0-4]):(0[0-9]|[1-5][0-9])|Z)?",
        "raw_prompt": "Matches xs:dateTime values described in XML Schema 1.0. Handles correct days in each month.\nhttp://www.w3.org/TR/xmlschema-2/#dateTime",
        "refined_prompt": "\nMatch examples:\n- \"2012-01-31T10:00:00Z\"\n- \"2012-02-28T10:00:00Z\"\n- \"2012-02-29T10:00:00Z\"\nNon-match examples:\n- \"2012-02-30T10:00:00Z\"\n- \"2012-01-32T10:00:00Z\"",
        "matches": [
            "2012-01-31T10:00:00Z",
            "2012-02-28T10:00:00Z",
            "2012-02-29T10:00:00Z"
        ],
        "non_matches": [
            "2012-02-30T10:00:00Z",
            "2012-01-32T10:00:00Z",
            "2012-04-31T10:00:00Z"
        ],
        "stress_tests": []
    },
    {
        "id": 3159,
        "expression": "(((0[1-9]|(1|2)[0-9]|3[0-1])\\/(0(1|3|5|7|8)|1(0|2)))|((0[1-9]|(1|2)[0-9]|30)\\/(0(4|6|9)|11))|((0[1-9]|(1|2)[0-9])\\/02))\\/[0-9]{4}",
        "raw_prompt": "UK Date Format, using '/' as the separator character.\nHandles correct days in each month.",
        "refined_prompt": "\nMatch examples:\n- \"01/01/2013\"\n- \"30/04/2013\"\n- \"29/01/2013\"\nNon-match examples:\n- \"32/01/2013\"\n- \"31/04/2013\"",
        "matches": [
            "01/01/2013",
            "30/04/2013",
            "29/01/2013"
        ],
        "non_matches": [
            "32/01/2013",
            "31/04/2013",
            "30/02/2013"
        ],
        "stress_tests": []
    },
    {
        "id": 3160,
        "expression": "[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}",
        "raw_prompt": "Matches a Version 4 UUID as described here http://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_.28random.29",
        "refined_prompt": "\nMatch examples:\n- \"e9257dd5-d221-4293-88c3-93f7d3fada4f\"\n- \"dd536276-4483-4c83-9901-2463f78c81cc\"\n- \"b0a59123-bf86-4047-9760-8c968c6b52d7\"\nNon-match examples:\n- \"e9257dd5-d221-1293-88c3-93f7d3fada4f\"\n- \"dd536276-4483-4c83-7901-2463f78c81cc\"",
        "matches": [
            "e9257dd5-d221-4293-88c3-93f7d3fada4f",
            "dd536276-4483-4c83-9901-2463f78c81cc",
            "b0a59123-bf86-4047-9760-8c968c6b52d7"
        ],
        "non_matches": [
            "e9257dd5-d221-1293-88c3-93f7d3fada4f",
            "dd536276-4483-4c83-7901-2463f78c81cc",
            "b0a59123-bf86-2047-9760-5c968c6b52d7"
        ],
        "stress_tests": []
    },
    {
        "id": 3161,
        "expression": "[a-f0-9]{8}-[a-f0-9]{4}-3[a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}",
        "raw_prompt": "Matches a Version 3 UUID as described here http://en.wikipedia.org/wiki/Uuid#Version_3_.28MD5_hash.29",
        "refined_prompt": "\nMatch examples:\n- \"e9257dd5-d221-3293-88c3-93f7d3fada4f\"\n- \"dd536276-4483-3c83-9901-2463f78c81cc\"\n- \"b0a59123-bf86-3047-9760-8c968c6b52d7\"\nNon-match examples:\n- \"e9257dd5-d221-4293-88c3-93f7d3fada4f\"\n- \"dd536276-4483-4c83-9901-2463f78c81cc\"",
        "matches": [
            "e9257dd5-d221-3293-88c3-93f7d3fada4f",
            "dd536276-4483-3c83-9901-2463f78c81cc",
            "b0a59123-bf86-3047-9760-8c968c6b52d7"
        ],
        "non_matches": [
            "e9257dd5-d221-4293-88c3-93f7d3fada4f",
            "dd536276-4483-4c83-9901-2463f78c81cc",
            "b0a59123-bf86-4047-9760-8c968c6b52d7"
        ],
        "stress_tests": []
    },
    {
        "id": 3162,
        "expression": "^((?!.*//.*)(?!.*/ .*)/{1}([^\\\\(){}:\\*\\?<>\\|\\\"\\'])+\\.(csv|jpg|txt|pdf|dat|xls|doc))$",
        "raw_prompt": "This will match with all absolute file paths in Unix/Linux. The extensions added are csv|jpg|txt|pdf|dat|xls|doc. Can be customized for specific extensions.",
        "refined_prompt": "\nMatch examples:\n- \"/usr/local/data/userdata.xls, /home/userdata.doc, /accounts.txt\"\nNon-match examples:\n- \"//usr/local/data/userdata.xls, //usr/local/,/usr/local/ data/users.txt\"",
        "matches": [
            "/usr/local/data/userdata.xls, /home/userdata.doc, /accounts.txt"
        ],
        "non_matches": [
            "//usr/local/data/userdata.xls, //usr/local/,/usr/local/ data/users.txt"
        ],
        "stress_tests": []
    },
    {
        "id": 3163,
        "expression": "(?<=[[]).*?(?=[]])",
        "raw_prompt": "Match Text in square braces",
        "refined_prompt": "\nMatch examples:\n- \"I love [INDIA]\"\nNon-match examples:\n- \"i love india\"",
        "matches": [
            "I love [INDIA]"
        ],
        "non_matches": [
            "i love india"
        ],
        "stress_tests": []
    },
    {
        "id": 3166,
        "expression": "[A-Z|a-z]{4}[0][\\d]{6}$",
        "raw_prompt": "IFSC Code normally contains 11 characters.In that first 4 characters are alphabets,5th character is 0 and next 6 characters are numerics",
        "refined_prompt": "\nMatch examples:\n- \"CITI0344444\"\nNon-match examples:\n- \"CITI3444444\"",
        "matches": [
            "CITI0344444"
        ],
        "non_matches": [
            "CITI3444444"
        ],
        "stress_tests": []
    },
    {
        "id": 3169,
        "expression": "^([7-9]{1})([0-9]{9})$",
        "raw_prompt": "Mobile Number starts with 7,8,9 and total 10 digits",
        "refined_prompt": "\nMatch examples:\n- \"9848457682\"\nNon-match examples:\n- \"123456789\"",
        "matches": [
            "9848457682"
        ],
        "non_matches": [
            "123456789"
        ],
        "stress_tests": []
    },
    {
        "id": 3170,
        "expression": "^[A-Za-z0-9. ]+(?:[_&%$*#@!-][A-Za-z0-9. ]+)*$",
        "raw_prompt": "Rules: Username can consist of lowercase and capitals Username can consist of alphanumeric characters Username can consist of underscore and hyphens and spaces Cannot be two underscores or any other specified special characters, two hypens or two spaces in a row Cannot have a underscore, hypen or space at the start or end",
        "refined_prompt": "\nMatch examples:\n- \"My Name is $Test$ and your name is #testuser# and his name is %testeds% they are *s on this planet.\"\nNon-match examples:\n- \"My Name is $Test$ and your name is #testuser# and his name is %testeds% they are *s on this planet.$\"",
        "matches": [
            "My Name is $Test$ and your name is #testuser# and his name is %testeds% they are *s on this planet."
        ],
        "non_matches": [
            "My Name is $Test$ and your name is #testuser# and his name is %testeds% they are *s on this planet.$"
        ],
        "stress_tests": []
    },
    {
        "id": 3171,
        "expression": "(23:59:59)|([01]{1}[0-9]|2[0-3]):((00)|(15)|(30)|(45))+:(00)",
        "raw_prompt": "match only if 23:59:59 OR increments of 15 minutes from 00:00:00 to 23:45:00\nhh:mm:ss format",
        "refined_prompt": "\nMatch examples:\n- \"00:00:00, 01:15:00, 22:45:00, 23:59:00\"\nNon-match examples:\n- \"00:00:01, 12:04:00, 23:55:00, 05:22:36\"",
        "matches": [
            "00:00:00, 01:15:00, 22:45:00, 23:59:00"
        ],
        "non_matches": [
            "00:00:01, 12:04:00, 23:55:00, 05:22:36"
        ],
        "stress_tests": []
    },
    {
        "id": 3175,
        "expression": "((((19|20)([2468][048]|[13579][26]|0[48])|2000)-02-29|((19|20)[0-9]{2}-(0[469]|11)-(0[1-9]|[12][0-9]|30)|(19|20)[0-9]{2}-(0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01])|(19|20)[0-9]{2}-02-(0[1-9]|1[0-9]|2[0-8])))\\s([01][0-9]|2[0-3]):([012345][0-9]):([012345][0-9]))",
        "raw_prompt": "Very secure MySQL datetime RegEx pattern control.\nStrictly allow the following format only :\n\"YYYY-MM-DD HH:MM:SS\"\nVerify if date is correct (28,29,30,31 days accoring to the month. Leap years with 29/02 also controled.",
        "refined_prompt": "\nMatch examples:\n- \"2013-04-05 17:59:59\"\n- \"2013-07-30 01:22:42\"\n- \"2099-12-30 23:59:59\"\nNon-match examples:\n- \"2016-02-29 -01:01:02\"\n- \"3000-04-24 17:42:21\"",
        "matches": [
            "2013-04-05 17:59:59",
            "2013-07-30 01:22:42",
            "2099-12-30 23:59:59",
            "2016-02-28 00:00:00"
        ],
        "non_matches": [
            "2016-02-29 -01:01:02",
            "3000-04-24 17:42:21",
            "2012-03-03 24:24:02",
            "2012-03-03 21:60:45"
        ],
        "stress_tests": []
    },
    {
        "id": 3177,
        "expression": "((\\+351|00351|351)?)(2\\d{1}|(9(3|6|2|1)))\\d{7}",
        "raw_prompt": "Validates mobile and land-line numbers. Also validates international Portuguese code +351.",
        "refined_prompt": "\nMatch examples:\n- \"217896545\"\n- \"+351214563214\"\n- \"917894125\"\nNon-match examples:\n- \"dfsdfdf9122222\"\n- \"528521445\"",
        "matches": [
            "217896545",
            "+351214563214",
            "917894125",
            "00351917896352"
        ],
        "non_matches": [
            "dfsdfdf9122222",
            "528521445",
            "+6542544545"
        ],
        "stress_tests": []
    },
    {
        "id": 3179,
        "expression": "[A-Za-z]{1,2}[\\d]{1,2}[A-Za-z]{0,1}\\s*[\\d]",
        "raw_prompt": "The postcode sector is the first block (the postcode district) of a UK postcode plus the first number of the second block. For example with DN55 1PT it would match DN55 1. Its a loose match as it only ensures that the format is correct, it doesn't validate the letters and numbers. It doesn't let in the non-geographic codes postcodes SAN TA1 and GIR 0AA. It will pull out the first block & the sector code of any of the matching examples below. Examples of the names of the different parts of a UK postcode can be found here: http://en.wikipedia.org/wiki/Postcodes_in_the_United_Kingdom#Life-cycle_of_post_codes",
        "refined_prompt": "\nMatch examples:\n- \"AA9A 9AA\"\n- \"A9A 9AA\"\n- \"A9 9AA\"\nNon-match examples:\n- \"SAN TA1\"\n- \"GIR 0AA\"",
        "matches": [
            "AA9A 9AA",
            "A9A 9AA",
            "A9 9AA",
            "A99 9AA",
            "AA9 9AA",
            "AA99 9AA",
            "EC1A 1BB",
            "W1A 1HQ",
            "M1 1AA",
            "B33 8TH",
            "CR2 6XH",
            "DN55 1PT",
            "AA9A9AA",
            "A9A9AA",
            "A99AA",
            "A999AA",
            "AA99AA",
            "AA999AA"
        ],
        "non_matches": [
            "SAN TA1",
            "GIR 0AA"
        ],
        "stress_tests": []
    },
    {
        "id": 3180,
        "expression": "^([(]?[+]{1}[0-9]{1,3}[)]?[ .\\-]?)?[(]?[0-9]{3}[)]?[ .\\-]?([0-9]{3}[ .\\-]?[0-9]{4}|[a-zA-Z0-9]{7})([ .\\-]?[/]{1}[ .\\-]?[0-9]{2,4})?$",
        "raw_prompt": "An inefficient number validator. PHP and JavaScript compatible.\nDashes [-] can be replaced by \" \" or \".\"\nSupport for extention /000",
        "refined_prompt": "\nMatch examples:\n- \"+000-000-000-0000\"\n- \"(+000) 000 000 0000\"\n- \"(+000) (000) 000-0000\"\nNon-match examples:\n- \"1-800-0000000\"\n- \"1-800-RLYCOOL\"",
        "matches": [
            "+000-000-000-0000",
            "(+000) 000 000 0000",
            "(+000) (000) 000-0000",
            "(000) 000-0000",
            "+1-800-0000000",
            "+1-800-RLYCOOL"
        ],
        "non_matches": [
            "1-800-0000000",
            "1-800-RLYCOOL"
        ],
        "stress_tests": []
    },
    {
        "id": 3197,
        "expression": "^-?(\\d+(,\\d{3})*(\\.\\d+)?|\\d?(\\.\\d+))$",
        "raw_prompt": "Matches any floating point numeric string with or without commas.",
        "refined_prompt": "\nMatch examples:\n- \"123\"\n- \"9,001\"\n- \"-123,456,789.123\"\nNon-match examples:\n- \"abc\"\n- \"-\"",
        "matches": [
            "123",
            "9,001",
            "-123,456,789.123",
            "3.14159",
            ".25"
        ],
        "non_matches": [
            "abc",
            "-",
            "123,456,78",
            "0.123.456",
            "234.567,890",
            ",123,456"
        ],
        "stress_tests": []
    },
    {
        "id": 3199,
        "expression": "(\\d{1,3}[\\.]\\d*)[, ]+-?(\\d{1,3}[\\.]\\d*)",
        "raw_prompt": "Matches Google Maps style GPS Decimal format, but not Northing, Easting style or DMS",
        "refined_prompt": "\nMatch examples:\n- \"38.048889, 122.157778\"\n- \"46.3881 -116.8204\"\nNon-match examples:\n- \"46\u00b023'17.1600, -116\u00b049'13.4400\"\n- \"38\u00b02'56'N, 122\u00b09'28'W\"",
        "matches": [
            "38.048889, 122.157778",
            "46.3881 -116.8204"
        ],
        "non_matches": [
            "46\u00b023'17.1600, -116\u00b049'13.4400",
            "38\u00b02'56'N, 122\u00b09'28'W",
            "38\u00b02'56''N, 122\u00b09'28''W",
            "38\u00b02'56\"N, 122\u00b09'28\"W",
            "40:26:46N,079:56:55W",
            "40\u00b026\u203247\u2033N 079\u00b058\u203236\u2033W",
            "40d 26m 47s N 079d 58\u2032 36\u2033 W",
            "90 00 00.0, 180 00 00.0",
            "89 59 50.4141 S 090 29 20.4 E",
            "00 00 00.0, 000 00 00.0"
        ],
        "stress_tests": []
    },
    {
        "id": 3200,
        "expression": "^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*\\W)(?!.*\\s).{8,}$",
        "raw_prompt": "Password expresion that requires one lower case letter, one upper case letter, one digit, one non-word character, 8>= length and no spaces.",
        "refined_prompt": "\nMatch examples:\n- \"aA@1aaaa\"\n- \"aA@1aaaaasfljs;lkfe\"\nNon-match examples:\n- \"aA@1a aaa\"\n- \"aA1aaaaaaaa\"",
        "matches": [
            "aA@1aaaa",
            "aA@1aaaaasfljs;lkfe"
        ],
        "non_matches": [
            "aA@1a aaa",
            "aA1aaaaaaaa",
            "12345678"
        ],
        "stress_tests": []
    },
    {
        "id": 3201,
        "expression": "^[a-zA-Z]{3}[0-9]{6}$",
        "raw_prompt": "Simple Pac code regex, first 3 should be letters and last 6 should be digits.",
        "refined_prompt": "\nMatch examples:\n- \"abc123456\"\n- \"ptx654321\"\nNon-match examples:\n- \"abc 123456\"\n- \"ab12345x\"",
        "matches": [
            "abc123456",
            "ptx654321"
        ],
        "non_matches": [
            "abc 123456",
            "ab12345x",
            "abc12345"
        ],
        "stress_tests": []
    },
    {
        "id": 3207,
        "expression": "^((\\+|00)[1-9]{1,3})?(\\-| {0,1})?(([\\d]{0,3})(\\-| {0,1})?([\\d]{5,11})){1}$",
        "raw_prompt": "International phone number with 6 capturing groups:\ninternational prefix (00 xor '+');\n1 to 3 international code number, no zero allowed;\noptional space or hyphen;\n0 to 3 local prefix number;\noptional space or hyphen;\n5 to 11 local number without spaces or hyphens;",
        "refined_prompt": "\nMatch examples:\n- \"0034 91 12345678\"\n- \"+39-2-1234567\"\n- \"9112345678\"\nNon-match examples:\n- \"0034 91 123-456-789\"\n- \"(91)12345678\"",
        "matches": [
            "0034 91 12345678",
            "+39-2-1234567",
            "9112345678"
        ],
        "non_matches": [
            "0034 91 123-456-789",
            "(91)12345678",
            "0034 (91)12345678"
        ],
        "stress_tests": []
    },
    {
        "id": 3209,
        "expression": "^([a-z0-9]+[.+-])*([a-z0-9]+)+@(([a-z0-9]+[.-])+([a-z]{2,})$|(([0-9]|[1-9][0-9]|1[0-9]{1,2}|2[0-4][0-9]|25[0-5])(\\.|$)){4})",
        "raw_prompt": "Validates most common varieties of email addresses.\nWill accept domain with character-valid TLD, and also will accept an IPv4 address.\nIt doesn't support validation of IPv6 address.\nWill also accept a valid username with tags.",
        "refined_prompt": "\nMatch examples:\n- \"j-ohn.smith@example.com\"\n- \"j.smith+account@sub-domain.domain.tld\"\n- \"1@4.144.0.255\"\nNon-match examples:\n- \".s@example.com\"\n- \"name.+tag@domain.tld\"",
        "matches": [
            "j-ohn.smith@example.com",
            "j.smith+account@sub-domain.domain.tld",
            "1@4.144.0.255",
            "a+a@0.0.0.0"
        ],
        "non_matches": [
            ".s@example.com",
            "name.+tag@domain.tld",
            "aaa+@domain.tld",
            "john@125.122.1",
            "a@a",
            "a@a.255",
            "a@a.com1"
        ],
        "stress_tests": []
    },
    {
        "id": 3211,
        "expression": "(?!^[0-9]*$)(?!^[a-zA-Z]*$)^([a-zA-Z0-9]{6,8})$",
        "raw_prompt": "It Required Input of a combination of Numbers & Strings also length must be greater than 6...",
        "refined_prompt": "\nMatch examples:\n- \"123456s\"\n- \"abc123\"\n- \"123abc\"\nNon-match examples:\n- \"1234567\"\n- \"+_()'675\"",
        "matches": [
            "123456s",
            "abc123",
            "123abc"
        ],
        "non_matches": [
            "1234567",
            "+_()'675",
            "abcdefgh"
        ],
        "stress_tests": []
    },
    {
        "id": 3214,
        "expression": "^\\d{5}[- .]?\\d{7}[- .]?\\d{1}$",
        "raw_prompt": "It Required Input of National ID Card Number with or without dash(-), Please Rate!",
        "refined_prompt": "\nMatch examples:\n- \"45506-6532448-5\"\n- \"4551658624457\"\nNon-match examples:\n- \"AAA45-65AAA7-2\"\n- \"AAAAA765A66AA\"",
        "matches": [
            "45506-6532448-5",
            "4551658624457"
        ],
        "non_matches": [
            "AAA45-65AAA7-2",
            "AAAAA765A66AA",
            "AAAAAAAAAAAAA"
        ],
        "stress_tests": []
    },
    {
        "id": 3215,
        "expression": "^\\{[A-Fa-f\\d]{8}-[A-Fa-f\\d]{4}-[A-Fa-f0\\d]{4}-[A-Fa-f\\d]{4}-[A-Fa-f\\d]{12}\\}$",
        "raw_prompt": "This validates GUID strings. It is not case sensitive and requires the beginning and ending curly brackets - '{' and '}' - to be present.",
        "refined_prompt": "\nMatch examples:\n- \"{CA373C30-293E-4DB8-A5E4-07AEA8D3F16E}\"\n- \"{01234567-8998-7654-3210-012345678998}\"\n- \"{ABCDEFFE-DCBA-ABCD-EFFE-DCBAABCDEFFE}\"\nNon-match examples:\n- \"{ABCDEFGH-IJKL-MNOP-QRST-UVWXYZ123456}\"\n- \"{0123-456789AB-CDEF-FEDC-BA9876543210}\"\"",
        "matches": [
            "{CA373C30-293E-4DB8-A5E4-07AEA8D3F16E}",
            "{01234567-8998-7654-3210-012345678998}",
            "{ABCDEFFE-DCBA-ABCD-EFFE-DCBAABCDEFFE}"
        ],
        "non_matches": [
            "{ABCDEFGH-IJKL-MNOP-QRST-UVWXYZ123456}",
            "{0123-456789AB-CDEF-FEDC-BA9876543210}\"",
            "{0123456789ABCDEFFEDCBA9876543210}"
        ],
        "stress_tests": []
    },
    {
        "id": 3216,
        "expression": "^(?=.*\\d)\\w+$",
        "raw_prompt": "Any alphabets are allowed.Passsword must contain atleast 1 digit and none of the characters are allowed.",
        "refined_prompt": "\nMatch examples:\n- \"password1\"\nNon-match examples:\n- \"password1@\"",
        "matches": [
            "password1"
        ],
        "non_matches": [
            "password1@"
        ],
        "stress_tests": []
    },
    {
        "id": 3219,
        "expression": "((0[1-9])|(1[0-9])|(2[0-9])|(3[0]))/((0[1-9])|(1[0-2]))/14[3-9]{2}",
        "raw_prompt": "Matches DD/MM/YYYY for Arabic Hijri Dates. It starts range from 1434 ( current year ) to 1499",
        "refined_prompt": "\nMatch examples:\n- \"29/12/1434\"\n- \"01/02/1435\"\n- \"30/11/1434\"\nNon-match examples:\n- \"31/12/144\"\n- \"01/2/1435\"",
        "matches": [
            "29/12/1434",
            "01/02/1435",
            "30/11/1434"
        ],
        "non_matches": [
            "31/12/144",
            "01/2/1435",
            "5/5/1435"
        ],
        "stress_tests": []
    },
    {
        "id": 3228,
        "expression": "^(0|\\+33)[1-9]([-. ]?[0-9]{2}){4}$",
        "raw_prompt": "Match french phone number with or without french international dialling code",
        "refined_prompt": "\nMatch examples:\n- \"+33622313131\"\n- \"02 02 02 02 02\"\n- \"0303030303\"\nNon-match examples:\n- \"+34622313131\"\n- \"1702020202\"",
        "matches": [
            "+33622313131",
            "02 02 02 02 02",
            "0303030303"
        ],
        "non_matches": [
            "+34622313131",
            "1702020202"
        ],
        "stress_tests": []
    },
    {
        "id": 3232,
        "expression": "(?<!\\.)(?<!e[+-])(\\b\\d+\\b)(?!\\.)",
        "raw_prompt": "Locates standalone integers, like the 1 and 4 in 1/4, but doesn't match the 5 in 6e-5 (nor the 6, in fact). I use this to convert 1/4 to 1.0/4.0 so that it can be evaluated as a floating number, since 1/4 by itself will normally eval to 0 (integer division). However, 6e-5.0 would not be valid.",
        "refined_prompt": "\nMatch examples:\n- \"1/4\"\n- \"1e-2+1/4\"\n- \"1.2+4/7\"\nNon-match examples:\n- \"1.9e-2\"\n- \"1e+3\"",
        "matches": [
            "1/4",
            "1e-2+1/4",
            "1.2+4/7"
        ],
        "non_matches": [
            "1.9e-2",
            "1e+3",
            "1e4"
        ],
        "stress_tests": []
    },
    {
        "id": 3234,
        "expression": "^(\\d?)*\\.?(\\d{1}|\\d{2})?$",
        "raw_prompt": "Expression to validate currency formatted numbers without the currency symbol. This is an updated version of my previous expression and now works in ASP.NET regular expression validators.",
        "refined_prompt": "\nMatch examples:\n- \"153\"\n- \"33.48\"\n- \"786.1\"\nNon-match examples:\n- \"-123\"\n- \"8524.258\"",
        "matches": [
            "153",
            "33.48",
            "786.1",
            "1567863483.33"
        ],
        "non_matches": [
            "-123",
            "8524.258",
            "eo45"
        ],
        "stress_tests": []
    },
    {
        "id": 3237,
        "expression": "^((?:[A-HJ-PR-Y][A-HJ-PR-Y]\\s?(?:0[2-9]|[1-9][0-9])\\s?[A-HJ-PR-Z]{3})|(?:[A-Z](?:[IZ][A-Z]|[A-Z][IZ])\\s?\\d{1,4})|(?:[A-HJ-NP-TV-Y]\\s?\\d{1,3}\\s?[A-Z]{3})|(?:[A-Z]{3}\\s?\\d{1,3}\\s?[A-HJ-NPR-TV-Y])|(?:\\d{1,3}\\s?[A-HJ-Y]{1,3}|[A-HJ-Y]{1,3}\\s?\\d{1,3})|(?:\\d{1,4}\\s?(?:[IZ][A-Z]|[A-Z][IZ]))|(?:[A-Z]{1,2}\\s?\\d{1,4}))$",
        "raw_prompt": "Matches all UK number plates used in England, Scotland, Wales and Northern Ireland, including the dateless formats pre-1932 and 1932-1963 formats, the year prefix and suffix formats, and the current style format brought into use from 2001 onwards.",
        "refined_prompt": "\nMatch examples:\n- \"AAA111\"\n- \"A123BCD\"\n- \"ACB123D\"\nNon-match examples:\n- \"A12345\"\n- \"I123JKL\"",
        "matches": [
            "AAA111",
            "A123BCD",
            "ACB123D",
            "AB12CDE"
        ],
        "non_matches": [
            "A12345",
            "I123JKL",
            "IQ12RST",
            "ABC123O"
        ],
        "stress_tests": []
    },
    {
        "id": 3239,
        "expression": "(t|T)(o|O)\\s\\d{4}($|\\D)",
        "raw_prompt": "Catch text containing \"to \" followed by 4 digit number. Not more than 4 digits, ie 5 or 8 digits.",
        "refined_prompt": "\nMatch examples:\n- \"to 9373H\"\n- \"tO 0934\"\n- \"TO 6266\"\nNon-match examples:\n- \"to 82799\"",
        "matches": [
            "to 9373H",
            "tO 0934",
            "TO 6266",
            "To 0937",
            "to 9347.",
            "to 9837",
            "to 8933",
            "to 8937"
        ],
        "non_matches": [
            "to 82799"
        ],
        "stress_tests": []
    },
    {
        "id": 3248,
        "expression": "^[13][a-zA-Z0-9]{26,33}$",
        "raw_prompt": "Matches bitcoin payment (public-key) address.\nAddress must begin with a 1 or 3 and have 27-34 total alphanumeric characters.\nWill exclude Litecoin addresses.\nDoes NOT do a checksum.",
        "refined_prompt": "\nMatch examples:\n- \"1EEVBLgg4h4TTLv76QiQ1Thcvvk3Be7VPV\"\nNon-match examples:\n- \"31uEbMgunupShBVTewXjtqbBv5MndwfXhbzz, L12332liteoinaddress\"",
        "matches": [
            "1EEVBLgg4h4TTLv76QiQ1Thcvvk3Be7VPV"
        ],
        "non_matches": [
            "31uEbMgunupShBVTewXjtqbBv5MndwfXhbzz, L12332liteoinaddress"
        ],
        "stress_tests": []
    },
    {
        "id": 3249,
        "expression": "^L[a-zA-Z0-9]{26,33}$",
        "raw_prompt": "Matches litecoin payment (public-key) address. Address must begin with a L and have 27-34 total alphanumeric characters. Will exclude bitcoin address since they begin with 1 or 3. Does NOT do a checksum.",
        "refined_prompt": "\nMatch examples:\n- \"Lg6GPVfPsmPAbTWYuKBQXtdGnBuCWcxHcr\"\nNon-match examples:\n- \"19RsSjVgob3JgU9cP9PPEiySftNpbU49Xm\"\n- \"qwerty\"",
        "matches": [
            "Lg6GPVfPsmPAbTWYuKBQXtdGnBuCWcxHcr"
        ],
        "non_matches": [
            "19RsSjVgob3JgU9cP9PPEiySftNpbU49Xm",
            "qwerty",
            "__**"
        ],
        "stress_tests": []
    },
    {
        "id": 3253,
        "expression": "(^|([:]|\\n|\\s))(4[0-9]{3}[ -]*[0-9]{4}[ -]*[0-9]{4}[ -]*[0-9]{4}|5[12345][0-9]{2}[ -]*[0-9]{4}[ -]*[0-9]{4}[ -]*[0-9]{4}|3[47][0-9]{2}[ -]*[0-9]{6}[ -]*[0-9]{5}|3(?:0[012345]|[68][0-9])[0-9][ -]*[0-9]{6}[ -]*[0-9]{4}|6(?:011|5[0-9]{2})[ -]*[0-9]{4}[ -]*[0-9]{4}[ -]*[0-9]{4}|35[0-9]{2}[ -]*[0-9]{4}[ -]*[0-9]{4}[ -]*[0-9]{4}|(?:2131|1800)[ -]*[0-9]{6}[ -]*[0-9]{5})",
        "raw_prompt": "Singular Expression standalone or starting with new line, any whitespace or a colon",
        "refined_prompt": "\nMatch examples:\n- \"4916 3337 5336 2425\"\nNon-match examples:\n- \"8024007142161982\"",
        "matches": [
            "4916 3337 5336 2425"
        ],
        "non_matches": [
            "8024007142161982"
        ],
        "stress_tests": []
    },
    {
        "id": 3254,
        "expression": "http[s]?://(www.facebook|[a-zA-Z]{2}-[a-zA-Z]{2}.facebook|facebook)\\.com/(pages/[a-zA-Z0-9\\.-]+/[0-9]+|[a-zA-Z0-9\\.-]+)[/]?$",
        "raw_prompt": "Validating facebook pages url with rules such as with \"www\" or without \"www\", include localization domain such as \"en-gb\"",
        "refined_prompt": "\nMatch examples:\n- \"https://www.facebook.com/PETRONASMOTORSPORTS\"\n- \"http://www.facebook.com/PETRONASMOTORSPORTS\"\n- \"https://facebook.com/PETRONASMOTORSPORTS\"\nNon-match examples:\n- \"https://facebook.com/pages/MotherKidzcommy/\"\n- \"http://facebook.com/pages/MotherKidzcommy/\"",
        "matches": [
            "https://www.facebook.com/PETRONASMOTORSPORTS",
            "http://www.facebook.com/PETRONASMOTORSPORTS",
            "https://facebook.com/PETRONASMOTORSPORTS",
            "http://facebook.com/PETRONASMOTORSPORTS",
            "https://www.facebook.com/pages/MotherKidzcommy/233933596702267",
            "http://www.facebook.com/pages/MotherKidzcommy/233933596702267",
            "http://www.facebook.com/233933596702267",
            "https://www.facebook.com/233933596702267"
        ],
        "non_matches": [
            "https://facebook.com/pages/MotherKidzcommy/",
            "http://facebook.com/pages/MotherKidzcommy/"
        ],
        "stress_tests": []
    },
    {
        "id": 3259,
        "expression": ".*[a-zA-Z]$",
        "raw_prompt": "This expression will accept only for characters both case(upper and lower)",
        "refined_prompt": "\nMatch examples:\n- \"lalu\"\n- \"LALU\"\n- \"LAlu\"\nNon-match examples:\n- \"lalu123\"\n- \"LALU #$#$\"",
        "matches": [
            "lalu",
            "LALU",
            "LAlu"
        ],
        "non_matches": [
            "lalu123",
            "LALU #$#$",
            "Lalu$%"
        ],
        "stress_tests": []
    },
    {
        "id": 3264,
        "expression": "^(([0][1-9]|[1|2][0-9]|[3][0|1])[./-]([0][1-9]|[1][0-2])[./-]([0-9]{4})|(([0][1-9]|[1|2][0-9]|[3][0|1])[./-]([0][1-9]|[1][0-2])[./-]([0-9]{4}))[ ]([0|1][0-2])[:](([0-5][0-9]))([:](([0-5][0-9])))?)$",
        "raw_prompt": "this regular expression accepts date and optinal time with format\n(dd)[.-/](MM)[.-/](yyyy)[ ]\n(hh)[:](mm)[:](ss)",
        "refined_prompt": "\nMatch examples:\n- \"01-01-2014 10:50\"\n- \"01/01/2014 10:50:59\"\n- \"11-10-2012\"\nNon-match examples:\n- \"01-01-2014 10:60\"\n- \"32-01-2014 10:50\"",
        "matches": [
            "01-01-2014 10:50",
            "01/01/2014 10:50:59",
            "11-10-2012"
        ],
        "non_matches": [
            "01-01-2014 10:60",
            "32-01-2014 10:50",
            "01-13-2014 10:50"
        ],
        "stress_tests": []
    },
    {
        "id": 3266,
        "expression": "^(0{1})([1-9]{2})(\\s|-|.{0,1})(\\d{3})(\\s|-|.{0,1})(\\d{2})(\\s|-|.{0,1})(\\d{2})$",
        "raw_prompt": "useful regex when we only need phone number from and for people inside the country",
        "refined_prompt": "\nMatch examples:\n- \"025 546 58 78\"\n- \"025-546-58-78\"\n- \"025.546.58.78\"\nNon-match examples:\n- \"0041 025 546 58 78\"\n- \"+41 025 546 58 78\"",
        "matches": [
            "025 546 58 78",
            "025-546-58-78",
            "025.546.58.78",
            "0255465878"
        ],
        "non_matches": [
            "0041 025 546 58 78",
            "+41 025 546 58 78",
            "+41 (0) 25 546 58 78"
        ],
        "stress_tests": []
    },
    {
        "id": 3270,
        "expression": "^[{|\\(]?[0-9a-fA-F]{8}[-]([0-9a-fA-F]{4}[-]){3}[0-9a-fA-F]{12}[\\)|}]?|[{|\\(]?[0-9a-fA-F]{8}([0-9a-fA-F]{4}){3}[0-9a-fA-F]{12}[\\)|}]?$",
        "raw_prompt": "Matches 32 hex string, with optional hypens and optional closing braces",
        "refined_prompt": "\nMatch examples:\n- \"{0C885DD3-7DD9-484B-9B20-3E6552BCA144}\"\n- \"0C885DD3-7DD9-484B-9B20-3E6552BCA144\"\n- \"0C885DD37DD9484B9B203E6552BCA144\"\nNon-match examples:\n- \"0C885DD3-7DD9-484B-9B20-1E6552BCA\"\n- \"0C885DD3-7DD9484B9B203E6552BCA144\"",
        "matches": [
            "{0C885DD3-7DD9-484B-9B20-3E6552BCA144}",
            "0C885DD3-7DD9-484B-9B20-3E6552BCA144",
            "0C885DD37DD9484B9B203E6552BCA144"
        ],
        "non_matches": [
            "0C885DD3-7DD9-484B-9B20-1E6552BCA",
            "0C885DD3-7DD9484B9B203E6552BCA144",
            "0C885DD37DD9484B9B203E6552BCA1TT"
        ],
        "stress_tests": []
    },
    {
        "id": 3275,
        "expression": "^((\\b[A-Z0-9](\\w)*\\b)|\\s)*$",
        "raw_prompt": "Validate first letter of each word must capital.",
        "refined_prompt": "\nMatch examples:\n- \"Amit Chandrakantbhai Rami\"\nNon-match examples:\n- \"Amit chandrakantbhai Rami\"",
        "matches": [
            "Amit Chandrakantbhai Rami"
        ],
        "non_matches": [
            "Amit chandrakantbhai Rami"
        ],
        "stress_tests": []
    },
    {
        "id": 3277,
        "expression": "^([0-9]{4})([0-9]{5})([0-9]{1})$",
        "raw_prompt": "The INN code is formed by:\nthe code of the tax department where INN was given (4 numbers), the record number of a registered company in the territorial section of the Unified State Register of Legal Entities in the tax department where INN was given (5 numbers), check digit (1 numbers)",
        "refined_prompt": "\nMatch examples:\n- \"1234567891\"\nNon-match examples:\n- \"-\"",
        "matches": [
            "1234567891"
        ],
        "non_matches": [
            "-"
        ],
        "stress_tests": []
    },
    {
        "id": 3278,
        "expression": "^([0-9]{1})([0-9]{2})([0-9]{2})([0-9]{7})([0-9]{1})$",
        "raw_prompt": "The OGRN code is formed by: the state registration number has the status of the main one (1 number), two last numbers of the year when the record was made (2 numbers), the sequence number of a constituent entity of Russia according to the list of constituent entities of Russia (2 numbers), record number entered in the state register within a year (7 numbers), check digit (1 number)",
        "refined_prompt": "\nMatch examples:\n- \"1234567891234\"\nNon-match examples:\n- \"-\"",
        "matches": [
            "1234567891234"
        ],
        "non_matches": [
            "-"
        ],
        "stress_tests": []
    },
    {
        "id": 3280,
        "expression": "^((0[1-9]|[12][0-9]|3[01])([/])(0[13578]|[1][02])([/])(19[0-9][0-9]|20[0-9][0-9]))|((0[1-9]|[12][0-9]|30)([/])(0[469]|11)([/])(19[0-9][0-9]|20[0-9][0-9]))|((0[1-9]|[1][0-9]|[2][0-8])([/])(02)([/])(19[0-9][0-9]|20[0-9][0-9]))|((29)([/])(02)([/])(190[48]|19[13579][26]|19[2468][048]|20[02468][048]|20[13579][26]))$",
        "raw_prompt": "This pattern validates dates with slash (/) separator and with years between 1900 and 2099.",
        "refined_prompt": "\nMatch examples:\n- \"01/01/1900\"\n- \"05/12/2014\"\n- \"31/12/2099\"\nNon-match examples:\n- \"41/01/1900\"\n- \"21/31/2014\"",
        "matches": [
            "01/01/1900",
            "05/12/2014",
            "31/12/2099"
        ],
        "non_matches": [
            "41/01/1900",
            "21/31/2014",
            "21/12/1899",
            "21/12/2100"
        ],
        "stress_tests": []
    },
    {
        "id": 3283,
        "expression": "^[A-Z]{1}[AEIOUX]{1}[A-Z]{2}((\\d{2}((0[13578]|1[02])(0[1-9]|[12][0-9]|3[01])|(0[13-9]|1[0-2])(0[1-9]|[12][0-9]|30)|02(0[1-9]|1[0-9]|2[0-8])))|([02468][048]|[13579][26])0229)[HM]{1}(AS|BC|BS|CC|CS|CH|CL|CM|DF|DG|GT|GR|HG|JC|MC|MN|MS|NT|NL|OC|PL|QT|QR|SP|SL|SR|TC|TS|TL|VZ|YN|ZS|NE)[B-DF-HJ-NP-TV-Z]{3}[0-9A-Z]{1}[0-9]$",
        "raw_prompt": "This regular expression is used to check the correct input of Mexican CURP, this regex has been modified over the years to correct some bugs.\nEsta expresi\u00f3n regular la uso para checar la captura de curp en un sistema donde es utilizada como llave universal y se ha actualizado para arreglar peque\u00f1os errores como X en el segundo caracter y que la fecha de nacimiento sea valida.",
        "refined_prompt": "\nMatch examples:\n- \"CUJM540331MZSNRX09\"\n- \"SASD760229HDFNRV04\"\n- \"PXTA920430HSLNRN02\"\nNon-match examples:\n- \"FRJU450324HBSKJD09\"\n- \"POLO530229MJCJWSD04\"",
        "matches": [
            "CUJM540331MZSNRX09",
            "SASD760229HDFNRV04",
            "PXTA920430HSLNRN02"
        ],
        "non_matches": [
            "FRJU450324HBSKJD09",
            "POLO530229MJCJWSD04",
            "LOOR540932MOCKLD00"
        ],
        "stress_tests": []
    },
    {
        "id": 3293,
        "expression": "myInstance\\.myMethod(.*)\\(.*myParam.*\\)",
        "raw_prompt": "Searchs through code for the myParam value passed as parameter of the myMethod call of myInstance object",
        "refined_prompt": "\nMatch examples:\n- \"myInstance.myMethod( 1, myParam, 'test')\"\nNon-match examples:\n- \"myInstance2.myMethod( 1, myParam, 'test')\"",
        "matches": [
            "myInstance.myMethod( 1, myParam, 'test')"
        ],
        "non_matches": [
            "myInstance2.myMethod( 1, myParam, 'test')"
        ],
        "stress_tests": []
    },
    {
        "id": 3295,
        "expression": "^(1[0-2]|0?[1-9]):([0-5]?[0-9])( AM| PM)$",
        "raw_prompt": "You want to validate times in various traditional time formats, such as hh:mm tt 12-hour formats.",
        "refined_prompt": "\nMatch examples:\n- \"12:45 AM\"\n- \"2:30 PM\"\nNon-match examples:\n- \"12:45AM\"\n- \"2:30PM\"",
        "matches": [
            "12:45 AM",
            "2:30 PM"
        ],
        "non_matches": [
            "12:45AM",
            "2:30PM"
        ],
        "stress_tests": []
    },
    {
        "id": 3296,
        "expression": "^(2[0-3]|[01]?[0-9]):([0-5]?[0-9]):([0-5]?[0-9])$",
        "raw_prompt": "Validate Traditional Time Formats Hours, minutes and seconds, 24-hour clock:",
        "refined_prompt": "\nMatch examples:\n- \"09:45:12\"\n- \"19:05:12\"\nNon-match examples:\n- \"07:35 AM\"",
        "matches": [
            "09:45:12",
            "19:05:12"
        ],
        "non_matches": [
            "07:35 AM"
        ],
        "stress_tests": []
    },
    {
        "id": 3300,
        "expression": "^(([a-zA-Z]:)|((\\\\|/){1,2}\\w+)\\$?)((\\\\|/)(\\w[\\w ]*.*))+\\.([a-zA-Z0-9]+)$",
        "raw_prompt": "Matches file paths to any valid format. Matches both \"\\\" and \"/\" as valid separators in file path. Extension (\"[a-zA-Z0-9]+\") can be changed to any specific extension like (txt|jpg|png) and so on.Does NOT match relative file paths.\nFeel free to write any comments about bugs or anything, since this is my first contribution to regexlib",
        "refined_prompt": "\nMatch examples:\n- \"/asdjd/jhsdh.ajsd\"\n- \"E:\\drive.txt\"\n- \"\\\\usr\\home\\docs.jpg\"\nNon-match examples:\n- \"//home/boo/\"\n- \"foo/bar.bmp\"",
        "matches": [
            "/asdjd/jhsdh.ajsd",
            "E:\\drive.txt",
            "\\\\usr\\home\\docs.jpg",
            "\\users\\assassin\\home/yp.r15"
        ],
        "non_matches": [
            "//home/boo/",
            "foo/bar.bmp"
        ],
        "stress_tests": []
    },
    {
        "id": 3302,
        "expression": "^(\\d{4}-((0[1-9]|1[012])-(0[1-9]|1\\d|2[0-8])|(0[13456789]|1[012])-(29|30)|(0[13578]|1[02])-31)|(\\d{2}[02468][048]|[13579][26])-02-29) (0[0-9]|1[0-9]|2[0-4]):(60|[0-5][0-9]):(60|[0-5][0-9])$",
        "raw_prompt": "This pattern allows for full DateTime entry using yyyy-MM-dd hh:mm:ss format.",
        "refined_prompt": "\nMatch examples:\n- \"2014-08-07 16:52:14\"\n- \"2004-02-29 00:00:59\"\n- \"1800-01-01 23:31:59\"\nNon-match examples:\n- \"2014-08-07 25:52:14\"\n- \"2004-02-30 00:00:59\"",
        "matches": [
            "2014-08-07 16:52:14",
            "2004-02-29 00:00:59",
            "1800-01-01 23:31:59"
        ],
        "non_matches": [
            "2014-08-07 25:52:14",
            "2004-02-30 00:00:59",
            "1800-30-01 23:31:59"
        ],
        "stress_tests": []
    },
    {
        "id": 3303,
        "expression": "([\\\"']).*?[^\\\\]\\1",
        "raw_prompt": "Matches strings in source code for languages that allow string to be single- or double-quoted.",
        "refined_prompt": "\nMatch examples:\n- \"It's called \"Montezuma's revenge\"\"\n- \"\"string with a \\\"string\\\" in it\"\"\n- \"Two 'quotes' on a single \"line\"\"\nNon-match examples:\n- \"Mom's cooking\"\n- \"\"\"",
        "matches": [
            "It's called \"Montezuma's revenge\"",
            "\"string with a \\\"string\\\" in it\"",
            "Two 'quotes' on a single \"line\""
        ],
        "non_matches": [
            "Mom's cooking",
            "\"",
            "\"improperly closed string'"
        ],
        "stress_tests": []
    },
    {
        "id": 3306,
        "expression": "((^\\d{8})|(^\\d{2}[ ]\\d{2}[ ]\\d{2}[ ]\\d{2})|(^\\d{4}[ ]\\d{4}))$",
        "raw_prompt": "A Danish phone number can be written in three ways (if you don't include the country code +45). Either\none block of 8 digits or two blocks of four digits or\nfour blocks of two digits.",
        "refined_prompt": "\nMatch examples:\n- \"12345678\"\n- \"1234 5678\"\n- \"12 34 56 78\"\nNon-match examples:\n- \"123 456 78\"\n- \"12 3456 78\"",
        "matches": [
            "12345678",
            "1234 5678",
            "12 34 56 78"
        ],
        "non_matches": [
            "123 456 78",
            "12 3456 78",
            "1 23 45 67 8",
            "55 ab 66 xy"
        ],
        "stress_tests": []
    },
    {
        "id": 3307,
        "expression": "^(?!0\\d)([0-9]{1,}(,[0-9]{2}))$",
        "raw_prompt": "No leading zeroes. Must have 2 digits after the decimal comma ','",
        "refined_prompt": "\nMatch examples:\n- \"0,00\"\n- \"12,34\"\n- \"2014,08\"\nNon-match examples:\n- \"00,00\"\n- \"12\"",
        "matches": [
            "0,00",
            "12,34",
            "2014,08"
        ],
        "non_matches": [
            "00,00",
            "12",
            "12,3",
            "12,345",
            "08,20"
        ],
        "stress_tests": []
    },
    {
        "id": 3312,
        "expression": "^((8|\\+7)[\\- ]?)?(\\(?\\d{3}\\)?[\\- ]?)?[\\d\\- ]{7,10}$",
        "raw_prompt": "Focused on the Russian mobile + city code of 3 digits (eg, Russia).\n+79261234567\n89261234567\n79261234567\n+7 926 123 45 67\n8(926)123-45-67\n123-45-67\n9261234567\n79261234567\n(495)1234567\n(495) 123 45 67\n89261234567\n8-926-123-45-67\n8 927 1234 234\n8 927 12 12 888\n8 927 12 555 12\n8 927 123 8 123",
        "refined_prompt": "\nMatch examples:\n- \"+79261234567\"\n- \"8(926)123-45-67\"\n- \"+7 926 123 45 67\"\nNon-match examples:\n- \"+9 000 000 00 00\"",
        "matches": [
            "+79261234567",
            "8(926)123-45-67",
            "+7 926 123 45 67"
        ],
        "non_matches": [
            "+9 000 000 00 00"
        ],
        "stress_tests": []
    },
    {
        "id": 3315,
        "expression": "^\\d?\\d([./-])\\d?\\d\\1(?:\\d\\d|\\d{4})$",
        "raw_prompt": "Here's a super simple one for checking dates written numerically, MM/DD/YYYY. Separators can be \"/\", \"-\", or \".\" and must be the same. Because of it's simplicity it will allow dates that don't exist but that doesn't matter if you're looking for a basic date format checker and like to keep it simple.",
        "refined_prompt": "\nMatch examples:\n- \"1/2/14\"\n- \"01-02-2014\"\n- \"1.20.14\"\nNon-match examples:\n- \"1/2/014\"\n- \"1-2.2014\"",
        "matches": [
            "1/2/14",
            "01-02-2014",
            "1.20.14"
        ],
        "non_matches": [
            "1/2/014",
            "1-2.2014",
            "Jan.2, 2014"
        ],
        "stress_tests": []
    },
    {
        "id": 3317,
        "expression": "^([a-yA-Y]{3,4}(?:\\.?|[a-yA-Y]{1,6}?)\\s?\\d?\\d(?:[d-tD-T]{2})?\\,?\\s?(?:\\'?\\d\\d|\\d{4}))$",
        "raw_prompt": "This will match things resembling a written date. It will match dates written incorrectly of course but this cute and funny date matching regex is for the beauty of the simplicity in checking the many ways to write a date.",
        "refined_prompt": "\nMatch examples:\n- \"Jan. 1, 2014\"\n- \"January 1, '14\"\n- \"JAN 1ST 2014\"\nNon-match examples:\n- \"this is not a date\"\n- \"123 isn't either\"",
        "matches": [
            "Jan. 1, 2014",
            "January 1, '14",
            "JAN 1ST 2014"
        ],
        "non_matches": [
            "this is not a date",
            "123 isn't either",
            "neither is this!"
        ],
        "stress_tests": []
    },
    {
        "id": 3322,
        "expression": "^100$|^0$|^[1-9]{0,1}[0-9]{0,1}$|^[1-9]{0,1}[0-9]{0,1}\\.[0-9]{1,3}$",
        "raw_prompt": "Or depending on the decimal convention:\n^100$|^0$|^[1-9]{0,1}[0-9]{0,1}$|^[1-9]{0,1}[0-9]{0,1}\\,[0-9]{1,3}$\nCredit to Samir Azza's expression which I used to expand and arrive at the above expression.",
        "refined_prompt": "\nMatch examples:\n- \"100\"\n- \"0\"\n- \"99.99\"\nNon-match examples:\n- \"00\"\n- \"09.9\"",
        "matches": [
            "100",
            "0",
            "99.99",
            "10",
            "5",
            "1.28"
        ],
        "non_matches": [
            "00",
            "09.9",
            "05.9"
        ],
        "stress_tests": []
    },
    {
        "id": 3323,
        "expression": "^((\\(([1-9]{2})\\))(\\s)?(\\.)?(\\-)?([0-9]{0,1})?([0-9]{4})(\\s)?(\\.)?(\\-)?([0-9]{4})|(([1-9]{2}))(\\s)?(\\.)?(\\-)?([0-9]{0,1})?([0-9]{4})(\\s)?(\\.)?(\\-)?([0-9]{4}))$",
        "raw_prompt": "This expression allows Brazilian phone numbers as they have 4 or 5 prefix digits and with/without regional code. Not perfect but simplifies. Also allows space or dot or hyphen as optional separator in the number as parenthesis in regional code.",
        "refined_prompt": "\nMatch examples:\n- \"(13)98145-5566\"\n- \"(11)8854-3236\"\n- \"(11) 8854-3236\"\nNon-match examples:\n- \"(13654854\"\n- \"01 9854-4253\"",
        "matches": [
            "(13)98145-5566",
            "(11)8854-3236",
            "(11) 8854-3236",
            "(11).8854.3236",
            "(11)-8854-3236",
            "1177854425",
            "11.5642-3115"
        ],
        "non_matches": [
            "(13654854",
            "01 9854-4253",
            "11.456758-525"
        ],
        "stress_tests": []
    },
    {
        "id": 3324,
        "expression": "((20)[0-9]{2})-((0[1-9])|(1[0-2]))-((3[0-1])|([0-2][1-9]|([1-2][0-9])))\\s((2[0-3])|[0-1][0-9]):[0-5][0-9]",
        "raw_prompt": "Date and hour with fixed format, only accepting year >= 2000. If you want more flexibility on the year, you could replace the first expression (20)[0-9]{2} with only [0-9]{4}, that would allow years from 0000 to 9999.",
        "refined_prompt": "\nMatch examples:\n- \"2000-12-29 10:00 2014-10-20 23:59 2001-01-01 00:00\"\nNon-match examples:\n- \"1999-12-29 09:00 2014-01-02 9:00 2000-1-1 23:10\"",
        "matches": [
            "2000-12-29 10:00 2014-10-20 23:59 2001-01-01 00:00"
        ],
        "non_matches": [
            "1999-12-29 09:00 2014-01-02 9:00 2000-1-1 23:10"
        ],
        "stress_tests": []
    },
    {
        "id": 3325,
        "expression": "[0-9.\\-/+() ]{4,}",
        "raw_prompt": "This regex supports international praefix, the national (0) and extension numbers.",
        "refined_prompt": "\nMatch examples:\n- \"+49 (0)40/529 567-31\"\n- \"529 567-31\"\nNon-match examples:\n- \"529\"",
        "matches": [
            "+49 (0)40/529 567-31",
            "529 567-31"
        ],
        "non_matches": [
            "529"
        ],
        "stress_tests": []
    },
    {
        "id": 3326,
        "expression": "[D]?[-D]?[0-9]{5}",
        "raw_prompt": "German postal code with or without national praefix.",
        "refined_prompt": "\nMatch examples:\n- \"D-25335; 25335\"\nNon-match examples:\n- \"5335\"",
        "matches": [
            "D-25335; 25335"
        ],
        "non_matches": [
            "5335"
        ],
        "stress_tests": []
    },
    {
        "id": 3328,
        "expression": "\\bhttp(s?)\\:\\/\\/[a-zA-Z0-9\\/\\?\\-\\.\\&amp;\\(\\)_=#]*",
        "raw_prompt": "Detects URLs in texts. http or https must precede the URL.",
        "refined_prompt": "\nMatch examples:\n- \"https://icd.slr.xxp.corp/xxp(bD1lbiZjPTAwMSZkPW1pbg==)/bc/bsp/xxp/crm_ui_start/default.htm?sxxrole=ZSU_DEF\"\n- \"http://de.selfhtml.org/perl/sprache/regexpr.htm#zeichen\"\n- \"http://dict.leo.org/#/search=precede&searchLoc=0&resultOrder=basic&multiwordShowSingle=on\"\nNon-match examples:\n- \"www.mgvo.de\"\n- \"www.facebook.com\"",
        "matches": [
            "https://icd.slr.xxp.corp/xxp(bD1lbiZjPTAwMSZkPW1pbg==)/bc/bsp/xxp/crm_ui_start/default.htm?sxxrole=ZSU_DEF",
            "http://de.selfhtml.org/perl/sprache/regexpr.htm#zeichen",
            "http://dict.leo.org/#/search=precede&searchLoc=0&resultOrder=basic&multiwordShowSingle=on"
        ],
        "non_matches": [
            "www.mgvo.de",
            "www.facebook.com",
            "google.de"
        ],
        "stress_tests": []
    },
    {
        "id": 3336,
        "expression": "(?i)\\w.*\\@\\w*\\.\\w*",
        "raw_prompt": "Extract Email Address - Autoit",
        "refined_prompt": "\nMatch examples:\n- \"test@server.com\"\n- \"test2_@server.net\"\nNon-match examples:\n- \"test3@server\"",
        "matches": [
            "test@server.com",
            "test2_@server.net"
        ],
        "non_matches": [
            "test3@server"
        ],
        "stress_tests": []
    },
    {
        "id": 3346,
        "expression": "[A-Za-z_.0-9-]+@{1}[a-z]+([.]{1}[a-z]{2,4})+",
        "raw_prompt": "Useful and easy to use RegEx for email validation. Allowed alphabets (capital and small), 0 to 9, \".\", \"_\" and \"-\" before \"@\". Then exactly one \"@\" is allowed in whole email then small letters (1 or more) then multiple set of \".\" and alphabets (2 to 4)",
        "refined_prompt": "\nMatch examples:\n- \"hamza@demo.net\"\n- \"hamza@demo.co.uk\"\n- \"s.hamza.hasan@googlemail.com\"\nNon-match examples:\n- \"a@b.c\"\n- \"@co.uk\"",
        "matches": [
            "hamza@demo.net",
            "hamza@demo.co.uk",
            "s.hamza.hasan@googlemail.com",
            "a@b.cc"
        ],
        "non_matches": [
            "a@b.c",
            "@co.uk",
            "hamza@tk.",
            "demo@.com",
            "demo.dem@hero.c"
        ],
        "stress_tests": []
    },
    {
        "id": 3347,
        "expression": "^[1-9][0-9][0-9][0-9][0-9][0-9]$",
        "raw_prompt": "picode test",
        "refined_prompt": "\nMatch examples:\n- \"221001\"\nNon-match examples:\n- \"abcdd\"",
        "matches": [
            "221001"
        ],
        "non_matches": [
            "abcdd"
        ],
        "stress_tests": []
    },
    {
        "id": 3348,
        "expression": "^([1-9]\\d{0,3}|[1-5]\\d{4}|6[0-4]\\d{3}|65[0-4]\\d{2}|655[0-2]\\d|6553[0-5])$",
        "raw_prompt": "Match TCP/UDP port number between 1 and 65535",
        "refined_prompt": "\nMatch examples:\n- \"1\"\n- \"23\"\n- \"1024\"\nNon-match examples:\n- \"0\"\n- \"65536\"",
        "matches": [
            "1",
            "23",
            "1024",
            "65535"
        ],
        "non_matches": [
            "0",
            "65536"
        ],
        "stress_tests": []
    },
    {
        "id": 3349,
        "expression": "^((19[0-9][0-9])|(20[0-1][0-5]))\\-((0?[1-9])|(1[0-2]))\\-((0?[1-9])|([1-2][0-9])|(3[0-1]))$",
        "raw_prompt": "Year, month and day with dashes.Year starts from 1900 to 2015 and must be 4 digits.",
        "refined_prompt": "\nMatch examples:\n- \"2012-05-21\"\n- \"1960-12-14\"\n- \"1910-5-3\"\nNon-match examples:\n- \"2011/5/21\"\n- \"60-12-14\"",
        "matches": [
            "2012-05-21",
            "1960-12-14",
            "1910-5-3"
        ],
        "non_matches": [
            "2011/5/21",
            "60-12-14",
            "2021-5-3"
        ],
        "stress_tests": []
    },
    {
        "id": 3351,
        "expression": "^\\w+\\W+[a-z]\\W+(\\w+)([a-z])(\\w+)\\s\\&\\s\\w+\\W+[a-z]\\W+\\1(?!\\2)[a-z]\\3$",
        "raw_prompt": "Spelling mistakes found in last name 2nd letter to before a end letter",
        "refined_prompt": "\nMatch examples:\n- \"william a parker & john l perker\"\nNon-match examples:\n- \"John a smith & William b smith\"",
        "matches": [
            "william a parker & john l perker"
        ],
        "non_matches": [
            "John a smith & William b smith"
        ],
        "stress_tests": []
    },
    {
        "id": 3352,
        "expression": "(=)|(<)|(>)|(')|(--)|(/)|(\\+)|(;)|(\\*)|(!)|({)|(})|(drop table)|(drop stored)|(alter table)|(alter stored)|(sp_)|(xp_)|(exec )|(execute )|(fetch)|(select)|(kill)|(selectsys)|(sysobjects)|(syscolumns)|(isnull)|(coalesce)|(dbo)|(tbl)|(usp)",
        "raw_prompt": "Prevent to use any text that can be executed on the database, it limits many options on the text but is safer than let all on the framework",
        "refined_prompt": "\nMatch examples:\n- \"example' OR 1=1, drop all the walls and drop table\"\nNon-match examples:\n- \"this is an example regex\"",
        "matches": [
            "example' OR 1=1, drop all the walls and drop table"
        ],
        "non_matches": [
            "this is an example regex"
        ],
        "stress_tests": []
    },
    {
        "id": 3355,
        "expression": "^(\\+{1,2}?([0-9]{2,4}|\\([0-9]{2,4}\\))?(-|\\s)?)?[0-9]{2,3}(-|\\s)?[0-9\\-]{5,10}$",
        "raw_prompt": "Detect most pattern of universal phone numbers",
        "refined_prompt": "\nMatch examples:\n- \"+(934)-50-1234567\"\nNon-match examples:\n- \"-94-567834\"",
        "matches": [
            "+(934)-50-1234567"
        ],
        "non_matches": [
            "-94-567834"
        ],
        "stress_tests": []
    },
    {
        "id": 3356,
        "expression": "http[s]?://(www.facebook|[a-zA-Z]{2}-[a-zA-Z]{2}.facebook|facebook)\\.com/(events/[0-9]+|[a-zA-Z0-9\\.-]+)[/]?$",
        "raw_prompt": "Validating facebook events url with rules such as with \"www\" or without \"www\", include localization domain such as \"en-gb\"",
        "refined_prompt": "\nMatch examples:\n- \"http://www.facebook.com/events/233933596702267 https://www.facebook.com/events/233933596702267\"\nNon-match examples:\n- \"http://facebook.com/pages/Andy-Worthington/196377860390800\"\n- \"www.facebook.com/pages/Andy-Worthington/196377860390800\"",
        "matches": [
            "http://www.facebook.com/events/233933596702267 https://www.facebook.com/events/233933596702267"
        ],
        "non_matches": [
            "http://facebook.com/pages/Andy-Worthington/196377860390800",
            "www.facebook.com/pages/Andy-Worthington/196377860390800",
            "http://www.facebook.com/people/Andy-Worthington/738143803"
        ],
        "stress_tests": []
    },
    {
        "id": 3357,
        "expression": "^(http(?:s)?\\:\\/\\/[a-zA-Z0-9]+(?:(?:\\.|\\-)[a-zA-Z0-9]+)+(?:\\:\\d+)?(?:\\/[\\w\\-]+)*(?:\\/?|\\/\\w+\\.[a-zA-Z]{2,7}(?:\\?[\\w]+\\=[\\w\\-]+)?)?(?:\\&[\\w]+\\=[\\w\\-]+)*)$",
        "raw_prompt": "A simple but powerful URL validating regex. Accepts multiple sub-domains and sub-directories. Even accepts query strings ande ports! Accepts HTTP or HTTPS. Also accepts optional \"/\" on end of address. This may be the mother of all URL regexes. It's much more stricter than most others that do far less.",
        "refined_prompt": "\nMatch examples:\n- \"http://website.com\"\n- \"http://subdomain.web-site.com/cgi-bin/perl.cgi?key1=value1&key2=value2\"\nNon-match examples:\n- \"http://website.com/perl.cgi?key=\"\n- \"http://web-site.com/cgi-bin/perl.cgi?key1=value1&key2\"",
        "matches": [
            "http://website.com",
            "http://subdomain.web-site.com/cgi-bin/perl.cgi?key1=value1&key2=value2"
        ],
        "non_matches": [
            "http://website.com/perl.cgi?key=",
            "http://web-site.com/cgi-bin/perl.cgi?key1=value1&key2"
        ],
        "stress_tests": []
    },
    {
        "id": 3358,
        "expression": "^([a-zA-Z0-9]+(?:[.-]?[a-zA-Z0-9]+)*@[a-zA-Z0-9]+(?:[.-]?[a-zA-Z0-9]+)*\\.[a-zA-Z]{2,7})$",
        "raw_prompt": "Yet another regex to help validate email addresses. This will work for 99% of all email addresses entered into the average website form. Stricter than RFC2822.",
        "refined_prompt": "\nMatch examples:\n- \"name@email.com\"\nNon-match examples:\n- \"_name@.email.com\"",
        "matches": [
            "name@email.com"
        ],
        "non_matches": [
            "_name@.email.com"
        ],
        "stress_tests": []
    },
    {
        "id": 3359,
        "expression": "^(http\\:\\/\\/[a-zA-Z0-9\\-\\.]+\\.[a-zA-Z]{2,7}(?:\\/[\\w\\-]+)*\\.(?:jpg|jpeg|gif|png))$",
        "raw_prompt": "An overly simple regex to verify a URL pointing towards an image. It's usually all you need for this purpose.",
        "refined_prompt": "\nMatch examples:\n- \"http://website.com/directory/image.gif\"\nNon-match examples:\n- \"www.website.com/image.php\"",
        "matches": [
            "http://website.com/directory/image.gif"
        ],
        "non_matches": [
            "www.website.com/image.php"
        ],
        "stress_tests": []
    },
    {
        "id": 3360,
        "expression": "^((?:\\?[a-zA-Z0-9_]+\\=[a-zA-Z0-9_]+)?(?:\\&[a-zA-Z0-9_]+\\=[a-zA-Z0-9_]+)*)$",
        "raw_prompt": "This is a very simple regex that check the query part of a string. That is to say anything after the \"?\" at the end of an URL.",
        "refined_prompt": "\nMatch examples:\n- \"?key=value\"\n- \"?key1=value1&key2=value2\"\nNon-match examples:\n- \"key=value\"\n- \"?key=value&\"",
        "matches": [
            "?key=value",
            "?key1=value1&key2=value2"
        ],
        "non_matches": [
            "key=value",
            "?key=value&"
        ],
        "stress_tests": []
    },
    {
        "id": 3361,
        "expression": "^((?:\\/[a-zA-Z0-9]+(?:_[a-zA-Z0-9]+)*(?:\\-[a-zA-Z0-9]+)*)+)$",
        "raw_prompt": "An overly simple UNIX based path regex. The path must begin with a forward slash. The path segments may not lead or end with an underscore or dash which is a good thing. They also can not be doubled (__ or --). Another good thing. I've omitted all the punctuation that RFC allows until further notice.",
        "refined_prompt": "\nMatch examples:\n- \"/users/web/mysite/web/cgi-bin\"\nNon-match examples:\n- \"/users/web/my site/web/cgi-bin\"\n- \"users/web/mysite/web/cgi-bin/\"",
        "matches": [
            "/users/web/mysite/web/cgi-bin"
        ],
        "non_matches": [
            "/users/web/my site/web/cgi-bin",
            "users/web/mysite/web/cgi-bin/"
        ],
        "stress_tests": []
    },
    {
        "id": 3365,
        "expression": "^.{2,}$",
        "raw_prompt": "^.{2,}$\n^ = start of line\n. = any character\n{2,} = 2 or more characters\n$ = end of line",
        "refined_prompt": "\nMatch examples:\n- \"LA\"\nNon-match examples:\n- \"I\"",
        "matches": [
            "LA"
        ],
        "non_matches": [
            "I"
        ],
        "stress_tests": []
    },
    {
        "id": 3367,
        "expression": "\\[([\\w \\.]+)\\]\\(([\\w\\.:\\/ ]*)\\)",
        "raw_prompt": "Easy way to match a markdown link\n[link title](www.sometinng.com)",
        "refined_prompt": "\nMatch examples:\n- \"[link title](www.sometinng.com)\"\nNon-match examples:\n- \"[link title]woow(www.sometinng.com)\"",
        "matches": [
            "[link title](www.sometinng.com)"
        ],
        "non_matches": [
            "[link title]woow(www.sometinng.com)"
        ],
        "stress_tests": []
    },
    {
        "id": 3368,
        "expression": "^([A-Z]{1}\\w{1,3}) (\\d{1}[A-Z]{2})$",
        "raw_prompt": "simple validation of a UK postcode.\nExamples of valid:\nAA9A 9AA\nA9A 9AA\nA9 9AA\nA99 9AA\nAA9 9AA\nAA99 9AA",
        "refined_prompt": "\nMatch examples:\n- \"EC1A 2BB\"\nNon-match examples:\n- \"111A 1BB\"",
        "matches": [
            "EC1A 2BB"
        ],
        "non_matches": [
            "111A 1BB"
        ],
        "stress_tests": []
    },
    {
        "id": 3376,
        "expression": "^(?:(((Jan(uary)?|Ma(r(ch)?|y)|Jul(y)?|Aug(ust)?|Oct(ober)?|Dec(ember)?)\\ 31)|((Jan(uary)?|Ma(r(ch)?|y)|Apr(il)?|Ju((ly?)|(ne?))|Aug(ust)?|Oct(ober)?|(Sept|Nov|Dec)(ember)?)\\ (0?[1-9]|([12]\\d)|30))|(Feb(ruary)?\\ (0?[1-9]|1\\d|2[0-8]|(29(?=,\\ ((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))))\\,((1[6-9]|[2-9]\\d)\\d{2})) (?:[0-1]?[0-9]|[2][1-4]):[0-5]?[0-9]:[0-5]?[0-9]\\s?([apAP][Mm])?$",
        "raw_prompt": "Tested with all date times:\nExamples Like:\n[Jul 30,2015 10:40:43 AM]\nif you want to use space then please add before ((1[6-9]|[2-9]\\d)\\d{2}))\nthen it will works fine.",
        "refined_prompt": "\nMatch examples:\n- \"Jul 30,2015 10:40:43 AM\"\nNon-match examples:\n- \"Jul 30, 2015 10:40:43 AM\"",
        "matches": [
            "Jul 30,2015 10:40:43 AM"
        ],
        "non_matches": [
            "Jul 30, 2015 10:40:43 AM"
        ],
        "stress_tests": []
    },
    {
        "id": 3377,
        "expression": "(\\+)?(\\()?(\\d+){1,4}(\\))?(\\s)?(-)?(\\d+){1,3}(\\s)?(-)?(\\d+){1,4}(\\s)?(-)?(\\d+){1,4}(\\s)?(-)?(\\d+){1,4}",
        "raw_prompt": "This regex make you extract all numbers format i develope it now and i want to share with you guys i know you will see it and thanks me later",
        "refined_prompt": "\nMatch examples:\n- \"800-555-5555\"\n- \"+212642477919\"\n- \"(800)-555-5555\"\nNon-match examples:\n- \"0000\"",
        "matches": [
            "800-555-5555",
            "+212642477919",
            "(800)-555-5555"
        ],
        "non_matches": [
            "0000"
        ],
        "stress_tests": []
    },
    {
        "id": 3380,
        "expression": "[0-9]{2}-?[DF][A-Z]{2}-?[0-9]{1}|[DF][A-Z]{1}-?[0-9]{3}-?[A-Z]{1}|[DF]-?[0-9]{3}-?[A-Z]{2}|[DF][A-Z]{2}-?[0-9]{2}-?[A-Z]{1}$",
        "raw_prompt": "Check for dutch moped licenseplate number validity",
        "refined_prompt": "\nMatch examples:\n- \"D-123-AS\"\n- \"D123AS\"\n- \"F-123-SA\"\nNon-match examples:\n- \"Others\"",
        "matches": [
            "D-123-AS",
            "D123AS",
            "F-123-SA",
            "F123SA"
        ],
        "non_matches": [
            "Others"
        ],
        "stress_tests": []
    },
    {
        "id": 3381,
        "expression": "\\(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\)",
        "raw_prompt": "This regex finds the IPs in its route. This uses the UNIX Bash 'traceroute' command's IP format",
        "refined_prompt": "\nMatch examples:\n- \"(8.8.8.8)\"\n- \"(127.0.0.1)\"\nNon-match examples:\n- \"(a.sg.af.)\"\n- \"8.8.8.8\"",
        "matches": [
            "(8.8.8.8)",
            "(127.0.0.1)"
        ],
        "non_matches": [
            "(a.sg.af.)",
            "8.8.8.8"
        ],
        "stress_tests": []
    },
    {
        "id": 3383,
        "expression": "^([A-z]{2}\\d{7})|([A-z]{4}\\d{10})$",
        "raw_prompt": "UK Parcelforce delivery tracking code for internal UK posts. Comes in two formats 2 letters and 7 numbers (e.g. AA1234567) and 4 letters and 10 numbers (e.g. AAAA1234567890). Case insensitive.",
        "refined_prompt": "\nMatch examples:\n- \"AA1234567\"\n- \"AAAA1234567890\"\nNon-match examples:\n- \"non\"\n- \"matching\"",
        "matches": [
            "AA1234567",
            "AAAA1234567890"
        ],
        "non_matches": [
            "non",
            "matching",
            "examples"
        ],
        "stress_tests": []
    },
    {
        "id": 3384,
        "expression": "^([A-z]{2}\\d{9}[Gg][Bb])|(\\d{12})$",
        "raw_prompt": "UK Parcelforce delivery tracking code for international tracking of exports. Comes in two formats: 2 letters and 9 numbers and GB (e.g. AA123456789GB) and 12 numbers (e.g. 123456789012). Case insensitive.",
        "refined_prompt": "\nMatch examples:\n- \"AA123456789GB\"\n- \"123456789012\"\nNon-match examples:\n- \"non\"\n- \"matching\"",
        "matches": [
            "AA123456789GB",
            "123456789012"
        ],
        "non_matches": [
            "non",
            "matching",
            "examples"
        ],
        "stress_tests": []
    },
    {
        "id": 3385,
        "expression": "^[A-z]{2}\\d{9}(?![Gg][Bb])[A-z]{2}$",
        "raw_prompt": "UK Parcelforce delivery tracking code for international tracking of imports. Uses a negative look ahead to prevent it ending in GB which would be an international export code.",
        "refined_prompt": "\nMatch examples:\n- \"AA123456789AA\"\nNon-match examples:\n- \"AA123456789GB\"\n- \"AA123456789gb\"",
        "matches": [
            "AA123456789AA"
        ],
        "non_matches": [
            "AA123456789GB",
            "AA123456789gb",
            "AA123456789Gb",
            "AA123456789gB"
        ],
        "stress_tests": []
    },
    {
        "id": 3387,
        "expression": "^(?:[A-z]{2})?\\d{9}(?:[A-z]{2})?$",
        "raw_prompt": "TNT UK delivery company consignment number tracking code for TNT Track and Trace service. The system will use the 9 digit code (e.g. 123456789) or you can use the letters as shown on your consignment note (e.g. GE123456781WW). Case insensitive.",
        "refined_prompt": "\nMatch examples:\n- \"123456789\"\n- \"GE123456781WW\"\nNon-match examples:\n- \"non\"\n- \"matching\"",
        "matches": [
            "123456789",
            "GE123456781WW"
        ],
        "non_matches": [
            "non",
            "matching",
            "examples"
        ],
        "stress_tests": []
    },
    {
        "id": 3389,
        "expression": "^((1[Zz]\\d{16})|(\\d{12})|([Tt]\\d{10})|(\\d{9}))$",
        "raw_prompt": "As listed in on the UK UPS tracking help page (listed in the source)",
        "refined_prompt": "\nMatch examples:\n- \"1Z9999999999999999\"\n- \"999999999999\"\n- \"T9999999999\"\nNon-match examples:\n- \"non\"\n- \"matching\"",
        "matches": [
            "1Z9999999999999999",
            "999999999999",
            "T9999999999",
            "999999999"
        ],
        "non_matches": [
            "non",
            "matching",
            "examples"
        ],
        "stress_tests": []
    },
    {
        "id": 3394,
        "expression": "^\\d{4}\\/\\d{1,2}\\/\\d{1,2}$",
        "raw_prompt": "This regular expressions matches jalali dates of the form YYYY/XX/XX where XX can be 1 or 2 digits long and YYYY is always 4 digits long.",
        "refined_prompt": "\nMatch examples:\n- \"1394/01/3\"\n- \"1365/12/31\"\n- \"1397/02/01\"\nNon-match examples:\n- \"1394/1/555\"\n- \"139/1/4\"",
        "matches": [
            "1394/01/3",
            "1365/12/31",
            "1397/02/01"
        ],
        "non_matches": [
            "1394/1/555",
            "139/1/4",
            "1/11/1394"
        ],
        "stress_tests": []
    },
    {
        "id": 3398,
        "expression": "^(\\+(1\\-)?\\d{1,3})?(\\s|\\-)?(\\s|\\-)?((\\(\\d{2}\\)|\\d{2})(\\s|\\-)?\\d{4}|(\\(\\d{3}\\)|\\d{3})(\\s|\\-)?\\d{3})(\\s|\\-)?\\d{4}(\\s)?(x|ext|ext.)?(\\d{1,6})?,?(\\d{1,6})?,?(\\d{1,6})?$",
        "raw_prompt": "Match mexican local or international numbers with optional area code parentheses and optional max 3 extensions with 6 chars length.",
        "refined_prompt": "\nMatch examples:\n- \"(55) 1234-5678 x123456,123,12\"\n- \"5512345678\"\n- \"+1 (510) 123-5678 x1234\"\nNon-match examples:\n- \"+1 510 (55 1234-5678\"\n- \"12345678 x123\"",
        "matches": [
            "(55) 1234-5678 x123456,123,12",
            "5512345678",
            "+1 (510) 123-5678 x1234"
        ],
        "non_matches": [
            "+1 510 (55 1234-5678",
            "12345678 x123",
            "+1 (510) 1234-5678 x1234567"
        ],
        "stress_tests": []
    },
    {
        "id": 3408,
        "expression": "(?:#|0x)?(?:[0-9A-F]{2}){4}",
        "raw_prompt": "32 bit hex color preceding with 0x or # . From http://tools.twainscanning.com/getmyregex .",
        "refined_prompt": "\nMatch examples:\n- \"0xF0F73611\"\nNon-match examples:\n- \"#FF006C\"",
        "matches": [
            "0xF0F73611"
        ],
        "non_matches": [
            "#FF006C"
        ],
        "stress_tests": []
    },
    {
        "id": 3417,
        "expression": "[0-9]{4}[/.-](?:1[0-2]|0?[1-9])[/.-](?:3[01]|[12][0-9]|0?[1-9])",
        "raw_prompt": "Date Year-Month-Day. From http://tools.twainscanning.com/getmyregex",
        "refined_prompt": "\nMatch examples:\n- \"2015-08-31\"\nNon-match examples:\n- \"31/08/2015\"",
        "matches": [
            "2015-08-31"
        ],
        "non_matches": [
            "31/08/2015"
        ],
        "stress_tests": []
    },
    {
        "id": 3420,
        "expression": "(facebook|twitter|youtube)",
        "raw_prompt": "Google Analytics Segment by source social media. From http://tools.twainscanning.com/getmyregex .",
        "refined_prompt": "\nMatch examples:\n- \"facebook\"\n- \"twitter\"\n- \"youtube\"\nNon-match examples:\n- \"imgur\"",
        "matches": [
            "facebook",
            "twitter",
            "youtube"
        ],
        "non_matches": [
            "imgur"
        ],
        "stress_tests": []
    },
    {
        "id": 3425,
        "expression": "((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])",
        "raw_prompt": "IP address IPv4 (127.0.0.1) . From http://tools.twainscanning.com/getmyregex .",
        "refined_prompt": "\nMatch examples:\n- \"127.0.0.1\"\nNon-match examples:\n- \"127-0-0-1\"",
        "matches": [
            "127.0.0.1"
        ],
        "non_matches": [
            "127-0-0-1"
        ],
        "stress_tests": []
    },
    {
        "id": 3426,
        "expression": "\\d{3}[.-]?\\d{3}[.-]?\\d{4}",
        "raw_prompt": "Phone number United States (555-555-1234) . From http://tools.twainscanning.com/getmyregex .",
        "refined_prompt": "\nMatch examples:\n- \"555-555-1234\"\nNon-match examples:\n- \"555-55-1234\"",
        "matches": [
            "555-555-1234"
        ],
        "non_matches": [
            "555-55-1234"
        ],
        "stress_tests": []
    },
    {
        "id": 3427,
        "expression": "(?:2[0-3]|[01]?[0-9])[:.][0-5]?[0-9]",
        "raw_prompt": "Time HH:MM (23:30). From http://tools.twainscanning.com/getmyregex .",
        "refined_prompt": "\nMatch examples:\n- \"23:30\"\n- \"23.30\"\nNon-match examples:\n- \"23-30\"",
        "matches": [
            "23:30",
            "23.30"
        ],
        "non_matches": [
            "23-30"
        ],
        "stress_tests": []
    },
    {
        "id": 3428,
        "expression": "(?:1[0-2]|0?[1-9])[:.][0-5]?[0-9][\\t ]+(?:AM|PM)",
        "raw_prompt": "Time HH:MM AM/PM (11:30 PM) . From http://tools.twainscanning.com/getmyregex .",
        "refined_prompt": "\nMatch examples:\n- \"11:30 PM\"\nNon-match examples:\n- \"11:61\"",
        "matches": [
            "11:30 PM"
        ],
        "non_matches": [
            "11:61"
        ],
        "stress_tests": []
    },
    {
        "id": 3430,
        "expression": "https?://[\\d.A-Za-z-]+\\.[A-Za-z]{2,6}/?",
        "raw_prompt": "URL http or https (http://twainscanning.com). From http://tools.twainscanning.com/getmyregex .",
        "refined_prompt": "\nMatch examples:\n- \"http://twainscanning.com\"\nNon-match examples:\n- \"ftp://twainscanning.com\"",
        "matches": [
            "http://twainscanning.com"
        ],
        "non_matches": [
            "ftp://twainscanning.com"
        ],
        "stress_tests": []
    },
    {
        "id": 3431,
        "expression": "(?:https?://|www\\.)[\\d.A-Za-z-]+\\.[A-Za-z]{2,6}/?",
        "raw_prompt": "URL http, https or www (www.twainscanning.com). From http://tools.twainscanning.com/getmyregex .",
        "refined_prompt": "\nMatch examples:\n- \"www.twainscanning.com\"\nNon-match examples:\n- \"twainscanning.com\"",
        "matches": [
            "www.twainscanning.com"
        ],
        "non_matches": [
            "twainscanning.com"
        ],
        "stress_tests": []
    },
    {
        "id": 3434,
        "expression": "[A-Za-z]{5}",
        "raw_prompt": "Word 5-letter word (TWAIN forum) . From http://tools.twainscanning.com/getmyregex .",
        "refined_prompt": "\nMatch examples:\n- \"TWAIN\"\n- \"forum\"\nNon-match examples:\n- \"test\"",
        "matches": [
            "TWAIN",
            "forum"
        ],
        "non_matches": [
            "test"
        ],
        "stress_tests": []
    },
    {
        "id": 3440,
        "expression": "\\[(.+)\\].+\\[n?varchar\\].+NULL,",
        "raw_prompt": "Notepad Plus Plus Replace\npublic string \\1 { get; set; }",
        "refined_prompt": "\nMatch examples:\n- \"[FirstName] [nvarchar](255) NULL,\"\n- \"[LastName] [nvarchar](255) NULL,\"\n- \"[City] [varchar](255) NULL,\"\nNon-match examples:\n- \"[Grade] [decimal](18, 0) NULL,\"\n- \"[Price] [decimal](19, 5) NULL,\"",
        "matches": [
            "[FirstName] [nvarchar](255) NULL,",
            "[LastName] [nvarchar](255) NULL,",
            "[City] [varchar](255) NULL,"
        ],
        "non_matches": [
            "[Grade] [decimal](18, 0) NULL,",
            "[Price] [decimal](19, 5) NULL,",
            "[IsEnabled] [bit] NULL,"
        ],
        "stress_tests": []
    },
    {
        "id": 3444,
        "expression": "[^\\\\]+(?=(\\.dwg)|(\\.pdf)|(\\.doc[^x]))",
        "raw_prompt": "Extract the file name from a full path string.\nFor example, given a full path:\nD:\\Drawing1\\Drawing2\\draw#1.pdf D:\\Drawing1\\Drawing2\\draw#2.doc D:\\Drawing1\\Drawing2\\draw#3.dwg\nresult: draw#1, draw#2, draw#3",
        "refined_prompt": "\nMatch examples:\n- \"D:\\Drawing1\\Drawing2\\draw#1.pdf D:\\Drawing1\\Drawing2\\draw#1.doc D:\\Drawing1\\Drawing2\\draw#1.dwg\"\nNon-match examples:\n- \"D:\\Drawing1\\Drawing2\\draw#1.docx, D:\\Calculations\\Preview\\calcsheet1.xls\"",
        "matches": [
            "D:\\Drawing1\\Drawing2\\draw#1.pdf D:\\Drawing1\\Drawing2\\draw#1.doc D:\\Drawing1\\Drawing2\\draw#1.dwg"
        ],
        "non_matches": [
            "D:\\Drawing1\\Drawing2\\draw#1.docx, D:\\Calculations\\Preview\\calcsheet1.xls"
        ],
        "stress_tests": []
    },
    {
        "id": 3445,
        "expression": "(([\\n, ])*((<+)([^<>]+)(>*))+([\\n, ])*)+",
        "raw_prompt": "finds all HTML tags (<___>) in text and leaves normal text alone. Also matches all extra spaces and empty lines next to html tag, if any.Ragex has extra parentheses for orientation.\nUsefull to delete all unwanted html from, lets say, wikipedia souce code.",
        "refined_prompt": "\nMatch examples:\n- \"<a id = al>\"\n- \"<blahblah>\"\n- \"<<div>something>\"\nNon-match examples:\n- \"9>3\"\n- \"normaltext\"",
        "matches": [
            "<a id = al>",
            "<blahblah>",
            "<<div>something>"
        ],
        "non_matches": [
            "9>3",
            "normaltext",
            "<<<<<<<<"
        ],
        "stress_tests": []
    },
    {
        "id": 3446,
        "expression": "^(([\\u0600-\\u065F\\u066A-\\u06EF\\u06FA-\\u06FF]+)\\s){3}([\\u0600-\\u065F\\u066A-\\u06EF\\u06FA-\\u06FF]+)$",
        "raw_prompt": "you can type the name consist of 4 parts .",
        "refined_prompt": "\nMatch examples:\n- \"\u062d\u0633\u0627\u0645 \u062d\u0633\u0646 \u0639\u0644\u0649 \u062d\u0633\u0646\"\nNon-match examples:\n- \"\u062d\u0633\u0627\u0645 \u062d\u0633\u0646 \u0639\u0644\u0649\"",
        "matches": [
            "\u062d\u0633\u0627\u0645 \u062d\u0633\u0646 \u0639\u0644\u0649 \u062d\u0633\u0646"
        ],
        "non_matches": [
            "\u062d\u0633\u0627\u0645 \u062d\u0633\u0646 \u0639\u0644\u0649"
        ],
        "stress_tests": []
    },
    {
        "id": 3448,
        "expression": "[0-9]{5}\\s?[0-9]{5}",
        "raw_prompt": "Basic UTR and CRT formats, 10 digits however are often written with an optional space after 1st 5",
        "refined_prompt": "\nMatch examples:\n- \"1234567890\"\n- \"12345 67890\"\nNon-match examples:\n- \"123 4567890\"\n- \"A123456789\"",
        "matches": [
            "1234567890",
            "12345 67890"
        ],
        "non_matches": [
            "123 4567890",
            "A123456789"
        ],
        "stress_tests": []
    },
    {
        "id": 3449,
        "expression": "[0-9]{3}P[A-Z][0-9]{7}[0-9X]",
        "raw_prompt": "HMRC Accounts Office Reference (AORef) in format\n3digits, the letter P and another letter followed by 7 digits and either an 8th digit or letter X",
        "refined_prompt": "\nMatch examples:\n- \"123PA12345678\"\n- \"451PW1234523X\"\nNon-match examples:\n- \"A01PA12345678\"\n- \"123RA1234567X\"",
        "matches": [
            "123PA12345678",
            "451PW1234523X"
        ],
        "non_matches": [
            "A01PA12345678",
            "123RA1234567X"
        ],
        "stress_tests": []
    },
    {
        "id": 3454,
        "expression": "^([1-9]|1[0-2])$",
        "raw_prompt": "Simple check for a value between 1 and 12",
        "refined_prompt": "\nMatch examples:\n- \"1\"\n- \"2\"\n- \"12\"\nNon-match examples:\n- \"-1\"\n- \"13\"",
        "matches": [
            "1",
            "2",
            "12"
        ],
        "non_matches": [
            "-1",
            "13",
            "A1"
        ],
        "stress_tests": []
    },
    {
        "id": 3457,
        "expression": "^(?=.*[1-9].*)[0-9]{3}$",
        "raw_prompt": "3 digit number representing an HMRC Tax Office. Office 000 is not valid",
        "refined_prompt": "\nMatch examples:\n- \"001\"\n- \"123\"\n- \"940\"\nNon-match examples:\n- \"-01\"\n- \"000\"",
        "matches": [
            "001",
            "123",
            "940"
        ],
        "non_matches": [
            "-01",
            "000",
            "90.1"
        ],
        "stress_tests": []
    },
    {
        "id": 3459,
        "expression": "^(GB)?([0-9]{9})$",
        "raw_prompt": "If you dont need to validate anything other than UK Numbers then this is for you, with optional GB at the start. If you need other countries then the EU Pattern is better suited",
        "refined_prompt": "\nMatch examples:\n- \"GB123456789\"\n- \"123456789\"\nNon-match examples:\n- \"GB12345678\"\n- \"AA123456789\"",
        "matches": [
            "GB123456789",
            "123456789"
        ],
        "non_matches": [
            "GB12345678",
            "AA123456789",
            "1234567"
        ],
        "stress_tests": []
    },
    {
        "id": 3460,
        "expression": "^[0-9]{8}R[A-HJ-NP-TV-Z]$",
        "raw_prompt": "Pension Schemes have their own references, 8 digits followed by R and then another letter.",
        "refined_prompt": "\nMatch examples:\n- \"12345678RA\"\n- \"43213245RT\"\nNon-match examples:\n- \"1234567RA\"\n- \"432132456RR\"",
        "matches": [
            "12345678RA",
            "43213245RT"
        ],
        "non_matches": [
            "1234567RA",
            "432132456RR"
        ],
        "stress_tests": []
    },
    {
        "id": 3467,
        "expression": "^(A[A-HJ-M]|[BR][A-Y]|C[A-HJ-PR-V]|[EMOV][A-Y]|G[A-HJ-O]|[DFHKLPSWY][A-HJ-PR-Y]|MAN|N[A-EGHJ-PR-Y]|X[A-F]|)(0[02-9]|[1-9][0-9])[A-HJ-P-R-Z]{3}$",
        "raw_prompt": "Current standard UK Registration plates running from Sept 2001 to Feb 2051, basic form AA99AAA but contains prefix combinations, the only number not used is 01",
        "refined_prompt": "\nMatch examples:\n- \"NE02ABC\"\n- \"AA58DEF\"\nNon-match examples:\n- \"NF02ABC\"\n- \"AA01WUX\"",
        "matches": [
            "NE02ABC",
            "AA58DEF"
        ],
        "non_matches": [
            "NF02ABC",
            "AA01WUX"
        ],
        "stress_tests": []
    },
    {
        "id": 3473,
        "expression": "^A([0-9]|10)$",
        "raw_prompt": "Sizes of paper from A0-A10",
        "refined_prompt": "\nMatch examples:\n- \"A0\"\n- \"A6\"\n- \"A10\"\nNon-match examples:\n- \"A-1\"\n- \"B1\"",
        "matches": [
            "A0",
            "A6",
            "A10"
        ],
        "non_matches": [
            "A-1",
            "B1",
            "A11"
        ],
        "stress_tests": []
    },
    {
        "id": 3475,
        "expression": "^([1-9]+)?[02468]$",
        "raw_prompt": "Any number possible as long as its even.",
        "refined_prompt": "\nMatch examples:\n- \"2\"\n- \"64\"\n- \"4343253298\"\nNon-match examples:\n- \"3\"\n- \"65\"",
        "matches": [
            "2",
            "64",
            "4343253298"
        ],
        "non_matches": [
            "3",
            "65",
            "5345643531"
        ],
        "stress_tests": []
    },
    {
        "id": 3478,
        "expression": "^((((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)))\\s*([,;]|$)+\\s*)*$",
        "raw_prompt": "Accept multiple IPs separated by comma or semicolumn",
        "refined_prompt": "\nMatch examples:\n- \"192.168.0.1,192.168.0.2; 192.168.0.3\"\nNon-match examples:\n- \"256.0.0.1\"\n- \"192.168.0.1-192.168.0.2\"",
        "matches": [
            "192.168.0.1,192.168.0.2; 192.168.0.3"
        ],
        "non_matches": [
            "256.0.0.1",
            "192.168.0.1-192.168.0.2",
            "10.0.0.0/172.16.0.1"
        ],
        "stress_tests": []
    },
    {
        "id": 3481,
        "expression": "^(-?)((\\d{1,3})(,\\d{3})*|\\d+)((\\.\\d+)?)$",
        "raw_prompt": "Matches negative and positive numbers with or without commas and with or without decimals",
        "refined_prompt": "\nMatch examples:\n- \"-9.999\"\n- \"99,999,999.99\"\n- \"9999.99\"\nNon-match examples:\n- \"-.9\"\n- \".9\"",
        "matches": [
            "-9.999",
            "99,999,999.99",
            "9999.99",
            "999"
        ],
        "non_matches": [
            "-.9",
            ".9",
            "9,99.99"
        ],
        "stress_tests": []
    },
    {
        "id": 3483,
        "expression": "^([\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[0-9]+[a-z]+[A-Z]+|[0-9]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[a-z]+[A-Z]+|[0-9]+[a-z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[A-Z]+|[0-9]+[a-z]+[A-Z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+|[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[0-9]+[A-Z]+[a-z]+|[0-9]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[A-Z]+[a-z]+|[0-9]+[A-Z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[a-z]+|[0-9]+[A-Z]+[a-z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+|[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[a-z]+[0-9]+[A-Z]+|[a-z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[0-9]+[A-Z]+|[a-z]+[0-9]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[A-Z]+|[a-z]+[0-9]+[A-Z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+|[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[a-z]+[A-Z]+[0-9]+|[a-z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[A-Z]+[0-9]+|[a-z]+[A-Z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[0-9]+|[a-z]+[A-Z]+[0-9]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+|[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[A-Z]+[0-9]+[a-z]+|[A-Z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[0-9]+[a-z]+|[A-Z]+[0-9]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[a-z]+|[A-Z]+[0-9]+[a-z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+|[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[A-Z]+[a-z]+[0-9]+|[A-Z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[a-z]+[0-9]+|[A-Z]+[a-z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[0-9]+|[A-Z]+[a-z]+[0-9]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+)+$",
        "raw_prompt": "Password with lower, upper case letters, digits and special characters in any order",
        "refined_prompt": "\nMatch examples:\n- \"#3aZ\"\n- \"3#aZ\"\n- \"3a#Z\"\nNon-match examples:\n- \"#$@!\"\n- \"aB3a\"",
        "matches": [
            "#3aZ",
            "3#aZ",
            "3a#Z",
            "3aZ#",
            "#3Za",
            "3#Za",
            "3Z#a",
            "3Za#",
            "#a3Z",
            "a#3Z",
            "a3#Z",
            "a3Z#",
            "#aZ3",
            "a#Z3",
            "aZ#3",
            "aZ3#",
            "#Z3a",
            "Z#3a",
            "Z3#a",
            "Z3a#",
            "#Za3",
            "Z#a3",
            "Za#3",
            "Za3#"
        ],
        "non_matches": [
            "#$@!",
            "aB3a",
            "zzzz",
            "BBBB",
            "1234"
        ],
        "stress_tests": []
    },
    {
        "id": 3488,
        "expression": "<!--(?!\\s*\\[if[^]]+]>[^<]*<!\\[endif\\]).*?-->",
        "raw_prompt": "Matches html comments but excludes comments that contain if statements",
        "refined_prompt": "\nMatch examples:\n- \"<!-- this is a comment -->\"\nNon-match examples:\n- \"<!-- [if lt IE 9]>blah<![endif]-->\"",
        "matches": [
            "<!-- this is a comment -->"
        ],
        "non_matches": [
            "<!-- [if lt IE 9]>blah<![endif]-->"
        ],
        "stress_tests": []
    },
    {
        "id": 3491,
        "expression": "^(?:[2-9]\\d\\d\\d)-(?:1[012]|0?[1-9])?-(?:31(?!.(?:0?[2469]|11))|(?:30|29)(?!.0?2)|29(?=.0?2.(?:(?:(?:1[6-9]|[2-9]\\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00)))(?:T))|(?:2[0-8]|1\\d|0?[1-9]))T(2[01234]|[01]\\d):[0-5]\\d:[0-5]\\d[+-][01]\\d:[0-5]\\d$",
        "raw_prompt": "Matches the strict datetime format for Common Alerting Protocol v1.2 (might be same as earlier versions too). Inspiration and some code came from Michael Ash's http://regexlib.com/REDetails.aspx?regexp_id=610 with tweaks of my own",
        "refined_prompt": "\nMatch examples:\n- \"2016-04-07T12:29:00-04:00\"\n- \"2016-04-07T11:13:00-05:00\"\n- \"2016-04-05T00:53:35-04:00\"\nNon-match examples:\n- \"31/12/2003 11:59:59 PM\"\n- \"2016-04-07 22:00:01+00:00\"",
        "matches": [
            "2016-04-07T12:29:00-04:00",
            "2016-04-07T11:13:00-05:00",
            "2016-04-05T00:53:35-04:00"
        ],
        "non_matches": [
            "31/12/2003 11:59:59 PM",
            "2016-04-07 22:00:01+00:00",
            "2016-04-07T22:00:01Z"
        ],
        "stress_tests": []
    },
    {
        "id": 3492,
        "expression": "[a-z]{2}[0-9]{5}[a-z]",
        "raw_prompt": "Very usefull on pirni: when connected with school's wifi this regex will find evry password of electronic register (es spaggiari classe viva portaleargo) divertitevi!",
        "refined_prompt": "\nMatch examples:\n- \"ab12345c\"\nNon-match examples:\n- \"aCF34568&\"",
        "matches": [
            "ab12345c"
        ],
        "non_matches": [
            "aCF34568&"
        ],
        "stress_tests": []
    },
    {
        "id": 3494,
        "expression": "^\\s*([\\w*]+)\\s*(?:(-?[\\d]+)?\\s*[(]?\\s*(%[\\w]+)?\\s*,?\\s*(%[\\w]+)\\s*,?\\s*([\\d]+)?[)]?|([$\\d]+))\\s*(?:,\\s*(-?[\\d]+)?\\s*[(]?\\s*(%[\\w]+)?\\s*,?\\s*(%[\\w]+)\\s*,?\\s*([\\d]+)?[)]?)?\\s*$",
        "raw_prompt": "Get Assembly param's instructions from instruction like: pop %eax to movl -12(%ebp, %eax, 4),-12(, %eax,4) or other like movl $0x324, (%ebx)",
        "refined_prompt": "\nMatch examples:\n- \"movl -12(%ebp, %eax, 4),-12(, %eax,4)\"\nNon-match examples:\n- \".global, .section, ecc\"",
        "matches": [
            "movl -12(%ebp, %eax, 4),-12(, %eax,4)"
        ],
        "non_matches": [
            ".global, .section, ecc"
        ],
        "stress_tests": []
    },
    {
        "id": 3498,
        "expression": "(?<!\\[)\\[(?!\\[).*(?<!\\])\\](?!\\])",
        "raw_prompt": "This will match the an External wiki link ONLY allowing you to separate the href and the title for use in other link types",
        "refined_prompt": "\nMatch examples:\n- \"[https://sub.domain.com/wiki/index.php?title=test Sample Wiki Link]\"\n- \"[https://regexlib.com/page.aspx Example External Wiki Link]\"\n- \"===[https://sub.domain.com/wiki/index.php Does Match a link surrounded by a header]===\"\nNon-match examples:\n- \"[[file://\\\\servername\\subfolder\\sample.txt Sample Text Link]]\"\n- \"[[Example Wiki Link Double Square Brackets]]\"",
        "matches": [
            "[https://sub.domain.com/wiki/index.php?title=test Sample Wiki Link]",
            "[https://regexlib.com/page.aspx Example External Wiki Link]",
            "===[https://sub.domain.com/wiki/index.php Does Match a link surrounded by a header]==="
        ],
        "non_matches": [
            "[[file://\\\\servername\\subfolder\\sample.txt Sample Text Link]]",
            "[[Example Wiki Link Double Square Brackets]]",
            "[https://sub.domain.com/wiki/index.php Will Not Match a link which is missing its matching bracket"
        ],
        "stress_tests": []
    },
    {
        "id": 3503,
        "expression": "((8|\\+7)-?)\\W((\\d{3,5})|\\(?\\d{3,5}\\))\\W\\d{3}\\W((\\d{2}\\W\\d{2})|(\\d{4}))|(((8|\\+7)-?)?\\(?\\d{3,5}\\)?-?\\d{1}-?\\d{1}-?\\d{1}-?\\d{1}-?\\d{1}((-?\\d{1})?-?\\d{1})?)",
        "raw_prompt": "It is looking for a phone number in the Russian format",
        "refined_prompt": "\nMatch examples:\n- \"+7 (495) 111-1111,+7 905-222-3333,+7 (342) 333 22 22, +7(916)9985670, 8-912-268-5440, 8905148-3339, 8(913)448-51-90, 903-345-34-34, 903-34-334-34, 903-34-33434, 8(34543)54-4-56\"\nNon-match examples:\n- \"x\"",
        "matches": [
            "+7 (495) 111-1111,+7 905-222-3333,+7 (342) 333 22 22, +7(916)9985670, 8-912-268-5440, 8905148-3339, 8(913)448-51-90, 903-345-34-34, 903-34-334-34, 903-34-33434, 8(34543)54-4-56"
        ],
        "non_matches": [
            "x"
        ],
        "stress_tests": []
    },
    {
        "id": 3504,
        "expression": "^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[!@#$%^&*()_\\~\\-\\`\\\\/\\\"\\'+|\\[\\]}{:;'?/>.<,])(?!.*\\s)(?!.*\\s).{8,55}$",
        "raw_prompt": "Password that allows for 1 special char, 1 numeric, 1 upper case, 1 lower case. Its been tested against the Javascript engine.",
        "refined_prompt": "\nMatch examples:\n- \"Passw0rd1!@#\"\nNon-match examples:\n- \"GeneralTso\"",
        "matches": [
            "Passw0rd1!@#"
        ],
        "non_matches": [
            "GeneralTso"
        ],
        "stress_tests": []
    },
    {
        "id": 3505,
        "expression": "(\\$\\d)|(\\\u20ac\\d)|(\\\u00a3\\d)",
        "raw_prompt": "Means that any \u00a3, \u20ac or $ symbol with a digit following it will be picked up.",
        "refined_prompt": "\nMatch examples:\n- \"\u00a31, \u00a31234, $131, \u20ac1231.1241\"\nNon-match examples:\n- \"\u00a3 1, $ 1231, \u20ac.12321\"",
        "matches": [
            "\u00a31, \u00a31234, $131, \u20ac1231.1241"
        ],
        "non_matches": [
            "\u00a3 1, $ 1231, \u20ac.12321"
        ],
        "stress_tests": []
    },
    {
        "id": 3506,
        "expression": "^(?=.*[a-zA-Z])(?=.*[0-9!@#$%^&*\\?\\+])(?!.*[()_\\-\\`\\\\/\\\"\\'|\\[\\]}{:;'/>.<,])(?!.*\\s)(?!.*\\s).{8,20}$",
        "raw_prompt": "Case sensitive:\n-8-20 characters\n-at least 1 letter\n-at least 1 numeric or special\n-these special chars only ~ ! @ # $ % ^ & ? * +",
        "refined_prompt": "\nMatch examples:\n- \"P@SSw0rd~!@#$%^&?*+\"\nNon-match examples:\n- \"Password\"",
        "matches": [
            "P@SSw0rd~!@#$%^&?*+"
        ],
        "non_matches": [
            "Password"
        ],
        "stress_tests": []
    },
    {
        "id": 3507,
        "expression": "^(?=.*[a-zA-Z])(?=.*[a-zA-Z0-9]).{6,20}$",
        "raw_prompt": "Only letters and numbers and at least 1 letter. 6-20 chars",
        "refined_prompt": "\nMatch examples:\n- \"myusername\"\nNon-match examples:\n- \"12345\"",
        "matches": [
            "myusername"
        ],
        "non_matches": [
            "12345"
        ],
        "stress_tests": []
    },
    {
        "id": 3508,
        "expression": "ng-[^\\s]+?=\".*?\"",
        "raw_prompt": "Find all angular properties in HTML markup. Handy for removing them.",
        "refined_prompt": "\nMatch examples:\n- \"ng-class=\"foo\"\"\n- \"ng-if=\"foo\"\"\n- \"ng-show=\"foo\"\"\nNon-match examples:\n- \"class=\"foo\"\"\n- \"ngClass=\"foo\"\"",
        "matches": [
            "ng-class=\"foo\"",
            "ng-if=\"foo\"",
            "ng-show=\"foo\""
        ],
        "non_matches": [
            "class=\"foo\"",
            "ngClass=\"foo\"",
            "class=\"ng-scope\""
        ],
        "stress_tests": []
    },
    {
        "id": 3512,
        "expression": "(?<!\\/|\\\\|\\.)[a-zA-Z]+\\.\\.(?!\\.|\\\\|\\/)",
        "raw_prompt": "a regex for finding usages of a \"partial ellipsis..\" in a sentence",
        "refined_prompt": "\nMatch examples:\n- \"Please Wait..\"\n- \"Error..\"\n- \"a..\"\nNon-match examples:\n- \"1..\"\n- \"\\..\\\"",
        "matches": [
            "Please Wait..",
            "Error..",
            "a.."
        ],
        "non_matches": [
            "1..",
            "\\..\\",
            "/../"
        ],
        "stress_tests": []
    },
    {
        "id": 3527,
        "expression": "^NL\\d{2}[A-Z]{4}0\\d{9}$",
        "raw_prompt": "Validate an International Bank Account Number (IBAN) without formatting. The first two characters represent the country code, coded according ISO 3166-1.\nISO 3166-1",
        "refined_prompt": "\nMatch examples:\n- \"NL91ABNA0417164300\"\nNon-match examples:\n- \"91ABNA0417164300\"\n- \"NL91 ABNA 0417164300\"",
        "matches": [
            "NL91ABNA0417164300"
        ],
        "non_matches": [
            "91ABNA0417164300",
            "NL91 ABNA 0417164300"
        ],
        "stress_tests": []
    },
    {
        "id": 3543,
        "expression": "^(~/|/|(((ht|f)tp(s?))\\://))[^/](\\S*)[^/]+$",
        "raw_prompt": "Allows selection of a root relative path or absolute path; or it allows off-site http://, https://, or ftp:// specific url.",
        "refined_prompt": "\nMatch examples:\n- \"http://www.google.com\"\n- \"ftp://crazy.com\"\n- \"https://securecon\"\nNon-match examples:\n- \"www.google.com\"\n- \"http:cozystuff\"",
        "matches": [
            "http://www.google.com",
            "ftp://crazy.com",
            "https://securecon",
            "~/rootrelative",
            "/absolute/path"
        ],
        "non_matches": [
            "www.google.com",
            "http:cozystuff",
            "go/here",
            "/not/valid/"
        ],
        "stress_tests": []
    },
    {
        "id": 3545,
        "expression": "^[a-z]+([\\d_-]*[a-z]+)*@[a-z]{2,}(\\.)[a-z]{2,}(\\.[a-z]{2})?$",
        "raw_prompt": "Starting to learn, so:\n1.(one or more)letters\n2.(optional) \"-\", \"_\", numbers + (one or more)letters\n3.\"@\"\n4.(two or more)letters\n5.\".\"\n6.(two or more)letters\n7.(optional) \".\" + (two)letters",
        "refined_prompt": "\nMatch examples:\n- \"t@alright.com\"\n- \"test1ok@alright.com.ha\"\n- \"t-e-s-t1_ok@alright.com.ha\"\nNon-match examples:\n- \"test1@alright.com\"\n- \"test-@alright.com\"",
        "matches": [
            "t@alright.com",
            "test1ok@alright.com.ha",
            "t-e-s-t1_ok@alright.com.ha"
        ],
        "non_matches": [
            "test1@alright.com",
            "test-@alright.com",
            "_test@alright.com",
            "test@alright.com.ha.ha"
        ],
        "stress_tests": []
    },
    {
        "id": 3546,
        "expression": "^\\d{1,2}\\/\\d{1,2}\\/\\d{4}$",
        "raw_prompt": "This regular expressions matches dates of the form XX/XX/YYYY where XX can be 1 or 2 digits long and YYYY is always 4 digits long",
        "refined_prompt": "\nMatch examples:\n- \"4/1/2001\"\n- \"12/12/2001\"\n- \"55/5/3434\"\nNon-match examples:\n- \"1/1/01\"\n- \"12 Jan 01\"",
        "matches": [
            "4/1/2001",
            "12/12/2001",
            "55/5/3434"
        ],
        "non_matches": [
            "1/1/01",
            "12 Jan 01",
            "1-1-2001"
        ],
        "stress_tests": []
    },
    {
        "id": 3549,
        "expression": "((a|p|A|P)(m|M)\\s{0,1}(0[0-9]|1[0-2]|[0-9]):[0-5][0-9]:[0-5][0-9])|((a|p|A|P)(m|M)\\s{0,1}(0[0-9]|1[0-2]|[0-9]):[0-5][0-9])|((0[0-9]|1[0-2]|[0-9]):[0-5][0-9]\\s{0,1}(a|p|A|P)(m|M))|((0[0-9]|1[0-2]|[0-9]):[0-5][0-9]:[0-5][0-9]\\s{0,1}(a|p|A|P)(m|M))|((0[0-9]|1[0-9]|2[0-3]|[0-9]):[0-5][0-9]:[0-5][0-9])|((0[0-9]|1[0-9]|2[0-3]|[0-9]):[0-5][0-9])",
        "raw_prompt": "Matches all types of time declaration with ':' separator.",
        "refined_prompt": "\nMatch examples:\n- \"0:26:12 aM\"\n- \"00:26:12 Pm\"\n- \"0:26:12aM\"\nNon-match examples:\n- \"n/a\"",
        "matches": [
            "0:26:12 aM",
            "00:26:12 Pm",
            "0:26:12aM",
            "00:26:12Pm",
            "Am 0:26:12",
            "pM 00:26:12",
            "Am0:26:12",
            "pM00:26:12",
            "0:26 PM",
            "01:26 am",
            "0:26PM",
            "01:26am",
            "Am 0:26",
            "pM 00:26",
            "Am0:26",
            "pM00:26",
            "23:26:12",
            "00:26:12",
            "0:26:12",
            "23:26",
            "0:26"
        ],
        "non_matches": [
            "n/a"
        ],
        "stress_tests": []
    },
    {
        "id": 3556,
        "expression": "(0\\d|1\\d|2[0-4]) ?: ?([0-5]\\d)( ?: ?[0-5]\\d)?",
        "raw_prompt": "Validate hh:minmin:ss",
        "refined_prompt": "\nMatch examples:\n- \"09:03:05\"\n- \"08 : 03 : 57\"\n- \"24:00: 05\"\nNon-match examples:\n- \"17:2\"\n- \"3:52\"",
        "matches": [
            "09:03:05",
            "08 : 03 : 57",
            "24:00: 05",
            "00: 00 :00",
            "17:54"
        ],
        "non_matches": [
            "17:2",
            "3:52"
        ],
        "stress_tests": []
    },
    {
        "id": 3560,
        "expression": ".+(?=((\\\\|\\/).+){2})",
        "raw_prompt": "Get file\\folder path and rise in hierarchy by n folders.\nFor example: c:\\fold1\\fold2\\fold3\\fold4\\fold5 will match c:\\fold1\\fold2\\fold3",
        "refined_prompt": "\nMatch examples:\n- \"c:\\fold1\\fold2\\fold3\\fold4\\fold5\"\nNon-match examples:\n- \"abcd\"",
        "matches": [
            "c:\\fold1\\fold2\\fold3\\fold4\\fold5"
        ],
        "non_matches": [
            "abcd"
        ],
        "stress_tests": []
    },
    {
        "id": 3561,
        "expression": "^-?[1-9]\\d*\\.?(\\d+([eE][-+]\\d+)?)?$",
        "raw_prompt": "Matches numbers including scintific format",
        "refined_prompt": "\nMatch examples:\n- \"-23333.1e+24\"\n- \"123\"\n- \"34.2\"\nNon-match examples:\n- \"23333.01+24\"\n- \"+123\"",
        "matches": [
            "-23333.1e+24",
            "123",
            "34.2"
        ],
        "non_matches": [
            "23333.01+24",
            "+123",
            "34.-20"
        ],
        "stress_tests": []
    },
    {
        "id": 3563,
        "expression": "^\\d{4}\\s\\d{4}\\s\\d{4}$",
        "raw_prompt": "This regular expression will match a Aadhar Number in the format 1111 1111 1111.",
        "refined_prompt": "\nMatch examples:\n- \"1234 5678 9123\"\nNon-match examples:\n- \"123456789123\"",
        "matches": [
            "1234 5678 9123"
        ],
        "non_matches": [
            "123456789123"
        ],
        "stress_tests": []
    },
    {
        "id": 3569,
        "expression": "\\B(\\s)(?!(?:[^\"]*\"[^\"]*\")*[^\"]*$)",
        "raw_prompt": "This expression finds a string of nothing but spaces between double quotes.",
        "refined_prompt": "\nMatch examples:\n- \"\" \"\"\nNon-match examples:\n- \"\"abc 123\"\"",
        "matches": [
            "\" \""
        ],
        "non_matches": [
            "\"abc 123\""
        ],
        "stress_tests": []
    },
    {
        "id": 3571,
        "expression": "[0-9]*[-| ][0-9]*[-| ][0-9]*[-| ][0-9]*[-| ][0-9]*",
        "raw_prompt": "Pattern for ISBN 13",
        "refined_prompt": "\nMatch examples:\n- \"978-1-86197-876-9\"\n- \"978 1 86197 876 9\"\nNon-match examples:\n- \"no isbn number\"",
        "matches": [
            "978-1-86197-876-9",
            "978 1 86197 876 9"
        ],
        "non_matches": [
            "no isbn number"
        ],
        "stress_tests": []
    },
    {
        "id": 3573,
        "expression": "^(0[1-9]|[12]\\d|3[01])(0[1-9]|1[0-2])([5-9]\\d\\+|\\d\\d-|[01]\\dA)\\d{3}[\\dABCDEFHJKLMNPRSTUVWXY]$",
        "raw_prompt": "Description\nThis is for the Finnish social security numbers (henkil\u00f6tunnus / hetu). It consists of eleven characters of the form DDMMYYCZZZQ, where DDMMYY is the date of birth, C the century sign (-,+, or A), ZZZ the individual number (even for men and odd for female), and Q the control character or the checksum. It is calculated DDMMYYZZZ mod 31, where the remainder 0,1,2,..,31 is converted from the list 0,1,...A,B,C..Y . The G,I, O and Q are not in the list, they are too similar to numbers 1, 8 and 0 (zero). Note: This regex does not calculate the checksum (mod 31).",
        "refined_prompt": "\nMatch examples:\n- \"010593-123A\"\n- \"010503A123A\"\n- \"210566-022Y\"\nNon-match examples:\n- \"010593123A\"\n- \"011403A123A\"",
        "matches": [
            "010593-123A",
            "010503A123A",
            "210566-022Y"
        ],
        "non_matches": [
            "010593123A",
            "011403A123A",
            "011203-123O"
        ],
        "stress_tests": []
    },
    {
        "id": 3601,
        "expression": "^(0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])[- /.](19|20)\\d\\d$",
        "raw_prompt": "Date in MM/DD/YYYY (USA Format). Allows for 1 or 2 digit month and day. Requires 4 digit year between 1900-2999. Allows for dash, slash, period or space for separators.",
        "refined_prompt": "\nMatch examples:\n- \"01/02/2015\"\n- \"5-7-1915\"\n- \"12.8.2035\"\nNon-match examples:\n- \"11-11-1845\"\n- \"31/12/2000\"",
        "matches": [
            "01/02/2015",
            "5-7-1915",
            "12.8.2035",
            "7 15 1963"
        ],
        "non_matches": [
            "11-11-1845",
            "31/12/2000",
            "10-17-85"
        ],
        "stress_tests": []
    },
    {
        "id": 3612,
        "expression": "^(?=.{16,})(?=.*[1-9])(?=.*[a-z])(?=.*[A-Z])(?=.*[(!@#$%^&*()_+|~\\- =\\`{}[\\]:\u201d;'<>?,.\\/, )])(?!.*(.)\\1{2,}).+$",
        "raw_prompt": "Password validator for a high complexity secure passwords.\nLength minimum 16 characters\nAt least one number\nAt least one lowercase character\nAt least one uppercase character\nAt least one special character from the following set \u201c(!@#$%^&*()_+|~\\- =\\`{}[\\]:\u201d;'<>?,.\\/, )]\u201d\nNo sequential repeating characters",
        "refined_prompt": "\nMatch examples:\n- \"Pas$words0123456\"\nNon-match examples:\n- \"Password\"",
        "matches": [
            "Pas$words0123456"
        ],
        "non_matches": [
            "Password"
        ],
        "stress_tests": []
    },
    {
        "id": 3657,
        "expression": "\\w+\\S?\\w+\\s?(@|\\W(at)\\W)\\s?\\w+\\s?(\\.|\\W(dot)\\W)\\s?\\w+\\.?\\w+",
        "raw_prompt": "This should be able to match all emails including ones which try to avoid scrapers.",
        "refined_prompt": "\nMatch examples:\n- \"example@demo.net\"\n- \"example @ demo.net\"\n- \"example at demo.net\"\nNon-match examples:\n- \"Not Sure Yet\"",
        "matches": [
            "example@demo.net",
            "example @ demo.net",
            "example at demo.net",
            "example at demo dot net",
            "example [at] demo.net",
            "example [at] demo [dot] net",
            "example.example@test.co.uk",
            "example-example@test.co.uk",
            "example_example@test.co.uk"
        ],
        "non_matches": [
            "Not Sure Yet"
        ],
        "stress_tests": []
    },
    {
        "id": 3712,
        "expression": "^(1[0-2]|0[1-9]|[1-9])\\/(1[0-9]|2[0-9]|3[0-1]|0[1-9]|[1-9])\\/\\d{4}$",
        "raw_prompt": "is very accurate when catching\nand matching dates within the correct ranges in US standard date formats MM/DD/YYYY",
        "refined_prompt": "\nMatch examples:\n- \"1/3/2017\"\n- \"01/03/2017\"\n- \"12/12/2017\"\nNon-match examples:\n- \"31/12/2017\"\n- \"99/99/9999\"",
        "matches": [
            "1/3/2017",
            "01/03/2017",
            "12/12/2017",
            "12/31/2017"
        ],
        "non_matches": [
            "31/12/2017",
            "99/99/9999",
            "12-31-2017",
            "December 30th, 2017"
        ],
        "stress_tests": []
    },
    {
        "id": 3731,
        "expression": "((((0[1-9]|[12][0-9]|3[01])(0[13578]|10|12)(\\d{2}))|(([0][1-9]|[12][0-9]|30)(0[469]|11)(\\d{2}))|((0[1-9]|1[0-9]|2[0-8])(02)(\\d{2}))|((29)(02)(0(0|4|8)))|((29)(02)([2468][048]))|((29)(02)([13579][26])))[- ]?\\d{4})",
        "raw_prompt": "Matches the format from www.cpr.dk and fixed to match 29th February for leap years",
        "refined_prompt": "\nMatch examples:\n- \"020955-2012\"\n- \"020955-2012\"\n- \"241283-1234\"\nNon-match examples:\n- \"459434-1234\"\n- \"123456-1234\"",
        "matches": [
            "020955-2012",
            "020955-2012",
            "241283-1234",
            "290204-1234",
            "010111-1111"
        ],
        "non_matches": [
            "459434-1234",
            "123456-1234"
        ],
        "stress_tests": []
    },
    {
        "id": 3734,
        "expression": "^([A-Za-z]+)([0-9]+)?([A-Za-z0-9\\.\\_]+)?\\@(([A-Za-z]+)([0-9]+)?([A-Za-z0-9\\.\\_]+)?)((\\.)([a-zA-Z]+))$",
        "raw_prompt": "Need Multiline option to validate email string for better result",
        "refined_prompt": "\nMatch examples:\n- \"ankur.ranpariya@test.com\"\n- \"ankur.ran.pariya@test.com\"\n- \"ankur@test.com\"\nNon-match examples:\n- \"ankur ankur@test.com\"\n- \"ankur-ranpariya@test.com\"",
        "matches": [
            "ankur.ranpariya@test.com",
            "ankur.ran.pariya@test.com",
            "ankur@test.com",
            "ankur01@test.com",
            "ankur.01abc@abc.com",
            "ankur@abc01.com",
            "ankur@ank01xt.com",
            "ankur@gaming.indianic.com"
        ],
        "non_matches": [
            "ankur ankur@test.com",
            "ankur-ranpariya@test.com",
            "ankur@@test.com",
            "ankur@ankur@test.com",
            "ankur@01ABC.com",
            "01ankur@test.com",
            "ankur@ankur",
            "@ankur.com",
            "ankur.ra@123.com",
            "ankur.ra@inda.123",
            "ankur.ra@test.a1",
            "1@inidnia.com",
            "ank%20@gmail.com"
        ],
        "stress_tests": []
    },
    {
        "id": 3736,
        "expression": "^(http(s?)\\:\\/\\/)?(www.)?(([A-Za-z]+)([0-9]+)?([A-Za-z0-9\\.\\_\\-]+)?)(\\.)(([a-zA-Z]{2,})([0-9a-zA-Z]+)?)(\\:\\d{0,5})?(\\/|(\\/[A-Za-z]+([a-zA-Z0-9]+)?)+)?(\\?[a-zA-Z0-9\\\\\\&\\%\\_\\.\\/\\-\\=\\~\\*]+)?$",
        "raw_prompt": "Web Url validation using regex. need mult-line option",
        "refined_prompt": "\nMatch examples:\n- \"https://www.test.com\"\n- \"https://www.test.com/\"\n- \"https://test.com\"\nNon-match examples:\n- \"*.google.com\"\n- \"goole.com/*\"",
        "matches": [
            "https://www.test.com",
            "https://www.test.com/",
            "https://test.com",
            "https://test.com/",
            "http://test.com",
            "www.test.com",
            "www.test.com/",
            "test.com",
            "test.com",
            "test069.com",
            "test.test.com",
            "test01.test01.com",
            "test.test.co",
            "test.com:1",
            "test.cm:12345",
            "www.xa.com/abc/a",
            "www.xa.com/abc",
            "test.com/con1/method1",
            "w.google.com",
            "google.com?te-st=xyz",
            "oogle.com?test=xyz",
            "google.com?test=",
            "google.com?test",
            "google.com?test=xyz&text",
            "google.com?test=xyz&text=t&*5"
        ],
        "non_matches": [
            "*.google.com",
            "goole.com/*",
            ".google.com",
            "google.com?",
            "google.com/?",
            "google.co-m",
            "@.google.com",
            "ftp://test.com",
            "test test.com",
            "www.xa.com/ab c/a",
            "test.com:123456",
            "//test.com",
            "test.test.c",
            "01test.test.com",
            "test.c",
            "test.test.",
            "http://www.test.c",
            "01test.com",
            "test.01",
            ""
        ],
        "stress_tests": []
    },
    {
        "id": 3737,
        "expression": "^(\\d{5})([\\-\\ ]\\d{4})?$",
        "raw_prompt": "Support Zip+4 with dash \"-\" or space \" \"\nneed multiline option",
        "refined_prompt": "\nMatch examples:\n- \"12345-4565\"\n- \"12345\"\n- \"12345 1234\"\nNon-match examples:\n- \"123456\"\n- \"1234\"",
        "matches": [
            "12345-4565",
            "12345",
            "12345 1234"
        ],
        "non_matches": [
            "123456",
            "1234",
            "1234-1234",
            "12345-12345",
            "12345-123",
            "12345 123",
            "12345 12345",
            "1234 1234",
            "1234 12345"
        ],
        "stress_tests": []
    },
    {
        "id": 3753,
        "expression": "(\\+989|9|09)(0[1-3]|1[0-9]|2[0-2]|3[0-9]|90|9[8-9])\\d{7}",
        "raw_prompt": "Regex for current available mobile numbers mention at\nhttps://fa.wikipedia.org/wiki/%D8%B4%D9%85%D8%A7%D8%B1%D9%87%E2%80%8C%D9%87%D8%A7%DB%8C_%D8%AA%D9%84%D9%81%D9%86_%D8%AF%D8%B1_%D8%A7%DB%8C%D8%B1%D8%A7%D9%86",
        "refined_prompt": "\nMatch examples:\n- \"09221113344\"\nNon-match examples:\n- \"09057614584\"",
        "matches": [
            "09221113344"
        ],
        "non_matches": [
            "09057614584"
        ],
        "stress_tests": []
    },
    {
        "id": 3772,
        "expression": "^([1-9][0][0]|[1-9][0-9][0][0]|[1-9][0-9][0-9][0][0]|[1-9][0-9][0-9][0-9][0][0]|[1-9][0-9][0-9][0-9][0-9][0][0])$",
        "raw_prompt": "Permite digitar valores m\u00faltiplos de 100 entre 0 e 9999999.",
        "refined_prompt": "\nMatch examples:\n- \"100\"\n- \"200\"\n- \"9999900\"\nNon-match examples:\n- \"101\"\n- \"201\"",
        "matches": [
            "100",
            "200",
            "9999900"
        ],
        "non_matches": [
            "101",
            "201",
            "9999901"
        ],
        "stress_tests": []
    },
    {
        "id": 3779,
        "expression": "^(\\+?1(-|\\.|\\s)?)?((\\(((8(00|22|33|44|55|66|77|[8[0-9]))|900)\\)|((8(00|22|33|44|55|66|77|[8[0-9]))|900))(-|\\.|\\s)?\\d{3}(-|\\.|\\s)?\\d{4}|(\\([2-9]([02-9]\\d|1[02-9])\\)|[2-9]([02-9]\\d|1[02-9]))(-|\\.|\\s)?[2-9]([02-9]\\d|1[02-9](-|\\.|\\s)?\\d{4}))$",
        "raw_prompt": "This is a very detailed RegEx that only allows for valid phone number combinations in accordance with \"North American Numbering Plan\" as well as any combinations for toll (9XX) and toll-free (8XX) numbers.\nNumbers can contain parenthesis around the area code, can include 1 or +1, and can be delimited using \"-\", \".\", or space.",
        "refined_prompt": "\nMatch examples:\n- \"800-211-5555\"\n- \"(800) 211-5555\"\n- \"1-800-211-5555\"\nNon-match examples:\n- \"555-555-555\"\n- \"555-211-5555\"",
        "matches": [
            "800-211-5555",
            "(800) 211-5555",
            "1-800-211-5555",
            "+1-800-211-5555",
            "555 212 1234",
            "555.212.1234"
        ],
        "non_matches": [
            "555-555-555",
            "555-211-5555",
            "2-555-555-5555",
            "555-123-1234"
        ],
        "stress_tests": []
    },
    {
        "id": 3786,
        "expression": "^\\d+?[A-Za-z]*\\s\\w*\\s?\\w+?\\s\\w{2}\\w*\\s*\\w*$",
        "raw_prompt": "Flexible match for valid US street addresses requiring at least some street number with or without a unit letter followed by a space, then either a modifier like N, W, West, etc, or no modifier, then another space, followed by the street name, then a space folowed by the street type abreviated or spelled out (ave or avenue). Can accept Apt number at the end. Does not match addresses with no number, improperly formatted numbers, or no street type.",
        "refined_prompt": "\nMatch examples:\n- \"3 Olive Lane\"\n- \"1234 SE Franklin St\"\n- \"34 East Avenue Apt 54\"\nNon-match examples:\n- \"West Avenue\"\n- \"22b2 East St\"",
        "matches": [
            "3 Olive Lane",
            "1234 SE Franklin St",
            "34 East Avenue Apt 54",
            "23b Orange Lane Apt 12",
            "55 Martingale St Apt A"
        ],
        "non_matches": [
            "West Avenue",
            "22b2 East St",
            "22 Olive",
            "Apt 5"
        ],
        "stress_tests": []
    },
    {
        "id": 3787,
        "expression": "^(([0]\\d)|([1][0-2])|(\\d))[/](([0-2]\\d)|([3][0-1])|(\\d))[/][2][0]\\d{2}[,]\\s(([0]\\d)|([1][0-2])|(\\d))[:][0-5]\\d\\s[AP][M]",
        "raw_prompt": "This is basic datetime validator that does bother with seconds and enforces slashes, a comma after the date, as well as a year that must start with \"20\". Morning and evening are represented by \"AM\" or \"PM\" only.",
        "refined_prompt": "\nMatch examples:\n- \"1/31/2086, 9:50 AM\"\n- \"08/04/2082, 09:13 PM\"\n- \"1/2/2000, 1:12 PM\"\nNon-match examples:\n- \"1/31/2086 9:50 AM\"\n- \"08/04/2082, 09:13\"",
        "matches": [
            "1/31/2086, 9:50 AM",
            "08/04/2082, 09:13 PM",
            "1/2/2000, 1:12 PM"
        ],
        "non_matches": [
            "1/31/2086 9:50 AM",
            "08/04/2082, 09:13",
            "1/2/1900, 1:12 PM"
        ],
        "stress_tests": []
    },
    {
        "id": 3791,
        "expression": "((0[1-9]|[12]\\d|3[01])(0[1-9]|1[0-2])\\d{3}\\d{2}\\d{4})",
        "raw_prompt": "Regex to match the \"Unique Master Citizen Number\" based on the wikipedia description.\nIt doesn't keep in account the checksum, but it matches the example on wikipedia.",
        "refined_prompt": "\nMatch examples:\n- \"0101006500006\"\nNon-match examples:\n- \"none\"",
        "matches": [
            "0101006500006"
        ],
        "non_matches": [
            "none"
        ],
        "stress_tests": []
    },
    {
        "id": 3800,
        "expression": "([0-8]?\\d(\u00b0|\\s)[0-5]?\\d('|\\s)[0-5]?\\d(\\.\\d{1,6})?\"?|90(\u00b0|\\s)0?0('|\\s)0?0\"?)\\s{0,}[NnSs]\\s{1,}([0-1]?[0-7]?\\d(\u00b0|\\s)[0-5]?\\d('|\\s)[0-5]?\\d(\\.\\d{1,6})?\"?|180(\u00b0|\\s)0?0('|\\s)0?0\"?)\\s{0,}[EeOoWw]",
        "raw_prompt": "Validate lat/lon coordinates",
        "refined_prompt": "\nMatch examples:\n- \"45\u00b023'36.0\" N 10\u00b033'48.0\" E or 45\u00b023'36.123456\"N 010\u00b033'48\"E\"\nNon-match examples:\n- \"45\u00b023'36.\" N 10\u00b033'48.0\" E or 45\u00b023'36.1234567\"N 010\u00b033'48\"E\"",
        "matches": [
            "45\u00b023'36.0\" N 10\u00b033'48.0\" E or 45\u00b023'36.123456\"N 010\u00b033'48\"E"
        ],
        "non_matches": [
            "45\u00b023'36.\" N 10\u00b033'48.0\" E or 45\u00b023'36.1234567\"N 010\u00b033'48\"E"
        ],
        "stress_tests": []
    },
    {
        "id": 3803,
        "expression": "([0-8]?\\d[0-5]?\\d[0-5]?\\d|900000)[NS]([0-1]?[0-7]?\\d[0-5]?\\d[0-5]?\\d|1800000)[EW]\\d{3}",
        "raw_prompt": "NOTAM coords and radius in \"Q\" field",
        "refined_prompt": "\nMatch examples:\n- \"440110N0123634E005\"\nNon-match examples:\n- \"any other format\"",
        "matches": [
            "440110N0123634E005"
        ],
        "non_matches": [
            "any other format"
        ],
        "stress_tests": []
    },
    {
        "id": 3805,
        "expression": "(?!219( |\\.|\\-|)??09( |\\.|\\-|)??9999|078( |\\.|\\-|)??05( |\\.|\\-|)??1120)(?!666|000|9\\d{2})\\d{3}( |\\.|\\-|)??(?!00)\\d{2}( |\\.|\\-|)??(?!0{4})\\d{4}",
        "raw_prompt": "Advanced SSN regular expression. Matches 9 digits separated by mixed spaces, hyphens, or periods. Excludes:\n- Values containing all 0's in any group\n- Values beginning with 900-999\n- 078-05-1120 (Woolworth's Wallet)\n- Values beginning with 666\nGuidelines can be seen at: https://www.ssa.gov/kc/SSAFactSheet--IssuingSSNs.pdf",
        "refined_prompt": "\nMatch examples:\n- \"001-23-1123\"\n- \"377.42.1423\"\n- \"389551234\"\nNon-match examples:\n- \"078051120\"\n- \"900 20 2211\"",
        "matches": [
            "001-23-1123",
            "377.42.1423",
            "389551234",
            "389 55.1234"
        ],
        "non_matches": [
            "078051120",
            "900 20 2211",
            "389.00.4411"
        ],
        "stress_tests": []
    },
    {
        "id": 3806,
        "expression": "^((?:\\*)|(?:[0-5]?[0-9])|(?:(?:(?:[0-5]?[0-9])-(?:[0-5]?[0-9]))(?:,(?:(?:[0-5]?[0-9])-(?:[0-5]?[0-9])))*)|(?:(?:[0-5]?[0-9])(?:,(?:[0-5]?[0-9]))*))\\s+((?:\\*)|(?:[0-9]|0[0-9]|1[0-9]|2[0-3])|(?:(?:(?:[0-9]|0[0-9]|1[0-9]|2[0-3])-(?:[0-9]|0[0-9]|1[0-9]|2[0-3]))(?:,(?:(?:[0-9]|0[0-9]|1[0-9]|2[0-3])-(?:[0-9]|0[0-9]|1[0-9]|2[0-3])))*)|(?:(?:[0-9]|0[0-9]|1[0-9]|2[0-3])(?:,(?:[0-9]|0[0-9]|1[0-9]|2[0-3]))*))\\s+((?:\\*)|(?:[1-9]|0[1-9]|1[0-9]|2[0-9]|3[0-1])|(?:(?:(?:[1-9]|0[1-9]|1[0-9]|2[0-9]|3[0-1])-(?:[1-9]|0[1-9]|1[0-9]|2[0-9]|3[0-1]))(?:,(?:(?:[1-9]|0[1-9]|1[0-9]|2[0-9]|3[0-1])-(?:[1-9]|0[1-9]|1[0-9]|2[0-9]|3[0-1])))*)|(?:(?:[1-9]|0[1-9]|1[0-9]|2[0-9]|3[0-1])(?:,(?:[1-9]|0[1-9]|1[0-9]|2[0-9]|3[0-1]))*))\\s+((?:\\*)|(?:[1-9]|0[1-9]|1[0-2])|(?:(?:(?:[1-9]|0[1-9]|1[0-2])-(?:[1-9]|0[1-9]|1[0-2]))(?:,(?:(?:[1-9]|0[1-9]|1[0-2])-(?:[1-9]|0[1-9]|1[0-2])))*)|(?:(?:[1-9]|0[1-9]|1[0-2])(?:,(?:[1-9]|0[1-9]|1[0-2]))*)|(?:\\*)|(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)|(?:(?:(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)-(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec))(?:,(?:(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)-(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)))*)|(?:(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)(?:,(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec))*))\\s+((?:\\*)|(?:[0-6]|0[0-6])|(?:(?:(?:[0-6]|0[0-6])-(?:[0-6]|0[0-6]))(?:,(?:(?:[0-6]|0[0-6])-(?:[0-6]|0[0-6])))*)|(?:(?:[0-6]|0[0-6])(?:,(?:[0-6]|0[0-6]))*)|(?:\\*)|(?:sun|mon|tue|wed|thu|fri|sat)|(?:(?:(?:sun|mon|tue|wed|thu|fri|sat)-(?:sun|mon|tue|wed|thu|fri|sat))(?:,(?:(?:sun|mon|tue|wed|thu|fri|sat)-(?:sun|mon|tue|wed|thu|fri|sat)))*)|(?:(?:sun|mon|tue|wed|thu|fri|sat)(?:,(?:sun|mon|tue|wed|thu|fri|sat))*))$",
        "raw_prompt": "Validates a cron schedule.\nSupports:\n- single values (zero-padded or not)\n- comma-separated lists of values (e.g. '2,14,17')\n- value ranges (e.g. '4-10')\n- list of ranges (e.g. '1-3,5-7')\n- days of the week and months specified as digits or strings (e.g. 'mon-tues', 'feb', '07', '3')\nDoes not support non-standard formats:\n- step values (e.g. '5/2')\n- @yearly, @annually, @monthly etc\n- Sunday specified as '7' (instead of '0')\n- 6th field (year)\nCapturing groups:\n1: minute\n2: hour\n3: day of the month\n4: month\n5: day of the week",
        "refined_prompt": "\nMatch examples:\n- \"15,45 4-5 2 feb *\"\n- \"00 06,08 * * mon,wed\"\n- \"00 * * 4 02\"\nNon-match examples:\n- \"*****\"\n- \"0 1 3 * * *\"",
        "matches": [
            "15,45 4-5 2 feb *",
            "00 06,08 * * mon,wed",
            "00 * * 4 02",
            "00 * * 4 mon-tue,thu-fri"
        ],
        "non_matches": [
            "*****",
            "0 1 3 * * *",
            "0 1 * * 7",
            "60 * * * *",
            "* 24 * * *",
            "* * 32 * *",
            "* * 0 * *",
            "* * * 13 *",
            "* * * 0 *",
            "* * * * mon-tue-wed",
            "* * * jan-feb-mar *",
            "* * * jan-fed *"
        ],
        "stress_tests": []
    },
    {
        "id": 3811,
        "expression": "(((\\d{2}((0[13578]|1[02])(0[1-9]|[12]\\d|3[01])|(0[13456789]|1[012])(0[1-9]|[12]\\d|30)|02(0[1-9]|1\\d|2[0-8])))|([02468][048]|[13579][26])0229))(( |-)(\\d{4})( |-)([01]8((( |-)\\d{1})|\\d{1}))|(\\d{4}[01]8\\d{1}))",
        "raw_prompt": "Matches valid South African ID numbers based on all criteria (except of course the checksum digit at the end).\nMatches the format defined as:\nYYMMDDSSSSCAZ.\nYY - Year,\nMM - Month,\nDD - Day,\nSSSS - Gender,\nC - Denotes citizenship (0 or a 1),\nA - Always an 8,\nZ - Checksum digit (doesn't validate if the checksum itself is valid).\nAlso supports the following ways of entering it:\nYYMMDDSSSSCAZ |\nYYMMDD SSSS CAZ |\nYYMMDD SSSS CA Z .\nSee this for a reference:\nhttps://www.westerncape.gov.za/general-publication/decoding-your-south-african-id-number-0",
        "refined_prompt": "\nMatch examples:\n- \"9202204720082\"\n- \"920220 4720 082\"\n- \"920220 4720 08 2\"\nNon-match examples:\n- \"9202204720282\"\n- \"920220 4720 052\"",
        "matches": [
            "9202204720082",
            "920220 4720 082",
            "920220 4720 08 2",
            "920220-4720-082",
            "920220-4720-08-2 9202204720183",
            "920220 4720 183",
            "920220 4720 18 3",
            "920220-4720-183",
            "920220-4720-18-3"
        ],
        "non_matches": [
            "9202204720282",
            "920220 4720 052",
            "920220 4720 05 2",
            "920220-4720-252"
        ],
        "stress_tests": []
    },
    {
        "id": 3813,
        "expression": "^[a-zA-Z0-9_.-@$]*$",
        "raw_prompt": "User name which will allow _ . @$And -",
        "refined_prompt": "\nMatch examples:\n- \"gcccbb@ghg$\"\nNon-match examples:\n- \"bb#Dntn^b,m\"",
        "matches": [
            "gcccbb@ghg$"
        ],
        "non_matches": [
            "bb#Dntn^b,m"
        ],
        "stress_tests": []
    },
    {
        "id": 3814,
        "expression": "((\\/\\*(\\r|\\n|(.(?!\\*/)))*)\\s\\*\\/|\\/\\/.*$)([\\r\\n\\s]+)?",
        "raw_prompt": "Matches block comments or line comments, and all whitespace until the next uncommented character.",
        "refined_prompt": "\nMatch examples:\n- \"/* this matches */\"\n- \"/** so does this */\"\n- \"// this too\"\nNon-match examples:\n- \"this does not match\"",
        "matches": [
            "/* this matches */",
            "/** so does this */",
            "// this too"
        ],
        "non_matches": [
            "this does not match"
        ],
        "stress_tests": []
    },
    {
        "id": 3825,
        "expression": "^(([\\da-fA-F]{2}[-:]){5}[\\da-fA-F]{2})$",
        "raw_prompt": "Easiest way to describe a MAC Address.",
        "refined_prompt": "\nMatch examples:\n- \"00-25-86-DC-FD-3B\"\n- \"00:25:86:DC:FD:3B\"\n- \"00-25-86-dc-fd-3b\"\nNon-match examples:\n- \"00 25 86 dc fd 3b\"\n- \"002586dcfd3b\"",
        "matches": [
            "00-25-86-DC-FD-3B",
            "00:25:86:DC:FD:3B",
            "00-25-86-dc-fd-3b",
            "00:25:86:dc:fd:3b"
        ],
        "non_matches": [
            "00 25 86 dc fd 3b",
            "002586dcfd3b",
            "00.25.86.dc.fd.3b"
        ],
        "stress_tests": []
    },
    {
        "id": 3860,
        "expression": "^((750|7[0-4]\\d|[1-6]\\d\\d|[1-9]\\d|[3-9])|((7[0-4]\\d|[1-6]\\d\\d|[1-9]\\d|[3-9])\\.{1}[0,5]{1}){1}|750.0)$",
        "raw_prompt": "Validate a number between 3 and 750 with one decimal that only is 0 or 5. Decimal separator is '.'",
        "refined_prompt": "\nMatch examples:\n- \"3.0\"\n- \"10.5\"\n- \"750.0\"\nNon-match examples:\n- \"2.0\"\n- \"750.5\"",
        "matches": [
            "3.0",
            "10.5",
            "750.0",
            "750"
        ],
        "non_matches": [
            "2.0",
            "750.5",
            "2.5",
            "23,5"
        ],
        "stress_tests": []
    },
    {
        "id": 3879,
        "expression": "^[a-zA-Z0-9,./-]*$",
        "raw_prompt": "check special character exists or not",
        "refined_prompt": "\nMatch examples:\n- \"a-zA-Z0-9,./-\"\nNon-match examples:\n- \"~`!@#$%^&*()_=+-\\\"\n- \"[]{}\"",
        "matches": [
            "a-zA-Z0-9,./-"
        ],
        "non_matches": [
            "~`!@#$%^&*()_=+-\\",
            "[]{}"
        ],
        "stress_tests": []
    },
    {
        "id": 3882,
        "expression": "([0-1][0-9]|[1-2][0-9]|[1-3][0-1])\\/([0][0-9]|[1][0-2])\\/(\\d{4})",
        "raw_prompt": "Simple regex that matches european date format with slashes.\nIt doesn\u00b4t validate the different number of days of each month.",
        "refined_prompt": "\nMatch examples:\n- \"31/12/1987\"\n- \"10/10/2010\"\n- \"21/02/2019\"\nNon-match examples:\n- \"2/5/1981\"\n- \"21/6/213\"",
        "matches": [
            "31/12/1987",
            "10/10/2010",
            "21/02/2019"
        ],
        "non_matches": [
            "2/5/1981",
            "21/6/213",
            "01/13/1900"
        ],
        "stress_tests": []
    },
    {
        "id": 3889,
        "expression": "^\\([2-9]\\d{2}\\) \\d{3}[- .]?\\d{4}\\D*(\\d*)$",
        "raw_prompt": "Forces parethesis and space before 7 digit number",
        "refined_prompt": "\nMatch examples:\n- \"(555) 555-5555\"\nNon-match examples:\n- \"555-555-5555\"",
        "matches": [
            "(555) 555-5555"
        ],
        "non_matches": [
            "555-555-5555"
        ],
        "stress_tests": []
    },
    {
        "id": 3893,
        "expression": "<a[\\s](?!.*\\b(title)\\b)[^>]+>",
        "raw_prompt": "Finding all the anchor tags that do not contain the title attribute",
        "refined_prompt": "\nMatch examples:\n- \"<a href=\"mailto:abc2.jagadale@gmail.com\">abc2.jagadale@gmail.com</a>\"\nNon-match examples:\n- \"This working well with all my files\"",
        "matches": [
            "<a href=\"mailto:abc2.jagadale@gmail.com\">abc2.jagadale@gmail.com</a>"
        ],
        "non_matches": [
            "This working well with all my files"
        ],
        "stress_tests": []
    },
    {
        "id": 3902,
        "expression": "(ns=[0-9])?;?((i=[0-9]+)|s=[a-zA-Z.]+)",
        "raw_prompt": "Regex to check if a string is a OPC UA NodeId XML schema. Only works for Numeric and String NodeIds",
        "refined_prompt": "\nMatch examples:\n- \"ns=1;i=3015\"\n- \"i=884\"\n- \"ns=2;s=Demo.Static.Scalar.String\"\nNon-match examples:\n- \"\"\n- \"10001\"",
        "matches": [
            "ns=1;i=3015",
            "i=884",
            "ns=2;s=Demo.Static.Scalar.String"
        ],
        "non_matches": [
            "",
            "10001",
            "\"Hallo\""
        ],
        "stress_tests": []
    },
    {
        "id": 3906,
        "expression": "[a-zA-Z]+[0-9]*@[a-zA-Z]+[\\.](edu|org|com)",
        "raw_prompt": "matches email syntax with com,edu,org only. You can add more the way you like it",
        "refined_prompt": "\nMatch examples:\n- \"aaa@dd.com, aa2332@bb.edu\"\nNon-match examples:\n- \"aa@dd.ee\"",
        "matches": [
            "aaa@dd.com, aa2332@bb.edu"
        ],
        "non_matches": [
            "aa@dd.ee"
        ],
        "stress_tests": []
    },
    {
        "id": 3909,
        "expression": "^\\d{1,2}-\\d{1,2}-\\d{4}$",
        "raw_prompt": "This takes an American date using mm-dd-yyyy format. It does not validate month or day values.",
        "refined_prompt": "\nMatch examples:\n- \"12-9-1969\"\n- \"2-8-1998\"\n- \"8-17-2002\"\nNon-match examples:\n- \"12-9-69\"\n- \"12/2/1948\"",
        "matches": [
            "12-9-1969",
            "2-8-1998",
            "8-17-2002"
        ],
        "non_matches": [
            "12-9-69",
            "12/2/1948"
        ],
        "stress_tests": []
    },
    {
        "id": 3910,
        "expression": "[\\+-]?(([0-9]*\\.[0-9]+|[0-9]+\\.[0-9]*)([Ee][\\+-]?[0-9]+)?[Ff]?|[0-9]+[Ff])",
        "raw_prompt": "match a float number with Exponent sign and f sign",
        "refined_prompt": "\nMatch examples:\n- \"2.0\"\n- \"0.3\"\n- \"-.4\"\nNon-match examples:\n- \"2\"\n- \"234\"",
        "matches": [
            "2.0",
            "0.3",
            "-.4",
            "3.f",
            "2.4E-2f",
            "0.4E4f"
        ],
        "non_matches": [
            "2",
            "234",
            ".f"
        ],
        "stress_tests": []
    },
    {
        "id": 3912,
        "expression": "(<<=|>>=|&&=|(\\|\\|=)|<<|>>(\\+=)|-=|(\\*=)|(\\/=)|%=|&=|(\\^=)|(\\|=)|<=|>=|==|!=|&&|(\\|\\|)|(\\+\\+)|--|>|<|\\^|&|(\\|)|\\*|\\/|%|\\+|-|~|=)",
        "raw_prompt": "matches almost all programming language operator",
        "refined_prompt": "\nMatch examples:\n- \"++\"\n- \"<=\"\n- \">>=\"\nNon-match examples:\n- \"identifier\"\n- \"2000\"",
        "matches": [
            "++",
            "<=",
            ">>="
        ],
        "non_matches": [
            "identifier",
            "2000",
            "0xFFF"
        ],
        "stress_tests": []
    },
    {
        "id": 3915,
        "expression": "^(?:[a-zA-Z]\\.?){1,4}$",
        "raw_prompt": "This expression will allow someone to place 1-4 Lower case or Upper case letters with optional periods after each letter for a total of up to 8 possible characters.",
        "refined_prompt": "\nMatch examples:\n- \"J.W.R.\"\n- \"JwR\"\n- \"j.r.\"\nNon-match examples:\n- \"j..r.\"\n- \"jwers\"",
        "matches": [
            "J.W.R.",
            "JwR",
            "j.r.",
            "jwre",
            "JWWR",
            "J.er.e"
        ],
        "non_matches": [
            "j..r.",
            "jwers",
            "jw2",
            ".j.w.r"
        ],
        "stress_tests": []
    },
    {
        "id": 3923,
        "expression": "^(?![-_.0-9])(?!.*[-_.][-_.])(?!.*[-_.]$)[A-Za-z0-9-_.]+$",
        "raw_prompt": "Provide username constraint that allow character and numeric and also perion hyphen and underscore, but it only allows alphabet at the begin, and alphanumeric at the end. also user may not user more than one sign side by side",
        "refined_prompt": "\nMatch examples:\n- \"my.username\"\n- \"u-s-e-r.n_a_m_e\"\n- \"xyz724\"\nNon-match examples:\n- \"9abc\"\n- \"x..z\"",
        "matches": [
            "my.username",
            "u-s-e-r.n_a_m_e",
            "xyz724",
            "c1"
        ],
        "non_matches": [
            "9abc",
            "x..z",
            "a._-c",
            "-a",
            "c54_"
        ],
        "stress_tests": []
    },
    {
        "id": 3934,
        "expression": "^([\\da-fA-f]{2}[:-]){5}[\\da-fA-f]{2}$",
        "raw_prompt": "Matches mixed case, colon or hypen hexadecimal notation. Discards string too short or long, or with invalid characters. Needs extended grep.",
        "refined_prompt": "\nMatch examples:\n- \"98-CE-d0-a2-0a-68\"\n- \"98:cE:d0:a2:0a:68\"\nNon-match examples:\n- \"98-cE-d0-a2-0a\"\n- \"98-cE-d0-a2-0a-68-f0\"",
        "matches": [
            "98-CE-d0-a2-0a-68",
            "98:cE:d0:a2:0a:68"
        ],
        "non_matches": [
            "98-cE-d0-a2-0a",
            "98-cE-d0-a2-0a-68-f0"
        ],
        "stress_tests": []
    },
    {
        "id": 3936,
        "expression": "^9792\\d{12}$",
        "raw_prompt": "Matches troy credit cards (length 16, prefix 9792)",
        "refined_prompt": "\nMatch examples:\n- \"9792131111111111\"\n- \"9792461111111111\"\n- \"9792111111111111\"\nNon-match examples:\n- \"9792 1311 1111 1111\"\n- \"1234561234561234\"",
        "matches": [
            "9792131111111111",
            "9792461111111111",
            "9792111111111111"
        ],
        "non_matches": [
            "9792 1311 1111 1111",
            "1234561234561234"
        ],
        "stress_tests": []
    },
    {
        "id": 3945,
        "expression": "(<log4j:Event logger=\")(.*?)(\" timestamp=\")(.*?)(\" level=\")(.*?)(\" thread=\")(.*?)(\">)(.*?)(<log4j:Message><!\\[CDATA\\[)(.*?)(\\]\\]>)",
        "raw_prompt": "This is a regex to split a message by log4j into:\nLogger (Group 2)\nTimestamp (Group 4)\nLoggin Level (Group 6)\nThread (Group 8)\nMessage (Group 12)\nImportant: You have to enable single line",
        "refined_prompt": "\nMatch examples:\n- \"<log4j:Event logger=\"dxa\" timestamp=\"1564402596208\" level=\"INFO\" thread=\"Client thread\"> <log4j:Message><![CDATA[Message from log4j]]></log4j:Message> </log4j:Event>\"\nNon-match examples:\n- \"asdf\"",
        "matches": [
            "<log4j:Event logger=\"dxa\" timestamp=\"1564402596208\" level=\"INFO\" thread=\"Client thread\"> <log4j:Message><![CDATA[Message from log4j]]></log4j:Message> </log4j:Event>"
        ],
        "non_matches": [
            "asdf"
        ],
        "stress_tests": []
    },
    {
        "id": 3951,
        "expression": "^(?:Yes\\b|No\\b|yes\\b|YES\\b|YEs\\b|yeS\\b|yEs\\b|NO\\b|nO\\b|no\\b)",
        "raw_prompt": "This regex will match below values only\nYES\nyes\nYes\nYEs\nyEs\nyeS\nNO\nno\nNo\nnO",
        "refined_prompt": "\nMatch examples:\n- \"YES yes Yes YEs yEs yeS NO no No nO\"\nNon-match examples:\n- \"Except YES yes Yes YEs yEs yeS NO no No nO\"",
        "matches": [
            "YES yes Yes YEs yEs yeS NO no No nO"
        ],
        "non_matches": [
            "Except YES yes Yes YEs yEs yeS NO no No nO"
        ],
        "stress_tests": []
    },
    {
        "id": 3981,
        "expression": "^01[0125]{1}[0-9]{8}",
        "raw_prompt": "- first 2 digits are 01\n- second 1 digit is 0 for (Vodafone) or 1 for (Etisalat) or 2 for (orange) or 5 for (We)\n- third 8 digits are between 0 and 9",
        "refined_prompt": "\nMatch examples:\n- \"01022685544\"\n- \"01122685544\"\n- \"01222685544\"\nNon-match examples:\n- \"+0201622685544\"\n- \"01322685544\"",
        "matches": [
            "01022685544",
            "01122685544",
            "01222685544",
            "01522685544"
        ],
        "non_matches": [
            "+0201622685544",
            "01322685544",
            "01422685544",
            "01622685544",
            "01722685544",
            "01822685544",
            "01922685544"
        ],
        "stress_tests": []
    },
    {
        "id": 3983,
        "expression": "^(\\d|\\d{1,9}|1\\d{1,9}|20\\d{8}|21[0-3]\\d{7}|214[0-6]\\d{6}|2147[0-3]\\d{5}|21474[0-7]\\d{4}|214748[0-2]\\d{3}|2147483[0-5]\\d{2}|21474836[0-3][0-9]|214748364[0-7])$",
        "raw_prompt": "regular expression for positive integer",
        "refined_prompt": "\nMatch examples:\n- \"2147483647\"\n- \"0\"\n- \"2147483639\"\nNon-match examples:\n- \"2147483648\"\n- \"0.0\"",
        "matches": [
            "2147483647",
            "0",
            "2147483639"
        ],
        "non_matches": [
            "2147483648",
            "0.0",
            "-54645"
        ],
        "stress_tests": []
    },
    {
        "id": 4006,
        "expression": "^[0][5-7]\\d{2}(?:(\\s|-|\\/))?\\d{2}(?:(\\s|-|\\/))?\\d{2}(?:(\\s|-|\\/))?\\d{2}$",
        "raw_prompt": "Algerian Mobile :\n1-Starts With 0\n2-Between 5 & 7\nThe rest can be filled with 8 digits with or without\nspaces or dashes, I even added slashes, grouped 2 by 2\nTotal of digits (without spaces/dashes/slashes) must be 10.",
        "refined_prompt": "\nMatch examples:\n- \"0696 22 13 23\"\nNon-match examples:\n- \"02252525225\"",
        "matches": [
            "0696 22 13 23"
        ],
        "non_matches": [
            "02252525225"
        ],
        "stress_tests": []
    },
    {
        "id": 4010,
        "expression": "^(0)((3[0-6][0-9]))(\\d{7})$",
        "raw_prompt": "All phone numbers starting with 03*********. total 11 digit numbers.",
        "refined_prompt": "\nMatch examples:\n- \"03355011998\"\nNon-match examples:\n- \"+923355011998\"",
        "matches": [
            "03355011998"
        ],
        "non_matches": [
            "+923355011998"
        ],
        "stress_tests": []
    },
    {
        "id": 4013,
        "expression": "(?:\\s|^)(?P<day>(?P<threeone>31)|(?P<thirty>30)|(?P<twonine>29)|(?P<twoeight>2[0-8]|1[0-9]|0?[1-9]))(?P<sep>[/\\-\\.:])(?P<month>(?(threeone)(?:1[02]|0?[13578]))(?(thirty)(?:1[012]|0?[13456789]))(?(twonine)(?:1[012]|0?[13-9]|(?P<leap>0?2)))(?(twoeight)(?:1[012]|0?[1-9])))(?P=sep)(?P<year>(?:\\d\\d)?(?(leap)(?:(?:[02468][048])|(?:[13579][26]))|(?:\\d\\d)))(?:$|\\s)",
        "raw_prompt": "This matches valid dates (including leap year dates of the following formats :\ndd/mm/yy\ndd/mm/yyyy\nd/m/yy\nd/m/yyyy\ndd-mm-yy\ndd-mm-yyyy\nd-m-yy\nd-m-yyyy\ndd.mm.yy\ndd.mm.yyyy\nd.m.yy\nd.m.yyyy\nuse the named groups day, month, year",
        "refined_prompt": "\nMatch examples:\n- \"29/02/2096\"\nNon-match examples:\n- \"29/02/2097\"\n- \"31/04/2020\"",
        "matches": [
            "29/02/2096"
        ],
        "non_matches": [
            "29/02/2097",
            "31/04/2020"
        ],
        "stress_tests": []
    },
    {
        "id": 4014,
        "expression": "(?:\\s|^)(?P<day>(?P<threeone>31)|(?P<thirty>30)|(?P<twonine>29)|(?P<twoeight>2[0-8]|1[0-9]|0?[1-9]))(?P<sep>[/\\-\\.:])(?P<month>(?(threeone)(?:jan|mar|may|jul|aug|oct|dec))(?(thirty)(?:jan|mar|apr|may|jun|jul|aug|sep|oct|nov|dec))(?(twonine)(?:jan|(?P<feb>feb)|mar|apr|may|jun|jul|aug|sep|oct|nov|dec|))(?(twoeight)(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)))(?P=sep)(?P<year>(?:\\d\\d)?(?(twonine)(?(feb)(?:(?:[02468][048])|(?:[13579][26]))|(?:\\d\\d))))(?:$|\\s)",
        "raw_prompt": "Validates dates in the (d)d-MMM-(yy)yy format",
        "refined_prompt": "\nMatch examples:\n- \"29-feb-2020, 1-jan-01\"\nNon-match examples:\n- \"29-feb-19, 31-sep-2010\"",
        "matches": [
            "29-feb-2020, 1-jan-01"
        ],
        "non_matches": [
            "29-feb-19, 31-sep-2010"
        ],
        "stress_tests": []
    },
    {
        "id": 4015,
        "expression": "(?:\\s|^)(?P<day>(?P<threeone>31)|(?P<thirty>30)|(?P<twonine>29)|(?P<twoeight>2[0-8]|1[0-9]|0?[1-9]))(?P<sep>[/\\-\\.:])(?P<month>(?(threeone)(?:jan|mar|may|jul|aug|oct|dec))(?(thirty)(?:jan|mar|apr|may|jun|jul|aug|sep|oct|nov|dec))(?(twonine)(?:jan|(?P<feb>feb)|mar|apr|may|jun|jul|aug|sep|oct|nov|dec|))(?(twoeight)(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)))(?P=sep)(?P<year>(?:\\d\\d)?(?(twonine)(?(feb)(?:(?:[02468][048])|(?:[13579][26]))|(?:\\d\\d))|(?:\\d\\d)))(?:$|\\s)",
        "raw_prompt": "Validates dates in the (d)d-MMM-(yy)yy format",
        "refined_prompt": "\nMatch examples:\n- \"29-feb-2020\"\n- \"1-jan-01\"\nNon-match examples:\n- \"29-feb-19\"\n- \"31-sep-2010\"",
        "matches": [
            "29-feb-2020",
            "1-jan-01"
        ],
        "non_matches": [
            "29-feb-19",
            "31-sep-2010"
        ],
        "stress_tests": []
    },
    {
        "id": 4029,
        "expression": "^[0-9]{4}(0[1-9]|1[0-2])(0[1-9]|[1-2][0-9]|3[0-1])($|(([01][0-9]|2[0-3])[0-5][0-9][0-5][0-9])$)",
        "raw_prompt": "This expression validate the YYYYMMDDHHMMSS datetime format but also only the date YYYYMMDD. It does not control month length or leap years. Made for a SAP retail sales tickets interface.\nFor XML pattern facet this would do:\n([0-9]{4}(0[1-9]|1[0-2])(0[1-9]|[1-2][0-9]|3[0-1])(([01][0-9]|2[0-3])[0-5][0-9][0-5][0-9]))|([0-9]{4}(0[1-9]|1[0-2])(0[1-9]|[1-2][0-9]|3[0-1]))",
        "refined_prompt": "\nMatch examples:\n- \"20200707181818\"\n- \"20200707\"\n- \"20200231010000\"\nNon-match examples:\n- \"20201232\"\n- \"20201301\"",
        "matches": [
            "20200707181818",
            "20200707",
            "20200231010000",
            "20200931",
            "00011231235959",
            "00000101"
        ],
        "non_matches": [
            "20201232",
            "20201301",
            "20200028",
            "20200500",
            "20200707235978",
            "20201231128533",
            "20200327453030"
        ],
        "stress_tests": []
    },
    {
        "id": 4034,
        "expression": "^((25[0-5]|2[0-4]\\d|1\\d{2}|[1-9]?\\d)(\\.|$)){4}\\b",
        "raw_prompt": "Match valid IPv4 address. Constraints: matches only IP. All numbers must be between 0-255 for each block, delimited by dots, and cannot be zero padded or be suffixed by a dot on the last class.",
        "refined_prompt": "\nMatch examples:\n- \"0.0.0.0\"\n- \"192.168.1.35\"\n- \"169.254.0.0\"\nNon-match examples:\n- \"127.0.0.01\"\n- \"255.255.255.256\"",
        "matches": [
            "0.0.0.0",
            "192.168.1.35",
            "169.254.0.0"
        ],
        "non_matches": [
            "127.0.0.01",
            "255.255.255.256",
            "7.7.7.7."
        ],
        "stress_tests": []
    },
    {
        "id": 4041,
        "expression": "(^[3|4|5|6|7|8|9]\\d{2}(\\ |-){0,1}\\d{4}$)|(^[4|5|7|8]\\d{3}(\\ |-){0,1}\\d{4}$)|(^8\\d{2,3}(\\ |-){0,1}\\d{3,4}(\\ |-){0,1}\\d{3,4}$)",
        "raw_prompt": "Supports 7 digits (starting with 3,4,5,6,7,8,9) 8 digits (starting with 4,5,7,8), machine-to-machine (M2M) numbers 9-12 digits (starting with 8).",
        "refined_prompt": "\nMatch examples:\n- \"300 3000\"\n- \"300-3000\"\n- \"3003000\"\nNon-match examples:\n- \"3000 3000\"\n- \"9000 9000 9000\"",
        "matches": [
            "300 3000",
            "300-3000",
            "3003000"
        ],
        "non_matches": [
            "3000 3000",
            "9000 9000 9000"
        ],
        "stress_tests": []
    },
    {
        "id": 4042,
        "expression": "^(\\d)(\\s)(\\d)*(-)(\\d)*(-)(\\d)*",
        "raw_prompt": "Matches any number following the 1 800 phone method. It's not 100% foolproof so please be wary - just wanted to present my legitimate, raw regex without having to look up anything on Stack Overflow. Thank you.\nLink to my GitHub: https://github.com/StoddardSpencer96",
        "refined_prompt": "\nMatch examples:\n- \"1 902-444-444 1 904-565-5555 1 419-444-4444 1 902-44-3333 (this one shouldnt match)\"\nNon-match examples:\n- \"23 904-5555-5555 1 902-44-3333 (this is where the number should be)\"",
        "matches": [
            "1 902-444-444 1 904-565-5555 1 419-444-4444 1 902-44-3333 (this one shouldnt match)"
        ],
        "non_matches": [
            "23 904-5555-5555 1 902-44-3333 (this is where the number should be)"
        ],
        "stress_tests": []
    },
    {
        "id": 4043,
        "expression": "([s]){10,}",
        "raw_prompt": "Matches the hissing noise of a snake. Link to my GitHub: https://github.com/StoddardSpencer96",
        "refined_prompt": "\nMatch examples:\n- \"ssssssssss wwwwwwwwwwwsssssssssssssssssss\"\nNon-match examples:\n- \"effsgrgrsfefsv54543534544 FKR$>%>??W?EK#$Krkdk3oror\"",
        "matches": [
            "ssssssssss wwwwwwwwwwwsssssssssssssssssss"
        ],
        "non_matches": [
            "effsgrgrsfefsv54543534544 FKR$>%>??W?EK#$Krkdk3oror"
        ],
        "stress_tests": []
    },
    {
        "id": 4044,
        "expression": "([ing]){3}$",
        "raw_prompt": "Matching any word that ends with \"ing\"\nLink to my GitHub: https://github.com/StoddardSpencer96",
        "refined_prompt": "\nMatch examples:\n- \"Reading Playing Comforting Crying\"\nNon-match examples:\n- \"Readings Listenings Playful Comfort\"",
        "matches": [
            "Reading Playing Comforting Crying"
        ],
        "non_matches": [
            "Readings Listenings Playful Comfort"
        ],
        "stress_tests": []
    },
    {
        "id": 4047,
        "expression": "^([\\d])([\\s])([\\d]){3}([-])([\\d]){3}([-])([\\d])*",
        "raw_prompt": "Matches the 1 800-8000 format.\nLink to Github: https://github.com/StoddardSpencer96",
        "refined_prompt": "\nMatch examples:\n- \"1 902-444-4444 1 405-543-3000 1 910-243-321\"\nNon-match examples:\n- \"1902-44-4-5-3-2-2 1 9023333333 1-902-3332222\"",
        "matches": [
            "1 902-444-4444 1 405-543-3000 1 910-243-321"
        ],
        "non_matches": [
            "1902-44-4-5-3-2-2 1 9023333333 1-902-3332222"
        ],
        "stress_tests": []
    },
    {
        "id": 4051,
        "expression": "((=)[A-F0-9]{2}){3}",
        "raw_prompt": "Using this Regex for finding spam in RAW email\nthis is Case sensitive\nHEX only CAPITAL A-F and numbers 0-9",
        "refined_prompt": "\nMatch examples:\n- \"=EF=BB=BF\"\n- \"=E2=9C=80\"\n- \"=E2=9D=A4\"\nNon-match examples:\n- \"e2 9d a4\"\n- \"ABCXYZ\"",
        "matches": [
            "=EF=BB=BF",
            "=E2=9C=80",
            "=E2=9D=A4"
        ],
        "non_matches": [
            "e2 9d a4",
            "ABCXYZ",
            "f0=9f=aa=81"
        ],
        "stress_tests": []
    },
    {
        "id": 4067,
        "expression": "\\b[0-9]{2}([0][1-9]{1}|[1][0-2]{1})([0][1-9]{1}|[1][0-9]{1}|[2][0-9]{1}|[3][0-1]{1})\\d{5}",
        "raw_prompt": "The PESEL number is an identification number given to every Polish citizen when they are born and registered in Poland.",
        "refined_prompt": "\nMatch examples:\n- \"11083197485\"\n- \"36110878229\"\n- \"00063172200\"\nNon-match examples:\n- \"1F083297485\"\n- \"36204578229\"",
        "matches": [
            "11083197485",
            "36110878229",
            "00063172200",
            "12110383138"
        ],
        "non_matches": [
            "1F083297485",
            "36204578229",
            "AA06317220B",
            "12203383138"
        ],
        "stress_tests": []
    },
    {
        "id": 4072,
        "expression": "^((0[1-9])|(1[0-2]))[\\/\\.\\-]*((2[0-9])|(3[0-9]))$",
        "raw_prompt": "valid years 2020 to 2039",
        "refined_prompt": "\nMatch examples:\n- \"12/20\"\n- \"12/39\"\n- \"05-25\"\nNon-match examples:\n- \"12/40\"\n- \"23/02\"",
        "matches": [
            "12/20",
            "12/39",
            "05-25"
        ],
        "non_matches": [
            "12/40",
            "23/02",
            "15-25"
        ],
        "stress_tests": []
    },
    {
        "id": 4086,
        "expression": "^((?!.*(00000|11111|22222|33333|44444|55555|66666|77777|88888|99999))[0-9]{5,10})",
        "raw_prompt": "In example for some input number in case random digits not repeat number 5 number in 5-10 digits in pattern.",
        "refined_prompt": "\nMatch examples:\n- \"0000110000\"\n- \"000010010\"\nNon-match examples:\n- \"00000\"\n- \"1122000009\"",
        "matches": [
            "0000110000",
            "000010010"
        ],
        "non_matches": [
            "00000",
            "1122000009"
        ],
        "stress_tests": []
    },
    {
        "id": 4087,
        "expression": "^((?!.*(01234|12345|23456|34567|45678|56789))[0-9]{5,10})",
        "raw_prompt": "In example for some input number in case random digits not sort number 5 number in 5-10 digits in pattern.",
        "refined_prompt": "\nMatch examples:\n- \"000111222\"\n- \"111222333\"\nNon-match examples:\n- \"0000123400\"\n- \"1112345\"",
        "matches": [
            "000111222",
            "111222333"
        ],
        "non_matches": [
            "0000123400",
            "1112345"
        ],
        "stress_tests": []
    },
    {
        "id": 4107,
        "expression": "(?!BG|GB|KN|NK|NT|TN|ZZ)[A-CEGHJ-PR-TW-Z][A-CEGHJ-NPR-TW-Z][0-9]{6}[A-D]",
        "raw_prompt": "UK NI number. ensured that the suffix is always a single character of A-D (as these are the only values currently supported by HMRC). Created 2021",
        "refined_prompt": "\nMatch examples:\n- \"XY123456D\"\nNon-match examples:\n- \"XY123456E\"",
        "matches": [
            "XY123456D"
        ],
        "non_matches": [
            "XY123456E"
        ],
        "stress_tests": []
    },
    {
        "id": 4110,
        "expression": "([A-Za-z]{3})([pchabgjlftPCHABGJLFT])([a-zA-Z])([0-9]{4})([A-Za-z]{1})",
        "raw_prompt": "1. 3 generic Alphabets\n2. 1 specific alphabet\n3. 1 generic alphabet\n4. 4 digits\n5. 1 generic alphabet\n(alphabets: small or capital)",
        "refined_prompt": "It matches a string that with ten characters that has the following structure.\r\n- the first three characters are any letter from A to Z (uppercase or lowercase).\r\n- the 4th character is one of the following letters: P, C, H, A, B, G, J, L, F, or T (upper case or lower case). \r\n- the 5th character is any letter (uppercase or lowercase).\r\n- the 6th-9th characters are any number (0 to 9)\r\n- the 10th character is any letter from A to Z (uppercase or lowercase).\nMatch examples:\n- \"AABCL5045N\"\nNon-match examples:\n- \"AABXL5045N\"",
        "matches": [
            "AABCL5045N",
            "AACCL5045Z",
            "BABCL4045N",
            "ACBCL5149D",
            "ADBFL5045O",
            "aabcl5045n",
            "AaBCL5045N",
            "AABCL5045x",
            "AABCr5045N",
            "AABCL5945N",
            "AABCL5045a",
            "aABCL5045N",
            "iABCL5045N"
        ],
        "non_matches": [
            "AABXL5045N",
            "AABCL5045",
            "1ABCL5045N",
            "AABRL5045N",
            "AABCL504N",
            "AABCL",
            "abc",
            "123",
            "9100",
            "AABCL-5045N",
            "AAB-C-L-5045-N",
            "AABCLN"
        ],
        "stress_tests": []
    }
]